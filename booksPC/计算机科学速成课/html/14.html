<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//谷歌浏览器  
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox等浏览器
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//谷歌浏览器  
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox等浏览器  
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
</script>
<script>
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:link，#container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:85.29%;
	line-height:1.6em;
	overflow:hidden;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}
#goTopBtn, #goBottom, #shangy, #xiay, #menuPage, #lPage, #fPage, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #menuPage, #lPage, #fPage, #ftsize1, #ftsize3{
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #lPage, #fPage, #ftsize, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#fPage{
	bottom: 236px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
	//writing-mode:tb-rl;
}
#menuPage{
	bottom: 198px;
	height:27px;
	white-space:nowrap;
	overflow:hidden;
}
#lPage{
	bottom: 145px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
}
#ftsize1{
	bottom:360px;
}
#ftsize2{
	bottom:334px;
}
#ftsize3{
	bottom:308px;
}
#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #menuPage:hover, #lPage:hover, #fPage:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #menuPage a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link, #menuPage a:visited, #lPage a:link, #fPage a:link, #lPage a:visited, #fPage a:visited {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
.code0, .code2, .code4{
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
.layout, .layout2{
    clear:both;
	width:95%;
	border:1px dotted #eee;
	margin:auto;
	margin-bottom:5px;
	overflow:hidden;
}
.layout2 .right, .layout2 .left, .layout p{
margin-bottom:-55px;
padding-bottom:55px;
text-align: justify;
margin:0;
padding:0;
margin-left:1%;
margin-right:1%;
}
.layout2 .left, .layout p{
float:left;
width:60%;
font-size:1.0em;
}
.layout2 .right,  .layout p+p {
	float: left;
	width:34%;
	border-left:1px dotted #cccccc;
	font-size:0.9em;
	padding-left:1%;
	
}
.layout2 .right p, .layout2 .left p, .layout p{
padding-bottom:5px;
}
h3{
text-indent:3%;
font-size:1em;
height:2.0em;
padding:0;
margin:0;
}
</style>
</head>
<body>
<div id="container">
﻿<div class='layout'><p>14 Data Structures</p><p>14 数据结构</p></div>	
<div class='layout'><p>Hi, I'm Carrie Anne, and welcome to Crash Course Computer Science!</p><p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p></div>	
<div class='layout'><p>Last episode, we discussed a few example classic algorithms,</p><p>上集讲了一些经典算法</p></div>	
<div class='layout'><p>like sorting a list of numbers and finding the shortest path in a graph.</p><p>比如给数组排序，找图的最短路径</p></div>	
<div class='layout'><p>What we didn't talk much about,</p><p>而上集没讲的是</p></div>	
<div class='layout'><p>is how the data the algorithms ran on was stored in computer memory.</p><p>算法处理的数据  存在内存里的格式是什么</p></div>	
<div class='layout'><p>You don't want your data to be like John Green's college dorm room,</p><p>你肯定不想数据像 John Green 的大学宿舍一样乱</p></div>	
<div class='layout'><p>with food, clothing and papers strewn everywhere.</p><p>到处都是食物，衣服和纸</p></div>	
<div class='layout'><p>Instead, we want our data to be structured,</p><p>我们希望数据是结构化的，</p></div>	
<div class='layout'><p>so that it's organized, allowing things to be easily retrieved and read.</p><p>方便读取</p></div>	
<div class='layout'><p>For this, computer scientists use Data Structures!</p><p>因此计算机科学家发明了 "数据结构"！</p></div>	
<div class='layout'><p>We already introduced one basic data structure last episode,</p><p>上集已经介绍了一种基本数据结构：</p></div>	
<div class='layout'><p>Arrays, also called lists or Vectors in some languages.</p><p>数组（Array），也叫列表（list）或向量（Vector）（在其它编程语言里）</p></div>	
<div class='layout'><p>These are a series of values stored in memory.</p><p>数组的值一个个连续存在内存里</p></div>	
<div class='layout'><p>So instead of just a single value being saved into a variable, like 'j equals 5',</p><p>所以不像之前，一个变量里只存一个值（比如 j = 5）</p></div>	
<div class='layout'><p>we can define a whole series of numbers, and save that into an array variable.</p><p>我们可以把多个值存在数组变量里</p></div>	
<div class='layout'><p>To be able to find a particular value in this array, we have to specify an index.</p><p>为了拿出数组中某个值，我们要指定一个下标（index）</p></div>	
<div class='layout'><p>Almost all programing languages start arrays at index 0,</p><p>大多数编程语言里，数组下标都从 0 开始</p></div>	
<div class='layout'><p>and use a square bracket syntax to denote array access.</p><p>用方括号 [ ] 代表访问数组</p></div>	
<div class='layout'><p>So, for example, if we want to add the values in the first and third spots of our array 'j',</p><p>如果想相加数组 J 的第一个和第三个元素</p></div>	
<div class='layout'><p>and save that into a variable 'a', we would write a line of code like this.</p><p>把结果存在变量 a，可以写上图这样一行代码</p></div>	
<div class='layout'><p>How an array is stored in memory is pretty straightforward.</p><p>数组存在内存里的方式  十分易懂</p></div>	
<div class='layout'><p>For simplicity, let's say that the compiler chose to store ours at memory location 1,000.</p><p>为了简单，假设编译器从内存地址 1000 开始存数组</p></div>	
<div class='layout'><p>The array contains 7 numbers, and these are stored one after another in memory, as seen here.</p><p>数组有7个数字，像上图一样按顺序存.</p></div>	
<div class='layout'><p>So when we write "j index of 0", the computer goes to memory location 1,000,</p><p>写 j[0]，会去内存地址 1000</p></div>	
<div class='layout'><p>with an offset of 0, and we get the value 5.</p><p>加 0 个偏移，得到地址 1000，拿值：5</p></div>	
<div class='layout'><p>If we wanted to retrieve "j index of 5", our program goes to memory location 1000,</p><p>如果写 j[5]，会去内存地址 1000</p></div>	
<div class='layout'><p>plus an offset of 5, which in this case, holds a value of 4.</p><p>加 5 个偏移，得到地址 1005，拿值： 4</p></div>	
<div class='layout'><p>It's easy to confuse the fifth number in the array with the number at index 5.</p><p>很容易混淆 "数组中第 5 个数" 和 "数组下标为 5 的数"</p></div>	
<div class='layout'><p>They are not the same.</p><p>它们不是一回事</p></div>	
<div class='layout'><p>Remember, the number at index 5 is the 6th number in the array</p><p>记住，下标 5 其实是数组中第 6 个数</p></div>	
<div class='layout'><p>because the first number is at index 0.</p><p>因为下标是从 0 开始算的</p></div>	
<div class='layout'><p>Arrays are extremely versatile data structures, used all the time,</p><p>数组的用途广泛</p></div>	
<div class='layout'><p>and so there are many functions that can handle them to do useful things.</p><p>所以几乎所有编程语言  都自带了很多函数来处理数组</p></div>	
<div class='layout'><p>For example, pretty much every programming language comes with a built-in sort function,</p><p>举例，数组排序函数很常见</p></div>	
<div class='layout'><p>where you just pass in your array, and it comes back sorted.</p><p>只需要传入数组，就会返回排序后的数组</p></div>	
<div class='layout'><p>So there's no need to write that algorithm from scratch.</p><p>不需要写排序算法</p></div>	
<div class='layout'><p>Very closely related are Strings, which are just arrays of characters,</p><p>数组的亲戚是 字符串 (string)</p></div>	
<div class='layout'><p>like letters, numbers, punctuation and other written symbols.</p><p>其实就是字母，数字，标点符号等  组成的数组</p></div>	
<div class='layout'><p>We talked about how computers store characters way back in Episode 4.</p><p>第 4 集讨论过计算机怎么存储字符</p></div>	
<div class='layout'><p>Most often, to save a string into memory, you just put it in quotes, like so.</p><p>写代码时 用引号括起来就行了 ，j = "STAN ROCKS"</p></div>	
<div class='layout'><p>Although it doesn't look like an array, it is.</p><p>虽然长的不像数组，但的确是数组</p></div>	
<div class='layout'><p>Behind the scenes, the memory looks like this.</p><p>幕后看起来像这样</p></div>	
<div class='layout'><p>Note that the string ends with a zero in memory.</p><p>注意，字符串在内存里以 0 结尾</p></div>	
<div class='layout'><p>It's not the character zero, but the binary value 0.</p><p>不是"字符0"，是"二进制值0"，</p></div>	
<div class='layout'><p>This is called the null character, and denotes the end of the string in memory.</p><p>这叫字符"null"，表示字符串结尾</p></div>	
<div class='layout'><p>This is important because if I call a function like "print quote",</p><p>这个字符非常重要，如果调用 print 函数</p></div>	
<div class='layout'><p>which writes the string to the screen,</p><p>print 在屏幕上输出字符串</p></div>	
<div class='layout'><p>it prints out each character in turn starting at the first memory location,</p><p>会从开始位置，逐个显示到屏幕</p></div>	
<div class='layout'><p>but it needs to know when to stop!</p><p>但得知道什么时候停下来！</p></div>	
<div class='layout'><p>Otherwise, it would print out every single thing in memory as text.</p><p>否则会把内存里所有东西 都显示出来</p></div>	
<div class='layout'><p>The zero tells string functions when to stop.</p><p>0 告诉函数何时停下</p></div>	
<div class='layout'><p>Because computers work with text so often,</p><p>因为计算机经常处理字符串，</p></div>	
<div class='layout'><p>there are many functions that specifically handle strings.</p><p>所以有很多函数专门处理字符串</p></div>	
<div class='layout'><p>For example, many programming languages have a string concatenation function, or "strcat",</p><p>比如连接字符串的 strcat</p></div>	
<div class='layout'><p>which takes in two strings, and copies the second one to the end of the first.</p><p>strcat 接收两个字符串，把第二个放到第一个结尾.</p></div>	
<div class='layout'><p>We can use arrays for making one dimensional lists,</p><p>我们可以用数组做一维列表</p></div>	
<div class='layout'><p>but sometimes you want to manipulate data that is two dimensional,</p><p>但有时想操作二维数据</p></div>	
<div class='layout'><p>like a grid of numbers in a spreadsheet, or the pixels on your computer screen.</p><p>比如电子表格，或屏幕上的像素</p></div>	
<div class='layout'><p>For this, we need a Matrix.</p><p>那么需要 矩阵（Matrix）</p></div>	
<div class='layout'><p>You can think of a Matrix as an array of arrays!</p><p>可以把矩阵看成  数组的数组！</p></div>	
<div class='layout'><p>So a 3 by 3 matrix is really  an array of size 3, with each index storing an array of size 3.</p><p>一个 3x3 矩阵就是一个长度为3的数组，数组里每个元素都是一个长度为3的数组</p></div>	
<div class='layout'><p>We can initialize a matrix like so.</p><p>可以这样初始化.</p></div>	
<div class='layout'><p>In memory, this is packed together in order like this.</p><p>内存里是这样排列的</p></div>	
<div class='layout'><p>To access a value, you need to specify two indexes, like "J index of 2, then index of 1" -</p><p>为了拿一个值，需要两个下标，比如 j[2][1]</p></div>	
<div class='layout'><p>this tells the computer you're looking for the item in subarray 2 at position 1.</p><p>告诉计算机在找数组 2 里，位置是 1 的元素</p></div>	
<div class='layout'><p>And this would give us the value 12.</p><p>得到数字 12</p></div>	
<div class='layout'><p>The cool thing about matrices is we're not limited to 3 by 3</p><p>矩阵酷的地方是，不止能做 3x3 的矩阵</p></div>	
<div class='layout'><p>we can make them any size we want</p><p>任何尺寸</p></div>	
<div class='layout'><p>and we can also make them any number of dimensions we want.</p><p>任何维度都行</p></div>	
<div class='layout'><p>For example, we can create a five dimensional matrix and access it like this.</p><p>可以做一个5维矩阵，然后这样访问，a = j[2][0][18][18][3]</p></div>	
<div class='layout'><p>That's right, you now know how to access a five dimensional matrix</p><p>现在你知道了  怎么读一个 5 维矩阵</p></div>	
<div class='layout'><p>tell your friends!</p><p>快去告诉你的朋友！</p></div>	
<div class='layout'><p>So far, we've been storing individual numbers or letters into our arrays or matrices.</p><p>目前我们只存过单个数字/字符，存进数组或矩阵</p></div>	
<div class='layout'><p>But often it's useful to store a block of related variables together.</p><p>但有时， 把几个有关系的变量存在一起， 会很有用</p></div>	
<div class='layout'><p>Like, you might want to store a bank account number along with its balance.</p><p>比如银行账户号和余额</p></div>	
<div class='layout'><p>Groups of variables like these can be bundled together into a Struct.</p><p>多个变量打包在一起叫  结构体 (Struct)</p></div>	
<div class='layout'><p>Now we can create variables that aren't just single numbers,</p><p>现在多个不同类型数据，</p></div>	
<div class='layout'><p>but are compound data structures, able to store several pieces of data at once.</p><p>可以放在一起</p></div>	
<div class='layout'><p>We can even make arrays of structs that we define,</p><p>甚至可以做一个数组，里面放很多结构体</p></div>	
<div class='layout'><p>which are automatically bundled together in memory.</p><p>这些数据在内存里  会自动打包在一起</p></div>	
<div class='layout'><p>If we access, for example, J index of 0, we get back the whole struct stored there,</p><p>如果写 j[0]，能拿到  j[0] 里的结构体</p></div>	
<div class='layout'><p>and we can pull the specific account number and balance data we want.</p><p>然后拿银行账户和余额</p></div>	
<img style="float:right;" width="70%" src="../img/1401.png" />
<div class='layout'><p>This array of structs, like any other array,</p><p>存结构体的数组，和其它数组一样</p></div>	
<div class='layout'><p>gets created at a fixed size that can't be enlarged to add more items.</p><p>创建时就有固定大小，不能动态增加大小</p></div>	
<div class='layout'><p>Also, arrays must be stored in order in memory,</p><p>还有，数组在内存中 按顺序存储</p></div>	
<div class='layout'><p>making it hard to add a new item to the middle.</p><p>在中间插入一个值很困难</p></div>	
<div class='layout'><p>But, the struct data structure can be used for</p><p>但结构体可以创造更复杂的数据结构，</p></div>	
<div class='layout'><p>building more complicated data structures that avoid these restrictions.</p><p>消除这些限制</p></div>	
<div class='layout'><p>Let's take a look at this struct that's called a "node".</p><p>我们来看一个结构体，叫 节点(node)</p></div>	
<div class='layout'><p>It stores a variable, like a number, and also a pointer.</p><p>它存一个变量，一个指针（pointer）</p></div>	
<div class='layout'><p>A pointer is a special variable that points, hence the name, to a location in memory.</p><p>指针 是一种特殊变量，指向一个内存地址，因此得名.</p></div>	
<div class='layout'><p>Using this struct, we can create a linked list,</p><p>用 节点 可以做 链表（linked list）</p></div>	
<div class='layout'><p>which is a flexible data structure that can store many nodes.</p><p>链表是一种灵活数据结构，能存很多个 节点 (node)</p></div>	
<div class='layout'><p>It does this by having each node point to the next node in the list.</p><p>灵活性是通过每个节点 指向 下一个节点实现的</p></div>	
<div class='layout'><p>Let's imagine we have three node structs saved in memory, at locations 1000, 1002 and 1008.</p><p>假设有三个节点，在内存地址 1000，1002， 1008</p></div>	
<div class='layout'><p>They might be spaced apart because they were created at different times,</p><p>隔开的原因 可能是创建时间不同</p></div>	
<div class='layout'><p>and other data can sit between them.</p><p>它们之间有其他数据</p></div>	
<div class='layout'><p>So, you see that the first node contains the value 7, and the location 1008 in its "next" pointer.</p><p>可以看到第一个节点，值是 7，指向地址 1008</p></div>	
<div class='layout'><p>This means that the next node in the linked list is located at memory location 1008.</p><p>代表下一个节点，位于内存地址 1008</p></div>	
<div class='layout'><p>Looking down the linked list, to the next node,</p><p>现在来到下一个节点</p></div>	
<div class='layout'><p>we see it stores the value 112 and points to another node at location 1002.</p><p>值是 112，指向地址 1002</p></div>	
<div class='layout'><p>If we follow that, we find a node that contains the value 14</p><p>如果跟着它，会看到一个值为 14 的节点</p></div>	
<div class='layout'><p>and points back to the first node at location 1000.</p><p>这个节点  指回地址 1000，也就是第一个节点</p></div>	
<div class='layout'><p>So this linked list happened to be circular,</p><p>这叫 循环链表</p></div>	
<div class='layout'><p>but it could also have been terminated by using a next pointer value of 0</p><p>但链表也可以是非循环的，最后一个指针是 0</p></div>	
<div class='layout'><p>the null value -which would indicate we've reached the end of the list.</p><p>null，代表链表尽头</p></div>	
<div class='layout'><p>When programmers use linked lists,</p><p>当程序员用链表时</p></div>	
<div class='layout'><p>they rarely look at the memory values stored in the next pointers.</p><p>很少看指针具体指向哪里</p></div>	
<div class='layout'><p>Instead, they can use an abstraction of a linked list, that looks like this,</p><p>而是用链表的抽象模型，就像上图</p></div>	
<div class='layout'><p>which is much easier to conceptualize.</p><p>更容易看懂</p></div>	
<div class='layout'><p>Unlike an array, whose size has to be pre-defined,</p><p>数组大小需要预先定好</p></div>	
<div class='layout'><p>linked lists can be dynamically extended or shortened.</p><p>链表大小可以动态增减</p></div>	
<div class='layout'><p>For example, we can allocate a new node in memory,</p><p>可以创建一个新节点，通过改变指针值，把新节点插入链表</p></div>	
<div class='layout'><p>and insert it into this list, just by changing the next pointers.</p><p>可以创建一个新节点，通过改变指针值，把新节点插入链表</p></div>	
<div class='layout'><p>Linked Lists can also easily be re-ordered, trimmed, split, reversed, and so on.</p><p>链表也很容易重新排序，两端缩减，分割，倒序等</p></div>	
<div class='layout'><p>Which is pretty nifty!</p><p>超方便！</p></div>	
<div class='layout'><p>And pretty useful for algorithms like sorting, which we talked about last week.</p><p>链表也适合上集的排序算法</p></div>	
<div class='layout'><p>Owing to this flexibility, many more-complex data structures are built on top of linked lists</p><p>因为灵活，很多复杂数据结构 都用链表</p></div>	
<div class='layout'><p>The most famous and universal are queues and stacks.</p><p>最出名的是 队列（queue）和 栈（stack）</p></div>	
<div class='layout'><p>A queue like the line at your post office goes in order of arrival.</p><p>队列 就像邮局排队，谁先来就排前面</p></div>	
<div class='layout'><p>The person who has been waiting the longest, gets served first.</p><p>队列 就像邮局排队，谁先来就排前面</p></div>	
<div class='layout'><p>No matter how frustrating it is that all you want to do is buy stamps</p><p>虽然你可能只想买邮票，</p></div>	
<div class='layout'><p>and the person in front of you seems to be mailing 23 packages.</p><p>而前面的人要寄 23 个包裹</p></div>	
<div class='layout'><p>But, regardless, this behavior is called First-In First-Out, or FIFO.</p><p>这叫 先进先出（FIFO）</p></div>	
<div class='layout'><p>That's the first part.</p><p>我指队列，</p></div>	
<div class='layout'><p>Not the 23 packages thing.</p><p>不是指那 23 个包裹</p></div>	
<div class='layout'><p>Imagine we have a pointer, named "post office queue", that points to the first node in our linked list.</p><p>想象有个指针叫"邮局队列"，指向链表第一个节点</p></div>	
<div class='layout'><p>Once we're done serving Hank, we can read Hank's next pointer,</p><p>第一个节点是 Hank，服务完 Hank 之后，读取 Hank 的指针</p></div>	
<div class='layout'><p>and update our "post office queue" pointer to the next person in the line.</p><p>把"邮局队列"指向下一个人</p></div>	
<div class='layout'><p>We've successfully dequeued Hank -he's gone, done, finished.</p><p>这样就把 Hank "出队"（dequeue）了</p></div>	
<div class='layout'><p>If we want to enqueue someone, that is, add them to the line,</p><p>如果我们想把某人"入队"（enqueue），意思是加到队列里</p></div>	
<div class='layout'><p>we have to traverse down the linked list until we hit the end,</p><p>要遍历整个链表到结尾</p></div>	
<div class='layout'><p>and then change that next pointer to point to the new person.</p><p>然后把结尾的指针，指向新人（Nick）</p></div>	
<div class='layout'><p>With just a small change, we can use linked lists as stacks, which are LIFO…</p><p>只要稍作修改，就能用链表做 栈，</p></div>	
<div class='layout'><p>Last-In First-Out.</p><p>栈是后进先出(LIFO)</p></div>	
<div class='layout'><p>You can think of this like a stack of pancakes...</p><p>可以把"栈"想成一堆松饼</p></div>	
<div class='layout'><p>as you make them, you add them to the top of stack.</p><p>做好一个新松饼，就堆在之前上面</p></div>	
<div class='layout'><p>And when you want to eat one, you take them from the top of the stack.</p><p>吃的时候，是从最上面开始</p></div>	
<div class='layout'><p>Delicious!</p><p>美味！</p></div>	
<div class='layout'><p>Instead of enqueueing and dequeuing,</p><p>栈就不叫"入队""出队"了</p></div>	
<div class='layout'><p>data is pushed onto the stack and popped from the stacks.</p><p>叫"入栈"（push） "出栈"（pop）</p></div>	
<div class='layout'><p>Yep, those are the official terms!</p><p>对，这些是正确术语！</p></div>	
<div class='layout'><p>If we update our node struct to contain not just one, but two pointers,</p><p>如果节点改一下，改成 2 个指针</p></div>	
<div class='layout'><p>we can build trees,</p><p>就能做 树（tree）</p></div>	
<img style="float:right;" width="70%" src="../img/1402.png" />
<div class='layout'><p>another data structure that's used in many algorithms.</p><p>很多算法用了 "树" 这种数据结构</p></div>	
<div class='layout'><p>Again, programmers rarely look at the values of these pointers,</p><p>同样，程序员很少看指针的具体值</p></div>	
<div class='layout'><p>and instead conceptualize trees like this: The top most node is called the root.</p><p>而是把"树"抽象成这样：最高的节点叫"根节点"（root）</p></div>	
<div class='layout'><p>And any nodes that hang from other nodes are called children nodes.</p><p>根节点下的所有节点   都叫"子节点"（children）</p></div>	
<div class='layout'><p>As you might expect, nodes above children are called parent nodes.</p><p>任何子节点的直属上层节点，叫"母节点"（parent node）</p></div>	
<div class='layout'><p>Does this example imply that Thomas Jefferson is the parent of Aaron Burr?</p><p>这个例子能说明 托马斯·杰斐逊 是 阿龙·伯尔 的父亲吗？</p></div>	
<div class='layout'><p>I'll leave that to your fanfiction to decide.</p><p>我让你们的同人文来决定</p></div>	
<div class='layout'><p>And finally, any nodes that have no children</p><p>没有任何"子节点"的节点</p></div>	
<div class='layout'><p>where the tree ends -are called Leaf Nodes.</p><p>也就是"树"结束的地方，叫"叶节点"（leaf）</p></div>	
<div class='layout'><p>In our example, nodes can have up to two children,</p><p>在这里的例子中，节点最多只可以有 2 个子节点</p></div>	
<div class='layout'><p>and for that reason, this particular data structure is called a binary tree.</p><p>因此叫 二叉树（binary tree）</p></div>	
<div class='layout'><p>But you could just as easily have trees with three, four or any number of children</p><p>但你可以随便改，</p></div>	
<div class='layout'><p>by modifying the data structure accordingly.</p><p>弄成 3个，4个，或更多</p></div>	
<div class='layout'><p>You can even have tree nodes that use linked lists to store all the nodes they point to.</p><p>甚至节点 可以用链表存所有子节点</p></div>	
<div class='layout'><p>An important property of trees both in real life and in data structures is that</p><p>树的一个重要性质是（不管现实中还是数据结构中）</p></div>	
<div class='layout'><p>there's a one-way path from roots to leaves.</p><p>根到"叶"是 单向 的</p></div>	
<div class='layout'><p>It'd be weird if roots connected to leaves, that connected to roots.</p><p>如果根连到叶，叶连到根  就很奇怪</p></div>	
<div class='layout'><p>For data that links arbitrarily, that include things like loops,</p><p>如果数据随意连接，包括循环</p></div>	
<div class='layout'><p>we can use a graph data structure instead.</p><p>可以用"图"表示</p></div>	
<div class='layout'><p>Remember our graph from last episode of cities connected by roads?</p><p>还记得上集用路连接城市的"图"吗？</p></div>	
<div class='layout'><p>This can be stored as nodes with many pointers, very much like a tree,</p><p>这种结构  可以用有多个指针的节点表示</p></div>	
<div class='layout'><p>but there is no notion of roots and leaves, and children and parents…</p><p>因此没有 根、叶、子节点、父节点 这些概念</p></div>	
<div class='layout'><p>Anything can point to anything!</p><p>可以随意指向！</p></div>	
<div class='layout'><p>So that's a whirlwind overview</p><p>以上概述了计算机科学中，</p></div>	
<div class='layout'><p>of pretty much all of the fundamental data structures used in computer science.</p><p>最主要的一些数据结构</p></div>	
<div class='layout'><p>On top of these basic building blocks,</p><p>这些基本结构之上，程序员做了各种新变体，有不同性质.</p></div>	
<div class='layout'><p>programmers have built all sorts of clever variants, with slightly different properties</p><p>这些基本结构之上，程序员做了各种新变体，有不同性质.</p></div>	
<div class='layout'><p>data structures like red-black trees and heaps, which we don't have time to cover.</p><p>比如"红黑树"和"堆"，我们没时间讲</p></div>	
<div class='layout'><p>These different data structures have properties that are useful for particular computations.</p><p>不同数据结构适用于不同场景</p></div>	
<div class='layout'><p>The right choice of data structure can make your job a lot easier,</p><p>选择正确数据结构会让工作更简单</p></div>	
<div class='layout'><p>so it pays off to think about how you want to structure your data before you jump in.</p><p>所以花时间考虑用什么数据结构是值得的</p></div>	
<div class='layout'><p>Fortunately, most programming languages come with</p><p>幸运的是，大多数编程语言自带了</p></div>	
<div class='layout'><p>libraries packed full of ready-made data structures.</p><p>预先做好的数据结构</p></div>	
<div class='layout'><p>For example, C++ has its Standard Template Library, and Java has the Java Class Library.</p><p>比如，C++有"标准模板库"，Java有"Java 类库"</p></div>	
<div class='layout'><p>These mean programmers don't have to waste time implementing things from scratch,</p><p>程序员不用浪费时间从零写</p></div>	
<div class='layout'><p>and can instead wield the power of data structures to do more interesting things,</p><p>时间可以花在更有趣的事情</p></div>	
<div class='layout'><p>once again allowing us to operate at a new level of abstraction!</p><p>又提升了一层抽象！</p></div>	
<div class='layout'><p>I'll see you next week.</p><p>下周见！</p></div>	
﻿
</div> <!--container-->
<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>
<a id="fPagea" href="index.html" target="_self"><div id="fPage" style="color:#fff;">上<br>一<br>章</div></a>
<a href="index.html" target="_self"><div id="menuPage" style="color:#fff;">目<br>录</div></a>
<a id="LPagea" href="javascript:void(null)" target="_self"><div id="lPage" style="color:#fff;">下<br>一<br>章</div></a>
<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
	//上一页、下一页按钮，需要文件名是数字
	var strUrl=window.location.href;
	var arrUrl=strUrl.split("/");
	var thispage=arrUrl[arrUrl.length-1];
	var thispage2=thispage.split(".");
	var thispage3=thispage2[thispage2.length-2];
	if(thispage3 == 0){
		var obj5=document.getElementById("fPage");
		obj5.style.display="none";
	}else{
		var fpage = thispage3 - 1;
		fpage = fpage +".html";
		document.getElementById("fPagea").href=fpage;
	}
	if(thispage3 == 100){
		var obj6=document.getElementById("lPage");
		obj6.style.display="none";
	}else{
		var fpage = parseInt(thispage3) + 1;
		fpage = fpage +".html";
		document.getElementById("LPagea").href=fpage;
	}
</script>
</div>
</body>
</html>
