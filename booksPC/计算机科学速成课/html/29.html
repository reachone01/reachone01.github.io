<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//谷歌浏览器  
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox等浏览器
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//谷歌浏览器  
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox等浏览器  
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
</script>
<script>
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:link，#container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:85.29%;
	line-height:1.6em;
	overflow:hidden;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}
#goTopBtn, #goBottom, #shangy, #xiay, #menuPage, #lPage, #fPage, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #menuPage, #lPage, #fPage, #ftsize1, #ftsize3{
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #lPage, #fPage, #ftsize, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#fPage{
	bottom: 236px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
	//writing-mode:tb-rl;
}
#menuPage{
	bottom: 198px;
	height:27px;
	white-space:nowrap;
	overflow:hidden;
}
#lPage{
	bottom: 145px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
}
#ftsize1{
	bottom:360px;
}
#ftsize2{
	bottom:334px;
}
#ftsize3{
	bottom:308px;
}
#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #menuPage:hover, #lPage:hover, #fPage:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #menuPage a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link, #menuPage a:visited, #lPage a:link, #fPage a:link, #lPage a:visited, #fPage a:visited {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
.code0, .code2, .code4{
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
.layout, .layout2{
    clear:both;
	width:95%;
	border:1px dotted #eee;
	margin:auto;
	margin-bottom:5px;
	overflow:hidden;
}
.layout2 .right, .layout2 .left, .layout p{
margin-bottom:-55px;
padding-bottom:55px;
text-align: justify;
margin:0;
padding:0;
margin-left:1%;
margin-right:1%;
}
.layout2 .left, .layout p{
float:left;
width:60%;
font-size:1.0em;
}
.layout2 .right,  .layout p+p {
	float: left;
	width:34%;
	border-left:1px dotted #cccccc;
	font-size:0.9em;
	padding-left:1%;
	
}
.layout2 .right p, .layout2 .left p, .layout p{
padding-bottom:5px;
}
h3{
text-indent:3%;
font-size:1em;
height:2.0em;
padding:0;
margin:0;
}
</style>
</head>
<body>
<div id="container">
﻿<div class='layout'><p>29 The Internet</p><p>29 互联网</p></div>	
<div class='layout'><p>Hi, I'm Carrie Anne, and welcome to CrashCourse Computer Science!</p><p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p></div>	
<div class='layout'><p>As we talked about last episode, your computer is connected to a large, distributed network,</p><p>上集讲到，你的计算机和一个巨大的分布式网络连在一起</p></div>	
<div class='layout'><p>called The Internet.</p><p>这个网络叫互联网</p></div>	
<div class='layout'><p>I know this because you're watching a YouTube video,</p><p>你现在就在网上看视频呀</p></div>	
<div class='layout'><p>which is being streamed over that very internet.</p><p>就在互联网上。</p></div>	
<div class='layout'><p>It's arranged as an ever-enlarging web of interconnected devices.</p><p>互联网由无数互联设备组成，而且日益增多</p></div>	
<div class='layout'><p>For your computer to get this video,</p><p>计算机为了获取这个视频，</p></div>	
<div class='layout'><p>the first connection is to your local area network, or LAN,</p><p>首先要连到局域网，也叫 LAN</p></div>	
<div class='layout'><p>which might be every device in your house that's connected to your wifi router.</p><p>你家 WIFI 路由器连着的所有设备，组成了局域网.</p></div>	
<div class='layout'><p>This then connects to a Wide Area Network, or WAN,</p><p>局域网再连到广域网，广域网也叫 WAN</p></div>	
<div class='layout'><p>which is likely to be a router run by your Internet Service Provider, or ISP，</p><p>WAN 的路由器一般属于你的"互联网服务提供商"，简称 ISP</p></div>	
<div class='layout'><p>companies like Comcast, AT&T or Verizon.</p><p>比如 Comcast，AT&T 和 Verizon 这样的公司</p></div>	
<div class='layout'><p>At first, this will be a regional router, like one for your neighborhood,</p><p>广域网里，先连到一个区域性路由器，这路由器可能覆盖一个街区。</p></div>	
<div class='layout'><p>and then that router connects to an even bigger WAN,</p><p>然后连到一个更大的 WAN，</p></div>	
<div class='layout'><p>maybe one for your whole city or town.</p><p>可能覆盖整个城市</p></div>	
<div class='layout'><p>There might be a couple more hops, but ultimately you'll connect to the backbone of the internet</p><p>可能再跳几次，但最终会到达互联网主干</p></div>	
<div class='layout'><p>made up of gigantic routers with super high-bandwidth connections running between them.</p><p>互联网主干由一群超大型、带宽超高路由器组成</p></div>	
<div class='layout'><p>To request this video file from YouTube,</p><p>为了从 YouTube 获得这个视频，</p></div>	
<div class='layout'><p>a packet had to work its way up to the backbone,</p><p>数据包（packet）要先到互联网主干</p></div>	
<div class='layout'><p>travel along that for a bit, and then work its way back down to a YouTube server that had the file.</p><p>沿着主干到达有对应视频文件的 YouTube 服务器</p></div>	
<div class='layout'><p>That might be four hops up, two hops across the backbone,</p><p>数据包从你的计算机跳到 Youtube 服务器，可能要跳个10次，</p></div>	
<div class='layout'><p>and four hops down, for a total of ten hops.</p><p>先跳4次到互联网主干，2次穿过主干，主干出来可能再跳4次，然后到 Youtube 服务器</p></div>	
<div class='layout'><p>If you're running Windows, Mac OS or Linux, you can see the route data takes to different</p><p>如果你在用 Windows， Mac OS 或 Linux系统，可以用 traceroute 来看跳了几次</p></div>	
<div class='layout'><p>places on the internet by using the traceroute program on your computer.</p><p>如果你在用 Windows， Mac OS 或 Linux系统，可以用 traceroute 来看跳了几次</p></div>	
<div class='layout'><p>Instructions in the Doobly Doo.</p><p>更多详情看视频描述（YouTube原视频下）</p></div>	
<div class='layout'><p>For us here at the Chad & Stacey Emigholz Studio in Indianapolis,</p><p>我们在"印第安纳波利斯"的 Chad&Stacy Emigholz 工作室，访问加州的 DFTBA 服务器，</p></div>	
<div class='layout'><p>the route to the DFTBA server in California goes through 11 stops.</p><p>经历了11次中转</p></div>	
<div class='layout'><p>We start at 192.168.0.1 -that's the IP address for my computer on our LAN.</p><p>从 192.168.0. 出发，这是我的电脑在 局域网（LAN）里的 IP 地址</p></div>	
<div class='layout'><p>Then there's the wifi router here at the studio,</p><p>然后到工作室的 WIFI 路由器</p></div>	
<div class='layout'><p>then a series of regional routers, then we get onto the backbone,</p><p>然后穿过一个个地区路由器，到达主干.</p></div>	
<div class='layout'><p>and then we start working back down to the computer hosting "DFTBA.com”,</p><p>然后从主干出来，又跳了几次，到达"DFTBA.com”的服务器</p></div>	
<div class='layout'><p>which has the IP address 104.24.109.186.</p><p>IP 地址是 104.24.109.186.</p></div>	
<div class='layout'><p>But how does a packet actually get there?</p><p>但数据包*到底*是怎么过去的？</p></div>	
<div class='layout'><p>What happens if a packet gets lost along the way?</p><p>如果传输时数据包被弄丢了，会发生什么？</p></div>	
<div class='layout'><p>If I type "DFTBA.com” into my web browser, how does it know the server's address?</p><p>如果在浏览器里输 "DFTBA.com"，浏览器怎么知道服务器的地址多少？</p></div>	
<div class='layout'><p>These are our topics for today!</p><p>我们今天会讨论这些话题.</p></div>	
<div class='layout'><p>As we discussed last episode, the internet is a huge distributed network</p><p>上集说过，互联网是一个巨型分布式网络，</p></div>	
<div class='layout'><p>that sends data around as little packets.</p><p>会把数据拆成一个个数据包来传输</p></div>	
<div class='layout'><p>If your data is big enough, like an email attachment,</p><p>如果要发的数据很大，比如邮件附件，</p></div>	
<div class='layout'><p>it might get broken up into many packets.</p><p>数据会被拆成多个小数据包</p></div>	
<div class='layout'><p>For example, this video stream is arriving to your computer right now</p><p>举例，你现在看的这个视频，就是一个个到达你电脑的数据包</p></div>	
<div class='layout'><p>as a series of packets, and not one gigantic file.</p><p>而不是一整个大文件发过来</p></div>	
<div class='layout'><p>Internet packets have to conform to a standard called the Internet Protocol, or IP.</p><p>数据包（packet）想在互联网上传输，要符合"互联网协议"的标准，简称 IP</p></div>	
<div class='layout'><p>It's a lot like sending physical mail through the postal system</p><p>就像邮寄手写信一样，邮寄是有标准的，</p></div>	
<div class='layout'><p>every letter needs a unique and legible address written on it,</p><p>每封信需要一个地址，而且地址必须是独特的</p></div>	
<div class='layout'><p>and there are limits to the size and weight of packages.</p><p>并且大小和重量是有限制的</p></div>	
<div class='layout'><p>Violate this, and your letter won't get through.</p><p>违反这些规定，信件就无法送达.</p></div>	
<div class='layout'><p>IP packets are very similar.</p><p>IP 数据包也是如此</p></div>	
<div class='layout'><p>However, IP is a very low level protocol</p><p>因为 IP 是一个非常底层的协议</p></div>	
<div class='layout'><p>there isn't much more than a destination address in a packet's header</p><p>数据包的头部（或者说前面）只有目标地址</p></div>	
<div class='layout'><p>which is the metadata that's stored in front of the data payload.</p><p>头部存 "关于数据的数据"，也叫 元数据(metadata)</p></div>	
<div class='layout'><p>This means that a packet can show up at a computer, but the computer may not know</p><p>这意味着当数据包到达对方电脑，对方不知道把包交给哪个程序，</p></div>	
<div class='layout'><p>which application to give the data to; Skype or Call of Duty.</p><p>是交给 Skype 还是使命召唤？</p></div>	
<div class='layout'><p>For this reason, more advanced protocols were developed that sit on top of IP.</p><p>因此需要在 IP 之上，开发更高级的协议.</p></div>	
<div class='layout'><p>One of the simplest and most common is the User Datagram Protocol, or UDP.</p><p>这些协议里，最简单最常见的叫"用户数据报协议"，简称 UDP</p></div>	
<div class='layout'><p>UDP has its own header, which sits inside the data payload.</p><p>UDP 也有头部，这个头部位于数据前面</p></div>	
<div class='layout'><p>Inside of the UDP header is some useful, extra information.</p><p>头部里包含有用的信息</p></div>	
<div class='layout'><p>One of them is a port number.</p><p>信息之一是端口号</p></div>	
<div class='layout'><p>Every program wanting to access the internet will</p><p>每个想访问网络的程序，</p></div>	
<div class='layout'><p>ask its host computer's Operating System to be given a unique port.</p><p>都要向操作系统申请一个端口号.</p></div>	
<div class='layout'><p>Like Skype might ask for port number 3478.</p><p>比如 Skype 会申请端口 3478</p></div>	
<div class='layout'><p>When a packet arrives to the computer, the Operating System</p><p>当一个数据包到达时，接收方的操作系统</p></div>	
<div class='layout'><p>will look inside the UDP header and read the port number.</p><p>会读 UDP 头部，读里面的端口号</p></div>	
<div class='layout'><p>Then, if it sees, for example, 3478, it will give the packet to Skype.</p><p>如果看到端口号是 3478，就把数据包交给 Skype</p></div>	
<div class='layout'><p>So to review, IP gets the packet to the right computer,</p><p>总结：IP 负责把数据包送到正确的计算机，</p></div>	
<div class='layout'><p>but UDP gets the packet to the right program running on that computer.</p><p>UDP 负责把数据包送到正确的程序</p></div>	
<div class='layout'><p>UDP headers also include something called a checksum,</p><p>UDP 头部里还有"校验和"，</p></div>	
<div class='layout'><p>which allows the data to be verified for correctness.</p><p>用于检查数据是否正确</p></div>	
<div class='layout'><p>As the name suggests, it does this by checking the sum of the data.</p><p>正如"校验和"这个名字所暗示的，检查方式是把数据求和来对比</p></div>	
<div class='layout'><p>Here's a simplified version of how this works.</p><p>以下是个简单例子</p></div>	
<div class='layout'><p>Let's imagine the raw data in our UDP packet is</p><p>假设 UDP 数据包里，</p></div>	
<div class='layout'><p>89 111 33 32 58 and 41.</p><p>原始数据是 89 111 33 32 58 41</p></div>	
<div class='layout'><p>Before the packet is sent, the transmitting computer calculates the checksum</p><p>在发送数据包前，电脑会把所有数据加在一起，算出"校验和"</p></div>	
<div class='layout'><p>by adding all the data together: 89 plus 111 plus 33 and so on.</p><p>89+111+33+.. 以此类推</p></div>	
<div class='layout'><p>In our example, this adds up to a checksum of 364.</p><p>得到 364，这就是"校验和".</p></div>	
<div class='layout'><p>In UDP, the checksum value is stored in 16 bits.</p><p>UDP 中，"校验和"以 16 位形式存储 (就是16个0或1)</p></div>	
<div class='layout'><p>If the sum exceeds the maximum possible value, the upper-most bits overflw,</p><p>如果算出来的和，超过了 16 位能表示的最大值，高位数会被扔掉，</p></div>	
<div class='layout'><p>and only the lower bits are used.</p><p>保留低位</p></div>	
<div class='layout'><p>Now, when the receiving computer gets this packet,</p><p>当接收方电脑收到这个数据包</p></div>	
<div class='layout'><p>it repeats the process, adding up all the data.</p><p>它会重复这个步骤，把所有数据加在一起，</p></div>	
<div class='layout'><p>89 plus 111 plus 33 and so on.</p><p>89+111+33.. 以此类推</p></div>	
<div class='layout'><p>If that sum is the same as the checksum sent in the header, all is well.</p><p>如果结果和头部中的校验和一致，代表一切正常</p></div>	
<div class='layout'><p>But, if the numbers don't match, you know that the data got corrupted</p><p>如果不一致，数据肯定坏掉了</p></div>	
<div class='layout'><p>at some point in transit, maybe because of a power fluctuation or faulty cable.</p><p>也许传输时碰到了功率波动，或电缆出故障了</p></div>	
<div class='layout'><p>Unfortunately, UDP doesn't offer any mechanisms to fix the data, or request a new copy</p><p>不幸的是，UDP 不提供数据修复或数据重发的机制</p></div>	
<div class='layout'><p>receiving programs are alerted to the corruption, but typically just discard the packet.</p><p>接收方知道数据损坏后，一般只是扔掉.</p></div>	
<div class='layout'><p>Also, UDP provides no mechanisms to know if packets are getting through</p><p>而且，UDP 无法得知数据包是否到达.</p></div>	
<div class='layout'><p>a sending computer shoots the UDP packet off,</p><p>发送方发了之后，</p></div>	
<div class='layout'><p>but has no confirmation it ever gets to its destination successfully.</p><p>无法知道数据包是否到达目的地</p></div>	
<div class='layout'><p>Both of these properties sound pretty catastrophic, but some applications are ok with this,</p><p>这些特性听起来很糟糕，但是有些程序不在意这些问题</p></div>	
<div class='layout'><p>because UDP is also really simple and fast.</p><p>因为 UDP 又简单又快.</p></div>	
<div class='layout'><p>Skype, for example, which uses UDP for video chat, can handle corrupt or missing packets.</p><p>拿 Skype 举例，它用 UDP 来做视频通话，能处理坏数据或缺失数据</p></div>	
<div class='layout'><p>That's why sometimes if you're on a bad internet connection,</p><p>所以网速慢的时候 Skype 卡卡的，</p></div>	
<div class='layout'><p>Skype gets all glitchy – only some of the UDP packets are making it to your computer.</p><p>因为只有一部分数据包到了你的电脑</p></div>	
<div class='layout'><p>But this approach doesn't work for many other types of data transmission.</p><p>但对于其他一些数据，这个方法不适用.</p></div>	
<div class='layout'><p>Like, it doesn't really work if you send an email, and it shows up with the middle missing.</p><p>比如发邮件，邮件不能只有开头和结尾 没有中间.</p></div>	
<div class='layout'><p>The whole message really needs to get there correctly!</p><p>邮件要完整到达收件方</p></div>	
<div class='layout'><p>When it "absolutely, positively needs to get there”,</p><p>如果"所有数据必须到达"，</p></div>	
<div class='layout'><p>programs use the Transmission Control Protocol, or TCP,</p><p>就用"传输控制协议"，简称 TCP</p></div>	
<div class='layout'><p>which like UDP, rides inside the data payload of IP packets.</p><p>TCP 和 UDP 一样，头部也在存数据前面</p></div>	
<div class='layout'><p>For this reason, people refer to this combination of protocols as TCP/IP.</p><p>因此，人们叫这个组合 TCP/IP</p></div>	
<div class='layout'><p>Like UDP, the TCP header contains a destination port and checksum.</p><p>就像 UDP ，TCP 头部也有"端口号"和"校验和"</p></div>	
<div class='layout'><p>But, it also contains fancier features, and we'll focus on the key ones.</p><p>但 TCP 有更高级的功能，我们这里只介绍重要的几个</p></div>	
<div class='layout'><p>First off, TCP packets are given sequential numbers.</p><p>1 TCP 数据包有序号</p></div>	
<div class='layout'><p>So packet 15 is followed by packet 16, which is followed by 17, and so on...</p><p>15号之后是16号，16号之后是17号，以此类推，</p></div>	
<div class='layout'><p>for potentially millions of packets sent during that session.</p><p>发上百万个数据包也是有可能的.</p></div>	
<div class='layout'><p>These sequence numbers allow a receiving computer to put the packets into the correct order,</p><p>序号使接收方可以把数据包排成正确顺序，</p></div>	
<div class='layout'><p>even if they arrive at different times across the network.</p><p>即使到达时间不同.</p></div>	
<div class='layout'><p>So if an email comes in all scrambled, the TCP implementation in your computer's operating</p><p>哪怕到达顺序是乱的，</p></div>	
<div class='layout'><p>system will piece it all together correctly.</p><p>TCP 协议也能把顺序排对</p></div>	
<div class='layout'><p>Second, TCP requires that once a computer has correctly received a packet</p><p>2 TCP 要求接收方的电脑收到数据包，</p></div>	
<div class='layout'><p>and the data passes the checksum – that it send back an acknowledgement,</p><p>并且"校验和"检查无误后（数据没有损坏），给发送方发一个确认码，代表收到了</p></div>	
<div class='layout'><p>or "ACK” as the cool kids say, to the sending computer.</p><p>确认码 简称 ACK，</p></div>	
<div class='layout'><p>Knowing the packet made it successfully, the sender can now transmit the next packet.</p><p>得知上一个数据包成功抵达后，发送方会发下一个数据包</p></div>	
<div class='layout'><p>But this time, let's say, it waits, and doesn't get an acknowledgement packet back.</p><p>假设这次发出去之后，没收到确认码，那么肯定哪里错了</p></div>	
<div class='layout'><p>Something must be wrong. If enough time elapses,</p><p>如果过了一定时间还没收到确认码，</p></div>	
<div class='layout'><p>the sender will go ahead and just retransmit the same packet.</p><p>发送方会再发一次</p></div>	
<div class='layout'><p>It's worth noting here  that the original packet might have actually gotten there,</p><p>注意 数据包可能的确到了</p></div>	
<div class='layout'><p>but the acknowledgment is just really delayed.</p><p>只是确认码延误了很久</p></div>	
<div class='layout'><p>Or perhaps it was the acknowledgment that was lost.</p><p>或传输中丢失了</p></div>	
<div class='layout'><p>Either way, it doesn't matter, because the receiver has those sequence numbers,</p><p>但这不碍事 因为收件方有序列号</p></div>	
<div class='layout'><p>and if a duplicate packet arrives, it can be discarded.</p><p>如果收到重复的数据包就删掉</p></div>	
<div class='layout'><p>Also, TCP isn't limited to a back and forth conversation – it can send many packets,</p><p>还有，TCP 不是只能一个包一个包发</p></div>	
<div class='layout'><p>and have many outstanding ACKs, which increases bandwidth significantly, since you aren't</p><p>可以同时发多个数据包，收多个确认码，这大大增加了效率，</p></div>	
<div class='layout'><p>wasting time waiting for acknowledgment packets to return.</p><p>不用浪费时间等确认码</p></div>	
<div class='layout'><p>Interestingly, the success rate of ACKs, and also the round trip time</p><p>有趣的是，确认码的成功率和来回时间，</p></div>	
<div class='layout'><p>between sending and acknowledging, can be used to infer network congestion.</p><p>可以推测网络的拥堵程度</p></div>	
<div class='layout'><p>TCP uses this information to adjust how aggressively it sends packets –</p><p>TCP 用这个信息，调整同时发包数量，</p></div>	
<div class='layout'><p>a mechanism for congestion control.</p><p>解决拥堵问题</p></div>	
<div class='layout'><p>So, basically, TCP can handle out-of-order packet delivery, dropped packets</p><p>简单说，TCP 可以处理乱序和丢失数据包，丢了就重发.</p></div>	
<div class='layout'><p>including retransmission – and even throttle its transmission rate according to available bandwidth.</p><p>还可以根据拥挤情况自动调整传输率</p></div>	
<div class='layout'><p>Pretty awesome!</p><p>相当厉害！</p></div>	
<div class='layout'><p>You might wonder why anyone would use UDP when TCP has all those nifty features.</p><p>你可能会奇怪，既然 TCP 那么厉害，还有人用 UDP 吗？</p></div>	
<div class='layout'><p>The single biggest downside are all those acknowledgment packets</p><p>TCP 最大的缺点是，</p></div>	
<div class='layout'><p>it doubles the number of messages on the network,</p><p>那些"确认码"数据包把数量翻了一倍</p></div>	
<div class='layout'><p>and yet, you're not transmitting any more data.</p><p>但并没有传输更多信息</p></div>	
<div class='layout'><p>That overhead, including associated delays, is sometimes not worth the improved robustness,</p><p>有时候这种代价是不值得的，特别是对时间要求很高的程序，</p></div>	
<div class='layout'><p>especially for time-critical applications, like Multiplayer First Person Shooters.</p><p>比如在线射击游戏</p></div>	
<div class='layout'><p>And if it's you getting lag-fragged you'll definitely agree!</p><p>如果你玩游戏很卡，你也会觉得这样不值！</p></div>	
<div class='layout'><p>When your computer wants to make a connection to a website, you need two things</p><p>当计算机访问一个网站时，需要两个东西：</p></div>	
<div class='layout'><p>an IP address and a port.</p><p>1 IP地址 2 端口号</p></div>	
<div class='layout'><p>Like port 80, at 172.217.7.238.</p><p>例如 172.217.7.238 的 80 端口，</p></div>	
<div class='layout'><p>This example is the IP address and port for the Google web server.</p><p>这是谷歌的 IP 地址和端口号</p></div>	
<div class='layout'><p>In fact, you can enter this into your browser's address bar, like so,</p><p>事实上，你可以输到浏览器里，</p></div>	
<div class='layout'><p>and you'll end up on the google homepage.</p><p>然后你会进入谷歌首页</p></div>	
<div class='layout'><p>This gets you to the right destination,</p><p>有了这两个东西就能访问正确的网站，</p></div>	
<div class='layout'><p>but remembering that long string of digits would be really annoying.</p><p>但记一长串数字很讨厌</p></div>	
<div class='layout'><p>It's much easier to remember: google.com.</p><p>google.com 比一长串数字好记</p></div>	
<div class='layout'><p>So the internet has a special service that maps these domain names to addresses.</p><p>所以互联网有个特殊服务，负责把域名和 IP 地址一一对应</p></div>	
<div class='layout'><p>It's like the phone book for the internet.</p><p>就像专为互联网的电话簿，</p></div>	
<div class='layout'><p>And it's called the Domain Name System, or DNS for short.</p><p>它叫"域名系统"，简称 DNS</p></div>	
<div class='layout'><p>You can probably guess how it works.</p><p>它的运作原理你可能猜到了</p></div>	
<div class='layout'><p>When you type something like "youtube.com” into your web browser,</p><p>在浏览器里输 youtube.com，浏览器会去问 DNS 服务器，它的 IP 地址是多少</p></div>	
<div class='layout'><p>it goes and asks a DNS server – usually one provided by your ISP – to lookup the address.</p><p>一般 DNS 服务器，是互联网供应商提供的</p></div>	
<div class='layout'><p>DNS consults its huge registry, and replies with the address... if one exists.</p><p>DNS 会查表，如果域名存在，就返回对应 IP 地址.</p></div>	
<div class='layout'><p>In fact, if you try mashing your keyboard, adding ".com”, and then hit enter in your</p><p>如果你乱敲键盘加个.com 然后按回车</p></div>	
<div class='layout'><p>browser, you'll likely be presented with an error that says DNS failed.</p><p>你很可能会看到 DNS 错误</p></div>	
<div class='layout'><p>That's because that site doesn't exist, so DNS couldn't give your browser an address.</p><p>因为那个网站不存在，所以 DNS 无法返回给你一个地址</p></div>	
<div class='layout'><p>But, if DNS returns a valid address, which it should for "YouTube.com”, then your</p><p>如果你输的是有效地址，比如 youtube.com，DNS 按理会返回一个地址</p></div>	
<div class='layout'><p>browser shoots off a request over TCP for the website's data.</p><p>然后浏览器会给这个 IP 地址，发 TCP 请求</p></div>	
<div class='layout'><p>There's over 300 million registered domain names, so to make out DNS Lookup a little</p><p>如今有三千万个注册域名，所以为了更好管理</p></div>	
<div class='layout'><p>more manageable, it's not stored as one gigantically long list,</p><p>DNS 不是存成一个超长超长的列表，</p></div>	
<div class='layout'><p>but rather in a tree data structure.</p><p>而是存成树状结构</p></div>	
<div class='layout'><p>What are called Top Level Domains, or TLDs, are at the very top.</p><p>顶级域名（简称 TLD）在最顶部，</p></div>	
<div class='layout'><p>These are huge categories like .com and .gov.</p><p>比如 .com 和 .gov</p></div>	
<div class='layout'><p>Then, there are lower level domains that sit below that, called second level domains; Examples</p><p>下一层是二级域名，比如 .com </p></div>	
<div class='layout'><p>under .com include google.com and dftba.com.</p><p>下面有，google.com 和 dftba.com</p></div>	
<div class='layout'><p>Then, there are even lower level domains, called subdomains,</p><p>再下一层叫子域名，</p></div>	
<div class='layout'><p>like images.google.com, store.dftba.com.</p><p>比如 images.google.com， store.dftba.com</p></div>	
<div class='layout'><p>And this tree is absolutely HUGE!</p><p>这个树超！级！大！</p></div>	
<div class='layout'><p>Like I said, more than 300 million domain names, and that's just second level domain</p><p>我前面说的"三千万个域名"只是二级域名，</p></div>	
<div class='layout'><p>names, not all the sub domains.</p><p>不是所有子域名</p></div>	
<div class='layout'><p>For this reason, this data is distributed across many DNS servers,</p><p>因此，这些数据散布在很多 DNS 服务器上</p></div>	

<img style="float:right;" width="70%" src="../img/2901.png" />

<div class='layout'><p>which are authorities for different parts of the tree.</p><p>不同服务器负责树的不同部分</p></div>	
<div class='layout'><p>Okay, I know you've been waiting for it...</p><p>好了 我知道你肯定在等这个梗：</p></div>	
<div class='layout'><p>We've reached a new level of abstraction!</p><p>我们到了一层新抽象！</p></div>	
<div class='layout'><p>Over the past two episodes, we've worked up from electrical signals on wires,</p><p>过去两集里，我们讲了线路里的电信号，</p></div>	
<div class='layout'><p>or radio signals transmitted through the air in the case of wireless networks.</p><p>以及无线网络里的无线信号</p></div>	
<div class='layout'><p>This is called the Physical Layer.</p><p>这些叫"物理层"</p></div>	
<div class='layout'><p>MAC addresses, collision detection,</p><p>而"数据链路层"负责操控"物理层"，数据链路层有：</p></div>	
<div class='layout'><p>exponential backoff and similar low level protocols that</p><p>媒体访问控制地址（MAC），碰撞检测，</p></div>	
<div class='layout'><p>mediate access to the physical layer are part of the Data Link Layer.</p><p>指数退避，以及其他一些底层协议</p></div>	
<div class='layout'><p>Above this is the Network Layer,</p><p>再上一层是"网络层"</p></div>	
<div class='layout'><p>which is where all the switching and routing technologies that we discussed operate.</p><p>负责各种报文交换和路由</p></div>	
<div class='layout'><p>And today, we mostly covered the Transport layer, protocols like UDP and TCP,</p><p>而今天，我们讲了"传输层"里一大部分，比如 UDP 和 TCP 这些协议，</p></div>	
<div class='layout'><p>which are responsible for point to point data transfer between computers,</p><p>负责在计算机之间进行点到点的传输</p></div>	
<div class='layout'><p>and also things like error detection and recovery when possible.</p><p>而且还会检测和修复错误</p></div>	
<div class='layout'><p>We've also grazed the Session Layer –</p><p>我们还讲了一点点"会话层"</p></div>	
<div class='layout'><p>where protocols like TCP and UDP are used to open a connection,</p><p>会话层会使用 TCP 和 UDP 来创建连接，</p></div>	
<div class='layout'><p>pass information back and forth, and then close the connection when finished</p><p>传递信息，然后关掉连接</p></div>	
<div class='layout'><p>what's called a session.</p><p>这一整套叫"会话"</p></div>	
<div class='layout'><p>This is exactly what happens when you, for example, do a DNS Lookup, or request a webpage.</p><p>查询 DNS 或看网页时，就会发生这一套流程</p></div>	
<div class='layout'><p>These are the bottom five layers of the Open System Interconnection (OSI) model,</p><p>这是 开放式系统互联通信参考模型(OSI) 的底下5层</p></div>	
<div class='layout'><p>a conceptual framework for compartmentalizing all these different network processes.</p><p>这个概念性框架 把网络通信划分成多层</p></div>	
<div class='layout'><p>Each level has different things to worry about and solve,</p><p>每一层处理各自的问题</p></div>	
<div class='layout'><p>and it would be impossible to build one huge networking implementation.</p><p>如果不分层，直接从上到下捏在一起实现网络通信，是完全不可能的</p></div>	
<div class='layout'><p>As we've talked about all series, abstraction allows computer scientists and engineers to</p><p>抽象使得科学家和工程师</p></div>	
<div class='layout'><p>be improving all these different levels of the stack simultaneously,</p><p>能分工同时改进多个层，</p></div>	
<div class='layout'><p>without being overwhelmed by the full complexity.</p><p>不被整体复杂度难倒.</p></div>	
<div class='layout'><p>And amazingly, we're not quite done yet</p><p>而且惊人的是！我们还没讲完呢！</p></div>	
<div class='layout'><p>The OSI model has two more layers, the Presentation Layer and the Application Layer,</p><p>OSI 模型还有两层，"表示层"和"应用程序层"</p></div>	
<div class='layout'><p>which include things like web browsers, Skype,</p><p>其中有浏览器，Skype，</p></div>	
<div class='layout'><p>HTML decoding, streaming movies and more.</p><p>HTML解码，在线看电影等</p></div>	
<div class='layout'><p>Which we'll talk about next week.  See you then.</p><p>我们下周说，到时见</p></div>	
﻿
</div> <!--container-->
<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>
<a id="fPagea" href="index.html" target="_self"><div id="fPage" style="color:#fff;">上<br>一<br>章</div></a>
<a href="index.html" target="_self"><div id="menuPage" style="color:#fff;">目<br>录</div></a>
<a id="LPagea" href="javascript:void(null)" target="_self"><div id="lPage" style="color:#fff;">下<br>一<br>章</div></a>
<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
	//上一页、下一页按钮，需要文件名是数字
	var strUrl=window.location.href;
	var arrUrl=strUrl.split("/");
	var thispage=arrUrl[arrUrl.length-1];
	var thispage2=thispage.split(".");
	var thispage3=thispage2[thispage2.length-2];
	if(thispage3 == 0){
		var obj5=document.getElementById("fPage");
		obj5.style.display="none";
	}else{
		var fpage = thispage3 - 1;
		fpage = fpage +".html";
		document.getElementById("fPagea").href=fpage;
	}
	if(thispage3 == 100){
		var obj6=document.getElementById("lPage");
		obj6.style.display="none";
	}else{
		var fpage = parseInt(thispage3) + 1;
		fpage = fpage +".html";
		document.getElementById("LPagea").href=fpage;
	}
</script>
</div>
</body>
</html>
