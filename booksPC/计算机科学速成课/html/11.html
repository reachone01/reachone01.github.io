<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//谷歌浏览器  
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox等浏览器
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//谷歌浏览器  
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox等浏览器  
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
</script>
<script>
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:link，#container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:85.29%;
	line-height:1.6em;
	overflow:hidden;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}
#goTopBtn, #goBottom, #shangy, #xiay, #menuPage, #lPage, #fPage, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #menuPage, #lPage, #fPage, #ftsize1, #ftsize3{
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #lPage, #fPage, #ftsize, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#fPage{
	bottom: 236px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
	//writing-mode:tb-rl;
}
#menuPage{
	bottom: 198px;
	height:27px;
	white-space:nowrap;
	overflow:hidden;
}
#lPage{
	bottom: 145px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
}
#ftsize1{
	bottom:360px;
}
#ftsize2{
	bottom:334px;
}
#ftsize3{
	bottom:308px;
}
#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #menuPage:hover, #lPage:hover, #fPage:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #menuPage a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link, #menuPage a:visited, #lPage a:link, #fPage a:link, #lPage a:visited, #fPage a:visited {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
.code0, .code2, .code4{
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
.layout, .layout2{
    clear:both;
	width:95%;
	border:1px dotted #eee;
	margin:auto;
	margin-bottom:5px;
	overflow:hidden;
}
.layout2 .right, .layout2 .left, .layout p{
margin-bottom:-55px;
padding-bottom:55px;
text-align: justify;
margin:0;
padding:0;
margin-left:1%;
margin-right:1%;
}
.layout2 .left, .layout p{
float:left;
width:60%;
font-size:1.0em;
}
.layout2 .right,  .layout p+p {
	float: left;
	width:34%;
	border-left:1px dotted #cccccc;
	font-size:0.9em;
	padding-left:1%;
	
}
.layout2 .right p, .layout2 .left p, .layout p{
padding-bottom:5px;
}
h3{
text-indent:3%;
font-size:1em;
height:2.0em;
padding:0;
margin:0;
}
</style>
</head>
<body>
<div id="container">
﻿<div class='layout'><p>11 The First Programming Languages</p><p>11 编程语言发展史</p></div>	
<div class='layout'><p>Hi, I'm Carrie Anne and welcome to Crash Course Computer Science!</p><p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p></div>	
<div class='layout'><p>So far, for most of this series, we've focused on hardware</p><p>之前我们把重点放在硬件 </p></div>	
<div class='layout'><p>the physical components of computing --</p><p>组成计算机的物理组件</p></div>	
<div class='layout'><p>things like: electricity and circuits, registers and RAM, ALUs and CPUs.</p><p>比如电，电路，寄存器，RAM，ALU，CPU</p></div>	
<div class='layout'><p>But programming at the hardware level is cumbersome and inflexible,</p><p>但在硬件层面编程非常麻烦</p></div>	
<div class='layout'><p>so programmers wanted a more versatile way to program computers</p><p>所以程序员想要一种更通用的方法编程</p></div>	
<div class='layout'><p>what you might call a "softer" medium.</p><p>一种"更软的"媒介</p></div>	
<div class='layout'><p>That's right, we're going to talk about Software!</p><p>没错，我们要讲软件！</p></div>	
<div class='layout'><p>In episode 8, we walked through a simple program for the CPU we designed.</p><p>第 8 集我们一步步讲了一个简单程序</p></div>	
<div class='layout'><p>The very first instruction to be executed, the one at memory address 0, was 0010 1110.</p><p>第一条指令在内存地址 0：0010 1110</p></div>	
<div class='layout'><p>As we discussed, the first four bits of an instruction is the operation code,</p><p>之前说过，前 4 位是操作码</p></div>	
<div class='layout'><p>or OPCODE for short.</p><p>简称 OPCODE</p></div>	
<div class='layout'><p>On our hypothetical CPU, 0010 indicated a LOAD_A instruction</p><p>对于这个假设 CPU，0010 代表 LOAD_A 指令</p></div>	
<div class='layout'><p>which moves a value from memory into Register A.</p><p>把值从内存复制到寄存器 A</p></div>	
<div class='layout'><p>The second set of four bits defines the memory location,</p><p>后 4 位是内存地址，</p></div>	
<div class='layout'><p>in this case, 1110, which is 14 in decimal.</p><p>1110 是十进制的 14</p></div>	
<div class='layout'><p>So what these eight numbers really mean is "LOAD Address 14 into Register A".</p><p>所以这 8 位表达的意思是，"读内存地址 14，放入寄存器 A"</p></div>	
<div class='layout'><p>We're just using two different languages.</p><p>只是用了两种不同语言</p></div>	
<div class='layout'><p>You can think of it like English and Morse Code.</p><p>可以想成是英语和摩尔斯码的区别</p></div>	
<div class='layout'><p>Hello and ".... . .-.. .-.. ---" mean the same thing -hello! --</p><p>你好 和 "... . .-. .-. ---" 是一个意思：你好</p></div>	
<div class='layout'><p>they're just encoded differently.</p><p>只是编码方式不同</p></div>	
<div class='layout'><p>English and Morse Code also have different levels of complexity.</p><p>英语和摩尔斯码的复杂度也不同</p></div>	
<div class='layout'><p>English has 26 different letters in its alphabet and way more possible sounds.</p><p>英文有 26 个字母以及各种发音</p></div>	
<div class='layout'><p>Morse only has dots and dashes.</p><p>摩尔斯码只有"点"和"线"</p></div>	
<div class='layout'><p>But, they can convey the same information, and computer languages are similar.</p><p>但它们可以传达相同的信息，计算机语言也类似.</p></div>	
<div class='layout'><p>As we've seen, computer hardware can only handle raw, binary instructions.</p><p>计算机能处理二进制，</p></div>	
<div class='layout'><p>This is the "language" computer processors natively speak.</p><p>二进制是处理器的"母语"</p></div>	
<div class='layout'><p>In fact, it's the only language they're able to speak.</p><p>事实上，它们*只能*理解二进制</p></div>	
<div class='layout'><p>It's called Machine Language or Machine Code.</p><p>这叫"机器语言"或"机器码"</p></div>	
<div class='layout'><p>In the early days of computing, people had to write entire programs in machine code.</p><p>在计算机早期阶段，必须用机器码写程序</p></div>	
<div class='layout'><p>More specifically, they'd first write a high-level version of a program on paper, in English,</p><p>具体来讲，会先在纸上用英语写一个"高层次版"</p></div>	
<div class='layout'><p>For example "retrieve the next sale from memory,</p><p>举例："从内存取下一个销售额，</p></div>	
<div class='layout'><p>then add this to the running total for the day, week and year,</p><p>然后加到天、周、年的总和</p></div>	
<div class='layout'><p>then calculate any tax to be added"</p><p>然后算税"</p></div>	
<div class='layout'><p>...and so on.</p><p>等等...</p></div>	
<div class='layout'><p>An informal, high-level description of a program like this is called Pseudo-Code.</p><p>这种对程序的高层次描述，叫 "伪代码"</p></div>	
<div class='layout'><p>Then, when the program was all figured out on paper,</p><p>在纸上写好后</p></div>	
<div class='layout'><p>they'd painstakingly expand and translate it into binary machine code by hand,</p><p>用"操作码表"把伪代码</p></div>	
<div class='layout'><p>using things like opcode tables.</p><p>转成二进制机器码</p></div>	
<img style="float:right;" width="70%" src="../img/1101.png" />
<div class='layout'><p>After the translation was complete, the program could be fed into the computer and run.</p><p>翻译完成后，程序可以喂入计算机并运行</p></div>	
<div class='layout'><p>As you might imagine, people quickly got fed up with this process.</p><p>你可能猜到了，很快人们就厌烦了</p></div>	
<img style="float:right;" width="70%" src="../img/1102.png" />
<div class='layout'><p>So, by the late 1940s and into the 50s,</p><p>所以在 1940~1950 年代</p></div>	
<div class='layout'><p>programmers had developed slightly higher-level languages that were more human-readable.</p><p>程序员开发出一种新语言，更可读 更高层次</p></div>	
<div class='layout'><p>Opcodes were given simple names, called mnemonics,</p><p>每个操作码分配一个简单名字，叫"助记符"</p></div>	
<div class='layout'><p>which were followed by operands, to form instructions.</p><p>助记符后面紧跟数据，形成完整指令</p></div>	
<div class='layout'><p>So instead of having to write instructions as a bunch of 1's and 0's,</p><p>与其用 1 和 0 写代码，</p></div>	
<div class='layout'><p>programmers could write something like "LOAD_A 14".</p><p>程序员可以写"LOAD_A 14"</p></div>	
<div class='layout'><p>We used this mnemonic in Episode 8 because it's so much easier to understand!</p><p>我们在第 8 集用过这个助记符，因为容易理解得多！</p></div>	
<div class='layout'><p>Of course, a CPU has no idea what "LOAD_A 14" is.</p><p>当然，CPU 不知道 LOAD_A 14 是什么</p></div>	
<div class='layout'><p>It doesn't understand text-based language, only binary.</p><p>它不能理解文字，只能理解二进制</p></div>	
<div class='layout'><p>And so programmers came up with a clever trick.</p><p>所以程序员想了一个技巧，</p></div>	
<div class='layout'><p>They created reusable helper programs, in binary,</p><p>写二进制程序来帮忙</p></div>	
<div class='layout'><p>that read in text-based instructions,</p><p>它可以读懂文字指令，</p></div>	
<div class='layout'><p>and assemble them into the corresponding binary instructions automatically.</p><p>自动转成二进制指令</p></div>	
<div class='layout'><p>This program is called</p><p>这种程序叫</p></div>	
<div class='layout'><p>you guessed it --</p><p>你可能猜到了</p></div>	
<div class='layout'><p>an Assembler.</p><p>汇编器</p></div>	
<div class='layout'><p>It reads in a program written in an Assembly Language</p><p>汇编器读取用"汇编语言"写的程序，</p></div>	
<div class='layout'><p>and converts it to native machine code.</p><p>然后转成"机器码"</p></div>	
<div class='layout'><p>LOAD_A 14 is one example of an assembly instruction.</p><p>LOAD_A 14 是一个汇编指令的例子</p></div>	
<div class='layout'><p>Over time, Assemblers gained new features that made programming even easier.</p><p>随着时间推移，汇编器有越来越多功能，让编程更容易</p></div>	
<div class='layout'><p>One nifty feature is automatically figuring out JUMP addresses.</p><p>其中一个功能是自动分析 JUMP 地址</p></div>	
<div class='layout'><p>This was an example program I used in episode 8:</p><p>这里有一个第8集用过的例子：</p></div>	
<div class='layout'><p>Notice how our JUMP NEGATIVE instruction jumps to address 5,</p><p>注意， JUMP NEGATIVE 指令跳到地址 5</p></div>	
<div class='layout'><p>and our regular JUMP goes to address 2.</p><p>JUMP 指令跳到地址 2</p></div>	
<div class='layout'><p>The problem is, if we add more code to the beginning of this program,</p><p>问题是，如果在程序开头多加一些代码</p></div>	
<div class='layout'><p>all of the addresses would change.</p><p>所有地址都会变</p></div>	
<div class='layout'><p>That's a huge pain if you ever want to update your program!</p><p>更新程序会很痛苦！</p></div>	
<div class='layout'><p>And so an assembler does away with raw jump addresses,</p><p>所以汇编器不用固定跳转地址</p></div>	
<div class='layout'><p>and lets you insert little labels that can be jumped to.</p><p>而是让你插入可跳转的标签</p></div>	
<div class='layout'><p>When this program is passed into the assembler,</p><p>当程序被传入汇编器，</p></div>	
<div class='layout'><p>it does the work of figuring out all of the jump addresses.</p><p>汇编器会自己搞定跳转地址</p></div>	
<div class='layout'><p>Now the programmer can focus more on programming</p><p>程序员可以专心编程，</p></div>	
<div class='layout'><p>and less on the underlying mechanics under the hood</p><p>不用管底层细节</p></div>	
<div class='layout'><p>enabling more sophisticated things to be built by hiding unnecessary complexity.</p><p>隐藏不必要细节来做更复杂的工作</p></div>	
<div class='layout'><p>As we've done many times in this series,</p><p>正如我们在本系列中所做的那样，</p></div>	
<div class='layout'><p>we're once again moving up another level of abstraction.</p><p>我们又提升了一层抽象</p></div>	
<div class='layout'><p>However, even with nifty assembler features like auto-linking JUMPs to labels,</p><p>然而，即使汇编器有这些厉害功能，比如自动跳转</p></div>	
<div class='layout'><p>Assembly Languages are still a thin veneer over machine code.</p><p>汇编只是修饰了一下机器码</p></div>	
<div class='layout'><p>In general, each assembly language instruction converts directly</p><p>一般来说，一条汇编指令</p></div>	
<div class='layout'><p>to a corresponding machine instruction a one-to-one mapping -</p><p>对应一条机器指令</p></div>	
<div class='layout'><p>so it's inherently tied to the underlying hardware.</p><p>所以汇编码和底层硬件的连接很紧密</p></div>	
<div class='layout'><p>And the assembler still forces programmers to think about</p><p>汇编器仍然强迫程序员思考</p></div>	
<div class='layout'><p>which registers and memory locations they will use.</p><p>用什么寄存器和内存地址</p></div>	
<div class='layout'><p>If you suddenly needed an extra value,</p><p>如果你突然要一个额外的数，</p></div>	
<div class='layout'><p>you might have to change a lot of code to fit it in.</p><p>可能要改很多代码</p></div>	
<div class='layout'><p>Let's go to the Thought Bubble.</p><p>让我们进入思考泡泡</p></div>	
<div class='layout'><p>This problem did not escape Dr. Grace Hopper.</p><p>葛丽丝·霍普博士 也遇到了这个问题</p></div>	
<div class='layout'><p>As a US naval officer, she was one of the first programmers on the Harvard Mark 1 computer,</p><p>作为美国海军军官，她是哈佛1号计算机的首批程序员之一</p></div>	
<div class='layout'><p>which we talked about in Episode 2.</p><p>这台机器我们在第 2 集提过</p></div>	
<div class='layout'><p>This was a colossal, electro-mechanical beast</p><p>这台巨大机电野兽</p></div>	
<div class='layout'><p>completed in 1944 as part of the allied war effort.</p><p>在 1944 年战时建造完成，帮助盟军作战</p></div>	
<div class='layout'><p>Programs were stored and fed into the computer on punched paper tape.</p><p>程序写在打孔纸带上，放进计算机执行</p></div>	
<div class='layout'><p>By the way, as you can see,</p><p>顺便一说，</p></div>	
<div class='layout'><p>they "patched" some bugs in this program</p><p>如果程序里有漏洞</p></div>	
<div class='layout'><p>by literally putting patches of paper over the holes on the punch tape.</p><p>真的就 直接用胶带来补"漏洞"</p></div>	
<div class='layout'><p>The Mark 1's instruction set was so primitive,</p><p>Mark 1 的指令集非常原始，</p></div>	
<div class='layout'><p>there weren't even JUMP instructions.</p><p>甚至没有 JUMP 指令</p></div>	
<div class='layout'><p>To create code that repeated the same operation multiple times,</p><p>如果代码要跑不止一次</p></div>	
<div class='layout'><p>you'd tape the two ends of the punched tape together, creating a physical loop.</p><p>得把带子的两端连起来  做成循环</p></div>	
<div class='layout'><p>In other words, programming the Mark 1 was kind of a nightmare!</p><p>换句话说，给 Mark 1 编程简直是噩梦！</p></div>	
<div class='layout'><p>After the war, Hopper continued to work at the forefront of computing.</p><p>战后，霍普继续在计算机前沿工作</p></div>	
<div class='layout'><p>To unleash the potential of computers,</p><p>为了释放电脑的潜力</p></div>	
<div class='layout'><p>she designed a high-level programming language called "Arithmetic Language Version 0",</p><p>她设计了一个高级编程语言，叫"算术语言版本 0"</p></div>	
<div class='layout'><p>or A-0 for short.</p><p>简称"A-0"</p></div>	
<div class='layout'><p>Assembly languages have direct, one-to-one mapping to machine instructions.</p><p>汇编与机器指令是一一对应的</p></div>	
<div class='layout'><p>But, a single line of a high-level programming language</p><p>但一行高级编程语言</p></div>	
<div class='layout'><p>might result in dozens of instructions being executed by the CPU.</p><p>可能会转成几十条二进制指令</p></div>	
<div class='layout'><p>To perform this complex translation, Hopper built the first compiler in 1952.</p><p>为了做到这种复杂转换，Hopper 在 1952 年创造了第一个编译器</p></div>	
<div class='layout'><p>This is a specialized program</p><p>编译器专门把高级语言</p></div>	
<div class='layout'><p>that transforms "source" code written in a programming language into a low-level language,</p><p>转成低级语言</p></div>	
<div class='layout'><p>like assembly or the binary "machine code" that the CPU can directly process.</p><p>比如汇编或机器码（CPU 可以直接执行机器码）</p></div>	
<div class='layout'><p>Thanks, Thought Bubble.</p><p>谢了 思想泡泡</p></div>	
<div class='layout'><p>So, despite the promise of easier programming,</p><p>尽管"使编程更简单"很诱人</p></div>	
<div class='layout'><p>many people were skeptical of Hopper's idea.</p><p>但很多人对霍普的点子持怀疑态度</p></div>	
<div class='layout'><p>She once said, "I had a running compiler and nobody would touch it.</p><p>她曾说"我有能用的编译器，但没人愿意用</p></div>	
<div class='layout'><p>they carefully told me, computers could only do arithmetic;</p><p>他们告诉我计算机只能做算术，</p></div>	
<div class='layout'><p>they could not do programs."</p><p>不能运行程序"</p></div>	
<div class='layout'><p>But the idea was a good one,</p><p>但这个点子是好的</p></div>	
<div class='layout'><p>and soon many efforts were underway to craft new programming languages</p><p>不久，很多人尝试创造新编程语言</p></div>	
<div class='layout'><p>today there are hundreds!</p><p>如今有上百种语言！</p></div>	
<div class='layout'><p>Sadly, there are no surviving examples of A-0 code,</p><p>可惜的是，没有任何 A-0 的代码遗留下来</p></div>	
<div class='layout'><p>so we'll use Python, a modern programming language, as an example.</p><p>所以我们用 Python 举例（一门现代编程语言）</p></div>	
<div class='layout'><p>Let's say we want to add two numbers and save that value.</p><p>假设我们想相加两个数字，保存结果</p></div>	
<div class='layout'><p>Remember, in assembly code,</p><p>记住，如果用汇编代码</p></div>	
<div class='layout'><p>we had to fetch values from memory, deal with registers, and other low-level details.</p><p>我们得从内存取值，和寄存器打交道，以及其他底层细节</p></div>	
<div class='layout'><p>But this same program can be written in python like so:</p><p>但同样的程序可以用 Python 这样写：</p></div>	
<div class='layout'><p>Notice how there are no registers or memory locations to deal with</p><p>不用管寄存器或内存位置</p></div>	
<div class='layout'><p>the compiler takes care of that stuff, abstracting away a lot of low-level and unnecessary complexity.</p><p>编译器会搞定这些细节，不用管底层细节</p></div>	
<div class='layout'><p>The programmer just creates abstractions for needed memory locations, known as variables,</p><p>程序员只需要创建 代表内存地址的抽象，叫"变量"</p></div>	
<div class='layout'><p>and gives them names.</p><p>给变量取名字</p></div>	
<div class='layout'><p>So now we can just take our two numbers, store them in variables we give names to</p><p>现在可以把两个数 存在变量里</p></div>	
<div class='layout'><p>in this case, I picked a and b but those variables could be anything -</p><p>这里取名 A 和 B， 实际编程时你可以随便取名</p></div>	
<div class='layout'><p>and then add those together, saving the result in c, another variable I created.</p><p>然后相加两个数，把结果存在变量 C</p></div>	
<div class='layout'><p>It might be that the compiler assigns Register A under the hood to store the value in a,</p><p>底层操作时，编译器可能把变量 A 存在寄存器 A</p></div>	
<div class='layout'><p>but I don't need to know about it!</p><p>但我不需要知道这些！</p></div>	
<div class='layout'><p>Out of sight, out of mind!</p><p>眼不见心不烦</p></div>	
<div class='layout'><p>It was an important historical milestone,</p><p>这是个重要历史里程碑</p></div>	
<div class='layout'><p>but A-0 and its later variants weren't widely used.</p><p>但 A-0 和之后的版本没有广泛使用</p></div>	
<div class='layout'><p>FORTRAN, derived from "Formula Translation",</p><p>FORTRAN，名字来自 "公式翻译"</p></div>	
<div class='layout'><p>was released by IBM a few years later, in 1957,</p><p>这门语言数年后由 IBM 在 1957 年发布</p></div>	
<div class='layout'><p>and came to dominate early computer programming.</p><p>主宰了早期计算机编程</p></div>	
<div class='layout'><p>John Backus, the FORTRAN project director,</p><p>FORTRAN 项目总监 John Backus 说过</p></div>	
<div class='layout'><p>said: "Much of my work has come from being lazy.</p><p>我做的大部分工作都是因为懒        </p></div>	
<div class='layout'><p>I didn't like writing programs,</p><p>我不喜欢写程序 </p></div>	
<div class='layout'><p>and so ... I started work on a programming system to make it easier to write programs.</p><p>所以我写这门语言，让编程更容易"</p></div>	
<div class='layout'><p>You know, typical lazy person.</p><p>你懂的，典型的"懒人"</p></div>	
<div class='layout'><p>They're always creating their own programming systems.</p><p>（白眼）创造自己的编程语言</p></div>	
<div class='layout'><p>Anyway, on average, programs written in FORTRAN</p><p>平均来说，FORTRAN 写的程序</p></div>	
<div class='layout'><p>were 20 times shorter than equivalent handwritten assembly code.</p><p>比等同的手写汇编代码短 20 倍</p></div>	
<div class='layout'><p>Then the FORTRAN Compiler would translate and expand that into native machine code.</p><p>然后 FORTRAN 编译器会把代码转成机器码</p></div>	
<div class='layout'><p>The community was skeptical that the performance would be as good as hand written code,</p><p>人们怀疑性能是否比得上手写代码</p></div>	
<div class='layout'><p>but the fact that programmers could write more code more quickly,</p><p>但因为能让程序员写程序更快，</p></div>	
<div class='layout'><p>made it an easy choice economically:</p><p>所以成了一个更经济的选择</p></div>	
<div class='layout'><p>trading a small increase in computation time for a significant decrease in programmer time.</p><p>运行速度慢一点点，编程速度大大加快</p></div>	
<div class='layout'><p>Of course, IBM was in the business of selling computers,</p><p>当时 IBM 在卖计算机</p></div>	
<div class='layout'><p>and so initially, FORTRAN code could only be compiled and run on IBM computers.</p><p>因此最初 FORTRAN 代码只能跑在 IBM 计算机上</p></div>	
<div class='layout'><p>And most programing languages and compilers of the 1950s</p><p>1950 年代大多数编程语言和编译器</p></div>	
<div class='layout'><p>could only run on a single type of computer.</p><p>只能运行在一种计算机上</p></div>	
<div class='layout'><p>So, if you upgraded your computer,</p><p>如果升级电脑</p></div>	
<div class='layout'><p>you'd often have to re-write all the code too!</p><p>可能要重写所有代码！</p></div>	
<div class='layout'><p>In response, computer experts from industry,</p><p>因此工业界，</p></div>	
<div class='layout'><p>academia and government formed a consortium in 1959</p><p>学术界，政府的计算机专家，在 1959 年组建了一个联盟</p></div>	
<div class='layout'><p>the Committee on Data Systems Languages, advised by our friend Grace Hopper --</p><p>数据系统语言委员会，Grace Hopper 担任顾问</p></div>	
<div class='layout'><p>to guide the development of a common programming language</p><p>开发一种通用编程语言，</p></div>	
<div class='layout'><p>that could be used across different machines.</p><p>可以在不同机器上通用</p></div>	
<div class='layout'><p>The result was the high-level, easy to use,</p><p>最后诞生了一门高级，易于使用，</p></div>	
<div class='layout'><p>Common Business-Oriented Language, or COBOL for short.</p><p>普通面向商业语言，简称 COBOL</p></div>	
<div class='layout'><p>To deal with different underlying hardware,</p><p>为了兼容不同底层硬件</p></div>	
<div class='layout'><p>each computing architecture needed its own COBOL compiler.</p><p>每个计算架构需要一个 COBOL 编译器</p></div>	
<div class='layout'><p>But critically, these compilers could all accept the same COBOL source code,</p><p>最重??要的是，这些编译器都可以接收相同 COBOL 代码</p></div>	
<div class='layout'><p>no matter what computer it was run on.</p><p>不管是什么电脑</p></div>	
<div class='layout'><p>This notion is called write once, run anywhere.</p><p>这叫"一次编写，到处运行"</p></div>	
<div class='layout'><p>It's true of most programming languages today,</p><p>如今大多数编程语言都是这样</p></div>	
<div class='layout'><p>a benefit of moving away from assembly and machine code,</p><p>不必接触 CPU 特有的</p></div>	
<div class='layout'><p>which is still CPU specific.</p><p>汇编码和机器码</p></div>	
<div class='layout'><p>The biggest impact of all this was reducing computing's barrier to entry.</p><p>减小了使用门槛</p></div>	
<div class='layout'><p>Before high level programming languages existed,</p><p>在高级编程语言出现之前</p></div>	
<div class='layout'><p>it was a realm exclusive to computer experts and enthusiasts.</p><p>编程只是计算机专家和爱好者才会做的事</p></div>	
<div class='layout'><p>And it was often their full time profession.</p><p>而且通常是主职</p></div>	
<div class='layout'><p>But now, scientists, engineers, doctors, economists, teachers,</p><p>但现在，科学家，工程师，医生，经济学家，教师</p></div>	
<div class='layout'><p>and many others could incorporate computation into their work .</p><p>等等，都可以把计算机用于工作</p></div>	
<div class='layout'><p>Thanks to these languages,</p><p>感谢这些语言</p></div>	
<div class='layout'><p>computing went from a cumbersome and esoteric discipline</p><p>计算机科学从深奥学科 </p></div>	
<div class='layout'><p>to a general purpose and accessible tool.</p><p>变成了大众化工具</p></div>	
<div class='layout'><p>At the same time, abstraction in programming allowed those computer experts</p><p>同时，编程的抽象也让计算机专家</p></div>	
<div class='layout'><p>now "professional programmers" -</p><p>现在叫"专业程序员"</p></div>	
<div class='layout'><p>to create increasingly sophisticated programs,</p><p>制作更复杂的程序</p></div>	
<div class='layout'><p>which would have taken millions, tens of millions, or even more lines of assembly code.</p><p>如果用汇编写可能要上百万行</p></div>	
<div class='layout'><p>Now, this history didn't end in 1959.</p><p>当然，计算机的历史没有在 1959 年结束</p></div>	
<div class='layout'><p>In fact, a golden era in programming language design jump started,</p><p>编程语言设计的黄金时代才刚刚开始</p></div>	
<div class='layout'><p>evolving in lockstep with dramatic advances in computer hardware.</p><p>和硬件一起飞速发展</p></div>	
<div class='layout'><p>In the 1960s, we had languages like ALGOL, LISP and BASIC.</p><p>在 1960 年代，有 ALGOL， LISP 和 BASIC 等语言</p></div>	
<div class='layout'><p>In the 70's: Pascal, C and Smalltalk were released.</p><p>70年代有：Pascal，C 和 Smalltalk</p></div>	
<div class='layout'><p>The 80s gave us C++, Objective-C, and Perl.</p><p>80年代有：C++，Objective-C 和 Perl</p></div>	
<div class='layout'><p>And the 90's: python, ruby, and Java.</p><p>90年代有：Python，Ruby 和 Java</p></div>	
<div class='layout'><p>And the new millennium has seen the rise of Swift, C#, and Go</p><p>新千年 Swift， C#， Go 在崛起</p></div>	
<div class='layout'><p>not to be confused with Let it Go and Pokemon Go.</p><p>不要把 Go 和，《冰雪奇缘》的 Let it Go 和游戏 Pokemon Go 弄混</p></div>	
<div class='layout'><p>Anyway, some of these might sound familiar</p><p>有些语言你可能听起来耳熟</p></div>	
<div class='layout'><p>many are still around today.</p><p>很多现在还存在</p></div>	
<div class='layout'><p>It's extremely likely that the web browser you're using right now</p><p>你现在用的浏览器很可能是</p></div>	
<div class='layout'><p>was written in C++ or Objective-C.</p><p> C++ 或 Objective-C 写的</p></div>	
<div class='layout'><p>That list I just gave is the tip of the iceberg.</p><p>我刚才说的编程语言名字 只是冰山一角</p></div>	
<div class='layout'><p>And languages with fancy, new features are proposed all the time.</p><p>新的编程语言在不断诞生</p></div>	
<div class='layout'><p>Each new language attempts to leverage new and clever abstractions</p><p>新语言想用更聪明的抽象</p></div>	
<div class='layout'><p>to make some aspect of programming easier or more powerful,</p><p>让某些方面更容易或更强大</p></div>	
<div class='layout'><p>or take advantage of emerging technologies and platforms,</p><p>或利用新技术和新平台带来的优势</p></div>	
<div class='layout'><p>so that more people can do more amazing things, more quickly.</p><p>让更多人能快速做出美妙的事情</p></div>	
<div class='layout'><p>Many consider the holy grail of programming to be the use of "plain ol' English",</p><p>许多人认为编程的"圣杯"是直接用英文</p></div>	
<div class='layout'><p>where you can literally just speak what you want the computer to do,</p><p>直接对计算机说话，然后它会理解并执行</p></div>	
<div class='layout'><p>it figures it out, and executes it.</p><p>直接对计算机说话，然后它会理解并执行</p></div>	
<div class='layout'><p>This kind of intelligent system is science fiction for now.</p><p>这种智能系统目前只存在于科幻小说</p></div>	
<div class='layout'><p>And fans of 2001: A Space Odyssey may be okay with that.</p><p>2001：太空漫游 的粉丝可能没什么意见</p></div>	
<div class='layout'><p>Now that you know all about programming languages,</p><p>现在你理解了编程语言，</p></div>	
<div class='layout'><p>we're going to deep dive for the next couple of episodes,</p><p>接下来几集</p></div>	
<div class='layout'><p>and we'll continue to build your understanding</p><p>我们会深入了解</p></div>	
<div class='layout'><p>of how programming languages, and the software they create,</p><p>编程语言和用语言写的软件</p></div>	
<div class='layout'><p>are used to do cool and unbelievable things.</p><p>是怎么做到那些酷事</p></div>	
<div class='layout'><p>See you next week.</p><p>下周见</p></div>	
﻿
</div> <!--container-->
<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>
<a id="fPagea" href="index.html" target="_self"><div id="fPage" style="color:#fff;">上<br>一<br>章</div></a>
<a href="index.html" target="_self"><div id="menuPage" style="color:#fff;">目<br>录</div></a>
<a id="LPagea" href="javascript:void(null)" target="_self"><div id="lPage" style="color:#fff;">下<br>一<br>章</div></a>
<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
	//上一页、下一页按钮，需要文件名是数字
	var strUrl=window.location.href;
	var arrUrl=strUrl.split("/");
	var thispage=arrUrl[arrUrl.length-1];
	var thispage2=thispage.split(".");
	var thispage3=thispage2[thispage2.length-2];
	if(thispage3 == 0){
		var obj5=document.getElementById("fPage");
		obj5.style.display="none";
	}else{
		var fpage = thispage3 - 1;
		fpage = fpage +".html";
		document.getElementById("fPagea").href=fpage;
	}
	if(thispage3 == 100){
		var obj6=document.getElementById("lPage");
		obj6.style.display="none";
	}else{
		var fpage = parseInt(thispage3) + 1;
		fpage = fpage +".html";
		document.getElementById("LPagea").href=fpage;
	}
</script>
</div>
</body>
</html>
