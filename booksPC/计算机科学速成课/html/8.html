<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//谷歌浏览器  
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox等浏览器
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//谷歌浏览器  
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox等浏览器  
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
</script>
<script>
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:link，#container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:85.29%;
	line-height:1.6em;
	overflow:hidden;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}
#goTopBtn, #goBottom, #shangy, #xiay, #menuPage, #lPage, #fPage, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #menuPage, #lPage, #fPage, #ftsize1, #ftsize3{
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #lPage, #fPage, #ftsize, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#fPage{
	bottom: 236px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
	//writing-mode:tb-rl;
}
#menuPage{
	bottom: 198px;
	height:27px;
	white-space:nowrap;
	overflow:hidden;
}
#lPage{
	bottom: 145px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
}
#ftsize1{
	bottom:360px;
}
#ftsize2{
	bottom:334px;
}
#ftsize3{
	bottom:308px;
}
#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #menuPage:hover, #lPage:hover, #fPage:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #menuPage a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link, #menuPage a:visited, #lPage a:link, #fPage a:link, #lPage a:visited, #fPage a:visited {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
.code0, .code2, .code4{
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
.layout, .layout2{
    clear:both;
	width:95%;
	border:1px dotted #eee;
	margin:auto;
	margin-bottom:5px;
	overflow:hidden;
}
.layout2 .right, .layout2 .left, .layout p{
margin-bottom:-55px;
padding-bottom:55px;
text-align: justify;
margin:0;
padding:0;
margin-left:1%;
margin-right:1%;
}
.layout2 .left, .layout p{
float:left;
width:60%;
font-size:1.0em;
}
.layout2 .right,  .layout p+p {
	float: left;
	width:34%;
	border-left:1px dotted #cccccc;
	font-size:0.9em;
	padding-left:1%;
	
}
.layout2 .right p, .layout2 .left p, .layout p{
padding-bottom:5px;
}
h3{
text-indent:3%;
font-size:1em;
height:2.0em;
padding:0;
margin:0;
}
</style>
</head>
<body>
<div id="container">
﻿<div class='layout'><p>8 Instructions & Programs</p><p>8 指令和程序</p></div>	
<div class='layout'><p>Hi, I'm Carrie Anne and this is Crash Course Computer Science!</p><p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p></div>	
<div class='layout'><p>Last episode, we combined an ALU, control unit, some memory, and a clock together to</p><p>上集我们把 ALU， 控制单元， RAM， 时钟 结合在一起</p></div>	
<div class='layout'><p>make a basic, but functional Central Processing Unit – or CPU</p><p>做了个基本，但可用的"中央处理单元"， 简称 CPU</p></div>	
<div class='layout'><p>the beating, ticking heart of a computer.</p><p>它是计算机的核心</p></div>	
<div class='layout'><p>We've done all the hard work of building many of these components from the electronic</p><p>我们已经用电路做了很多组件.</p></div>	
<div class='layout'><p>circuits up, and now it's time to give our CPU some actual instructions to process!</p><p>这次我们给 CPU 一些指令来运行！</p></div>	
<div class='layout'><p>The thing that makes a CPU powerful is the fact that it is programmable –</p><p>CPU 之所以强大，是因为它是可编程的 -</p></div>	
<div class='layout'><p>if you write a different sequence of instructions, then the CPU will perform a different task.</p><p>如果写入不同指令，就会执行不同任务</p></div>	
<div class='layout'><p>So the CPU is a piece of hardware which is controlled by easy-to-modify software!</p><p>CPU 是一块硬件，可以被软件控制！</p></div>	
<div class='layout'><p>Let's quickly revisit the simple program that we stepped through last episode.</p><p>我们重新看一下上集的简单程序</p></div>	
<div class='layout'><p>The computer memory looked like this.</p><p>内存里有这些值</p></div>	
<div class='layout'><p>Each address contained 8 bits of data.</p><p>每个地址可以存 8 位数据</p></div>	
<div class='layout'><p>For our hypothetical CPU, the first four bits specified the operation code, or opcode, and</p><p>因为我们的 CPU 是假设的，这里前4位是"操作码"</p></div>	
<div class='layout'><p>the second set of four bits specified an address or registers.</p><p>后4位指定一个内存地址，或寄存器.</p></div>	
<div class='layout'><p>In memory address zero we have 0010 1110.</p><p>内存地址 0 是 0010 1110</p></div>	
<div class='layout'><p>Again, those first four bits are our opcode which corresponds to a "LOAD_A" instruction.</p><p>前 4 位代表 LOAD_A 指令</p></div>	
<div class='layout'><p>This instruction reads data from a location of memory specified in those last four bits</p><p>意思是：把后 4 位指定的内存地址的值，放入寄存器 A</p></div>	
<div class='layout'><p>of the instruction and saves it into Register A. In this case, 1110, or 14 in decimal.</p><p>后 4 位是 1110，十进制的 14</p></div>	
<div class='layout'><p>So let's not think of this of memory address 0 as "0010 1110", but rather as the instruction</p><p>我们来把 0010 1110 看成 "LOAD_A 14" 指令</p></div>	
<div class='layout'><p>LOAD_A 14.</p><p>我们来把 0010 1110 看成 "LOAD_A 14" 指令</p></div>	
<div class='layout'><p>That's much easier to read and understand!</p><p>这样更好理解！</p></div>	
<div class='layout'><p>And for me to say!</p><p>也更方便说清楚</p></div>	
<div class='layout'><p>And we can do the same thing for the rest of the data in memory.</p><p>可以对内存里剩下的数也这样转换.</p></div>	
<div class='layout'><p>In this case, our program is just four instructions long,</p><p>这里，我们的程序只有4个指令</p></div>	
<div class='layout'><p>and we've put some numbers into memory too, 3 and 14.</p><p>还有数字 3 和 14</p></div>	
<div class='layout'><p>So now let's step through this program:</p><p>现在一步步看</p></div>	
<div class='layout'><p>First is LOAD_A 14, which takes the value in address 14, which is the number 3,</p><p>LOAD_A 14 是从地址 14 中拿到数字3，</p></div>	
<div class='layout'><p>and stores it into Register A.</p><p>放入寄存器A</p></div>	
<div class='layout'><p>Then we have a "LOAD_B 15" instruction, which takes the value in memory location 15,</p><p>LOAD_B 15 是从地址 15 中拿到数字14，</p></div>	
<div class='layout'><p>which is the number 14, and saves it into Register B.</p><p>放入寄存器B</p></div>	
<div class='layout'><p>Okay.</p><p>好.</p></div>	
<div class='layout'><p>Easy enough.</p><p>挺简单的！</p></div>	
<div class='layout'><p>But now we have an "ADD" instruction.</p><p>下一个是 ADD 指令</p></div>	
<div class='layout'><p>This tells the processor to use the ALU to add two registers together,</p><p>ADD B A 告诉 ALU，</p></div>	
<div class='layout'><p>in this case, B and A are specified.</p><p>把寄存器 B 和寄存器 A 里的数字加起来</p></div>	
<div class='layout'><p>The ordering is important, because the resulting sum is saved into the second register that's specified.</p><p>（B和A的）顺序很重要，因为结果会存在第二个寄存器</p></div>	
<div class='layout'><p>So in this case, the resulting sum is saved into Register A.</p><p>也就是寄存器 A</p></div>	
<div class='layout'><p>And finally, our last instruction is "STORE_A 13", which instructs the CPU to write whatever</p><p>最后一条指令是 "STORE_A 13"，</p></div>	
<div class='layout'><p>value is in Register A into memory location 13.</p><p>把寄存器 A 的值存入内存地址 13</p></div>	
<div class='layout'><p>Yesss!</p><p>好棒！</p></div>	
<div class='layout'><p>Our program adds two numbers together.</p><p>我们把 2 个数加在了一起！</p></div>	
<div class='layout'><p>That's about as exciting as it gets when we only have four instructions to play with.</p><p>毕竟只有4个指令，也只能做这个了.</p></div>	
<div class='layout'><p>So let's add some more!</p><p>加多一些指令吧！</p></div>	
<div class='layout'><p>Now we've got a subtract function, which like ADD, specifies two registers to operate on.</p><p>SUB 是减法，和 ADD 一样也要 2 个寄存器来操作.</p></div>	
<div class='layout'><p>We've also got a fancy new instruction called JUMP.</p><p>还有 JUMP（跳转）</p></div>	
<div class='layout'><p>As the name implies, this causes the program to "jump" to a new location.</p><p>让程序跳转到新位置</p></div>	
<div class='layout'><p>This is useful if we want to change the order of instructions, or choose to skip some instructions.</p><p>如果想改变指令顺序，或跳过一些指令，这个很实用</p></div>	
<div class='layout'><p>For example, a JUMP 0, would cause the program to go back to the beginning.</p><p>举例， JUMP 0 可以跳回开头</p></div>	
<div class='layout'><p>At a low level, this is done by writing the value specified in the last four bits into</p><p>JUMP 在底层的实现方式是，把指令后 4 位代表的内存地址的值</p></div>	
<div class='layout'><p>the instruction address register, overwriting the current value.</p><p>覆盖掉 "指令地址寄存器" 里的值</p></div>	
<div class='layout'><p>We've also added a special version of JUMP called JUMP_NEGATIVE.</p><p>还有一个特别版的 JUMP 叫 JUMP_NEGATIVE</p></div>	
<div class='layout'><p>This only jumps the program if the ALU's negative flag is set to true. </p><p>它只在 ALU 的 负数标志" 为真时，进行 JUMP</p></div>	
<div class='layout'><p>As we talked about in Episode 5, the negative flag is only set</p><p>第5集讲过，算术结果为负，</p></div>	
<div class='layout'><p>when the result of an arithmetic operation is negative.</p><p>负数标志才是真</p></div>	
<div class='layout'><p>If the result of the arithmetic was zero or positive, the negative flag would not be set.</p><p>结果不是负数时， "负数标志"为假</p></div>	
<div class='layout'><p>So the JUMP NEGATIVE won't jump anywhere, and the CPU will just continue on to the next instruction.</p><p>如果是假，JUMP_NEGATIVE 就不会执行，程序照常进行</p></div>	
<div class='layout'><p>Our previous program really should have looked like this to be correct,</p><p>我们之前的例子程序，其实应该是这样，才能正确工作.</p></div>	
<div class='layout'><p>otherwise the CPU would have just continued on after the STORE instruction, processing all those 0's.</p><p>否则跑完  STORE_A 13 之后，CPU 会不停运行下去，处理后面的 0</p></div>	
<div class='layout'><p>But there is no instruction with an opcode of 0, and so the computer would have crashed!</p><p>因为 0 不是操作码，所以电脑会崩掉！</p></div>	
<div class='layout'><p>It's important to point out here that we're storing</p><p>我还想指出一点，</p></div>	
<div class='layout'><p>both instructions and data in the same memory.</p><p>指令和数据都是存在同一个内存里的.</p></div>	
<div class='layout'><p>There is no difference fundamentally -it's all just binary numbers.</p><p>它们在根本层面上毫无区别 都是二进制数</p></div>	
<div class='layout'><p>So the HALT instruction is really important because it allows us to separate the two.</p><p>HALT 很重要，能区分指令和数据</p></div>	
<div class='layout'><p>Okay, so let's make our program a bit more interesting, by adding a JUMP.</p><p>好，现在用 JUMP 让程序更有趣一些.</p></div>	
<div class='layout'><p>We'll also modify our two starting values in memory to 1 and 1.</p><p>我们还把内存中 3 和 14 两个数字，改成 1 和 1</p></div>	
<div class='layout'><p>Lets step through this program just as our CPU would.</p><p>现在来从 CPU 的视角走一遍程序</p></div>	
<div class='layout'><p>First, LOAD_A 14 loads the value 1 into Register A.</p><p>首先 LOAD_A 14，把 1 存入寄存器A ，（因为地址 14 里的值是 1）</p></div>	
<div class='layout'><p>Next, LOAD_B 15 loads the value 1 into Register B.</p><p>然后 LOAD_B 15，把 1 存入寄存器B，（因为地址 15 里的值也是 1）</p></div>	
<div class='layout'><p>As before, we ADD registers B and A together, with the sum going into Register A. 1+1 = 2,</p><p>然后 ADD B A 把寄存器 B 和 A 相加，结果放到寄存器 A 里</p></div>	
<div class='layout'><p>so now Register A has the value 2 in it (stored in binary of course)</p><p>现在寄存器 A 的值是 2，(当然是以二进制存的）</p></div>	
<div class='layout'><p>Then the STORE instruction saves that into memory location 13.</p><p>然后 STORE_A 13 指令，把寄存器 A 的值存入内存地址 13</p></div>	
<div class='layout'><p>Now we hit a "JUMP 2" instruction.</p><p>现在遇到 JUMP 2 指令</p></div>	
<div class='layout'><p>This causes the processor to overwrite the value in the instruction address register,</p><p>CPU 会把"指令地址寄存器"的值，</p></div>	
<div class='layout'><p>which is currently 4, with the new value, 2.</p><p>现在是 4，改成 2</p></div>	
<div class='layout'><p>Now, on the processor's next fetch cycle, we don't fetch HALT,</p><p>因此下一步不再是 HALT</p></div>	
<div class='layout'><p>instead we fetch the instruction at memory location 2, which is ADD B A.</p><p>而是读内存地址 2 里的指令，也就是 ADD B A</p></div>	
<div class='layout'><p>We've jumped!</p><p>我们跳转了！</p></div>	
<div class='layout'><p>Register A contains the value 2, and register B contains the value 1.</p><p>寄存器 A 里是 2，寄存器 B 里是 1</p></div>	
<div class='layout'><p>So 1+2 = 3, so now Register A has the value 3.</p><p>1+2=3，寄存器 A 变成 3</p></div>	
<div class='layout'><p>We store that into memory.</p><p>存入内存</p></div>	
<div class='layout'><p>And we've hit the JUMP again, back to ADD B A.</p><p>又碰到 JUMP 2，又回到 ADD B A.</p></div>	
<div class='layout'><p>1+3=4</p><p>1+3=4</p></div>	
<div class='layout'><p>So now register A has the value 4.</p><p>现在寄存器 A 是 4</p></div>	
<div class='layout'><p>See what's happening here?</p><p>发现了吗？</p></div>	
<div class='layout'><p>Every loop, we're adding one.</p><p>每次循环都+1</p></div>	
<div class='layout'><p>Its counting up!</p><p>不断增多</p></div>	
<div class='layout'><p>Cooooool.</p><p>酷</p></div>	
<div class='layout'><p>But notice there's no way to ever escape.</p><p>但没法结束啊</p></div>	
<div class='layout'><p>We're never.. ever.. going to get to that halt instruction,</p><p>永远不会碰到 HALT</p></div>	
<div class='layout'><p>because we're always going to hit that JUMP.</p><p>总是会碰到 JUMP</p></div>	
<div class='layout'><p>This is called an infinite loop – a program that runs forever… ever… ever… ever…</p><p>这叫无限循环 这个程序会永远跑下去. 下去. 下去. 下去</p></div>	
<div class='layout'><p>ever</p><p>下去</p></div>	
<div class='layout'><p>To break the loop, we need a conditional jump.</p><p>为了停下来，我们需要有条件的 JUMP</p></div>	
<div class='layout'><p>A jump that only happens if a certain condition is met.</p><p>只有特定条件满足了，才执行 JUMP.</p></div>	
<div class='layout'><p>Our JUMP_NEGATIVE is one example of a conditional jump,</p><p>比如 JUMP NEGATIVE 就是条件跳转的一个例子</p></div>	
<div class='layout'><p>but computers have other types too like JUMP IF EQUAL and JUMP IF GREATER.</p><p>还有其他类型的条件跳转，比如， JUMP IF EQUAL（如果相等），JUMP IF GREATER（如果更大）</p></div>	
<div class='layout'><p>So let's make our code a little fancier and step through it.</p><p>现在把代码弄花哨一点，再过一遍代码</p></div>	
<div class='layout'><p>Like before, the program starts by loading values from memory into registers A and B.</p><p>就像之前，程序先把内存值放入寄存器 A 和 B.</p></div>	
<div class='layout'><p>In this example, the number 11 gets loaded into Register A, and 5 gets loaded into Register B.</p><p>寄存器 A 是 11，寄存器 B 是 5</p></div>	
<div class='layout'><p>Now we subtract register B from register A. That's 11 minus 5, which is 6,</p><p>SUB B A，用 A 减 B，11-5=6</p></div>	
<div class='layout'><p>and so 6 gets saved into Register A.</p><p>6 存入寄存器 A</p></div>	
<div class='layout'><p>Now we hit our JUMP NEGATIVE.</p><p>JUMP NEGATIVE 出场</p></div>	
<div class='layout'><p>The last ALU result was 6.</p><p>上一次 ALU 运算的结果是 6</p></div>	
<div class='layout'><p>That's a positive number, so the the negative flag is false.</p><p>是正数，所以 "负数标志" 是假</p></div>	
<div class='layout'><p>That means the processor does not jump.</p><p>因此处理器不会执行 JUMP</p></div>	
<div class='layout'><p>So we continue on to the next instruction...</p><p>继续下一条指令</p></div>	
<div class='layout'><p>...which is a JUMP 2.</p><p>JUMP 2</p></div>	
<div class='layout'><p>No conditional on this one, so we jump to instruction 2 no matter what.</p><p>JUMP 2 没有条件，直接执行！</p></div>	
<div class='layout'><p>Ok, so we're back at our SUBTRACT Register B from Register A. 6 minus 5 equals 1.</p><p>又回到寄存器 A-B，6-5=1</p></div>	
<div class='layout'><p>So 1 gets saved into register A.</p><p>A 变成 1</p></div>	
<div class='layout'><p>Next instruction.</p><p>下一条指令</p></div>	
<div class='layout'><p>We're back again at our JUMP NEGATIVE.</p><p>又是 JUMP NEGATIVE</p></div>	
<div class='layout'><p>1 is also a positive number, so the CPU continues on to the JUMP 2, looping back around again</p><p>因为 1 还是正数，因此 JUMP NEGATIVE 不会执行，来到下一条指令，JUMP 2</p></div>	
<div class='layout'><p>to the SUBTRACT instruction.</p><p>又来减一次</p></div>	
<div class='layout'><p>This time is different though.</p><p>这次就不一样了</p></div>	
<div class='layout'><p>1 minus 5 is negative 4.</p><p>1-5=-4</p></div>	
<div class='layout'><p>And so the ALU sets its negative flag to true for the first time.</p><p>这次ALU的 "负数标志" 是真</p></div>	
<div class='layout'><p>Now, when we advance to the next instruction,</p><p>现在下一条指令</p></div>	
<div class='layout'><p>JUMP_NEGATIVE 5, the CPU executes the jump to memory location 5.</p><p>JUMP NEGATIVE 5， CPU 的执行跳到内存地址 5</p></div>	
<div class='layout'><p>We're out of the infinite loop!</p><p>跳出了无限循环！</p></div>	
<div class='layout'><p>Now we have a ADD B to A. Negative 4 plus 5, is positive 1, and we save that into Register A.</p><p>现在的指令是 ADD B A，-4+5=1，1 存入寄存器 A</p></div>	
<div class='layout'><p>Next we have a STORE instruction that saves Register A into memory address 13.</p><p>下一条指令  STORE_A 13，把 A 的值存入内存地址 13</p></div>	
<div class='layout'><p>Lastly, we hit our HALT instruction and the computer rests.</p><p>最后碰到 HALT 指令，停下来.</p></div>	
<div class='layout'><p>So even though this program is only 7 instructions long, the CPU ended up executing 13 instructions,</p><p>虽然程序只有 7 个指令，但 CPU 执行了 13 个指令，</p></div>	
<div class='layout'><p>and that's because it looped twice internally.</p><p>因为在内部循环了 2 次.</p></div>	
<div class='layout'><p>This code calculated the remainder if we divide 5 into 11, which is one.</p><p>这些代码其实是算余数的，11除5余1</p></div>	
<div class='layout'><p>With a few extra lines of code, we could also keep track of how many loops we did, the count</p><p>如果加多几行指令，我们还可以跟踪循环了多少次</p></div>	
<div class='layout'><p>of which would be how many times 5 went into 11… we did two loops, so that means 5 goes</p><p>11除5，循环2次</p></div>	
<div class='layout'><p>into 11 two times... with a remainder of 1.</p><p>余1</p></div>	
<div class='layout'><p>And of course this code could work for any two numbers, which we can just change in memory</p><p>当然，我们可以用任意2个数，7和81，18和54，什么都行</p></div>	
<div class='layout'><p>to whatever we want: 7 and 81, 18 and 54, it doesn't matter</p><p>当然，我们可以用任意2个数，7和81，18和54，什么都行</p></div>	
<div class='layout'><p>that's the power of software!</p><p>这就是软件的强大之处</p></div>	
<div class='layout'><p>Software also allowed us to do something our hardware could not.</p><p>软件还让我们做到硬件做不到的事</p></div>	
<div class='layout'><p>Remember, our ALU didn't have the functionality to divide two numbers,</p><p>ALU 可没有除法功能</p></div>	
<div class='layout'><p>instead it's the program we made that gave us that functionality.</p><p>是程序给了我们这个功能.</p></div>	
<div class='layout'><p>And then other programs can use our divide program to do even fancier things.</p><p>别的程序也可以用我们的除法程序，来做其他事情</p></div>	
<div class='layout'><p>And you know what that means.</p><p>这意味着</p></div>	
<div class='layout'><p>New levels of abstraction!</p><p>一层新抽象！</p></div>	
<div class='layout'><p>So, our hypothetical CPU is very basic – all of its instructions are 8 bits long,</p><p>我们这里假设的 CPU 很基础，所有指令都是 8 位，</p></div>	
<div class='layout'><p>with the opcode occupying only the first four bits.</p><p>操作码只占了前面 4 位</p></div>	
<div class='layout'><p>So even if we used every combination of 4 bits, our CPU would only be able to support</p><p>即便用尽 4 位，</p></div>	
<div class='layout'><p>a maximum of 16 different instructions.</p><p>也只能代表 16 个指令</p></div>	
<div class='layout'><p>On top of that, several of our instructions used the last 4 bits to specify a memory location.</p><p>而且我们有几条指令，是用后 4 位来指定内存地址</p></div>	
<div class='layout'><p>But again, 4 bits can only encode 16 different values,</p><p>因为 4 位最多只能表示 16 个值，</p></div>	
<div class='layout'><p>meaning we can address a maximum of 16 memory locations that's not a lot to work with.</p><p>所以我们只能操作 16 个地址，这可不多.</p></div>	
<div class='layout'><p>For example, we couldn't even JUMP to location 17,</p><p>我们甚至不能 JUMP 17</p></div>	
<div class='layout'><p>because we literally can't fit the number 17 into 4 bits.</p><p>因为 4 位二进制无法表示数字 17</p></div>	
<div class='layout'><p>For this reason, real, modern CPUs use two strategies.</p><p>因此，真正的现代 CPU 用两种策略</p></div>	
<div class='layout'><p>The most straightforward approach is just to have bigger instructions, with more bits,</p><p>最直接的方法是用更多位来代表指令，</p></div>	
<div class='layout'><p>like 32 or 64 bits.</p><p>比如 32 位或 64 位</p></div>	
<div class='layout'><p>This is called the instruction length.</p><p>这叫 指令长度</p></div>	
<div class='layout'><p>Unsurprisingly.</p><p>毫不意外</p></div>	
<div class='layout'><p>The second approach is to use variable length instructions.</p><p>第二个策略是 "可变指令长度"</p></div>	
<div class='layout'><p>For example, imagine a CPU that uses 8 bit opcodes.</p><p>举个例子，比如某个 CPU 用 8 位长度的操作码</p></div>	
<div class='layout'><p>When the CPU sees an instruction that needs no extra values, like the HALT instruction,</p><p>如果看到 HALT 指令，HALT 不需要额外数据</p></div>	
<div class='layout'><p>it can just execute it immediately.</p><p>那么会马上执行.</p></div>	
<div class='layout'><p>However, if it sees something like a JUMP instruction, it knows it must also fetch</p><p>如果看到 JUMP，它得知道位置值</p></div>	
<div class='layout'><p>the address to jump to, which is saved immediately behind the JUMP instruction in memory.</p><p>这个值在 JUMP 的后面</p></div>	
<div class='layout'><p>This is called, logically enough, an Immediate Value.</p><p>这叫 "立即值"</p></div>	
<div class='layout'><p>In such processor designs, instructions can be any number of bytes long,</p><p>这样设计，指令可以是任意长度</p></div>	
<div class='layout'><p>which makes the fetch cycle of the CPU a tad more complicated.</p><p>但会让读取阶段复杂一点点</p></div>	
<div class='layout'><p>Now, our example CPU and instruction set is hypothetical,</p><p>要说明的是，我们拿来举例的 CPU 和指令集都是假设的，</p></div>	
<div class='layout'><p>designed to illustrate key working principles.</p><p>是为了展示核心原理</p></div>	
<div class='layout'><p>So I want to leave you with a real CPU example.</p><p>所以我们来看个真的 CPU 例子.</p></div>	
<div class='layout'><p>In 1971, Intel released the 4004 processor.</p><p>1971年，英特尔发布了 4004 处理器.</p></div>	
<div class='layout'><p>It was the first CPU put all into a single chip</p><p>这是第一次把 CPU 做成一个芯片 ，</p></div>	
<div class='layout'><p>and paved the path to the intel processors we know and love today.</p><p>给后来的英特尔处理器打下了基础</p></div>	
<div class='layout'><p>It supported 46 instructions, shown here.</p><p>它支持 46 个指令</p></div>	
<div class='layout'><p>Which was enough to build an entire working computer.</p><p>足够做一台能用的电脑</p></div>	
<div class='layout'><p>And it used many of the instructions we've talked about like JUMP ADD SUBTRACT and LOAD.</p><p>它用了很多我们说过的指令，比如 JUMP ADD SUB LOAD</p></div>	
<div class='layout'><p>It also uses 8-bit immediate values, like we just talked about, for things like JUMPs,</p><p>它也用 8 位的"立即值"来执行 JUMP， </p></div>	
<div class='layout'><p>in order to address more memory.</p><p>以表示更多内存地址.</p></div>	
<div class='layout'><p>And processors have come a long way since 1971.</p><p>处理器从 1971 年到现在发展巨大.</p></div>	
<div class='layout'><p>A modern computer processor, like an Intel Core i7, has thousands of different instructions</p><p>现代 CPU， 比如英特尔酷睿 i7， 有上千个指令和指令变种</p></div>	
<div class='layout'><p>and instruction variants, ranging from one to fifteen bytes long.</p><p>长度从1到15个字节.</p></div>	
<div class='layout'><p>For example, there's over a dozens different opcodes just for variants of ADD!</p><p>举例，光 ADD 指令就有很多变种！</p></div>	
<div class='layout'><p>And this huge growth in instruction set size is due in large part to extra bells and whistles</p><p>指令越来越多，是因为给 CPU 设计了越来越多功能</p></div>	
<div class='layout'><p>that have been added to processor designs overtime, which we'll talk about next episode.</p><p>下集我们会讲</p></div>	
<div class='layout'><p>See you next week!</p><p>下周见</p></div>	
﻿
</div> <!--container-->
<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>
<a id="fPagea" href="index.html" target="_self"><div id="fPage" style="color:#fff;">上<br>一<br>章</div></a>
<a href="index.html" target="_self"><div id="menuPage" style="color:#fff;">目<br>录</div></a>
<a id="LPagea" href="javascript:void(null)" target="_self"><div id="lPage" style="color:#fff;">下<br>一<br>章</div></a>
<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
	//上一页、下一页按钮，需要文件名是数字
	var strUrl=window.location.href;
	var arrUrl=strUrl.split("/");
	var thispage=arrUrl[arrUrl.length-1];
	var thispage2=thispage.split(".");
	var thispage3=thispage2[thispage2.length-2];
	if(thispage3 == 0){
		var obj5=document.getElementById("fPage");
		obj5.style.display="none";
	}else{
		var fpage = thispage3 - 1;
		fpage = fpage +".html";
		document.getElementById("fPagea").href=fpage;
	}
	if(thispage3 == 100){
		var obj6=document.getElementById("lPage");
		obj6.style.display="none";
	}else{
		var fpage = parseInt(thispage3) + 1;
		fpage = fpage +".html";
		document.getElementById("LPagea").href=fpage;
	}
</script>
</div>
</body>
</html>
