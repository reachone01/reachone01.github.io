<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//谷歌浏览器  
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox等浏览器
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//谷歌浏览器  
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox等浏览器  
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
</script>
<script>
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:link，#container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:85.29%;
	line-height:1.6em;
	overflow:hidden;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}
#goTopBtn, #goBottom, #shangy, #xiay, #menuPage, #lPage, #fPage, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #menuPage, #lPage, #fPage, #ftsize1, #ftsize3{
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #lPage, #fPage, #ftsize, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#fPage{
	bottom: 236px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
	//writing-mode:tb-rl;
}
#menuPage{
	bottom: 198px;
	height:27px;
	white-space:nowrap;
	overflow:hidden;
}
#lPage{
	bottom: 145px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
}
#ftsize1{
	bottom:360px;
}
#ftsize2{
	bottom:334px;
}
#ftsize3{
	bottom:308px;
}
#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #menuPage:hover, #lPage:hover, #fPage:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #menuPage a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link, #menuPage a:visited, #lPage a:link, #fPage a:link, #lPage a:visited, #fPage a:visited {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
.code0, .code2, .code4{
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
.layout, .layout2{
    clear:both;
	width:95%;
	border:1px dotted #eee;
	margin:auto;
	margin-bottom:5px;
	overflow:hidden;
}
.layout2 .right, .layout2 .left, .layout p{
margin-bottom:-55px;
padding-bottom:55px;
text-align: justify;
margin:0;
padding:0;
margin-left:1%;
margin-right:1%;
}
.layout2 .left, .layout p{
float:left;
width:60%;
font-size:1.0em;
}
.layout2 .right,  .layout p+p {
	float: left;
	width:34%;
	border-left:1px dotted #cccccc;
	font-size:0.9em;
	padding-left:1%;
	
}
.layout2 .right p, .layout2 .left p, .layout p{
padding-bottom:5px;
}
h3{
text-indent:3%;
font-size:1em;
height:2.0em;
padding:0;
margin:0;
}
</style>
</head>
<body>
<div id="container">
﻿<div class='layout'><p>27 3D Graphics</p><p>27 3D 图形</p></div>	
<div class='layout'><p>Hi, I'm Carrie Anne, and welcome to Crash Course Computer Science!</p><p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p></div>	
<div class='layout'><p>Over the past five episodes,</p><p>在过去五集</p></div>	
<div class='layout'><p>we've worked up from text-based teletype interfaces to pixelated bitmapped graphics.</p><p>我们从基于电传打字机的命令行界面，讲到图形怎么显示到屏幕上</p></div>	
<div class='layout'><p>Then, last episode,we covered Graphical User Interfaces and all</p><p>再到上集的 图形用户界面（GUI）</p></div>	
<div class='layout'><p>their "Ooey Gooey" richness.</p><p>以及图形界面的美味</p></div>	
<div class='layout'><p>All of these examples have been 2D. But of course "we are living in a 3D world</p><p>之前的例子都是2D， 但我们生活的世界是3D的</p></div>	
<div class='layout'><p>and I'm a 3 dimensional girl!</p><p>我也是个三维 girl~</p></div>	
<div class='layout'><p>So today, we're going to talk about some fundamental methods in 3D computer graphics</p><p>所以今天，我们讲3D图形的基础知识</p></div>	
<div class='layout'><p>and how you render them onto a 2D screen.</p><p>以及如何渲染 3D 图形到 2D 屏幕上</p></div>	
<div class='layout'><p>As we discussed in episode 24 we can write functions that draw a line between any two points like A and B.</p><p>24集中说过，可以写一个函数，从A到B画一条线</p></div>	
<div class='layout'><p>By manipulating the X and Y coordinates of points A and B, we can manipulate the line.</p><p>通过控制 A 和 B 的(X，Y)坐标，可以控制一条线</p></div>	
<div class='layout'><p>In 3D graphics, points have not just two coordinates, but three -X, Y and Z.</p><p>在3D图像中， 点的坐标不再是两点， 而是三点， X，Y，Z</p></div>	
<div class='layout'><p>Or "zee" but I'm going to say "zed".</p><p>或读"Zee"，但我之后会读成"Zed"</p></div>	
<div class='layout'><p>Of course, we don't have X/Y/Z coordinates on a 2D computer screen</p><p>当然，2D的电脑屏幕上，不可能有 XYZ 立体坐标轴</p></div>	
<div class='layout'><p>so graphics algorithms are responsible for "flattening" 3D coordinates onto a 2D plane.</p><p>所以有图形算法，负责把3D坐标"拍平"显示到2D屏幕上</p></div>	
<div class='layout'><p>This process is known as 3D Projection.</p><p>这叫"3D投影"</p></div>	
<div class='layout'><p>Once all of the points have been converted from 3D to 2D</p><p>所有的点都从3D转成2D后</p></div>	
<div class='layout'><p>we can use the regular 2D line drawing function to connect the dots… literally.</p><p>就可以用画2D线段的函数 来连接这些点</p></div>	
<div class='layout'><p>This is called Wireframe Rendering.</p><p>这叫 "线框渲染"</p></div>	
<div class='layout'><p>Imagine building a cube out of chopsticks, and shining a flashlight on it.</p><p>想象用筷子做一个立方体，然后用手电筒照它</p></div>	
<div class='layout'><p>The shadow it casts onto your wall its projection is flat.</p><p>墙上的影子就是投射，是平的</p></div>	

<img style="float:right;" width="70%" src="../img/2701.png" />

<div class='layout'><p>If you rotate the cube around</p><p>如果旋转立方体</p></div>	
<div class='layout'><p>you can see it's a 3D object, even though it's a flat projection.</p><p>投影看起来会像 3D 物体，尽管是投影面是平的</p></div>	
<div class='layout'><p>This transformation from 3D to 2D is exactly what your computer is doing</p><p>电脑也是这样3D转2D</p></div>	
<div class='layout'><p>just with a lot more math… and less chopsticks.</p><p>只不过用大量数学，而不是筷子</p></div>	
<div class='layout'><p>There are several types of 3D Projection.</p><p>3D投影有好几种</p></div>	
<div class='layout'><p>What you're seeing right now is an Orthographic Projection</p><p>你现在看到的，叫 正交投影</p></div>	
<div class='layout'><p>where, for example, the parallel sides in the cube appear as parallel in the projection.</p><p>立方体的各个边，在投影中互相平行</p></div>	
<div class='layout'><p>In the real 3D world through, parallel lines converge as they get further from the viewer</p><p>在真实3D世界中，平行线段会在远处收敛于一点</p></div>	
<div class='layout'><p>like a road going to the horizon.</p><p>就像远处的马路汇聚到一点</p></div>	
<div class='layout'><p>This type of 3D projection is called Perspective Projection .</p><p>这叫 透视投射</p></div>

<img style="float:right;" width="70%" src="../img/2702.png" />
	
<div class='layout'><p>It's the same process, just with different math.</p><p>过程是类似的，只是数学稍有不同</p></div>	
<div class='layout'><p>Sometimes you want perspective and sometimes you don't --</p><p>有时你想要透视投影，有时不想</p></div>	
<div class='layout'><p>the choice is up to the developer.</p><p>具体取决于开发人员</p></div>	
<div class='layout'><p>Simple shapes, like cubes, are easily defined by straight lines.</p><p>如果想画立方体这种简单图形，直线就够了</p></div>	
<div class='layout'><p>But for more complex shapes, triangles are better</p><p>但更复杂的图形，三角形更好</p></div>	
<div class='layout'><p>what are called polygons in 3D graphics.</p><p>在3D图形学中，我们叫三角形"多边形"(Polygons)</p></div>	
<div class='layout'><p>Look at this beautiful teapot made out of polygons.</p><p>看看这个多边形组成的 漂亮茶壶</p></div>	
<div class='layout'><p>A collection of polygons like this is a mesh</p><p>一堆多边形的集合叫 网格</p></div>	
<div class='layout'><p>The denser the mesh, the smoother the curves and the finer the details.</p><p>网格越密，表面越光滑，细节越多</p></div>	
<div class='layout'><p>But, that also increases the polygon count, which means more work for the computer</p><p>但意味着更多计算量</p></div>	
<div class='layout'><p>Game designers have to carefully balance model fidelity vs. polygon count,</p><p>游戏设计者要平衡角色的真实度，和多边形数量</p></div>	
<div class='layout'><p>because if the count goes too high</p><p>如果数量太多，</p></div>	
<div class='layout'><p>the framerate of an animation drops below what users perceive as smooth.</p><p>帧率会下降到肉眼可感知，用户会觉得卡</p></div>	
<div class='layout'><p>For this reason, there are algorithms for simplifying meshes.</p><p>因此有算法用来简化网格</p></div>	
<div class='layout'><p>The reason triangles are used,</p><p>之所以三角形更常用，</p></div>	
<div class='layout'><p>and not squares, or polygons, or some other more complex shape</p><p>而不是用正方形，或其它更复杂的图形</p></div>	
<div class='layout'><p>is simplicity:</p><p>是因为三角形的简单性</p></div>	
<div class='layout'><p>three points in space unambiguously define a plane.</p><p>空间中  三点定义一个平面</p></div>	
<div class='layout'><p>If you give me three points in a 3D space, I can draw a plane through it</p><p>如果给3个3D点，我能画出一个平面</p></div>	
<div class='layout'><p>there is only one.. single.. answer.</p><p>而且只有这一个答案</p></div>	
<div class='layout'><p>This isn't guaranteed to be true for shapes with four or more points.</p><p>4个或多于4个点就不一定了</p></div>	
<div class='layout'><p>Also two points aren't enough to define a plane, only a line,</p><p>而2个点不够定义平面，只能定义线段</p></div>	
<div class='layout'><p>so three is the perfect and minimal number. Triangles for the win!</p><p>所以3是最完美的数字，三角形万岁</p></div>	
<div class='layout'><p>Wireframe rendering is cool and all sorta retro but of course 3D graphics can also be filled.</p><p>线框渲染 虽然很酷，但3D图像需要填充</p></div>	
<div class='layout'><p>The classic algorithm for doing this is called Scanline Rendering,</p><p>填充图形的经典算法叫 扫描线渲染 (Scanline Rendering)，</p></div>	
<div class='layout'><p>first developed in 1967 at the University of Utah</p><p>于1967年诞生在犹他州大学</p></div>	
<div class='layout'><p>For a simple example, let's consider just one polygon.</p><p>为了例子简单，我们只看一个多边形</p></div>	
<div class='layout'><p>Our job here is to figure out how this polygon translates to filled pixels on a computer screen</p><p>我们要思考，这个多边形如何转成一块填满像素的区域</p></div>	
<div class='layout'><p>so let's first overlay a grid of pixels to fill</p><p>我们先铺一层像素网格</p></div>	
<div class='layout'><p>The scanline algorithm starts by reading the three points that make up the polygon</p><p>扫描线算法 先读多边形的3个点</p></div>	
<div class='layout'><p>and finding the lowest and highest Y values.  It will only consider rows between these two points.</p><p>找最大和最小的Y值，只在这两点间工作</p></div>	
<div class='layout'><p>Then, the algorithm works down one row at a time.</p><p>然后算法从上往下，一次处理一行</p></div>	
<div class='layout'><p>In each row, it calculates where a line running through</p><p>计算每一行</p></div>	
<div class='layout'><p>the center of a row intersects with the side of the polygon.</p><p>和多边形相交的2个点</p></div>	
<div class='layout'><p>Because polygons are triangles, if you intersect one line, you have to intersect with another.</p><p>因为是三角形，如果相交一条边， </p></div>	
<div class='layout'><p>It's guaranteed!</p><p>必然相交另一条</p></div>	
<div class='layout'><p>The job of the scanline algorithm is to fill in the pixels between the two intersections.</p><p>扫描线算法 会填满2个相交点之间的像素</p></div>	
<div class='layout'><p>Let's see how this works.</p><p>来看个具体例子</p></div>	
<div class='layout'><p>On the first row we look at we intersect here and here.</p><p>第一行 相交于这里和这里</p></div>	
<div class='layout'><p>The algorithm then colors in all pixels between those two intersections.</p><p>算法把两点间填满颜色</p></div>	
<div class='layout'><p>And this just continues, row by row, which is why it's called Scan... Line... Rendering.</p><p>然后下一行，再下一行，所以叫 扫描..线..渲染</p></div>	

<img style="float:right;" width="70%" src="../img/2703.png" />

<div class='layout'><p>When we hit the bottom of the polygon, we're done.</p><p>扫到底部就完成了</p></div>	
<div class='layout'><p>The rate at which a computer fills in polygons is called the fillrate.</p><p>填充的速度叫 fillrate（填充速率）</p></div>	
<div class='layout'><p>Admittedly, this is a pretty ugly filled polygon. It has what are known as "Jaggies" rough edges.</p><p>当然 这样的三角形比较丑，边缘满是锯齿</p></div>	
<div class='layout'><p>This effect is less pronounced when using smaller pixels.</p><p>当像素较小时 就不那么明显</p></div>	
<div class='layout'><p>But nonetheless, you see these in games all the time, especially on lower powered platforms.</p><p>但尽管如此，你肯定在游戏里见过这种效果，特别是低配电脑</p></div>	
<div class='layout'><p>One method to soften this effect is Antialiasing.</p><p>一种减轻锯齿的方法叫， 抗锯齿(Antialiasing)</p></div>	
<div class='layout'><p>Instead of filling pixels in a polygon with the same color,</p><p>与其每个像素都涂成一样的颜色</p></div>	
<div class='layout'><p>we can adjust the color based on how much the polygon cuts through each pixel</p><p>可以判断多边形切过像素的程度，来调整颜色</p></div>	
<div class='layout'><p>If a pixel is entirely inside of a polygon,it gets fully colored.</p><p>如果像素在多边形内部，就直接涂颜色</p></div>	
<div class='layout'><p>But if the polygon only grazes a pixel, it'll get a lighter shade.</p><p>如果多边形划过像素，颜色就浅一些</p></div>	

<img style="float:right;" width="70%" src="../img/2704.png" />

<div class='layout'><p>This feathering of the edges is much more pleasant to the eyes.</p><p>这种边缘羽化的效果 看着更舒服些</p></div>	
<div class='layout'><p>Antialiasing is used all over the place, including in 2D graphics, like fonts and icons.</p><p>抗锯齿 被广泛使用，比如字体和图标</p></div>	
<div class='layout'><p>If you lean in real close to your monitor..</p><p>如果你把脸贴近屏幕</p></div>	
<div class='layout'><p>Closer, Closer.</p><p>近点..再近点</p></div>	
<div class='layout'><p>You'll see all the fonts in your browser are Antialiased. So smooth!</p><p>你能看到浏览器里字体是抗锯齿的，超平滑</p></div>	
<div class='layout'><p>In a 3D scene, there are polygons that are part objects in the back, near the front,and just about everywhere.</p><p>在3D场景中，多边形到处都是</p></div>	
<div class='layout'><p>Only some are visible,</p><p>但只有一部分能看见</p></div>	
<div class='layout'><p>because some objects are hidden behind other objects in the scene</p><p>因为其它的被挡住了</p></div>	
<div class='layout'><p>what's called occlusion .</p><p>这叫 遮挡</p></div>	
<div class='layout'><p>The most straightforward way to handle this is to use a sort algorithm,</p><p>最直接的处理办法是用排序算法</p></div>	
<div class='layout'><p>and arrange all the polygons in the scene from farthest to nearest, then render them in that order.</p><p>从远到近排列，然后从远到近渲染</p></div>	
<div class='layout'><p>This is called the Painter's Algorithm , because painters also have to start with the background</p><p>这叫 画家算法 因为画家也是先画背景</p></div>	
<div class='layout'><p>and then increasingly work up to foreground elements.</p><p>然后再画更近的东西</p></div>	
<div class='layout'><p>Consider this example scene with three overlapping polygons.</p><p>看这个例子，有3个重叠的多边形</p></div>	
<div class='layout'><p>To make things easier to follow, we're going to color the polygons differently.</p><p>为了简单，我们画成不同颜色</p></div>	
<div class='layout'><p>Also for simplicity, we'll assume these polygons are all parallel to the screen</p><p>同时，假设3个多边形都和屏幕平行</p></div>	
<div class='layout'><p>but in a real program, like a game,</p><p>但在实际应用中， 比如游戏里，</p></div>	
<div class='layout'><p>the polygons can be tilted in 3D space.</p><p>多边形可能是倾斜的</p></div>	
<div class='layout'><p>Our three polygons, A B and C… are at distance 20, 12 and 14.</p><p>3个多边形A，B，C，距离20，12，14</p></div>	
<div class='layout'><p>The first thing the Painter's Algorithm does is sort all the polygons, from farthest to nearest.</p><p>画家算法的第一件事，是从远到近排序</p></div>	
<div class='layout'><p>Now that they're in order, we can use scanline rendering to fill each polygon, one at a time.</p><p>现在有序了，我们可以用 扫描线算法 填充多边形，一次填一个</p></div>	
<div class='layout'><p>We start with Polygon A, the farthest one away.</p><p>我们从最远的A开始</p></div>	
<div class='layout'><p>Then we repeat the process for the next farthest polygon, in this case, C.</p><p>然后重复这个过程，填充第二远的C</p></div>	
<div class='layout'><p>And then we repeat this again, for Polygon B.</p><p>然后是 B</p></div>	
<div class='layout'><p>Now we're all done, and you can see the ordering is correct. The polygons that are closer, are in front!</p><p>现在完成了，可以看到顺序是对的，近的多边形在前面！</p></div>	
<div class='layout'><p>An alternative method for handling occlusion is called Z-Buffering .</p><p>还有一种方法叫 深度缓冲</p></div>	
<div class='layout'><p>It achieves the same output as before, but with a different algorithm.</p><p>它和之前的算法做的事情一样，但方法不同</p></div>	
<div class='layout'><p>Let's go back to our previous example, before it was sorted.</p><p>我们回到之前的例子，回到排序前的状态</p></div>	
<div class='layout'><p>That's because this algorithm doesn't need to sort any polygons, which makes it faster.</p><p>因为这个算法不用排序，所以速度更快</p></div>	
<div class='layout'><p>In short, Z-buffering keeps track of the closest distance</p><p>简而言之，Z-buffering 算法会记录</p></div>	
<div class='layout'><p>to a polygon for every pixel in the scene.</p><p>场景中每个像素和摄像机的距离</p></div>	
<div class='layout'><p>It does this by maintaining a Z-Buffer, which is just a matrix of values that sits in memory.</p><p>在内存里存一个数字矩阵</p></div>	
<div class='layout'><p>At first, every pixel is initialized to infinity.</p><p>首先，每个像素的距离被初始化为"无限大"</p></div>	
<div class='layout'><p>Then Z-buffering starts with the first polygon in its list. In this case, that's A.</p><p>然后 Z-buffering 从列表里第一个多边形开始处理，也就是A</p></div>	
<div class='layout'><p>It follows the same logic as the scanline algorithm, but instead of coloring in pixels,</p><p>它和扫描线算法逻辑相同，但不是给像素填充颜色</p></div>	
<div class='layout'><p>it checks the distance of the polygon versus what's recorded in its Z-Buffer.</p><p>而是把多边形的距离，和 Z-Buffer 里的距离进行对比</p></div>	
<div class='layout'><p>It records the lower of the two values.</p><p>它总是记录更低的值</p></div>	
<div class='layout'><p>For our Polygon A, with a distance of 20, it wins against infinity every time.</p><p>A距离20，20小于"无限大"，所以缓冲区记录20</p></div>	
<div class='layout'><p>When it's done with Polygon A, it moves on to the next polygon in its list, and the same thing happens.</p><p>算完A之后算下一个，以此类推</p></div>	
<div class='layout'><p>Now, because we didn't sort the polygons,</p><p>因为没对多边形排序</p></div>	
<div class='layout'><p>it's not always the case that later polygons overwrite high values.</p><p>所以后处理的多边形并不总会覆盖前面的</p></div>	
<div class='layout'><p>In the case of Polygon C,</p><p>对于多边形C</p></div>	
<div class='layout'><p>only some of the values in the Z-buffer get new minimum distances.</p><p>缓冲区里只有一部分值会被多边形C的距离值覆盖</p></div>	
<div class='layout'><p>This completed Z-buffer is used in conjunction with a fancier version of scanline rendering</p><p>Z缓冲区完成后，会和"扫描线"算法的改进高级版配合使用</p></div>	
<div class='layout'><p>that not only tests for line intersection,</p><p>不仅可以勘测到线的交叉点</p></div>	
<div class='layout'><p>but also does a look up to see if that pixel will even be visible in the final scene.</p><p>还可以知道某像素是否在最终场景中可见</p></div>	
<div class='layout'><p>If it's not, the algorithm skips it and moves on.</p><p>如果不可见，扫描线算法会跳过那个部分</p></div>	
<div class='layout'><p>An interesting problem arises when two polygons have the same distance,</p><p>当两个多边形距离相同时，会出现一个有趣问题</p></div>	
<div class='layout'><p>like if Polygon A and B are both at a distance of 20. Which one do you draw on top?</p><p>比如多边形 A 和 B 距离都是 20， 哪个画上面？</p></div>	
<div class='layout'><p>Polygons are constantly being shuffled around in memory and changing their access order.</p><p>多边形会在内存中移来移去，访问顺序会不断变化</p></div>	
<div class='layout'><p>Plus, rounding errors are inherent in floating point computations.</p><p>另外，计算浮点数有舍入误差</p></div>	
<div class='layout'><p>So, which one gets drawn on top is often unpredictable.</p><p>所以哪一个画在上面， 往往是不可预测的</p></div>	
<div class='layout'><p>The result is a flickering effect called Z-Fighting, which if you've played 3D games no doubt encountered.</p><p>导致出现 Z-fighting 效果，如果你玩过3D游戏，肯定见过</p></div>	
<div class='layout'><p>Speaking of glitches, another common optimization in 3D graphics is called Back-Face Culling.</p><p>说起 故障，3D游戏中有个优化叫 背面剔除</p></div>	
<div class='layout'><p>If you think about it, a triangle has two sides, a front and a back.</p><p>你想想，三角形有两面，正面和背面</p></div>	
<div class='layout'><p>With something like the head of an avatar, or the ground in a game,</p><p>游戏角色的头部或地面，</p></div>	
<div class='layout'><p>you should only ever see one side -the side facing outwards.</p><p>只能看到朝外的一面</p></div>	
<div class='layout'><p>So to save processing time, the back-side of polygons are often ignored in the rendering pipeline</p><p>所以为了节省处理时间，会忽略多边形背面</p></div>	
<div class='layout'><p>which cuts the number of polygon faces to consider in half.</p><p>减了一半多边形面数</p></div>	
<div class='layout'><p>This is great, except when there's a bug that lets you get inside of those objects,and look outwards.</p><p>这很好，但有个bug是 如果进入模型内部往外看</p></div>	
<div class='layout'><p>Then the avatar head or ground becomes invisible.</p><p>头部和地面会消失</p></div>	
<div class='layout'><p>Moving on. We need to talk about lighting -also known as shading</p><p>继续，我们讲灯光，也叫 明暗处理</p></div>	
<div class='layout'><p>because if it's a 3D scene, the lighting should vary over the surface of objects.</p><p>因为3D场景中， 物体表面应该有明暗变化</p></div>	
<div class='layout'><p>Let's go back to our teapot mesh.</p><p>我们回到之前的茶壶网格</p></div>	
<div class='layout'><p>With scanline rendering coloring in all the polygons, our teapot looks like this.</p><p>用"扫描线"算法渲染所有多边形后，茶壶看起来像这样</p></div>	
<div class='layout'><p>Not very 3D.</p><p>没什么 3D 感</p></div>	
<div class='layout'><p>So, let's add some lighting to enhance the realism!</p><p>我们来加点灯光，提高真实感</p></div>	
<div class='layout'><p>As an example, we'll pick 3 polygons from different parts of our teapot.</p><p>为了举例，我们从茶壶上挑3个不同位置的多边形</p></div>	
<div class='layout'><p>Unlike our previous examples, we're now going to consider how these polygons are oriented in 3D space</p><p>和之前的例子不同，这次要考虑这些多边形面对的方向</p></div>	
<div class='layout'><p>they're no longer parallel to the screen, but rather tilted in different 3D directions.</p><p>它们不平行于屏幕，而是面对不同方向</p></div>	
<div class='layout'><p>The direction they face is called the Surface Normal ,</p><p>他们面对的方向叫 " 表面法线 "</p></div>	
<div class='layout'><p>and we can visualize that direction with a little 3D arrow that's perpendicular to the polygon's surface.</p><p>我们可以用一个垂直于表面的小箭头，来显示这个方向</p></div>	
<div class='layout'><p>Now let's add a light source.</p><p>现在加个光源</p></div>	
<div class='layout'><p>Each polygon is going to be illuminated a different amount. Some will appear brighter</p><p>每个多边形被照亮的程度不同 有的更亮</p></div>	
<div class='layout'><p>because their angle causes more light to be reflected towards the viewer.</p><p>因为面对的角度，导致更多光线反射到观察者</p></div>	
<div class='layout'><p>For example, the bottom-most polygon is tilted downwards,</p><p>举个例子，底部的多边形向下倾斜</p></div>	
<div class='layout'><p>away from the light source, which means it's going to be dark.</p><p>远离光源，所以更暗一些</p></div>	
<div class='layout'><p>In a similar way, the rightmost polygon is slightly facing away from the light,</p><p>类似的，最右的多边形更背对光源</p></div>	
<div class='layout'><p>so it will be partially illuminated.</p><p>所以只有部分照亮</p></div>	
<div class='layout'><p>And finally, there's the upper-left polygon.</p><p>最后是左上角的多边形</p></div>	
<div class='layout'><p>Its angle means that it will reflect light from the light source towards our view.</p><p>因为它面对的角度  意味着会把光线反射到我们这里</p></div>	
<div class='layout'><p>So, it'll appear bright.</p><p>所以会显得更亮</p></div>	
<div class='layout'><p>If we do this for every polygon, our teapot looks like this which is much more realistic!</p><p>如果对每个多边形执行同样的步骤，看上去会更真实！</p></div>	
<div class='layout'><p>This approach is called Flat Shading, and it's the most basic lighting algorithm.</p><p>这叫 平面着色，是最基本的照明算法</p></div>	

<img style="float:right;" width="70%" src="../img/2705.png" />

<div class='layout'><p>Unfortunately, it also makes all those polygon boundaries really noticeable</p><p>不幸的是，这使多边形的边界非常明显，</p></div>	
<div class='layout'><p>and the mesh doesn't look smooth.</p><p>看起来不光滑</p></div>	
<div class='layout'><p>For this reason, more advanced lighting algorithms were developed,</p><p>因此开发了更多算法</p></div>	
<div class='layout'><p>such as Gouraud Shading and Phong Shading .</p><p>比如 高洛德着色 和 冯氏着色</p></div>	
<div class='layout'><p>Instead of coloring in polygons using just one colour,</p><p>不只用一种颜色给整个多边形上色</p></div>	
<div class='layout'><p>they vary the colour across the surface in clever ways,</p><p>而是以巧妙的方式改变颜色</p></div>	
<div class='layout'><p>which results in much nicer output.</p><p>得到更好的效果</p></div>	
<div class='layout'><p>We also need to talk about textures ,</p><p>我们还要说下" 纹理 "</p></div>	
<div class='layout'><p>which in graphics refers to the look of a surface,rather than its feel.</p><p>纹理在图形学中指外观，而不是手感</p></div>	
<div class='layout'><p>Like with lighting, there are many algorithms with all sorts of fancy effects.</p><p>就像照明算法一样，纹理也有多种算法，来做各种花哨效果</p></div>	
<div class='layout'><p>The simplest is texture mapping .</p><p>最简单的是 纹理映射</p></div>	
<div class='layout'><p>To visualize this process,let's go back to our single polygon.</p><p>为了理解纹理映射，回到单个多边形</p></div>	
<div class='layout'><p>When we're filling this in, using scanline rendering,</p><p>用"扫描线算法"填充时</p></div>	
<div class='layout'><p>we can look up what color to use at every pixel according to a texture image saved in memory.</p><p>可以看看内存内的纹理图像 决定像素用什么颜色</p></div>	
<div class='layout'><p>To do this, we need a mapping between the polygon's coordinates and the texture's coordinates.</p><p>为了做到这点，需要把多边形坐标和纹理坐标对应起来</p></div>	
<div class='layout'><p>Let's jump to the first pixel that scanline rendering needs to fill in.</p><p>我们来看看"扫描线算法"要填充的第一个像素</p></div>	
<div class='layout'><p>The texturing algorithm will consult the texture in memory,</p><p>纹理算法会查询纹理</p></div>	
<div class='layout'><p>take the average color from the corresponding region, and fill the polygon accordingly.</p><p>从相应区域取平均颜色，并填充多边形</p></div>	
<div class='layout'><p>This process repeats for all pixels in the polygon, and that's how we get textures.</p><p>重复这个过程，就可以获得纹理</p></div>	

<img style="float:right;" width="70%" src="../img/2706.png" />

<div class='layout'><p>If you combine all the techniques we've talked about this episode, you get a wonderfully funky little teapot.</p><p>如果结合这集提到的所有技巧，会得到一个精美的小茶壶</p></div>	
<div class='layout'><p>And this teapot can sit in an even bigger scene, comprised of millions of polygons.</p><p>这个茶壶可以放进更大的场景里，场景由上百万个多边形组成</p></div>	
<div class='layout'><p>Rendering a scene like this takes a fair amount of computation.</p><p>渲染这样的场景需要大量计算</p></div>	
<div class='layout'><p>But importantly, it's the same type of calculations being performed</p><p>但重要的是，再大的场景，过程都是一样的，</p></div>	
<div class='layout'><p>over and over and over again for many millions of polygons –</p><p>一遍又一遍，处理所有多边形</p></div>	
<div class='layout'><p>scanline filling, antialiasing, lighting, and texturing.</p><p>扫描线填充， 抗锯齿， 光照， 纹理化</p></div>	
<div class='layout'><p>However there are a couple of ways to make this much faster!</p><p>然而，有几种方法可以加速渲染</p></div>	
<div class='layout'><p>First off, we can speed things up by having special hardware</p><p>首先，我们可以为这种特定运算，</p></div>	
<div class='layout'><p>with extra bells and whistles just for these specific types of computations, making them lightning fast.</p><p>做专门的硬件来加快速度，让运算快如闪电</p></div>	
<div class='layout'><p>And secondly,we can divide up a 3D scene into many smaller parts,</p><p>其次，我们可以把3D场景分解成多个小部分</p></div>	
<div class='layout'><p>and then render all the pieces in parallel,rather than sequentially.</p><p>然后并行渲染，而不是按顺序渲染</p></div>	
<div class='layout'><p>CPU's aren't designed for this, so they aren't particularly fast.</p><p>CPU不是为此设计的，因此图形运算不快</p></div>	
<div class='layout'><p>So, computer engineers created special processors just for graphics</p><p>所以，计算机工程师为图形做了专门的处理器</p></div>	
<div class='layout'><p>a GPU, or Graphics Processing Unit.</p><p>叫 GPU "图形处理单元"</p></div>	
<div class='layout'><p>These can be found on graphics cards inside of your computer, along with RAM reserved for graphics.</p><p>GPU 在显卡上，周围有专用的 RAM</p></div>	
<div class='layout'><p>This is where all the meshes and textures live,</p><p>所有网格和纹理都在里面</p></div>	
<div class='layout'><p>allowing them to be accessed super fast by many different cores of the GPU all at once.</p><p>让 GPU 的多个核心可以高速访问</p></div>	
<div class='layout'><p>A modern graphics card, like a GeForce GTX 1080 TI,</p><p>现代显卡，如 GeForce GTX 1080 TI</p></div>	
<div class='layout'><p>contains 3584 processing cores, offering massive parallelization.</p><p>有3584个处理核心，提供大规模并行处理</p></div>	
<div class='layout'><p>It can process hundreds of millions of polygons every second!</p><p>每秒处理上亿个多边形！</p></div>	
<div class='layout'><p>Ok, that concludes our whistle stop tour of 3D graphics.</p><p>好了，本集对3D图形的介绍到此结束</p></div>	
<div class='layout'><p>Next week, we switch topics entirely.</p><p>下周我们聊全新的主题</p></div>	
<div class='layout'><p>I'll ping you then.</p><p>我到时会 ping 你~</p></div>	
﻿
</div> <!--container-->
<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>
<a id="fPagea" href="index.html" target="_self"><div id="fPage" style="color:#fff;">上<br>一<br>章</div></a>
<a href="index.html" target="_self"><div id="menuPage" style="color:#fff;">目<br>录</div></a>
<a id="LPagea" href="javascript:void(null)" target="_self"><div id="lPage" style="color:#fff;">下<br>一<br>章</div></a>
<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
	//上一页、下一页按钮，需要文件名是数字
	var strUrl=window.location.href;
	var arrUrl=strUrl.split("/");
	var thispage=arrUrl[arrUrl.length-1];
	var thispage2=thispage.split(".");
	var thispage3=thispage2[thispage2.length-2];
	if(thispage3 == 0){
		var obj5=document.getElementById("fPage");
		obj5.style.display="none";
	}else{
		var fpage = thispage3 - 1;
		fpage = fpage +".html";
		document.getElementById("fPagea").href=fpage;
	}
	if(thispage3 == 100){
		var obj6=document.getElementById("lPage");
		obj6.style.display="none";
	}else{
		var fpage = parseInt(thispage3) + 1;
		fpage = fpage +".html";
		document.getElementById("LPagea").href=fpage;
	}
</script>
</div>
</body>
</html>
