<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//谷歌浏览器  
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox等浏览器
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//谷歌浏览器  
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox等浏览器  
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
</script>
<script>
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:link，#container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:85.29%;
	line-height:1.6em;
	overflow:hidden;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}
#goTopBtn, #goBottom, #shangy, #xiay, #menuPage, #lPage, #fPage, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #menuPage, #lPage, #fPage, #ftsize1, #ftsize3{
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #lPage, #fPage, #ftsize, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#fPage{
	bottom: 236px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
	//writing-mode:tb-rl;
}
#menuPage{
	bottom: 198px;
	height:27px;
	white-space:nowrap;
	overflow:hidden;
}
#lPage{
	bottom: 145px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
}
#ftsize1{
	bottom:360px;
}
#ftsize2{
	bottom:334px;
}
#ftsize3{
	bottom:308px;
}
#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #menuPage:hover, #lPage:hover, #fPage:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #menuPage a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link, #menuPage a:visited, #lPage a:link, #fPage a:link, #lPage a:visited, #fPage a:visited {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
.code0, .code2, .code4{
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
.layout, .layout2{
    clear:both;
	width:95%;
	border:1px dotted #eee;
	margin:auto;
	margin-bottom:5px;
	overflow:hidden;
}
.layout2 .right, .layout2 .left, .layout p{
margin-bottom:-55px;
padding-bottom:55px;
text-align: justify;
margin:0;
padding:0;
margin-left:1%;
margin-right:1%;
}
.layout2 .left, .layout p{
float:left;
width:60%;
font-size:1.0em;
}
.layout2 .right,  .layout p+p {
	float: left;
	width:34%;
	border-left:1px dotted #cccccc;
	font-size:0.9em;
	padding-left:1%;
	
}
.layout2 .right p, .layout2 .left p, .layout p{
padding-bottom:5px;
}
h3{
text-indent:3%;
font-size:1em;
height:2.0em;
padding:0;
margin:0;
}
</style>
</head>
<body>
<div id="container">
﻿<div class='layout'><p>9 Advanced CPU Designs</p><p>9 高级CPU设计</p></div>	
<div class='layout'><p>Hi, I'm Carrie Anne and welcome to CrashCourse Computer Science!</p><p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p></div>	
<div class='layout'><p>As we've discussed throughout the series, computers have come a long way from mechanical devices</p><p>随着本系列进展，我们知道计算机进步巨大</p></div>	
<div class='layout'><p>capable of maybe one calculation per second,</p><p>从 1 秒 1 次运算，</p></div>	
<div class='layout'><p>to CPUs running at kilohertz and megahertz speeds.</p><p>到现在有千赫甚至兆赫的CPU</p></div>	
<div class='layout'><p>The device you're watching this video on right now is almost certainly running at Gigahertz speeds</p><p>你现在看视频的设备八成也有 GHz 速度</p></div>	
<div class='layout'><p>that's billions of instructions executed every second.</p><p>1 秒十亿条指令</p></div>	
<div class='layout'><p>Which, trust me, is a lot of computation!</p><p>这是很大的计算量！</p></div>	
<div class='layout'><p>In the early days of electronic computing, processors were typically made faster by</p><p>早期计算机的提速方式是  </p></div>	
<div class='layout'><p>improving the switching time of the transistors inside the chip</p><p>减少晶体管的切换时间.</p></div>	
<div class='layout'><p>the ones that make up all the logic gates, ALUs</p><p>晶体管组成了逻辑门，</p></div>	
<div class='layout'><p>and other stuff we've talked about over the past few episodes.</p><p>ALU 以及前几集的其他组件</p></div>	
<div class='layout'><p>But just making transistors faster and more efficient only went so far, so processor designers</p><p>但这种提速方法最终会碰到瓶颈，所以处理器厂商</p></div>	
<div class='layout'><p>have developed various techniques to boost performance allowing not only simple instructions</p><p>发明各种新技术来提升性能，不但让简单指令运行更快</p></div>	
<div class='layout'><p>to run fast, but also performing much more sophisticated operations.</p><p>也让它能进行更复杂的运算</p></div>	
<div class='layout'><p>Last episode, we created a small program for our CPU that allowed us to divide two numbers.</p><p>上集我们写了个做除法的程序，给 CPU 执行</p></div>	
<div class='layout'><p>We did this by doing many subtractions in a row... so, for example, 16 divided by 4</p><p>方法是做一连串减法，比如16除4 会变成</p></div>	
<div class='layout'><p>could be broken down into the smaller problem of 16 minus 4, minus 4, minus 4, minus 4.</p><p>16-4 -4 -4 -4</p></div>	
<div class='layout'><p>When we hit zero, or a negative number, we knew that we we're done.</p><p>碰到 0 或负数才停下.</p></div>	
<div class='layout'><p>But this approach gobbles up a lot of clock cycles, and isn't particularly efficient.</p><p>但这种方法要多个时钟周期，很低效</p></div>	
<div class='layout'><p>So most computer processors today have divide as one of the instructions</p><p>所以现代 CPU 直接在硬件层面设计了除法，</p></div>	
<div class='layout'><p>that the ALU can perform in hardware.</p><p>可以直接给 ALU 除法指令</p></div>	
<div class='layout'><p>Of course, this extra circuitry makes the ALU bigger and more complicated to design,</p><p>这让 ALU 更大也更复杂一些</p></div>	
<div class='layout'><p>but also more capable a complexity-for-speed tradeoff that</p><p>但也更厉害，复杂度 vs 速度 的平衡</p></div>	
<div class='layout'><p>has been made many times in computing history.</p><p>在计算机发展史上经常出现</p></div>	
<div class='layout'><p>For instance, modern computer processors now have special circuits for things like</p><p>举例，现代处理器有专门电路来处理，</p></div>	
<div class='layout'><p>graphics operations, decoding compressed video, and encrypting files</p><p>图形操作， 解码压缩视频， 加密文档 等等</p></div>	
<div class='layout'><p>all of which are operations that would take many many many clock cycles to perform with standard operations.</p><p>如果用标准操作来实现，要很多个时钟周期.</p></div>	
<div class='layout'><p>You may have even heard of processors with MMX, 3DNow!, or SSE.</p><p>你可能听过某些处理器有 MMX， 3DNOW， SEE</p></div>	
<div class='layout'><p>These are processors with additional, fancy circuits that allow them to</p><p>它们有额外电路做更复杂的操作</p></div>	
<div class='layout'><p>execute additional fancy instructions for things like gaming and encryption.</p><p>用于游戏和加密等场景</p></div>	
<div class='layout'><p>These extensions to the instruction set have grown, and grown over time, and once people</p><p>指令不断增加，</p></div>	
<div class='layout'><p>have written programs to take advantage of them, it's hard to remove them.</p><p>人们一旦习惯了它的便利就很难删掉</p></div>	
<div class='layout'><p>So instruction sets tend to keep getting larger and larger keeping all the old opcodes around for backwards compatibility.</p><p>所以为了兼容旧指令集，指令数量越来越多</p></div>	
<div class='layout'><p>The Intel 4004, the first truly integrated CPU, had 46 instructions</p><p>英特尔 4004，第一个集成CPU，有 46 条指令</p></div>	
<div class='layout'><p>which was enough to build a fully functional computer.</p><p>足够做一台能用的计算机</p></div>	
<div class='layout'><p>But a modern computer processor has thousands of different instructions,</p><p>但现代处理器有上千条指令，</p></div>	
<div class='layout'><p>which utilize all sorts of clever and complex internal circuitry.</p><p>有各种巧妙复杂的电路</p></div>	
<div class='layout'><p>Now, high clock speeds and fancy instruction sets lead to another problem</p><p>超高的时钟速度带来另一个问题</p></div>	
<div class='layout'><p>getting data in and out of the CPU quickly enough.</p><p>如何快速传递数据给 CPU</p></div>	
<div class='layout'><p>It's like having a powerful steam locomotive, but no way to shovel in coal fast enough.</p><p>就像有强大的蒸汽机  但无法快速加煤</p></div>	
<div class='layout'><p>In this case, the bottleneck is RAM.</p><p>RAM 成了瓶颈</p></div>	
<div class='layout'><p>RAM is typically a memory module that lies outside the CPU.</p><p>RAM 是 CPU 之外的独立组件</p></div>	
<div class='layout'><p>This means that data has to be transmitted to and from RAM along sets of data wires,</p><p>意味着数据要用线来传递，</p></div>	
<div class='layout'><p>called a bus.</p><p>叫"总线"</p></div>	
<div class='layout'><p>This bus might only be a few centimeters long,</p><p>总线可能只有几厘米</p></div>	
<div class='layout'><p>and remember those electrical signals are traveling near the speed of light,</p><p>别忘了电信号的传输接近光速</p></div>	
<div class='layout'><p>but when you are operating at gigahertz speeds</p><p>但 CPU 每秒可以处理上亿条指令</p></div>	
<div class='layout'><p>that's billionths of a second – even this small delay starts to become problematic.</p><p>很小的延迟也会造成问题</p></div>	
<div class='layout'><p>It also takes time for RAM itself to lookup the address, retrieve the data</p><p>RAM 还需要时间找地址，取数据，</p></div>	
<div class='layout'><p>and configure itself for output.</p><p>配置，输出数据</p></div>	
<div class='layout'><p>So a “load from RAM” instruction might take dozens of clock cycles to complete, and during</p><p>一条"从内存读数据"的指令可能要多个时钟周期</p></div>	
<div class='layout'><p>this time the processor is just sitting there idly waiting for the data.</p><p>CPU 空等数据</p></div>	
<div class='layout'><p>One solution is to put a little piece of RAM right on the CPU -called a cache.</p><p>解决延迟的方法之一是，给 CPU 加一点 RAM 叫"缓存"</p></div>	
<div class='layout'><p>There isn't a lot of space on a processor's chip,</p><p>因为处理器里空间不大，</p></div>	
<div class='layout'><p>so most caches are just kilobytes or maybe megabytes in size,</p><p>所以缓存一般只有 KB 或 MB</p></div>	
<div class='layout'><p>where RAM is usually gigabytes.</p><p>而 RAM 都是 GB 起步</p></div>	
<div class='layout'><p>Having a cache speeds things up in a clever way.</p><p>缓存提高了速度</p></div>	
<div class='layout'><p>When the CPU requests a memory location from RAM, the RAM can transmit</p><p>CPU 从 RAM 拿数据时，</p></div>	
<div class='layout'><p>not just one single value, but a whole block of data.</p><p>RAM 不用传一个，可以传一批</p></div>	
<div class='layout'><p>This takes only a little bit more time,</p><p>虽然花的时间久一点，</p></div>	
<div class='layout'><p>but it allows this data block to be saved into the cache.</p><p>但数据可以存在缓存</p></div>	
<div class='layout'><p>This tends to be really useful because computer data is often arranged and processed sequentially.</p><p>这很实用，因为数据常常是一个个按顺序处理</p></div>	
<div class='layout'><p>For example, let say the processor is totalling up daily sales for a restaurant.</p><p>举个例子，算餐厅的当日收入</p></div>	
<div class='layout'><p>It starts by fetching the first transaction from RAM at memory location 100.</p><p>先取 RAM 地址 100 的交易额</p></div>	
<div class='layout'><p>The RAM, instead of sending back just that one value, sends a block of data, from memory</p><p>RAM 与其只给1个值，直接给一批值</p></div>	
<div class='layout'><p>location 100 through 200, which are then all copied into the cache.</p><p>把地址100到200都复制到缓存</p></div>	
<div class='layout'><p>Now, when the processor requests the next transaction to add to its running total, the</p><p>当处理器要下一个交易额时</p></div>	
<div class='layout'><p>value at address 101, the cache will say “Oh, I've already got that value right here,</p><p>地址 101，缓存会说："我已经有了，</p></div>	
<div class='layout'><p>so I can give it to you right away!”</p><p>现在就给你"</p></div>	
<div class='layout'><p>And there's no need to go all the way to RAM.</p><p>不用去 RAM 取数据</p></div>	
<div class='layout'><p>Because the cache is so close to the processor,</p><p>因为缓存离 CPU 近， </p></div>	
<div class='layout'><p>it can typically provide the data in a single clock cycle -no waiting required.</p><p>一个时钟周期就能给数据 CPU 不用空等！</p></div>	
<div class='layout'><p>This speeds things up tremendously over having to go back and forth to RAM every single time.</p><p>比反复去 RAM 拿数据快得多</p></div>	
<div class='layout'><p>When data requested in RAM is already stored in the cache like this it's called a</p><p>如果想要的数据已经在缓存，</p></div>	
<div class='layout'><p>cache hit,</p><p>叫 缓存命中</p></div>	
<div class='layout'><p>and if the data requested isn't in the cache, so you have to go to RAM, it's a called</p><p>如果想要的数据不在缓存，</p></div>	
<div class='layout'><p>a cache miss.</p><p>叫 缓存未命中</p></div>	
<div class='layout'><p>The cache can also be used like a scratch space,</p><p>缓存也可以当临时空间，</p></div>	
<div class='layout'><p>storing intermediate values when performing a longer, or more complicated calculation.</p><p>存一些中间值，适合长/复杂的运算</p></div>	
<div class='layout'><p>Continuing our restaurant example, let's say the processor has finished totalling up</p><p>继续餐馆的例子，假设 CPU 算完了一天的销售额</p></div>	
<div class='layout'><p>all of the sales for the day, and wants to store the result in memory address 150.</p><p>想把结果存到地址 150</p></div>	
<div class='layout'><p>Like before, instead of going back all the way to RAM to save that value,</p><p>就像之前，数据不是直接存到 RAM</p></div>	
<div class='layout'><p>it can be stored in cached copy, which is faster to save to,</p><p>而是存在缓存，这样不但存起来快一些</p></div>	
<div class='layout'><p>and also faster to access later if more calculations are needed.</p><p>如果还要接着算，取值也快一些</p></div>	
<div class='layout'><p>But this introduces an interesting problem -</p><p>但这样带来了一个有趣的问题</p></div>	
<div class='layout'><p>the cache's copy of the data is now different to the real version stored in RAM.</p><p>缓存和 RAM 不一致了.</p></div>	
<div class='layout'><p>This mismatch has to be recorded, so that at some point everything can get synced up.</p><p>这种不一致必须记录下来，之后要同步</p></div>	
<div class='layout'><p>For this purpose, the cache has a special flag for each block of memory it stores, called</p><p>因此缓存里每块空间  有一个特殊标记</p></div>	
<div class='layout'><p>the dirty bit</p><p>叫 "脏位"</p></div>	
<div class='layout'><p>which might just be the best term computer scientists have ever invented.</p><p>这可能是计算机科学家取的最贴切的名字</p></div>	
<div class='layout'><p>Most often this synchronization happens when the cache is full,</p><p>同步一般发生在 当缓存满了</p></div>	
<div class='layout'><p>but a new block of memory is being requested by the processor.</p><p>而 CPU 又要缓存时</p></div>	
<div class='layout'><p>Before the cache erases the old block to free up space, it checks its dirty bit,</p><p>在清理缓存腾出空间之前，会先检查 "脏位"</p></div>	
<div class='layout'><p>and if it's dirty, the old block of data is written back to RAM before loading in the new block.</p><p>如果是"脏"的， 在加载新内容之前， 会把数据写回 RAM</p></div>	
<div class='layout'><p>Another trick to boost cpu performance is called instruction pipelining.</p><p>另一种提升性能的方法叫 "指令流水线"</p></div>	
<div class='layout'><p>Imagine you have to wash an entire hotel's worth of sheets,</p><p>想象下你要洗一整个酒店的床单</p></div>	
<div class='layout'><p>but you've only got one washing machine and one dryer.</p><p>但只有 1 个洗衣机， 1 个干燥机</p></div>	
<div class='layout'><p>One option is to do it all sequentially: put a batch of sheets in the washer</p><p>选择1：按顺序来，</p></div>	
<div class='layout'><p>and wait 30 minutes for it to finish.</p><p>放洗衣机等 30 分钟洗完</p></div>	
<div class='layout'><p>Then take the wet sheets out and put them in the dryer and wait another 30 minutes for that to finish.</p><p>然后拿出湿床单，放进干燥机等 30 分钟烘干</p></div>	
<div class='layout'><p>This allows you to do one batch of sheets every hour.</p><p>这样1小时洗一批</p></div>	
<div class='layout'><p>Side note: if you have a dryer that can dry a load of laundry in 30 minutes,</p><p>另外一说：如果你有 30 分钟就能烘干的干燥机</p></div>	
<div class='layout'><p>Please tell me the brand and model in the comments, because I'm living with 90 minute dry times, minimum.</p><p>请留言告诉我是什么牌子，我的至少要 90 分钟.</p></div>	
<div class='layout'><p>But, even with this magic clothes dryer,</p><p>即使有这样的神奇干燥机， </p></div>	
<div class='layout'><p>you can speed things up even more if you parallelize your operation.</p><p>我们可以用"并行处理"进一步提高效率</p></div>	
<div class='layout'><p>As before, you start off putting one batch of sheets in the washer.</p><p>就像之前，先放一批床单到洗衣机</p></div>	
<div class='layout'><p>You wait 30 minutes for it to finish.</p><p>等 30 分钟洗完</p></div>	
<div class='layout'><p>Then you take the wet sheets out and put them in the dryer.</p><p>然后把湿床单放进干燥机</p></div>	
<div class='layout'><p>But this time, instead of just waiting 30 minutes for the dryer to finish,</p><p>但这次，与其干等 30 分钟烘干，</p></div>	
<div class='layout'><p>you simultaneously start another load in the washing machine.</p><p>可以放另一批进洗衣机</p></div>	
<div class='layout'><p>Now you've got both machines going at once.</p><p>让两台机器同时工作</p></div>	
<div class='layout'><p>Wait 30 minutes, and one batch is now done, one batch is half done,</p><p>30 分钟后，一批床单完成， 另一批完成一半</p></div>	
<div class='layout'><p>and another is ready to go in.</p><p>另一批准备开始</p></div>	
<div class='layout'><p>This effectively doubles your throughput.</p><p>效率x2！</p></div>	
<div class='layout'><p>Processor designs can apply the same idea.</p><p>处理器也可以这样设计</p></div>	
<div class='layout'><p>In episode 7, our example processor performed the fetch-decode-execute cycle sequentially</p><p>第7集，我们演示了 CPU 按序处理</p></div>	
<div class='layout'><p>and in a continuous loop: Fetch-decode-execute, fetch-decode-execute, fetch-decode-execute, and so on</p><p>取指 → 解码 → 执行， 不断重复</p></div>	
<div class='layout'><p>This meant our design required three clock cycles to execute one instruction.</p><p>这种设计，三个时钟周期执行 1 条指令</p></div>	
<div class='layout'><p>But each of these stages uses a different part of the CPU,</p><p>但因为每个阶段用的是 CPU 的不同部分</p></div>	
<div class='layout'><p>meaning there is an opportunity to parallelize!</p><p>意味着可以并行处理！</p></div>	
<div class='layout'><p>While one instruction is getting executed, the next instruction could be getting decoded,</p><p>执行一个指令时，同时"解码"下一个指令</p></div>	
<div class='layout'><p>and the instruction beyond that fetched from memory.</p><p>读取下下个指令</p></div>	
<div class='layout'><p>All of these separate processes can overlap</p><p>不同任务重叠进行，</p></div>	
<div class='layout'><p>so that all parts of the CPU are active at any given time.</p><p>同时用上 CPU 里所有部分.</p></div>	
<div class='layout'><p>In this pipelined design, an instruction is executed every single clock cycle</p><p>这样的流水线  每个时钟周期执行1个指令</p></div>	
<div class='layout'><p>which triples the throughput.</p><p>吞吐量 x 3</p></div>	
<div class='layout'><p>But just like with caching this can lead to some tricky problems.</p><p>和缓存一样，这也会带来一些问题</p></div>	
<div class='layout'><p>A big hazard is a dependency in the instructions.</p><p>第一个问题是 指令之间的依赖关系</p></div>	
<div class='layout'><p>For example, you might fetch something that the currently executing instruction is just about to modify,</p><p>举个例子，你在读某个数据，而正在执行的指令会改这个数据</p></div>	
<div class='layout'><p>which means you'll end up with the old value in the pipeline.</p><p>也就是说拿的是旧数据</p></div>	
<div class='layout'><p>To compensate for this, pipelined processors have to look ahead for data dependencies,</p><p>因此流水线处理器  要先弄清数据依赖性</p></div>	
<div class='layout'><p>and if necessary, stall their pipelines to avoid problems.</p><p>必要时停止流水线，避免出问题</p></div>	
<div class='layout'><p>High end processors, like those found in laptops and smartphones,</p><p>高端 CPU，比如笔记本和手机里那种</p></div>	
<div class='layout'><p>go one step further and can dynamically reorder instructions with dependencies</p><p>会更进一步，动态排序 有依赖关系的指令</p></div>	
<div class='layout'><p>in order to minimize stalls and keep the pipeline moving,</p><p>最小化流水线的停工时间</p></div>	
<div class='layout'><p>which is called out-of-order execution.</p><p>这叫 "乱序执行"</p></div>	
<div class='layout'><p>As you might imagine, the circuits that figure this all out are incredibly complicated.</p><p>和你猜的一样，这种电路非常复杂</p></div>	
<div class='layout'><p>Nonetheless, pipelining is tremendously effective and almost all processors implement it today.</p><p>但因为非常高效，几乎所有现代处理器都有流水线</p></div>	
<div class='layout'><p>Another big hazard are conditional jump instructions -we talked about one example, a JUMP NEGATIVE,last episode.</p><p>第二个问题是 "条件跳转"，比如上集的 JUMP NEGATIVE</p></div>	
<div class='layout'><p>These instructions can change the execution flow of a program depending on a value.</p><p>这些指令会改变程序的执行流</p></div>	
<div class='layout'><p>A simple pipelined processor will perform a long stall when it sees a jump instruction,</p><p>简单的流水线处理器，看到 JUMP 指令会停一会儿，</p></div>	
<div class='layout'><p>waiting for the value to be finalized.</p><p>等待条件值确定下来</p></div>	
<div class='layout'><p>Only once the jump outcome is known, does the processor start refilling its pipeline.</p><p>一旦 JUMP 的结果出了，处理器就继续流水线</p></div>	
<div class='layout'><p>But, this can produce long delays, so high-end processors have some tricks to deal with this problem too.</p><p>因为空等会造成延迟，所以高端处理器会用一些技巧</p></div>	
<div class='layout'><p>Imagine an upcoming jump instruction as a fork in a road a branch.</p><p>可以把 JUMP 想成是 "岔路口"</p></div>	
<div class='layout'><p>Advanced CPUs guess which way they are going to go, and start filling their pipeline with</p><p>高端 CPU 会猜哪条路的可能性大一些</p></div>	
<div class='layout'><p>instructions based off that guess – a technique called speculative execution.</p><p>然后提前把指令放进流水线，这叫 "推测执行"</p></div>	
<div class='layout'><p>When the jump instruction is finally resolved, if the CPU guessed correctly,</p><p>当 JUMP 的结果出了，如果 CPU 猜对了</p></div>	
<div class='layout'><p>then the pipeline is already full of the correct instructions and it can motor along without delay.</p><p>流水线已经塞满正确指令，可以马上运行</p></div>	
<div class='layout'><p>However, if the CPU guessed wrong, it has to discard all its speculative results and</p><p>如果 CPU 猜错了，就要清空流水线</p></div>	
<div class='layout'><p>perform a pipeline flush sort of like when you miss a turn and have to do a u-turn to</p><p>就像走错路掉头</p></div>	
<div class='layout'><p>get back on route, and stop your GPS's insistent shouting.</p><p>让 GPS 不要再！叫！了！</p></div>	
<div class='layout'><p>To minimize the effects of these flushes, CPU manufacturers have developed sophisticated</p><p>为了尽可能减少清空流水线的次数，CPU 厂商开发了复杂的方法</p></div>	
<div class='layout'><p>ways to guess which way branches will go, called branch prediction.</p><p>来猜测哪条分支更有可能，叫"分支预测"</p></div>	
<div class='layout'><p>Instead of being a 50/50 guess, today's processors can often guess with over 90% accuracy!</p><p>现代 CPU 的正确率超过 90%</p></div>	
<div class='layout'><p>In an ideal case, pipelining lets you complete one instruction every single clock cycle,</p><p>理想情况下，流水线一个时钟周期完成 1 个指令</p></div>	
<div class='layout'><p>but then superscalar processors came along</p><p>然后"超标量处理器"出现了，</p></div>	
<div class='layout'><p>which can execute more than one instruction per clock cycle.</p><p>一个时钟周期完成多个指令</p></div>	
<div class='layout'><p>During the execute phase even in a pipelined design,</p><p>即便有流水线设计，在指令执行阶段</p></div>	
<div class='layout'><p>whole areas of the processor might be totally idle.</p><p>处理器里有些区域还是可能会空闲</p></div>	
<div class='layout'><p>For example, while executing an instruction that fetches a value from memory,</p><p>比如，执行一个 "从内存取值" 指令期间</p></div>	
<div class='layout'><p>the ALU is just going to be sitting there, not doing a thing.</p><p>ALU 会闲置</p></div>	
<div class='layout'><p>So why not fetch-and-decode several instructions at once, and whenever possible, execute instructions</p><p>所以一次性处理多条指令（取指令+解码） 会更好.</p></div>	
<div class='layout'><p>that require different parts of the CPU all at the same time</p><p>如果多条指令要 ALU 的不同部分，就多条同时执行</p></div>	
<div class='layout'><p>But we can take this one step further and add duplicate circuitry</p><p>我们可以再进一步，加多几个相同的电路，</p></div>	
<div class='layout'><p>for popular instructions.</p><p>执行出现频次很高的指令</p></div>	
<div class='layout'><p>For example, many processors will have four, eight or more identical ALUs,</p><p>举例，很多 CPU 有四个， 八个甚至更多 完全相同的ALU</p></div>	
<div class='layout'><p>so they can execute many mathematical instructions all in parallel!</p><p>可以同时执行多个数学运算</p></div>	
<div class='layout'><p>Ok, the techniques we've discussed so far primarily optimize the execution throughput</p><p>好了，目前说过的方法，</p></div>	
<div class='layout'><p>of a single stream of instructions,</p><p>都是优化 1 个指令流的吞吐量</p></div>	
<div class='layout'><p>but another way to increase performance is to run several streams of instructions at once</p><p>另一个提升性能的方法是 同时运行多个指令流</p></div>	
<div class='layout'><p>with multi-core processors.</p><p>用多核处理器</p></div>	
<div class='layout'><p>You might have heard of dual core or quad core processors.</p><p>你应该听过双核或四核处理器</p></div>	
<div class='layout'><p>This means there are multiple independent processing units inside of a single CPU chip.</p><p>意思是一个 CPU 芯片里，有多个独立处理单元</p></div>	
<div class='layout'><p>In many ways, this is very much like having multiple separate CPUs,</p><p>很像是有多个独立 CPU</p></div>	
<div class='layout'><p>but because they're tightly integrated, they can share some resources,</p><p>但因为它们整合紧密，可以共享一些资源</p></div>	
<div class='layout'><p>like cache, allowing the cores to work together on shared computations.</p><p>比如缓存，使得多核可以合作运算</p></div>	
<div class='layout'><p>But, when more cores just isn't enough, you can build computers with multiple independent CPUs!</p><p>但多核不够时，可以用多个 CPU</p></div>	
<div class='layout'><p>High end computers, like the servers streaming this video from YouTube's datacenter, often</p><p>高端计算机，比如现在给你传视频的 Youtube 服务器</p></div>	
<div class='layout'><p>need the extra horsepower to keep it silky smooth for the hundreds of people watching simultaneously.</p><p>需要更多马力，让上百人能同时流畅观看</p></div>	
<div class='layout'><p>Twoand four-processor configuration are the most common right now,</p><p>2个或4个CPU是最常见的</p></div>	
<div class='layout'><p>but every now and again even that much processing power isn't enough.</p><p>但有时人们有更高的性能要求</p></div>	
<div class='layout'><p>So we humans get extra ambitious and build ourselves a supercomputer!</p><p>所以造了超级计算机！</p></div>	
<div class='layout'><p>If you're looking to do some really monster calculations</p><p>如果要做怪兽级运算</p></div>	
<div class='layout'><p>like simulating the formation of the universe you'll need some pretty serious compute power.</p><p>比如模拟宇宙形成，你需要强大的计算能力</p></div>	
<div class='layout'><p>A few extra processors in a desktop computer just isn't going to cut it.</p><p>给普通台式机加几个 CPU 没什么用</p></div>	
<div class='layout'><p>You're going to need a lot of processors.</p><p>你需要很多处理器！</p></div>	
<div class='layout'><p>No.. no... even more than that.</p><p>不…不…还要更多</p></div>	
<div class='layout'><p>A lot more!</p><p>更多</p></div>	
<div class='layout'><p>When this video was made, the world's fastest computer was located in</p><p>截止至视频发布，世上最快的计算机在</p></div>	
<div class='layout'><p>The National Supercomputing Center in Wuxi, China.</p><p>中国无锡的国家超算中心</p></div>	
<div class='layout'><p>The Sunway TaihuLight contains a brain-melting 40,960 CPUs, each with 256 cores!</p><p>神威·太湖之光有 40960 个CPU，每个 CPU 有 256 个核心</p></div>	
<div class='layout'><p>Thats over ten million cores in total... and each one of those cores runs at 1.45 gigahertz.</p><p>总共超过1千万个核心，每个核心的频率是 1.45GHz</p></div>	
<div class='layout'><p>In total, this machine can process 93 Quadrillion -that's 93 million-billions</p><p>每秒可以进行 9. 亿亿次浮点数运算</p></div>	
<div class='layout'><p>floating point math operations per second, knows as FLOPS.</p><p>也叫 每秒浮点运算次数 (FLOPS)</p></div>	
<div class='layout'><p>And trust me, that's a lot of FLOPS!!</p><p>相信我  这个速度很可怕</p></div>	
<div class='layout'><p>No word on whether it can run Crysis at max settings, but I suspect it might.</p><p>没人试过跑最高画质的《孤岛危机》但我估计没问题</p></div>	
<div class='layout'><p>So long story short, not only have computer processors gotten a lot faster over the years,</p><p>长话短说，这些年处理器不但大大提高了速度</p></div>	
<div class='layout'><p>but also a lot more sophisticated, employing all sorts of clever tricks to squeeze out</p><p>而且也变得更复杂，用各种技巧</p></div>	
<div class='layout'><p>more and more computation per clock cycle.</p><p>榨干每个时钟周期 做尽可能多运算</p></div>	
<div class='layout'><p>Our job is to wield that incredible processing power to do cool and useful things.</p><p>我们的任务是利用这些运算能力，做又酷又实用的事</p></div>	
<div class='layout'><p>That's the essence of programming, which we'll start discussing next episode.</p><p>编程就是为了这个，我们下集说</p></div>	
<div class='layout'><p>See you next week.</p><p>下周见</p></div>	
﻿
</div> <!--container-->
<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>
<a id="fPagea" href="index.html" target="_self"><div id="fPage" style="color:#fff;">上<br>一<br>章</div></a>
<a href="index.html" target="_self"><div id="menuPage" style="color:#fff;">目<br>录</div></a>
<a id="LPagea" href="javascript:void(null)" target="_self"><div id="lPage" style="color:#fff;">下<br>一<br>章</div></a>
<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
	//上一页、下一页按钮，需要文件名是数字
	var strUrl=window.location.href;
	var arrUrl=strUrl.split("/");
	var thispage=arrUrl[arrUrl.length-1];
	var thispage2=thispage.split(".");
	var thispage3=thispage2[thispage2.length-2];
	if(thispage3 == 0){
		var obj5=document.getElementById("fPage");
		obj5.style.display="none";
	}else{
		var fpage = thispage3 - 1;
		fpage = fpage +".html";
		document.getElementById("fPagea").href=fpage;
	}
	if(thispage3 == 100){
		var obj6=document.getElementById("lPage");
		obj6.style.display="none";
	}else{
		var fpage = parseInt(thispage3) + 1;
		fpage = fpage +".html";
		document.getElementById("LPagea").href=fpage;
	}
</script>
</div>
</body>
</html>
