<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//谷歌浏览器  
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox等浏览器
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//谷歌浏览器  
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox等浏览器  
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
</script>
<script>
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:link，#container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:85.29%;
	line-height:1.6em;
	overflow:hidden;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}
#goTopBtn, #goBottom, #shangy, #xiay, #menuPage, #lPage, #fPage, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #menuPage, #lPage, #fPage, #ftsize1, #ftsize3{
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #lPage, #fPage, #ftsize, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#fPage{
	bottom: 236px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
	//writing-mode:tb-rl;
}
#menuPage{
	bottom: 198px;
	height:27px;
	white-space:nowrap;
	overflow:hidden;
}
#lPage{
	bottom: 145px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
}
#ftsize1{
	bottom:360px;
}
#ftsize2{
	bottom:334px;
}
#ftsize3{
	bottom:308px;
}
#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #menuPage:hover, #lPage:hover, #fPage:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #menuPage a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link, #menuPage a:visited, #lPage a:link, #fPage a:link, #lPage a:visited, #fPage a:visited {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
.code0, .code2, .code4{
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
.layout, .layout2{
    clear:both;
	width:95%;
	border:1px dotted #eee;
	margin:auto;
	margin-bottom:5px;
	overflow:hidden;
}
.layout2 .right, .layout2 .left, .layout p{
margin-bottom:-55px;
padding-bottom:55px;
text-align: justify;
margin:0;
padding:0;
margin-left:1%;
margin-right:1%;
}
.layout2 .left, .layout p{
float:left;
width:60%;
font-size:1.0em;
}
.layout2 .right,  .layout p+p {
	float: left;
	width:34%;
	border-left:1px dotted #cccccc;
	font-size:0.9em;
	padding-left:1%;
	
}
.layout2 .right p, .layout2 .left p, .layout p{
padding-bottom:5px;
}
h3{
text-indent:3%;
font-size:1em;
height:2.0em;
padding:0;
margin:0;
}
</style>
</head>
<body>
<div id="container">
﻿<div class='layout'><p>23 Screens&2D Graphics</p><p>23 屏幕&2D 图形显示</p></div>	
<div class='layout'><p>Hi, I'm Carrie Anne, and welcome to Crash Course Computer Science!</p><p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p></div>	
<div class='layout'><p>This 1960 PDP-1 is a great example of early computing with graphics.</p><p>这台 1960 年的 PDP-1，是一个早期图形计算机的好例子</p></div>	
<div class='layout'><p>You can see a cabinet-sized computer on the left,</p><p>你可以看到 左边是柜子大小的电脑</p></div>	
<div class='layout'><p>an electromechanical teletype machine in the middle,</p><p>中间是电传打字机</p></div>	
<div class='layout'><p>and a round screen on the right.</p><p>右边是一个圆形的屏幕</p></div>	
<div class='layout'><p>Note how they're separated.</p><p>注意它们是分开的</p></div>	
<div class='layout'><p>That's because text-based tasks and graphical tasks were often distinct back then.</p><p>因为当时文本任务和图形任务是分开的.</p></div>	
<div class='layout'><p>In fact, these early computer screens had a very hard time rendering crisp text, whereas</p><p>事实上，早期的屏幕无法显示清晰的文字</p></div>	
<div class='layout'><p>typed paper offered much higher contrast and resolution.</p><p>而打印到纸上  有更高的对比度和分辨率</p></div>	
<div class='layout'><p>The most typical use for early computer screens was to keep track of a program's operation,</p><p>早期屏幕的典型用途 是跟踪程序的运行情况</p></div>	
<div class='layout'><p>like values in registers.</p><p>比如寄存器的值</p></div>	
<div class='layout'><p>It didn't make sense to have a teletype machine print this on paper</p><p>如果用打印机，一遍又一遍打印出来没有意义</p></div>	
<div class='layout'><p>over and over and over again -that'd waste a lot of paper, and it was slow.</p><p>不仅费纸而且慢</p></div>	
<div class='layout'><p>On the other hand, screens were dynamic and quick to update -perfect for temporary values.</p><p>另一方面，屏幕更新很快，对临时值简直完美</p></div>	
<div class='layout'><p>Computer screens were rarely considered for program output, though.</p><p>但屏幕很少用于输出计算结果，结果一般都打印到纸上</p></div>	
<div class='layout'><p>Instead, any results from a computation were typically written to paper</p><p>但屏幕很少用于输出计算结果，结果一般都打印到纸上</p></div>	
<div class='layout'><p>or some other more permanent medium.</p><p>或其它更永久的东西上</p></div>	
<div class='layout'><p>But, screens were so darn useful</p><p>但屏幕超有用，到1960年代，</p></div>	
<div class='layout'><p>that by the early 1960s, people started to use them for awesome things.</p><p>人们开始用屏幕做很多酷炫的事情</p></div>	
<div class='layout'><p>A lot of different display technologies have been created over the decades,</p><p>几十年间出现了很多显示技术</p></div>	
<div class='layout'><p>but the most influential, and also the earliest, were Cathode Ray Tubes, or CRT</p><p>但最早最有影响力的是 阴极射线管（CRT）</p></div>	
<div class='layout'><p>These work by shooting electrons out of an emitter at a phosphor-coated screen.</p><p>原理是把电子发射到 有磷光体涂层的屏幕上</p></div>	

<img style="float:right;" width="70%" src="../img/2301.png" />

<div class='layout'><p>When electrons hit the coating, it glows for a fraction of a second.</p><p>当电子撞击涂层时 会发光几分之一秒</p></div>	
<div class='layout'><p>Because electrons are charged particles,</p><p>由于电子是带电粒子，路径可以用磁场控制</p></div>	
<div class='layout'><p>their paths can be manipulated with electromagnetic fields.</p><p>由于电子是带电粒子，路径可以用磁场控制</p></div>	
<div class='layout'><p>Plates or coils are used inside to steer electrons to a desired position,</p><p>屏幕内用板子或线圈  把电子引导到想要的位置</p></div>	
<div class='layout'><p>both left-right and up-down.</p><p>上下左右都行</p></div>	
<div class='layout'><p>With this control, there are two ways you can draw graphics.</p><p>既然可以这样控制，有 2 种方法绘制图形，</p></div>	
<div class='layout'><p>The first option is to direct the electron beam to trace out shapes.</p><p>1 引导电子束描绘出形状</p></div>	

<img style="float:right;" width="70%" src="../img/2302.png" />

<div class='layout'><p>This is called Vector Scanning.</p><p>这叫"矢量扫描"</p></div>	
<div class='layout'><p>Because the glow persists for a little bit, if you repeat the path quickly enough,</p><p>因为发光只持续一小会儿，如果重复得足够快 </p></div>	
<div class='layout'><p>you create a solid image.</p><p>可以得到清晰的图像</p></div>	
<div class='layout'><p>The other option is to repeatedly follow a fixed path, scanning line by line,</p><p>2 按固定路径，一行行来，从上向下，</p></div>	
<div class='layout'><p>from top left to bottom right, and looping over and over again.</p><p>从左到右，不断重复</p></div>	

<img style="float:right;" width="70%" src="../img/2303.png" />

<div class='layout'><p>You only turn on the electron beam at certain points to create graphics.</p><p>只在特定的点打开电子束，以此绘制图形</p></div>	
<div class='layout'><p>This is called Raster Scanning.</p><p>这叫 "光栅扫描"</p></div>	
<div class='layout'><p>With this approach, you can display shapes... and even text... all made of little line segments.</p><p>用这种方法，可以用很多小线段绘制形状  甚至文字</p></div>	
<div class='layout'><p>Eventually, as display technologies improved,</p><p>最后，因为显示技术的发展</p></div>	
<div class='layout'><p>it was possible to render crisp dots onto the screen, aka pixels.</p><p>我们终于可以在屏幕上显示清晰的点，叫"像素"</p></div>	
<div class='layout'><p>The Liquid Crystal Displays, or LCDs,</p><p>液晶显示器，简称 LCD</p></div>	
<div class='layout'><p>that we use today are quite a different technology.</p><p>和以前的技术相当不同</p></div>	
<div class='layout'><p>But, they use raster scanning too,</p><p>但 LCD 也用光栅扫描，</p></div>	
<div class='layout'><p>updating the brightness of little tiny red, green and blue pixels many times a second.</p><p>每秒更新多次 像素里红绿蓝的颜色</p></div>	
<div class='layout'><p>Interestingly, most early computers didn't use pixels</p><p>有趣的是，很多早期计算机不用像素</p></div>	
<div class='layout'><p>not because they couldn't physically,</p><p>不是技术做不到， </p></div>	
<div class='layout'><p>but because it consumed way too much memory for computers of the time.</p><p>而是因为像素占太多内存</p></div>	
<div class='layout'><p>A 200 by 200 pixel image contains 40,000 pixels.</p><p>200像素×200像素的图像，有 40，000 个像素</p></div>	
<div class='layout'><p>Even if you use just one bit of data for each pixel,</p><p>哪怕每个像素只用一个 bit 表示，</p></div>	
<div class='layout'><p>that's black OR white -not grayscale!</p><p>代表黑色或白色，连灰度都没有！</p></div>	
<div class='layout'><p>the image would consume 40,000 bits of memory.</p><p>会占 40，000 bit 内存，</p></div>	
<div class='layout'><p>That would have gobbled up more than half of a PDP-1's entire RAM.</p><p>比 PDP-1 全部内存的一半还多</p></div>	
<div class='layout'><p>So, computer scientists and engineers had to come up with clever tricks to render graphics</p><p>所以计算机科学家和工程师，得想一些技巧来渲染图形，</p></div>	
<div class='layout'><p>until memory sizes caught up to our pixelicious ambitions.</p><p>等内存发展到足够用</p></div>	
<div class='layout'><p>Instead of storing tens of thousands of pixels,</p><p>所以早期计算机不存大量像素值，</p></div>	
<div class='layout'><p>early computers stored a much smaller grid of letters, most typically 80 by 25 characters.</p><p>而是存符号，80x25个符号最典型</p></div>	
<div class='layout'><p>That's 2000 characters in total.</p><p>总共 2000 个字符</p></div>	
<div class='layout'><p>And if each is encoded in 8 bits, using something like ASCII,</p><p>如果每个字符用 8 位表示，比如用 ASCII</p></div>	
<div class='layout'><p>it would consume 16,000 bits of memory for an entire screen full of text,</p><p>总共才 16000 位，</p></div>	
<div class='layout'><p>which is way more reasonable.</p><p>这种大小更合理</p></div>	
<div class='layout'><p>To pull this off, computers needed an extra piece of hardware that</p><p>为此，计算机需要额外硬件</p></div>	
<div class='layout'><p>could read characters out of RAM, and convert them into raster graphics to be drawn onto the screen.</p><p>来从内存读取字符，转换成光栅图形，这样才能显示到屏幕上</p></div>	
<div class='layout'><p>This was called a character generator, and they were basically the first graphics cards.</p><p>这个硬件叫 "字符生成器"，基本算是第一代显卡</p></div>	
<div class='layout'><p>Inside, they had a little piece of Read Only Memory, a ROM,</p><p>它内部有一小块只读存储器，简称 ROM</p></div>	
<div class='layout'><p>that stored graphics for each character, called a dot matrix pattern.</p><p>存着每个字符的图形，叫"点阵图案"</p></div>	
<div class='layout'><p>If the graphics card saw the 8-bit code for the letter "K",</p><p>如果图形卡看到一个 8 位二进制，发现是字母 K</p></div>	
<div class='layout'><p>then it would raster scan the 2D pattern for the letter K onto the screen, in the appropriate position.</p><p>那么会把字母 K 的点阵图案 ，光栅扫描显示到屏幕的适当位置</p></div>	
<div class='layout'><p>To do this, the character generator had special access to a portion of a computer's memory</p><p>为了显示，"字符生成器" 会访问内存中一块特殊区域，</p></div>	
<div class='layout'><p>reserved for graphics, a region called the screen buffer.</p><p>这块区域专为图形保留，叫 屏幕缓冲区</p></div>	
<div class='layout'><p>Computer programs wishing to render text to the screen</p><p>程序想显示文字时，</p></div>	
<div class='layout'><p>simply manipulated the values stored in this region,</p><p>修改这块区域里的值就行</p></div>	
<div class='layout'><p>just as they could with any other data in RAM.</p><p>就像他们在RAM中处理其他数据一样。</p></div>	
<div class='layout'><p>This scheme required much less memory,</p><p>这个方案用的内存少得多，</p></div>	
<div class='layout'><p>but it also meant the only thing you could draw was text.</p><p>但也意味着 只能画字符到屏幕上</p></div>	
<div class='layout'><p>Even still, people got pretty inventive with ASCII art!</p><p>即使有这样限制，人们用 ASCII 艺术发挥了很多创意！</p></div>	
<div class='layout'><p>People also tried to make rudimentary, pseudo-graphical interfaces out of this basic set of characters</p><p>也有人用字符模仿图形界面</p></div>	
<div class='layout'><p>using things like underscores and plus signs to create boxes, lines and other primitive shapes.</p><p>用下划线和加号来画盒子，线，和其他简单形状</p></div>	
<div class='layout'><p>But, the character set was really too small to do anything terribly sophisticated.</p><p>但字符集实在太小，做不了什么复杂的事</p></div>	
<div class='layout'><p>So, various extensions to ASCII were made that added new semigraphical characters,</p><p>因此对 ASCII 进行了各种扩展，加新字符</p></div>	
<div class='layout'><p>like IBM's CP437 character set, seen here, which was used in DOS.</p><p>比如上图的 IBM CP437 字符集，用于 DOS.</p></div>	
<div class='layout'><p>On some systems, the text color and background color could be defined with a few extra bits.</p><p>某些系统上，可以用额外的 bit 定义字体颜色和背景颜色</p></div>	
<div class='layout'><p>That allowed glorious interfaces like this DOS example,</p><p>做出这样的 DOS 界面，</p></div>	
<div class='layout'><p>which is built entirely out the character set you just saw.</p><p>这界面只用了刚刚提到的字符集</p></div>	

<img style="float:right;" width="70%" src="../img/2304.png" />

<div class='layout'><p>Character generators were a clever way to save memory.</p><p>字符生成器 是一种省内存的技巧，</p></div>	
<div class='layout'><p>But, they didn't provide any way to draw arbitrary shapes.</p><p>但没办法绘制任意形状</p></div>	
<div class='layout'><p>And that's important if you want to draw content like electrical circuits, architectural</p><p>绘制任意形状很重要，因为电路设计，建筑</p></div>	
<div class='layout'><p>plans, maps, and... well pretty much everything that isn't text!</p><p>平面图，地图，好多东西都不是文字！</p></div>	
<div class='layout'><p>To do this, without resorting to memory-gobbling pixels,</p><p>为了绘制任意形状，同时不吃掉所有内存</p></div>	
<div class='layout'><p>computer scientists used the vector mode available on CRTs.</p><p>计算机科学家用 CRT 上的"矢量模式"</p></div>	
<div class='layout'><p>The idea is pretty straightforward: all content to be drawn on screen is defined by a series of lines.</p><p>概念非常简单：所有东西都由线组成</p></div>	
<div class='layout'><p>There's no text.</p><p>没有文字这回事</p></div>	
<div class='layout'><p>If you need to draw text, you have to draw it out of lines.</p><p>如果要显示文字，就用线条画出来</p></div>	
<div class='layout'><p>Don't read between the lines here. There is only lines!</p><p>只有线条，没有别的</p></div>	
<div class='layout'><p>Got it? Alright, no more word play.</p><p>明白了吗？好，我们举个实例吧</p></div>	
<div class='layout'><p>I'm drawing the line here.</p><p>我在这里画一条 线</p></div>	
<div class='layout'><p>Let's pretend this video is a cartesian plane, 200 units wide and 100 tall, with the</p><p>假设这个视频是一个 笛卡尔平面，200个单位宽，100个单位高</p></div>	
<div class='layout'><p>origin that's the zero-zero point in the upper left corner.</p><p>原点 (0，0) 在左上角</p></div>	
<div class='layout'><p>We can draw a shape with the following vector commands,</p><p>我们可以画形状，用如下矢量命令</p></div>	
<div class='layout'><p>which we've borrowed from the Vectrex, an early vector display system.</p><p>这些命令来自 Vectrex，一个早期矢量显示系统</p></div>	
<div class='layout'><p>First, we reset, which clears the screen,</p><p>首先，reset ，这个命令会清空屏幕</p></div>	
<div class='layout'><p>moves the drawing point of the electron gun to zero-zero,</p><p>把电子枪的绘图点移动到坐标 (0，0)</p></div>	
<div class='layout'><p>and sets the brightness of lines to zero.</p><p>并把线的亮度设为 0</p></div>	
<div class='layout'><p>Then we move the drawing point down to 50 50,</p><p>MOVE_TO 50 50，把绘图点移动到坐标 (50，50)</p></div>	
<div class='layout'><p>and set the line intensity to 100%.</p><p>INTENSITY 100，把强度设为 100</p></div>	
<div class='layout'><p>With the intensity up, now we move to 100, 50, then 60, 75 and then back to 50,50.</p><p>现在亮度提高了，移动到 (100，50)  然后 (60，75)  然后 (50，50)</p></div>	
<div class='layout'><p>The last thing to do is set our line intensity back to 0%.</p><p>最后把强度设回 0</p></div>	
<div class='layout'><p>Cool! We've got a triangle!</p><p>酷，我们画了一个三角形！</p></div>	
<div class='layout'><p>This sequence of commands would consume on the order of 160 bits, which is way more efficient</p><p>这些命令占 160 bit ，</p></div>	
<div class='layout'><p>than keeping a huge matrix of pixel values!</p><p>比存一个庞大的像素矩阵更好</p></div>	
<div class='layout'><p>Just like how characters were stored in memory and turned into graphics by a character generator,</p><p>就像之前的"字符生成器" ，把内存里的字符转成图形一样</p></div>	
<div class='layout'><p>these vector instructions were also stored in memory, and rendered to a screen using</p><p>这些矢量指令也存在内存中，</p></div>	
<div class='layout'><p>a vector graphics card.</p><p>通过矢量图形卡画到屏幕上</p></div>	
<div class='layout'><p>Hundreds of commands could be packed together, sequentially, in the screen buffer,</p><p>数百个命令可以按序存在屏幕缓冲区</p></div>	
<div class='layout'><p>and used to build up complex graphics. All made of lines!</p><p>画出复杂图形，全是线段组成的！</p></div>	
<div class='layout'><p>Because all these vectors are stored in memory, computer programs can update the values freely,</p><p>由于这些矢量都在内存中，程序可以更新这些值</p></div>	
<div class='layout'><p>allowing for graphics that change over time -Animation!</p><p>让图形随时间变化 动画！</p></div>	
<div class='layout'><p>One of the very earliest video games, Spacewar!,</p><p>最早的电子游戏之一， Spacewar！</p></div>	
<div class='layout'><p>was built on a PDP-1 in 1962 using vector graphics.</p><p>是 1962 年在 PDP-1 上用矢量图形制作的.</p></div>	
<div class='layout'><p>It's credited with inspiring many later games, like Asteroids,</p><p>它启发了许多后来的游戏，比如 爆破彗星(Asteroids)</p></div>	
<div class='layout'><p>and even the first commercial arcade video game: Computer Space.</p><p>甚至第一个商业街机游戏：太空大战</p></div>	
<div class='layout'><p>1962 was also a huge milestone because of Sketchpad,</p><p>1962 年是一个大里程碑，Sketchpad 诞生</p></div>	
<div class='layout'><p>an interactive graphical interface</p><p>一个交互式图形界面，用途是计算机辅助设计 (CAD)</p></div>	
<div class='layout'><p>that offered Computer-Aided Design -called CAD Software today.</p><p>一个交互式图形界面，用途是计算机辅助设计 (CAD)</p></div>	
<div class='layout'><p>It's widely considered the earliest example of a complete graphical application.</p><p>它被广泛认为是第一个完整的图形程序</p></div>	
<div class='layout'><p>And its inventor, Ivan Sutherland, later won the Turing Award for this breakthrough.</p><p>发明人 伊万·萨瑟兰 后来因此获得图灵奖</p></div>	
<div class='layout'><p>To interact with graphics,</p><p>为了与图形界面交互，</p></div>	
<div class='layout'><p>Sketchpad used a recently invented input device called a light pen,</p><p>Sketchpad 用了当时发明不久的输入设备 光笔</p></div>	
<div class='layout'><p>which was a stylus tethered to a computer with a wire.</p><p>就是一个有线连着电脑的触控笔</p></div>	
<div class='layout'><p>By using a light sensor in the tip, the pen detected the refresh of the computer monitor.</p><p>笔尖用光线传感器，可以检测到显示器刷新</p></div>	
<div class='layout'><p>Using the timing of the refresh,</p><p>通过判断刷新时间，电脑可以知道笔的位置</p></div>	
<div class='layout'><p>the computer could actually figure out the pen's position on the screen!</p><p>通过判断刷新时间，电脑可以知道笔的位置</p></div>	
<div class='layout'><p>With this light pen, and various buttons on a gigantic computer,</p><p>有了光笔和各种按钮，</p></div>	
<div class='layout'><p>users could draw lines and other simple shapes.</p><p>用户可以画线和其他简单形状</p></div>	
<div class='layout'><p>Sketchpad could do things like make lines perfectly parallel, the same length, straighten</p><p>Sketchpad 可以让线条完美平行，长度相同，</p></div>	
<div class='layout'><p>corners into perfect 90 degree intersections, and even scale shapes up and down dynamically.</p><p>完美垂直90度，甚至动态缩放</p></div>	
<div class='layout'><p>These things that were laborious on paper, a computer now did with a press of a button!</p><p>这些在纸上很费力，在计算机上非常简单！</p></div>	
<div class='layout'><p>Users were also able to save complex designs they created,</p><p>用户还可以保存设计结果，</p></div>	
<div class='layout'><p>and then paste them into later designs, and even share with other people.</p><p>方便以后再次使用，甚至和其他人分享</p></div>	
<div class='layout'><p>You could have whole libraries of shapes, like electronic components and pieces of furniture</p><p>你可以有一整个库，里面有电子元件和家具之类的</p></div>	
<div class='layout'><p>that you could just plop in and manipulate in your creations.</p><p>可以直接拖进来用</p></div>	
<div class='layout'><p>This might all sound pretty routine from today's perspective.</p><p>从如今的角度来看 好像很普通</p></div>	
<div class='layout'><p>But in 1962, when computers were still cabinet-sized behemoths chugging through punch cards,</p><p>但在1962年，计算机还是吃纸带的大怪兽，有柜子般大小</p></div>	
<div class='layout'><p>Sketchpad and light pens were equal parts eye opening and brain melting.</p><p>Sketchpad 和光笔让人大开眼界</p></div>	
<div class='layout'><p>They represented a key turning point in how computers could be used.</p><p>它们代表了人机交互方式的关键转折点</p></div>	
<div class='layout'><p>They were no longer just number crunching math machines that hummed along behind closed doors.</p><p>电脑不再是关在门后 负责算数的机器了</p></div>	
<div class='layout'><p>Now, they were potential assistants, interactively augmenting human tasks.</p><p>可以当助手 帮人类做事</p></div>	
<div class='layout'><p>The earliest computers and displays with true pixel graphics emerged in the late 1960s.</p><p>最早用真正像素的计算机和显示器，出现于 1960 年代末</p></div>	
<div class='layout'><p>Bits in memory directly "mapped" to pixels on the screen,</p><p>内存中的位(Bit) 对应屏幕上的像素</p></div>	
<div class='layout'><p>what are called bitmapped displays.</p><p>这叫 位图显示</p></div>	
<div class='layout'><p>With full pixel control, totally arbitrary graphics were possible.</p><p>现在我们可以绘制任意图形了</p></div>	
<div class='layout'><p>You can think of a screen's graphics as a huge matrix of pixel values .</p><p>你可以把图形想成一个巨大像素值矩阵</p></div>	
<div class='layout'><p>As before,</p><p>就像之前</p></div>	
<div class='layout'><p>computers reserve a special region of memory for pixel data, called the frame buffer.</p><p>计算机把像素数据存在内存中一个特殊区域，叫"帧缓冲区"</p></div>	
<div class='layout'><p>In the early days, the computer's RAM was used,</p><p>早期时，这些数据存在内存里，</p></div>	
<div class='layout'><p>but later systems used special high speed Video RAM, or VRAM,</p><p>后来存在高速视频内存里，简称 VRAM</p></div>	
<div class='layout'><p>which was located on the graphics card itself for high speed access.</p><p>VRAM 在显卡上，这样访问更快，</p></div>	
<div class='layout'><p>This is how it's done today.</p><p>如今就是这样做的.</p></div>	
<div class='layout'><p>On an 8-bit grayscale screen, we can set values from 0 intensity, which is black,</p><p>在 8 位灰度屏幕上，我们可用的颜色范围是 0 强度（黑色）</p></div>	
<div class='layout'><p>to 255 intensity, which is white.</p><p>到 255 强度(白色)</p></div>	
<div class='layout'><p>Well actually, it might be green... or orange, as many early displays couldn't do white.</p><p>其实更像绿色或橙色，因为许多早期显示器不能显示白色</p></div>	
<div class='layout'><p>Let's pretend this video is a really low resolution bitmapped screen,</p><p>我们假设 这个视频在低分辨率的位图屏幕上</p></div>	
<div class='layout'><p>with a resolution of 60 by 35 pixels.</p><p>分辨率 60x35像素</p></div>	
<div class='layout'><p>If we wanted to set the pixel at 10 10 to be white,</p><p>如果我们想把 (10，10) 的像素设为白色，</p></div>	
<div class='layout'><p>we could do it with a piece of code like this.</p><p>可以用这样的代码</p></div>	
<div class='layout'><p>If we wanted to draw a line, let's say from 30, 0 to 30, 35, we can use a loop, like so.</p><p>如果想画一条线  假设从(30，0)到(30，35)，可以用这样一个循环</p></div>	
<div class='layout'><p>.And this changes a whole line of pixels to white.</p><p>把整列像素变成白色</p></div>	
<div class='layout'><p>If we want to draw something more complicated, let's say a rectangle,</p><p>如果想画更复杂的图形，比如矩形，</p></div>	
<div class='layout'><p>we need to know four values.</p><p>那么需要四个值</p></div>	
<div class='layout'><p>The X and Y coordinate of its starting corner, and its width and height.</p><p>1 起始点X坐标；2 起始点Y坐标；3 宽度；4 高度</p></div>	
<div class='layout'><p>So far, we've drawn everything in white, so let's specify this rectangle to be grey.</p><p>目前只试了白色，这次画矩形试下灰色</p></div>	
<div class='layout'><p>Grey is halfway between 0 and 255, so that's a color value of 127.</p><p>灰色介于0到255中间，所以我们用 127 (255/2=127.5)</p></div>	
<div class='layout'><p>Then, with two loops C one nested in the other,</p><p>然后用两个循环，一个套另一个</p></div>	
<div class='layout'><p>so that the inner loop runs once for every iteration of the outer loop,</p><p>这样外部每跑一次，内部会循环多次，可以画一个矩形</p></div>	
<div class='layout'><p>we can draw a rectangle.</p><p>这样外部每跑一次，内部会循环多次，可以画一个矩形</p></div>	
<div class='layout'><p>When the computer executes our code as part of its draw routine, it colors in all the</p><p>计算机绘图时会用</p></div>	
<div class='layout'><p>pixels we specified.</p><p>指定的颜色</p></div>	
<div class='layout'><p>Let's wrap this up into a "draw rectangle function", like this:</p><p>我们来包装成 "画矩形函数"，就像这样：</p></div>	
<div class='layout'><p>Now, to draw a second rectangle on the other side of the screen, maybe in black this time,</p><p>假设要在屏幕的另一边 画第二个矩形，这次可能是黑色矩形</p></div>	
<div class='layout'><p>we can just call our rectangle drawing function. Voila!!</p><p>可以直接调用 "画矩形函数"， 超棒！</p></div>	
<div class='layout'><p>Just like the other graphics schemes we've discussed,</p><p>就像之前说的其他方案</p></div>	
<div class='layout'><p>programs can manipulate pixel data in the frame buffer, creating interactive graphics.</p><p>程序可以操纵"帧缓冲区"中的像素数据，实现交互式图形</p></div>	
<div class='layout'><p>Pong time!</p><p>乒乓球时间！</p></div>	
<div class='layout'><p>Of course, programmers aren't wasting time writing drawing functions from scratch.</p><p>当然，程序员不会浪费时间从零写绘图函数，</p></div>	
<div class='layout'><p>They use graphics libraries with ready-to-go functions</p><p>而是用预先写好的函数来做，</p></div>	
<div class='layout'><p>for drawing lines, curves, shapes, text, and other cool stuff.</p><p>画直线，曲线，图形，文字等</p></div>	
<div class='layout'><p>Just a new level of abstraction!</p><p>一层新抽象！</p></div>	
<div class='layout'><p>The flexibility of bitmapped graphics opened up a whole new world of possibilities for</p><p>位图的灵活性，为交互式开启了全新可能，</p></div>	
<div class='layout'><p>interactive computing, but it remained expensive for decades.</p><p>但它的高昂成本持续了十几年</p></div>	
<div class='layout'><p>As I mentioned last episode, by as late as 1971,</p><p>上集提到，1971 年，</p></div>	
<div class='layout'><p>it was estimated there were around 70,000 electro-mechanical teletype machines</p><p>整个美国也只有大约 7 万个电传打字机</p></div>	
<div class='layout'><p>and 70,000 terminals in use, in the United States.</p><p>和 7 万个终端</p></div>	
<div class='layout'><p>Amazingly, there were only around 1,000 computers in the US that had interactive graphical screens.</p><p>令人惊讶的是，只有大约 1000 台电脑有交互式图形屏幕</p></div>	
<div class='layout'><p>That's not a lot!</p><p>这可不多！</p></div>	
<div class='layout'><p>But the stage was set helped along by pioneering efforts like Sketchpad and Space Wars</p><p>Sketchpad 和 太空大战 这样的先驱 ，推动了图形界面发展</p></div>	
<div class='layout'><p>for computer displays to become ubiquitous,</p><p>帮助普及了计算机显示器，</p></div>	
<div class='layout'><p>and with them, the dawn of graphical user interfaces,</p><p>由此，图形界面的曙光初现</p></div>	
<div class='layout'><p>which we'll cover in a few episodes!</p><p>接下来讲图形界面</p></div>	
<div class='layout'><p>I'll see you next week.</p><p>下周见</p></div>	
﻿
</div> <!--container-->
<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>
<a id="fPagea" href="index.html" target="_self"><div id="fPage" style="color:#fff;">上<br>一<br>章</div></a>
<a href="index.html" target="_self"><div id="menuPage" style="color:#fff;">目<br>录</div></a>
<a id="LPagea" href="javascript:void(null)" target="_self"><div id="lPage" style="color:#fff;">下<br>一<br>章</div></a>
<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
	//上一页、下一页按钮，需要文件名是数字
	var strUrl=window.location.href;
	var arrUrl=strUrl.split("/");
	var thispage=arrUrl[arrUrl.length-1];
	var thispage2=thispage.split(".");
	var thispage3=thispage2[thispage2.length-2];
	if(thispage3 == 0){
		var obj5=document.getElementById("fPage");
		obj5.style.display="none";
	}else{
		var fpage = thispage3 - 1;
		fpage = fpage +".html";
		document.getElementById("fPagea").href=fpage;
	}
	if(thispage3 == 100){
		var obj6=document.getElementById("lPage");
		obj6.style.display="none";
	}else{
		var fpage = parseInt(thispage3) + 1;
		fpage = fpage +".html";
		document.getElementById("LPagea").href=fpage;
	}
</script>
</div>
</body>
</html>
