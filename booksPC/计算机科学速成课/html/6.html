<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//谷歌浏览器  
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox等浏览器
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//谷歌浏览器  
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox等浏览器  
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
</script>
<script>
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:link，#container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:85.29%;
	line-height:1.6em;
	overflow:hidden;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}
#goTopBtn, #goBottom, #shangy, #xiay, #menuPage, #lPage, #fPage, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #menuPage, #lPage, #fPage, #ftsize1, #ftsize3{
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #lPage, #fPage, #ftsize, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#fPage{
	bottom: 236px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
	//writing-mode:tb-rl;
}
#menuPage{
	bottom: 198px;
	height:27px;
	white-space:nowrap;
	overflow:hidden;
}
#lPage{
	bottom: 145px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
}
#ftsize1{
	bottom:360px;
}
#ftsize2{
	bottom:334px;
}
#ftsize3{
	bottom:308px;
}
#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #menuPage:hover, #lPage:hover, #fPage:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #menuPage a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link, #menuPage a:visited, #lPage a:link, #fPage a:link, #lPage a:visited, #fPage a:visited {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
.code0, .code2, .code4{
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
.layout, .layout2{
    clear:both;
	width:95%;
	border:1px dotted #eee;
	margin:auto;
	margin-bottom:5px;
	overflow:hidden;
}
.layout2 .right, .layout2 .left, .layout p{
margin-bottom:-55px;
padding-bottom:55px;
text-align: justify;
margin:0;
padding:0;
margin-left:1%;
margin-right:1%;
}
.layout2 .left, .layout p{
float:left;
width:60%;
font-size:1.0em;
}
.layout2 .right,  .layout p+p {
	float: left;
	width:34%;
	border-left:1px dotted #cccccc;
	font-size:0.9em;
	padding-left:1%;
	
}
.layout2 .right p, .layout2 .left p, .layout p{
padding-bottom:5px;
}
h3{
text-indent:3%;
font-size:1em;
height:2.0em;
padding:0;
margin:0;
}
</style>
</head>
<body>
<div id="container">
﻿<div class='layout'><p>6 Registers and RAM</p><p>6 寄存器&内存</p></div>	
<div class='layout'><p>Hi, I'm Carrie Anne and welcome to Crash Course Computer Science.</p><p>嗨，我是CarrieAnne，欢迎收看计算机科学速成课</p></div>	
<div class='layout'><p>So last episode, using just logic gates, we built a simple ALU,</p><p>上集，我们用逻辑门做了个简单ALU</p></div>	
<div class='layout'><p>which performs arithmetic and logic operations, hence the 'A' and the 'L'.</p><p>它能执行算术<sup>(Arithmetic)</sup>和逻辑<sup>(Logic)</sup>运算，ALU里的A和L因此得名</p></div>	
<div class='layout'><p>But of course, there's not much point in calculating a result only to throw it away</p><p>当然，算出来之后如果扔掉就没什么意义了</p></div>	
<div class='layout'><p>it would be useful to store that value somehow,</p><p>得找个方法存起来</p></div>	
<div class='layout'><p>and maybe even run several operations in a row.</p><p>可能还要进行多个连续操作</p></div>	
<div class='layout'><p>That's where computer memory comes in!</p><p>这就用到计算机内存了</p></div>	
<div class='layout'><p>If you've ever been in the middle of a long RPG campaign on your console,</p><p>如果你在主机上打过一场长时间的对局</p></div>	
<div class='layout'><p>or slogging through a difficult level on Minesweeper on your desktop,</p><p>或玩困难模式的"扫雷"</p></div>	
<div class='layout'><p>and your dog came by, tripped and pulled the power cord out of the wall,</p><p>然后狗跑过来，被电源线绊倒，把插头拔了出来</p></div>	
<div class='layout'><p>you know the agony of losing all your progress.</p><p>你知道失去进度的痛苦</p></div>	
<div class='layout'><p>Condolences.</p><p>真同情你:<sup>(</p></div>	
<div class='layout'><p>But the reason for your loss is that your console, your laptop and your computers</p><p>你损失数据的原因是，</p></div>	
<div class='layout'><p>make use of Random Access Memory, or RAM,</p><p>电脑用的是"随机存取存储器"，简称"RAM"</p></div>	
<div class='layout'><p>which stores things like game state as long as the power stays on.</p><p>它只能在有电的情况下存储东西，比如游戏状态</p></div>	
<div class='layout'><p>Another type of memory, called persistent memory, can survive without power,</p><p>另一种存储<sup>(memory)</sup>叫持久存储，电源关闭时数据也不会丢失</p></div>	
<div class='layout'><p>and it's used for different things;</p><p>它用来存其他东西.</p></div>	
<div class='layout'><p>We'll talk about the persistence of memory in a later episode.</p><p>我们之后会讨论存储<sup>(memory)</sup>的持久性问题</p></div>	
<div class='layout'><p>Today, we're going to start small</p><p>今天我们从简单开始</p></div>	
<div class='layout'><p>literally by building a circuit that can store one.. single.. bit of information.</p><p>做只能存储1位的电路</p></div>	
<div class='layout'><p>After that, we'll scale up, and build our very own memory module,</p><p>之后再扩大，做出我们的内存模块</p></div>	
<div class='layout'><p>and we'll combine it with our ALU next time, when we finally build our very own CPU!</p><p>下次和ALU结合起来，做出CPU！</p></div>	
<div class='layout'><p>All of the logic circuits we've discussed so far go in one direction</p><p>我们至今说过的电路都是单向的</p></div>	
<div class='layout'><p>always flowing forward.</p><p>总是向前流动</p></div>	
<div class='layout'><p>like our 8-bit ripple adder from last episode.</p><p>比如上集的8位"脉动进位加法器"</p></div>	
<div class='layout'><p>But we can also create circuits that loop back on themselves.</p><p>但也可以做回向电路，把输出连回输入</p></div>	
<div class='layout'><p>Let's try taking an ordinary OR gate, and feed the output back into one of its inputs</p><p>我们拿一个OR门试试，把输出连回输入</p></div>	
<div class='layout'><p>and see what happens.</p><p>看看会发生什么</p></div>	
<div class='layout'><p>First, let's set both inputs to 0.</p><p>首先，两个输入都设为0</p></div>	
<div class='layout'><p>So 0 OR 0 is 0, and so this circuit always outputs 0.</p><p>0OR0是0，所以电路输出0</p></div>	
<div class='layout'><p>If we were to flip input A to 1.</p><p>如果将A变成1</p></div>	
<div class='layout'><p>1 OR 0 is 1, so now the output of the OR gate is 1.</p><p>1OR0为1，所以输出1</p></div>	
<div class='layout'><p>A fraction of a second later, that loops back around into input B,</p><p>一转眼的功夫，输出回到B</p></div>	
<div class='layout'><p>so the OR gate sees that both of its inputs are now 1.</p><p>OR门看到两个输入都是1</p></div>	
<div class='layout'><p>1 OR 1 is still 1, so there is no change in output.</p><p>1OR1仍然为1，所以输出不变</p></div>	
<div class='layout'><p>If we flip input A back to 0, the OR gate still outputs 1.</p><p>如果将A变成0，OR门依然输出1</p></div>	
<div class='layout'><p>So now we've got a circuit that records a "1" for us.</p><p>现在我们有个电路能记录"1"</p></div>	
<div class='layout'><p>Except, we've got a teensy tiny problem this change is permanent!</p><p>然而有个小问题：这是永久的！</p></div>	
<div class='layout'><p>No matter how hard we try, there's no way to get this circuit to flip back from a 1 to a 0.</p><p>无论怎么试，都没法从1变回0</p></div>	
<div class='layout'><p>Now let's look at this same circuit, but with an AND gate instead.</p><p>我们换成AND门看看会怎样</p></div>	
<div class='layout'><p>We'll start inputs A and B both at 1.</p><p>开始时，A和B都设1</p></div>	
<div class='layout'><p>1 AND 1 outputs 1 forever.</p><p>1AND1永远输出1</p></div>	
<div class='layout'><p>But, if we then flip input A to 0, because it's an AND gate, the output will go to 0.</p><p>如果之后A设为0，由于是AND门，输出会变成0</p></div>	
<div class='layout'><p>So this circuit records a 0, the opposite of our other circuit.</p><p>这个电路能记录0，和之前那个相反</p></div>	
<div class='layout'><p>Like before, no matter what input we apply to input A afterwards, the circuit will always output 0.</p><p>就像之前，无论A设什么值，电路始终输出0</p></div>	
<div class='layout'><p>Now we've got circuits that can record both 0s and 1s.</p><p>现在有了能存0和1的电路</p></div>	
<div class='layout'><p>The key to making this a useful piece of memory is to combine our two circuits into what is</p><p>为了做出有用的存储<sup>(memory)</sup>，我们把两个电路结合起来</p></div>	
<div class='layout'><p>called the AND-OR Latch.</p><p>这叫"AND-OR锁存器"</p></div>	
<div class='layout'><p>It has two inputs, a "set" input, which sets the output to a 1，called the AND-OR Latch.</p><p>它有两个输入，"设置"输入，把输出变成1，称为AND-OR锁存器。</p></div>	
<div class='layout'><p>and a "reset" input, which resets the output to a 0.</p><p>复位输入，把输出变成0</p></div>	
<div class='layout'><p>If set and reset are both 0, the circuit just outputs whatever was last put in it.</p><p>如果"设置"和"复位"都是0，电路会输出最后放入的内容</p></div>	
<div class='layout'><p>In other words, it remembers a single bit of information!</p><p>也就是说，它存住了1位的信息！</p></div>	
<div class='layout'><p>Memory!</p><p>存储！</p></div>	
<div class='layout'><p>This is called a "latch" because it "latches onto" a particular value and stays that way.</p><p>这叫"锁存"，因为它"锁定"了一个值</p></div>	
<div class='layout'><p>The action of putting data into memory is called writing, whereas getting the data out is called reading.</p><p>放入数据的动作叫"写入"，拿出数据的动作叫"读取"</p></div>	
<div class='layout'><p>Ok, so we've got a way to store a single bit of information!</p><p>现在我们终于有办法存一个位了！</p></div>	
<div class='layout'><p>Great!</p><p>超棒！</p></div>	
<div class='layout'><p>Unfortunately, having two different wires for input set and reset is a bit confusing.</p><p>麻烦的是，用两条线"设置"和"复位"来输入，有点难理解</p></div>	
<div class='layout'><p>To make this a little easier to use, we really want a single wire to input data,</p><p>为了更容易用，我们希望只有一条输入线</p></div>	
<div class='layout'><p>that we can set to either 0 or 1 to store the value.</p><p>将它设为0或1来存储值</p></div>	
<div class='layout'><p>Additionally, we are going to need a wire that enables the memory</p><p>还需要一根线来"启用"内存</p></div>	
<div class='layout'><p>to be either available for writing or "locked" down</p><p>启用时允许写入，没启用时就"锁定"</p></div>	
<div class='layout'><p>which is called the write enable line.</p><p>这条线叫"允许写入线"</p></div>	
<div class='layout'><p>By adding a few extra logic gates, we can build this circuit,</p><p>加一些额外逻辑门，可以做出这个电路</p></div>	
<div class='layout'><p>which is called a Gated Latch since the "gate" can be opened or closed.</p><p>这叫"门锁"，因为门可以打开和关上</p></div>	
<div class='layout'><p>Now this circuit is starting to get a little complicated.</p><p>现在有点复杂了</p></div>	
<div class='layout'><p>We don't want to have to deal with all the individual logic gates...</p><p>我们不想关心单独的逻辑门</p></div>	
<div class='layout'><p>so as before, we're going to bump up a level of abstraction,</p><p>所以我们提升一层抽象</p></div>	
<div class='layout'><p>and put our whole Gated Latch circuit in a box -a box that stores one bit.</p><p>把"门锁"放到盒子里这个盒子能存一个bit</p></div>	
<div class='layout'><p>Let's test out our new component!</p><p>我们来测一下新组件！</p></div>	
<div class='layout'><p>Let's start everything at 0.</p><p>一切从0开始</p></div>	
<div class='layout'><p>If we toggle the Data wire from 0 to 1 or 1 to 0,</p><p>数据输入从0换到1，从1换到0</p></div>	
<div class='layout'><p>nothing happens the output stays at 0.</p><p>什么也不会发生输出依然是0</p></div>	
<div class='layout'><p>That's because the write enable wire is off, which prevents any change to the memory.</p><p>因为"允许写入线"是关闭的，所以内容不会变化</p></div>	
<div class='layout'><p>So we need to "open" the "gate" by turning the write enable wire to 1.</p><p>所以要给"允许写入线"输入1，"打开"门</p></div>	
<div class='layout'><p>Now we can put a 1 on the data line to save the value 1 to our latch.</p><p>现在往"数据线"放1，1就能存起来了</p></div>	
<div class='layout'><p>Notice how the output is now 1.</p><p>注意输出现在是1了</p></div>	
<div class='layout'><p>Now we can put a 1 on the data line to save the value 1 to our latch.</p><p>现在我们可以在数据线上加一个1，将值1保存到锁存器中。</p></div>	
<div class='layout'><p>Success!</p><p>成功！</p></div>	
<div class='layout'><p>We can turn off the enable line and the output stays as 1.</p><p>现在可以关掉"允许写入线"，输出会保持1</p></div>	
<div class='layout'><p>Once again, we can toggle the value on the data line all we want,</p><p>现在不管给"数据线"什么值</p></div>	
<div class='layout'><p>but the output will stay the same.</p><p>输出都不会变</p></div>	
<div class='layout'><p>The value is saved in memory.</p><p>值存起来了</p></div>	
<div class='layout'><p>Now let's turn the enable line on again use our data line to set the latch to 0.</p><p>现在又打开"允许写入线"，"数据线"设为0</p></div>	
<div class='layout'><p>Done.</p><p>完成</p></div>	
<div class='layout'><p>Enable line off, and the output is 0.</p><p>允许写入线关闭，输出0</p></div>	
<div class='layout'><p>And it works!</p><p>成功了！</p></div>	
<div class='layout'><p>Now, of course, computer memory that only stores one bit of information isn't very useful</p><p>当然，只能存1bit没什么大用</p></div>	
<div class='layout'><p>definitely not enough to run Frogger.</p><p>肯定玩不了游戏</p></div>	
<div class='layout'><p>Or anything, really.</p><p>或做其它事情</p></div>	
<div class='layout'><p>But we're not limited to using only one latch.</p><p>但我们没限制只能用一个锁存器</p></div>	
<div class='layout'><p>If we put 8 latches side-by-side, we can store 8 bits of information like an 8-bit number.</p><p>如果我们并排放8个锁存器，可以存8位信息，比如一个8bit数字</p></div>	
<div class='layout'><p>A group of latches operating like this is called a register,</p><p>一组这样的锁存器叫"寄存器"</p></div>	
<div class='layout'><p>which holds a single number, and the number of bits in a register is called its width.</p><p>寄存器能存一个数字，这个数字有多少位，叫"位宽"</p></div>	
<div class='layout'><p>Early computers had 8-bit registers, then 16, 32,</p><p>早期电脑用8位寄存器，然后是16位，32位</p></div>	
<div class='layout'><p>and today, many computers have registers that are 64-bits wide.</p><p>如今许多计算机都有64位宽的寄存器</p></div>	
<div class='layout'><p>To write to our register, we first have to enable all of the latches.</p><p>写入寄存器前，要先启用里面所有锁存器</p></div>	
<div class='layout'><p>We can do this with a single wire that connects to all of their enable inputs, which we set to 1.</p><p>我们可以用一根线连接所有"允许输入线"，把它设为1</p></div>	
<div class='layout'><p>We then send our data in using the 8 data wires, and then set enable back to 0,</p><p>然后用8条数据线发数据，然后将"允许写入线"设回0</p></div>	
<div class='layout'><p>and the 8 bit value is now saved in memory.</p><p>现在8位的值就存起来了</p></div>	
<div class='layout'><p>Putting latches side-by-side works ok for a small-ish number of bits.</p><p>如果只有很少的位<sup>(bits)</sup>，把锁存器并排放置，也勉强够用了.</p></div>	
<div class='layout'><p>A 64-bit register would need 64 wires running to the data pins, and 64 wires running to the outputs.</p><p>64位寄存器要64根数据线，64根连到输出端</p></div>	
<div class='layout'><p>Luckily we only need 1 wire to enable all the latches, but that's still 129 wires.</p><p>幸运的是，我们只要1根线启用所有锁存器，但加起来也有129条线了</p></div>	
<div class='layout'><p>For 256 bits, we end up with 513 wires!</p><p>如果存256位要513条线！</p></div>	
<div class='layout'><p>The solution is a matrix!</p><p>解决方法是矩阵！</p></div>	
<div class='layout'><p>In this matrix, we don't arrange our latches in a row,</p><p>在矩阵中，我们不并列排放锁存器</p></div>	
<div class='layout'><p>we put them in a grid.</p><p>而是做成网格</p></div>	
<div class='layout'><p>For 256 bits, we need a 16 by 16 grid of latches with 16 rows and columns of wires.</p><p>存256位，我们用16x16网格的锁存器，有16行16列</p></div>	
<div class='layout'><p>To activate any one latch, we must turn on the corresponding row AND column wire.</p><p>要启用某个锁存器，就打开相应的行线和列线</p></div>	
<div class='layout'><p>Let's zoom in and see how this works.</p><p>放大看看怎么做的</p></div>	
<div class='layout'><p>We only want the latch at the intersection of the two active wires to be enabled,</p><p>我们只想打开交叉处锁存器的"允许写入线"</p></div>	
<div class='layout'><p>but all of the other latches should stay disabled.</p><p>所有其他锁存器，保持关闭</p></div>	
<div class='layout'><p>For this, we can use our trusty AND gate!</p><p>我们可以用AND门！</p></div>	
<div class='layout'><p>The AND gate will output a 1 only if the row and the column wires are both 1.</p><p>只有行线和列线均为1，AND门才输出1</p></div>	
<div class='layout'><p>So we can use this signal to uniquely select a single latch.</p><p>所以可以用选择单个锁存器</p></div>	
<div class='layout'><p>This row/column setup connects all our latches with a single, shared, write enable wire.</p><p>这种行/列排列法，用一根"允许写入线"连所有锁存器</p></div>	
<div class='layout'><p>In order for a latch to become write enabled,</p><p>为了让锁存器变成"允许写入"</p></div>	
<div class='layout'><p>the row wire, the column wire, and the write enable wire must all be 1.</p><p>行线，列线和"允许写入线"都必须是1</p></div>	
<div class='layout'><p>That should only ever be true for one single latch at any given time.</p><p>每次只有1个锁存器会这样</p></div>	
<div class='layout'><p>This means we can use a single, shared wire for data.</p><p>代表我们可以只用一根"数据线"，连所有锁存器来传数据</p></div>	
<div class='layout'><p>Because only one latch will ever be write enabled, only one will ever save the data</p><p>因为只有一个锁存器会启用，只有那个会存数据</p></div>	
<div class='layout'><p>the rest of the latches will simply ignore values on the data wire because they are not write enabled.</p><p>其他锁存器会忽略数据线上的值，因为没有"允许写入"</p></div>	
<div class='layout'><p>We can use the same trick with a read enable wire to read the data later,</p><p>我们可以用类似的技巧，做"允许读取线"来读数据</p></div>	
<div class='layout'><p>to get the data out of one specific latch.</p><p>从一个指定的锁存器，读取数据</p></div>	
<div class='layout'><p>This means in total, for 256 bits of memory,</p><p>所以对于256位的存储</p></div>	
<div class='layout'><p>we only need 35 wires 1 data wire, 1 write enable wire, 1 read enable wire,</p><p>只要35条线，1条"数据线"，1条"允许写入线"，1条"允许读取线"</p></div>	
<div class='layout'><p>and 16 rows and columns for the selection.</p><p>还有16行16列的线用于选择锁存器，（16+16=32，32+3=35）</p></div>	
<div class='layout'><p>That's significant wire savings!</p><p>这省了好多线！</p></div>	
<div class='layout'><p>But we need a way to uniquely specify each intersection.</p><p>但我们需要某种方法来唯一指定交叉路口</p></div>	
<div class='layout'><p>We can think of this like a city,</p><p>我们可以想成城市</p></div>	
<div class='layout'><p>where you might want to meet someone at 12th avenue and 8th street</p><p>你可能想和别人在第12大道和第8街的交界碰面</p></div>	
<div class='layout'><p>that's an address that defines an intersection.</p><p>这是一个交叉点的地址</p></div>	
<div class='layout'><p>The latch we just saved our one bit into has an address of row 12 and column 8.</p><p>我们刚刚存了一位的地址是"12行8列"</p></div>	
<div class='layout'><p>Since there is a maximum of 16 rows, we store the row address in a 4 bit number.</p><p>由于最多16行，用4位就够了</p></div>	
<div class='layout'><p>12 is 1100 in binary.</p><p>12用二进制表示为1100</p></div>	
<div class='layout'><p>We can do the same for the column address: 8 is 1000 in binary.</p><p>列地址也可以这样：8用二进制表示为1000</p></div>	
<div class='layout'><p>So the address for the particular latch we just used can be written as 11001000.</p><p>刚才说的"12行8列"可以写成11001000</p></div>	
<div class='layout'><p>To convert from an address into something that selects the right row or column,</p><p>为了将地址转成行和列</p></div>	
<div class='layout'><p>we need a special component called a multiplexer</p><p>我们需要"多路复用器"</p></div>	
<div class='layout'><p>which is the computer component with a pretty cool name at least compared to the ALU.</p><p>这个名字起码比ALU酷一点</p></div>	
<div class='layout'><p>Multiplexers come in all different sizes,</p><p>多路复用器有不同大小</p></div>	
<div class='layout'><p>but because we have 16 rows, we need a 1 to 16 multiplexer.</p><p>因为有16行，我们需要1到16多路复用器</p></div>	
<div class='layout'><p>It works like this.</p><p>工作方式是</p></div>	
<div class='layout'><p>You feed it a 4 bit number, and it connects the input line to a corresponding output line.</p><p>输入一个4位数字，它会把那根线，连到相应的输出线</p></div>	
<div class='layout'><p>So if we pass in 0000, it will select the very first column for us.</p><p>如果输入0000，它会选择第一列</p></div>	
<div class='layout'><p>If we pass in 0001, the next column is selected, and so on.</p><p>如果输入0001，会选择下一列，依此类推</p></div>	
<div class='layout'><p>We need one multiplexer to handle our rows and another multiplexer to handle the columns.</p><p>一个多路复用器处理行<sup>(row)</sup>，另一个多路复用器处理列<sup>(column)</sup></p></div>	
<div class='layout'><p>Ok, it's starting to get complicated again,</p><p>好吧，开始有点复杂了</p></div>	
<div class='layout'><p>so let's make our 256-bit memory its own component.</p><p>那么把256位内存当成一个整体好了</p></div>	
<div class='layout'><p>Once again a new level of abstraction!</p><p>又提升了一层抽象！</p></div>	
<div class='layout'><p>It takes an 8-bit address for input the 4 bits for the column and 4 for the row.</p><p>它输入一个8位地址：4位代表列，4位代表行</p></div>	
<div class='layout'><p>We also need write and read enable wires.</p><p>我们还需要"允许写入线"和"允许读取线"</p></div>	
<div class='layout'><p>And finally, we need just one data wire, which can be used to read or write data.</p><p>最后，还需要一条数据线，用于读/写数据</p></div>	
<div class='layout'><p>Unfortunately, even 256-bits of memory isn't enough to run much of anything,</p><p>不幸的是，256位的内存也没法做什么事</p></div>	
<div class='layout'><p>so we need to scale up even more!</p><p>所以还要扩大规模</p></div>	
<div class='layout'><p>We're going to put them in a row.</p><p>把它们并排放置</p></div>	
<div class='layout'><p>Just like with the registers.</p><p>就像寄存器一样</p></div>	
<div class='layout'><p>We'll make a row of 8 of them, so we can store an 8 bit number also known as a byte.</p><p>一行8个，可以存一个8位数字，8位也叫一个字节（byte）</p></div>	
<div class='layout'><p>To do this, we feed the exact same address into all 8 of our 256-bit memory components at the same time,</p><p>为了存一个8位数字，我们同时给8个256位内存一样的地址</p></div>	
<div class='layout'><p>and each one saves one bit of the number.</p><p>每个地址存1位</p></div>	
<div class='layout'><p>That means the component we just made can store 256 bytes at 256 different addresses.</p><p>意味着这里总共能存256个字节（byte）</p></div>	
<div class='layout'><p>Again, to keep things simple, we want to leave behind this inner complexity.</p><p>再次，为了简单，我们不管内部</p></div>	
<div class='layout'><p>Instead of thinking of this as a series of individual memory modules and circuits,</p><p>不看作是一堆独立的存储模块和电路</p></div>	
<div class='layout'><p>we'll think of it as a uniform bank of addressable memory.</p><p>而是看成一个整体的可寻址内存</p></div>	
<div class='layout'><p>We have 256 addresses,</p><p>我们有256个地址</p></div>	
<div class='layout'><p>and at each address, we can read or write an 8-bit value.</p><p>每个地址能读或写一个8位值</p></div>	
<div class='layout'><p>We're going to use this memory component next episode when we build our CPU.</p><p>我们下集做CPU时会用到这个内存</p></div>	
<div class='layout'><p>The way that modern computers scale to megabytes and gigabytes of memory</p><p>现代计算机的内存，扩展到上兆字节（MB）和千兆字节（GB）的方式</p></div>	
<div class='layout'><p>is by doing the same thing we've been doing here</p><p>和我们这里做的一样</p></div>	
<div class='layout'><p>keep packaging up little bundles of memory into larger, and larger, and larger arrangements.</p><p>不断把内存打包到更大规模</p></div>	
<div class='layout'><p>As the number of memory locations grow, our addresses have to grow as well.</p><p>随着内存地址增多，内存地址也必须增长</p></div>	
<div class='layout'><p>8 bits hold enough numbers to provide addresses for 256 bytes of our memory,</p><p>8位最多能代表256个内存地址，（11111111是255，0~255一共256个数字）</p></div>	
<div class='layout'><p>but that's all.</p><p>只有这么多</p></div>	
<div class='layout'><p>To address a gigabyte or a billion bytes of memory we need 32-bit addresses.</p><p>要给千兆或十亿字节的内存寻址，需要32位的地址</p></div>	
<div class='layout'><p>An important property of this memory is that we can access any memory location, at any time, and in a random order.</p><p>内存的一个重要特性是：可以随时访问任何位置</p></div>	
<div class='layout'><p>For this reason, it's called Random-Access Memory or RAM.</p><p>因此叫"随机存取存储器"，简称RAM</p></div>	
<div class='layout'><p>When you hear people talking about how much RAM a computer has</p><p>当你听到有人说RAM有多大</p></div>	
<div class='layout'><p>that's the computer's memory.</p><p>他的意思是内存有多大</p></div>	
<div class='layout'><p>RAM is like a human's short term or working memory,</p><p>RAM就像人类的短期记忆</p></div>	
<div class='layout'><p>where you keep track of things going on right now</p><p>记录当前在做什么事</p></div>	
<div class='layout'><p>like whether or not you had lunch or paid your phone bill.</p><p>比如吃了午饭没，或有没有交电话费</p></div>	
<div class='layout'><p>Here's an actual stick of RAM with 8 memory modules soldered onto the board.</p><p>这是一条真的内存，上面焊了8个内存模块</p></div>	
<div class='layout'><p>If we carefully opened up one of these modules and zoomed in,</p><p>如果打开其中一个，然后放大</p></div>	
<div class='layout'><p>The first thing you would see are 32 squares of memory.</p><p>会看到32个内存方块</p></div>	
<div class='layout'><p>Zoom into one of those squares, and we can see each one is comprised of 4 smaller blocks.</p><p>放大其中一个方块，可以看到有4个小块</p></div>	
<div class='layout'><p>If we zoom in again, we get down to the matrix of individual bits.</p><p>如果再放大，可以看到存一个"位"的矩阵</p></div>	
<div class='layout'><p>This is a matrix of 128 by 64 bits.</p><p>这个矩阵是128位x64位</p></div>	
<div class='layout'><p>That's 8192 bits in total.</p><p>总共8192位</p></div>	
<div class='layout'><p>Each of our 32 squares has 4 matrices, so that's 32 thousand, 7 hundred and 68 bits.</p><p>每个方格4个矩阵，所以一个方格有32768个位（8192x4=32768）</p></div>	
<div class='layout'><p>And there are 32 squares in total.</p><p>而一共32个方格</p></div>	
<div class='layout'><p>So all in all, that's roughly 1 million bits of memory in each chip.</p><p>总而言之，1个芯片大约存100万位</p></div>	
<div class='layout'><p>Our RAM stick has 8 of these chips, so in total, this RAM can store 8 millions bits,</p><p>RAM有8个芯片，所以总共800万位</p></div>	
<div class='layout'><p>otherwise known as 1 megabyte.</p><p>也就是1兆字节（1MB）</p></div>	
<div class='layout'><p>That's not a lot of memory these days -this is a RAM module from the 1980's.</p><p>1MB如今不算大这是1980年代的RAM</p></div>	
<div class='layout'><p>Today you can buy RAM that has a gigabyte or more of memory</p><p>如今你可以买到千兆字节（GB）的RAM</p></div>	
<div class='layout'><p>that's billions of bytes of memory.</p><p>那可是数十亿字节的内存</p></div>	
<div class='layout'><p>So, today, we built a piece of SRAM Static Random-Access Memory which uses latches.</p><p>今天，我们用锁存器做了一块SRAM（静态随机存取存储器）</p></div>	
<div class='layout'><p>There are other types of RAM, such as DRAM, Flash memory, and NVRAM.</p><p>还有其他类型的RAM，如DRAM，闪存和NVRAM</p></div>	
<div class='layout'><p>These are very similar in function to SRAM,</p><p>它们在功能上与SRAM相似</p></div>	
<div class='layout'><p>but use different circuits to store the individual bits</p><p>但用不同的电路存单个位</p></div>	
<div class='layout'><p>for example, using different logic gates, capacitors, charge traps, or memristors.</p><p>比如用不同的逻辑门，电容器，电荷捕获或忆阻器</p></div>	
<div class='layout'><p>But fundamentally, all of these technologies store bits of information</p><p>但根本上这些技术都是矩阵层层嵌套，</p></div>	
<div class='layout'><p>in massively nested matrices of memory cells.</p><p>来存储大量信息</p></div>	
<div class='layout'><p>Like many things in computing, the fundamental operation is relatively simple.</p><p>就像计算机中的很多事情，底层其实都很简单</p></div>	
<div class='layout'><p>it's the layers and layers of abstraction that's mind blowing</p><p>让人难以理解的，是一层层精妙的抽象</p></div>	
<div class='layout'><p>like a russian doll that keeps getting smaller and smaller and smaller.</p><p>像一个越来越小的俄罗斯套娃</p></div>	
<div class='layout'><p>I'll see you next week.</p><p>下周见</p></div>	
﻿
</div> <!--container-->
<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>
<a id="fPagea" href="index.html" target="_self"><div id="fPage" style="color:#fff;">上<br>一<br>章</div></a>
<a href="index.html" target="_self"><div id="menuPage" style="color:#fff;">目<br>录</div></a>
<a id="LPagea" href="javascript:void(null)" target="_self"><div id="lPage" style="color:#fff;">下<br>一<br>章</div></a>
<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
	//上一页、下一页按钮，需要文件名是数字
	var strUrl=window.location.href;
	var arrUrl=strUrl.split("/");
	var thispage=arrUrl[arrUrl.length-1];
	var thispage2=thispage.split(".");
	var thispage3=thispage2[thispage2.length-2];
	if(thispage3 == 0){
		var obj5=document.getElementById("fPage");
		obj5.style.display="none";
	}else{
		var fpage = thispage3 - 1;
		fpage = fpage +".html";
		document.getElementById("fPagea").href=fpage;
	}
	if(thispage3 == 100){
		var obj6=document.getElementById("lPage");
		obj6.style.display="none";
	}else{
		var fpage = parseInt(thispage3) + 1;
		fpage = fpage +".html";
		document.getElementById("LPagea").href=fpage;
	}
</script>
</div>
</body>
</html>
