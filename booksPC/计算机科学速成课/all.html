<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//chrome
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop 
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//chrome
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//chrome
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
</script>
<script>
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:65.29%;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h3{
	font-size:1.1em;
	font-weight:bold;
	text-indent:0em;
	color:#990000;
}
h4{
	font-size:1.0em;
	font-weight:bold;
	text-indent:0em;
}

#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}

#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:120%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	padding:8px;
	margin-left:2em;
	color:blue;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style>
</head>

<body>

<div id="container">





<h3>计算机科学速成课</h3>

<p>1 计算机早期历史</p>
<p>Early Computing</p>
<p>Hello world, I'm Carrie Anne, and welcome to Crash Course Computer Science!</p>
<p>Hello world！我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>Over the course of this series, we're going to go from bits, bytes, transistors and logic gates,</p>
<p>在这个系列中，我们会学习 Bits(位)，Bytes(字节)，晶体管, 逻辑门，</p>
<p>all the way to Operating Systems, Virtual Reality and Robots!</p>
<p>一直到操作系统，虚拟现实和机器人!</p>
<p>We're going to cover a lot, but just to clear things up</p>
<p>我们要学很多东西，但预先说明</p>
<p>we ARE NOT going to teach you how to program.</p>
<p>我们 *不会* 教你怎么编程</p>
<p>Instead, we're going to explore a range of computing topics as a discipline and a technology.</p>
<p>我们会从高层次上纵览一系列计算机话题</p>
<p>Computers are the lifeblood of today's world.</p>
<p>计算机是当今世界的命脉</p>
<p>If they were to suddenly turn off, all at once,</p>
<p>如果突然关掉所有的计算机</p>
<p>the power grid would shut down, cars would crash, planes would fall,</p>
<p>电网会关闭，车辆会相撞，飞机会坠毁</p>
<p>water treatment plants would stop, stock markets would freeze,</p>
<p>净水厂会关闭，证券市场会停止运作</p>
<p>trucks with food wouldn't know where to deliver, and employees wouldn't get paid.</p>
<p>装满食物的卡车不知运往何方，员工得不到薪水</p>
<p>Even many non-computer objects -like DFTBA shirts and the chair I'm sitting on-</p>
<p>甚至很多和计算机无关的东西，例如 DFTBA 的 T 恤和我现在坐的椅子</p>
<p>are made in factories run by computers.</p>
<p>也都是在计算机管理的工厂中制造的</p>
<p>Computing really has transformed nearly every aspect of our lives.</p>
<p>计算机改变了我们生活中几乎所有方面</p>
<p>And this isn't the first time we've seen this sort of technology-driven global change.</p>
<p>我们也不是第一次遇到推动全球发展的科技了</p>
<p>Advances in manufacturing during the Industrial Revolution</p>
<p>工业革命中生产能力的提高</p>
<p>brought a new scale to human civilization in agriculture, industry and domestic life.</p>
<p>大幅提升了农业，工业，畜牧业的规模</p>
<p>Mechanization meant superior harvests and more food, mass produced goods,</p>
<p>机械化导致更好的收成，更多的食物，商品可以大批量生产</p>
<p>cheaper and faster travel and communication, and usually a better quality of life.</p>
<p>旅行和通讯变得更便宜更快，生活质量变得更好.</p>
<p>And computing technology is doing the same right now</p>
<p>计算机和工业革命有一样的影响</p>
<p>from automated farming and medical equipment,</p>
<p>从自动化农业和医疗设备</p>
<p>to global telecommunications and educational opportunities,</p>
<p>到全球通信和教育机会</p>
<p>and new frontiers like Virtual Reality and Self Driving Cars.</p>
<p>还有虚拟现实和 无人驾驶汽车等新领域</p>
<p>We are living in a time likely to be remembered as the Electronic Age.</p>
<p>现在这个时代很可能会被后人总结成 "信息时代"</p>
<p>And with billions of transistors in just your smartphones, computers can seem pretty complicated,</p>
<p>你的智能手机中有数十亿个晶体管，看起来好像很复杂</p>
<p>but really, they're just simple machines</p>
<p>但实际上它是很简单的机器</p>
<p>that perform complex actions through many layers of abstraction.</p>
<p>通过一层层的抽象来做出复杂操作</p>
<p>So in this series, we're going break down those layers,</p>
<p>在这个系列中，我们会一层层讲解，</p>
<p>and build up from simple 1's and 0's, to logic units, CPUs,</p>
<p>从最底层的1和0，到逻辑门，CPU</p>
<p>operating systems, the entire internet and beyond.</p>
<p>操作系统，整个互联网，以及更多~~</p>
<p>And don't worry, in the same way someone buying t-shirts on a webpage</p>
<p>不用担心，正如在网上买T恤的人不用知道网站代码是怎么写的</p>
<p>doesn't need to know how that webpage was programmed,</p>
<p>不用担心，正如在网上买T恤的人不用知道网站代码是怎么写的</p>
<p>or the web designer doesn't need to know how all the packets are routed,</p>
<p>设计师不用知道数据包是怎么传输的</p>
<p>or router engineers don't need to know about transistor logic,</p>
<p>设计路由器的工程师不用理解晶体管的逻辑</p>
<p>this series will build on previous episodes but not be dependent on them.</p>
<p>本系列中每个视频会接着上集继续讲，但并不依赖前面的视频</p>
<p>By the end of this series,</p>
<p>等这个系列结束后</p>
<p>I hope that you can better contextualize computing's role both in your own life and society,</p>
<p>希望你能了解计算机在你的人生以及社会中扮演什么角色</p>
<p>and how humanity's (arguably) greatest invention is just in its infancy,</p>
<p>以及这个人类史上最伟大的发明（可以这样说啦）是怎么开始的，</p>
<p>with its biggest impacts yet to come.</p>
<p>它对未来还会有更大的影响</p>
<p>But before we get into all that, we should start at computing's origins,</p>
<p>但深入之前，我们应该从计算的起源讲起,</p>
<p>because although electronic computers are relatively new, the need for computation is not.</p>
<p>虽然电子计算机才出现不久，但人类对计算的需求早就有了</p>
<p>The earliest recognized device for computing was the abacus,</p>
<p>公认最早的计算设备是算盘</p>
<p>invented in Mesopotamia around 2500 BCE.</p>
<p>发明于"美索不达米亚"，大约公元前 2500 年</p>
<p>It's essentially a hand operated calculator,</p>
<p>它是手动计算器，</p>
<p>that helps add and subtract many numbers.</p>
<p>用来帮助加减数字</p>
<p>It also stores the current state of the computation, much like your hard drive does today.</p>
<p>它存储着当前的计算状态，类似于如今的硬盘</p>
<p>The abacus was created because,</p>
<p>人们制造算盘是因为</p>
<p>the scale of society had become greater than</p>
<p>社会的规模已经超出个人心算的能力</p>
<p>what a single person could keep and manipulate in their mind.</p>
<p>社会的规模已经超出个人心算的能力</p>
<p>There might be thousands of people in a village or tens of thousands of cattle.</p>
<p>一个村庄可能有上千个人和上万头牛</p>
<p>There are many variants of the abacus,</p>
<p>算盘有很多变种</p>
<p>but let's look at a really basic version with each row representing a different power of ten.</p>
<p>但我们来看一个基础版，每行代表 10 的不同次方</p>
<p>So each bead on the bottom row represents a single unit,</p>
<p>最底下那行，一个珠子代表 10 的 0 次方，也就是 1，</p>
<p>in the next row they represent 10, the row above 100, and so on.</p>
<p>再上面一行是 10 的 1 次方（也就是 10），再上面一行是 10 的 2 次方 （以此类推）</p>
<p>Let's say we have 3 heads of cattle represented by 3 beads on the bottom row on the right side.</p>
<p>假设最底部的 3 颗珠子，代表 3 头牛</p>
<p>If we were to buy 4 more cattle we would just slide 4 more beads to the right for a total of 7.</p>
<p>假设再买 4 头牛，只需要向右移动 4 颗珠子，共 7 个珠子</p>
<p>But if we were to add 5 more after the first 3 we would run out of beads,</p>
<p>但如果再买 5 头，珠子就不够用了</p>
<p>so we would slide everything back to the left,</p>
<p>所以把所有珠子移回左边</p>
<p>slide one bead on the second row to the right, representing ten,</p>
<p>在第二排把 1 颗珠子向右移动，代表 10</p>
<p>and then add the final 2 beads on the bottom row for a total of 12.</p>
<p>然后最底下那行，向右移动 2 颗珠子，代表 12</p>
<p>This is particularly useful with large numbers.</p>
<p>这种方法处理大数字很有效</p>
<p>So if we were to add 1,251</p>
<p>假设要表示 1251</p>
<p>we would just add 1 to the bottom row, 5 to the second row, 2 to the third row, and 1 to the fourth row</p>
<p>从下往上：，第一行移 1 个，第二行移 5 个，第三行移 2 个，第四行移 1 个</p>
<p>we don't have to add in our head and the abacus stores the total for us.</p>
<p>我们不用记在脑子里，算盘会记住.</p>
<p>Over the next 4000 years, humans developed all sorts of clever computing devices,</p>
<p>在接下来 4000 年，人类发明了各种巧妙的计算设备</p>
<p>like the astrolabe, which enabled ships to calculate their latitude at sea.</p>
<p>比如星盘，让船只可以在海上计算纬度</p>
<p>Or the slide rule, for assisting with multiplication and division.</p>
<p>或计算尺，帮助计算乘法和除法</p>
<p>And there are literally hundred of types of clocks created</p>
<p>人们还创造了上百种时钟</p>
<p>that could be used to calculate sunrise, tides, positions of celestial bodies, and even just the time.</p>
<p>算日出，潮汐，天体的位置，或纯粹拿来计时</p>
<p>Each one of these devices made something that was previously laborious to calculate much faster,</p>
<p>这些设备让原先很费力的事变得更快，</p>
<p>easier, and often more accurate</p>
<p>更简单，更精确</p>
<p>it lowered the barrier to entry,</p>
<p>降低了门槛</p>
<p>and at the same time, amplified our mental abilities -</p>
<p>加强了我们的能力</p>
<p>take note, this is a theme we're going to touch on a lot in this series.</p>
<p>记笔记!（敲黑板）这个系列会多次提到这一点</p>
<p>As early computer pioneer Charles Babbage said:</p>
<p>计算机先驱 Charles Babbage 说过：</p>
<p>"At each increase of knowledge, as well as on the contrivance of every new tool,</p>
<p>"随着知识的增长和新工具的诞生，人工劳力会越来越少"</p>
<p>human labour becomes abridged."</p>
<p>"随着知识的增长和新工具的诞生，人工劳力会越来越少"</p>
<p>However, none of these devices were called "computers".</p>
<p>然而，这些设备那时都不叫 "计算机"</p>
<p>The earliest documented use of the word "computer" is from 1613, in a book by Richard Braithwait.</p>
<p>最早使用 "计算机" 一词的文献，来自 1613 年的一本书，作者 Richard Braithwait</p>
<p>And it wasn't a machine at all it was a job title.</p>
<p>然而指的不是机器，而是一种职业</p>
<p>Braithwait said,</p>
<p>Braithwait 说：</p>
<p>"I have read the truest computer of times,</p>
<p>"我听说过的计算者里最厉害的，能把好几天的工作量大大缩减"</p>
<p>and the best arithmetician that ever breathed, and he reduceth thy dayes into a short number".</p>
<p>"我听说过的计算者里最厉害的，能把好几天的工作量大大缩减"</p>
<p>In those days, computer was a person who did calculations,</p>
<p>那时, "Computer" 指负责计算的人</p>
<p>sometimes with the help of machines, but often not.</p>
<p>"Computer" 偶尔会用机器帮忙，但大部分时候靠自己</p>
<p>This job title persisted until the late 1800s,</p>
<p>这个职位一直到 1800 年代还存在</p>
<p>when the meaning of computer started shifting to refer to devices.</p>
<p>之后 "Computer" 逐渐开始代表机器</p>
<p>Notable among these devices was the Step Reckoner,</p>
<p>其中"步进计算器"最有名</p>
<p>built by German polymath Gottfried Leibniz in 1694.</p>
<p>由德国博学家戈特弗里德·莱布尼茨建造于 1694 年</p>
<p>Leibniz said "... it is beneath the dignity of excellent men to waste their time in calculation</p>
<p>莱布尼茨说过 "... 让优秀的人浪费时间算数简直侮辱尊严</p>
<p>when any peasant could do the work just as accurately with the aid of a machine."</p>
<p>农民用机器能算得一样准"</p>
<p>It worked kind of like the odometer in your car,</p>
<p>"步进计算器"有点像汽车里的里程表，不断累加里程数</p>
<p>which is really just a machine for adding up the number of miles your car has driven.</p>
<p>"步进计算器"有点像汽车里的里程表，不断累加里程数</p>
<p>The device had a series of gears that turned;</p>
<p>它有一连串可以转动的齿轮</p>
<p>each gear had ten teeth, to represent the digits from 0 to 9.</p>
<p>每个齿轮有十个齿，代表数字0到9</p>
<p>Whenever a gear bypassed nine, it rotated back to 0 and advanced the adjacent gear by one tooth.</p>
<p>每当一个齿轮转过 9，它会转回 0，同时让旁边的齿轮前进 1 个齿</p>
<p>Kind of like when hitting 10 on that basic abacus.</p>
<p>就像算盘超过 10 一样.</p>
<p>This worked in reverse when doing subtraction, too.</p>
<p>做减法时，机器会反向运作.</p>
<p>With some clever mechanical tricks,</p>
<p>利用一些巧妙的机械结构</p>
<p>the Step Reckoner was also able to multiply and divide numbers.</p>
<p>步进计算器也能做乘法和除法</p>
<p>Multiplications and divisions are really just many additions and subtractions.</p>
<p>乘法和除法实际上只是多个加法和减法</p>
<p>For example, if we want to divide 17 by 5, we just subtract 5, then 5, then 5 again,</p>
<p>举例，17除以5，我们只要减5，减5，再减5</p>
<p>and then we can't subtract any more 5's… so we know 5 goes into 17 three times, with 2 left over.</p>
<p>直到不能再减 5，就知道了 17=5x3+2</p>
<p>The Step Reckoner was able to do this in an automated way,</p>
<p>步进计算器可以自动完成这种操作</p>
<p>and was the first machine that could do all four of these operations.</p>
<p>它是第一台能做"加减乘除"全部四种运算的机器</p>
<p>And this design was so successful it was used for the next three centuries of calculator design.</p>
<p>它的设计非常成功，以至于沿用了 3 个世纪.</p>
<p>Unfortunately, even with mechanical calculators,</p>
<p>不幸的是，即使有机械计算器</p>
<p>most real world problems required many steps of computation before an answer was determined.</p>
<p>许多现实问题依然需要很多步</p>
<p>It could take hours or days to generate a single result.</p>
<p>算一个结果可能要几小时甚至几天</p>
<p>Also, these hand-crafted machines were expensive, and not accessible to most of the population.</p>
<p>而且这些手工制作的机器非常昂贵，大部分人买不起</p>
<p>So, before 20th century,</p>
<p>所以在 20 世纪以前</p>
<p>most people experienced computing through pre-computed tables</p>
<p>大部分人会用预先算好的计算表</p>
<p>assembled by those amazing "human computers" we talked about.</p>
<p>这些计算表由之前说的 "人力计算器" 编撰</p>
<p>So if you needed to know the square root of 8 million 6 hundred and 75 thousand 3 hundred and 9,</p>
<p>如果你想知道 867,5309 的平方根</p>
<p>instead of spending all day hand-cranking your step reckoner,</p>
<p>与其花一整天来手摇 "步进计算器"</p>
<p>you could look it up in a huge book full of square root tables in a minute or so.</p>
<p>你可以花一分钟在表里找答案</p>
<p>Speed and accuracy is particularly important on the battlefield,</p>
<p>速度和准确性在战场上尤为重要</p>
<p>and so militaries were among the first to apply computing to complex problems.</p>
<p>因此军队很早就开始用计算解决复杂问题</p>
<p>A particularly difficult problem is accurately firing artillery shells,</p>
<p>如何精确瞄准炮弹是一个很难的问题</p>
<p>which by the 1800s could travel well over a kilometer (or a bit more than half a mile).</p>
<p>19世纪，这些炮弹的射程可以达到 1 公里以上（比半英里多一点）</p>
<p>Add to this varying wind conditions, temperature, and atmospheric pressure,</p>
<p>因为风力，温度，大气压力会不断变化</p>
<p>and even hitting something as large as a ship was difficult.</p>
<p>想打中船一样大的物体也非常困难</p>
<p>Range Tables were created that allowed gunners to look up environmental conditions</p>
<p>于是出现了射程表，炮手可以查环境条件和射击距离</p>
<p>and the distance they wanted to fire,</p>
<p>于是出现了射程表，炮手可以查环境条件和射击距离</p>
<p>and the table would tell them the angle to set the canon.</p>
<p>然后这张表会告诉他们，角度要设成多少</p>
<p>These Range Tables worked so well, they were used well into World War Two.</p>
<p>这些射程表很管用，二战中被广泛应用</p>
<p>The problem was, if you changed the design of the cannon or of the shell,</p>
<p>问题是如果改了大炮或炮弹的设计，就要算一张新表</p>
<p>a whole new table had to be computed,</p>
<p>问题是如果改了大炮或炮弹的设计，就要算一张新表</p>
<p>which was massively time consuming and inevitably led to errors.</p>
<p>这样很耗时而且会出错</p>
<p>Charles Babbage acknowledged this problem in 1822</p>
<p>Charles Babbage 在 1822 年写了一篇论文</p>
<p>in a paper to the Royal Astronomical Society entitled:</p>
<p>向皇家天文学会指出了这个问题</p>
<p>"Note on the application of machinery to the computation of astronomical and mathematical tables".</p>
<p>标题叫： "机械在天文与计算表中的应用"</p>
<p>Let's go to the thought bubble.</p>
<p>让我们进入思想泡泡</p>
<p>Charles Babbage proposed a new mechanical device called the Difference Engine,</p>
<p>Charles Babbage 提出了一种新型机械装置叫 "差分机"</p>
<p>a much more complex machine that could approximate polynomials.</p>
<p>一个更复杂的机器，能近似多项式.</p>
<p>Polynomials describe the relationship between several variables</p>
<p>多项式描述了几个变量之间的关系</p>
<p>like range and air pressure, or amount of pizza Carrie Anne eats and happiness.</p>
<p>比如射程和大气压力，或者 Carrie Anne 要吃多少披萨才开心</p>
<p>Polynomials could also be used to approximate logarithmic and trigonometric functions,</p>
<p>多项式也可以用于近似对数和三角函数</p>
<p>which are a real hassle to calculate by hand.</p>
<p>这些函数手算相当麻烦</p>
<p>Babbage started construction in 1823,</p>
<p>Charles Babbage 在 1823 年开始建造差分机</p>
<p>and over the next two decades, tried to fabricate and assemble the 25,000 components,</p>
<p>并在接下来二十年，试图制造和组装 25,000 个零件</p>
<p>collectively weighing around 15 tons.</p>
<p>总重接近 15 吨</p>
<p>Unfortunately, the project was ultimately abandoned.</p>
<p>不幸的是，该项目最终放弃了</p>
<p>But, in 1991,</p>
<p>但在 1991 年</p>
<p>historians finished constructing a Difference Engine based on Babbage's drawings and writings</p>
<p>历史学家根据 Charles Babbage 的草稿做了一个差分机</p>
<p>and it worked!</p>
<p>而且它还管用！</p>
<p>But more importantly, during construction of the Difference Engine,</p>
<p>但更重要的是，在差分机的建造期间</p>
<p>Babbage imagined an even more complex machine the Analytical Engine.</p>
<p>Charles Babbage 构想了一个更复杂的机器分析机</p>
<p>Unlike the Difference Engine,</p>
<p>不像差分机，步进计算器和以前的其他计算设备</p>
<p>Step Reckoner and all other computational devices before it</p>
<p>不像差分机，步进计算器和以前的其他计算设备</p>
<p>the Analytical Engine was a "general purpose computer".</p>
<p>分析机是 "通用计算机"</p>
<p>It could be used for many things, not just one particular computation;</p>
<p>它可以做很多事情，不只是一种特定运算</p>
<p>it could be given data and run operations in sequence;</p>
<p>甚至可以给它数据，然后按顺序执行一系列操作</p>
<p>it had memory and even a primitive printer.</p>
<p>它有内存甚至一个很原始的打印机</p>
<p>Like the Difference Engine, it was ahead of its time, and was never fully constructed.</p>
<p>就像差分机，这台机器太超前了，所以没有建成</p>
<p>However, the idea of an "automatic computer"</p>
<p>然而，这种 "自动计算机" 的概念</p>
<p>one that could guide itself through a series of operations automatically,</p>
<p>-计算机可以自动完成一系列操作</p>
<p>was a huge deal, and would foreshadow computer programs.</p>
<p>是个跨时代的概念，预示着计算机程序的诞生</p>
<p>English mathematician Ada Lovelace wrote hypothetical programs for the Analytical Engine, saying,</p>
<p>英国数学家 Ada Lovelace 给分析机写了假想的程序，她说：</p>
<p>"A new, a vast, and a powerful language is developed for the future use of analysis."</p>
<p>"未来会诞生一门全新的，强大的，专为分析所用的语言"</p>
<p>For her work, Ada is often considered the world's first programmer.</p>
<p>因此 Ada 被认为是世上第一位程序员.</p>
<p>The Analytical Engine would inspire, arguably, the first generation of computer scientists,</p>
<p>分析机激励了（可以这么讲）第一代计算机科学家</p>
<p>who incorporated many of Babbage's ideas in their machines.</p>
<p>这些计算机科学家，把很多 Charles Babbage 的点子融入到他们的机器</p>
<p>This is why Babbage is often considered the "father of computing".</p>
<p>所以 Charles Babbage 经常被认为是 "计算之父"</p>
<p>Thanks! Thought Bubble</p>
<p>谢啦！思想泡泡</p>
<p>So by the end of the 19th century,</p>
<p>到了 19 世纪末</p>
<p>computing devices were used for special purpose tasks in the sciences and engineering,</p>
<p>科学和工程领域中的特定任务会用上计算设备</p>
<p>but rarely seen in business, government or domestic life.</p>
<p>但公司，政府，家庭中很少见到计算设备</p>
<p>However, the US government faced a serious problem for its 1890 census</p>
<p>然而，美国政府在 1890 年的人口普查中面临着严重的问题</p>
<p>that demanded the kind of efficiency that only computers could provide.</p>
<p>只有计算机能提供所需的效率</p>
<p>The US Constitution requires that a census be conducted every ten years,</p>
<p>美国宪法要求 10 年进行一次人口普查</p>
<p>for the purposes of distributing federal funds, representation in congress, and good stuff like that.</p>
<p>目的是分配联邦资金，国会代表，等等</p>
<p>And by 1880s, the US population was booming, mostly due to immigration.</p>
<p>到 1880 年代，美国人口迅速增长，大部分因为移民</p>
<p>That census took seven years to manually compile</p>
<p>人口普查要七年时间来手工编制，等做完都过时了</p>
<p>and by the time it was completed, it was already out of date</p>
<p>人口普查要七年时间来手工编制，等做完都过时了</p>
<p>and it was predicted that the 1890 census would take 13 years to compute.</p>
<p>而且 1890 年的人口普查，预计要 13 年完成</p>
<p>That's a little problematic when it's required every decade!</p>
<p>但人口普查可是 10 年一次啊！</p>
<p>The Census bureau turned to Herman Hollerith, who had built a tabulating machine.</p>
<p>人口普查局找了 Herman Hollerith，他发明了打孔卡片制表机</p>
<p>His machine was "electro-mechanical"</p>
<p>他的机器是 "电动机械的"</p>
<p>it used traditional mechanical systems for keeping count,</p>
<p>用传统机械来计数</p>
<p>like Leibniz's Step Reckoner but coupled them with electrically-powered components.</p>
<p>结构类似莱布尼茨的乘法器，但用电动结构连接其他组件</p>
<p>Hollerith's machine used punch cards</p>
<p>Hollerith 的机器用打孔卡</p>
<p>which were paper cards with a grid of locations that can be punched out to represent data.</p>
<p>一种纸卡，上面有网格，用打孔来表示数据.</p>
<p>For example, there was a series of holes for marital status.</p>
<p>举个例子，有一连串孔代表婚姻状况</p>
<p>If you were married, you would punch out the married spot,</p>
<p>如果你结婚了，就在 "结婚" 的位置打孔</p>
<p>then when the card was inserted into Hollerith's machine, little metal pins would come down over the card</p>
<p>当卡插入 Hollerith 的机器时，小金属针会到卡片上</p>
<p>if a spot was punched out, the pin would pass through the hole in the paper</p>
<p>-如果有个地方打孔了，针会穿过孔</p>
<p>and into a little vial of mercury, which completed the circuit.</p>
<p>泡入一小瓶汞，联通电路</p>
<p>This now completed circuit powered an electric motor,</p>
<p>电路会驱动电机</p>
<p>which turned a gear to add one, in this case, to the "married" total.</p>
<p>然后给 "已婚" 的齿轮 + 1</p>
<p>Hollerith's machine was roughly 10x faster than manual tabulations,</p>
<p>Hollerith 的机器速度是手动的 10 倍左右</p>
<p>and the Census was completed in just two and a half years</p>
<p>使人口普查在短短两年半内完成</p>
<p>saving the census office millions of dollars.</p>
<p>给人口普查办公室省了上百万美元</p>
<p>Businesses began recognizing the value of computing,</p>
<p>企业开始意识到计算机的价值</p>
<p>and saw its potential to boost profits by improving laborand data-intensive tasks,</p>
<p>可以提升劳动力以及数据密集型任务来提升利润</p>
<p>like accounting, insurance appraisals, and inventory management.</p>
<p>比如会计，保险评估和库存管理等行业</p>
<p>To meet this demand, Hollerith founded The Tabulating Machine Company,</p>
<p>为了满足这一需求，Hollerith 成立了制表机器公司</p>
<p>which later merged with other machine makers in 1924</p>
<p>这家公司后来在 1924 年与其它机械制造商合并</p>
<p>to become The International Business Machines Corporation or IBM</p>
<p>成为了 "国际商业机器公司"，简称 IBM</p>
<p>which you've probably heard of.</p>
<p>-你可能听过 IBM</p>
<p>These electro-mechanical "business machines" were a huge success, transforming commerce and government,</p>
<p>这些电子机械的 "商业机器" 取得了巨大成功，改变了商业和政府.</p>
<p>and by the mid-1900s, the explosion in world population and the rise of globalized trade</p>
<p>到了 1900 年代中叶，世界人口的爆炸和全球贸易的兴起</p>
<p>demanded even faster and more flexible tools for processing data,</p>
<p>要求更快，更灵活的工具来处理数据</p>
<p>setting the stage for digital computers,</p>
<p>为电子计算机的发展奠定了基础</p>
<p>which we'll talk about next week.</p>
<p>我们下周讨论</p>
<p>02. 电子计算机</p>
<p>Electronic Computing</p>
<p>Our last episode brought us to the start of the 20th century,</p>
<p>上集讲到 20 世纪初</p>
<p>where early, special purpose computing devices, like tabulating machines,</p>
<p>当时的早期计算设备都针对特定用途比如制表机</p>
<p>were a huge boon to governments and business</p>
<p>大大推进了政府和企业</p>
<p>aiding, and sometimes replacing, rote manual tasks.</p>
<p>它们帮助, 甚至代替了人工</p>
<p>But the scale of human systems continued to increase at an unprecedented rate.</p>
<p>然而人类社会的规模在以前所未有的速度增长</p>
<p>The first half of the 20th century saw the world's population almost double.</p>
<p>20世纪上半叶，世界人口几乎翻倍</p>
<p>World War 1 mobilized 70 million people, and World War 2 involved more than 100 million.</p>
<p>一战动员7千万人，二战1亿多人</p>
<p>Global trade and transit networks became interconnected like never before,</p>
<p>全球贸易和运输更加紧密</p>
<p>and the sophistication of our engineering and scientific endeavors reached new heights</p>
<p>工程和科学的复杂度也达到新高</p>
<p>we even started to seriously consider visiting other planets.</p>
<p>我们甚至开始考虑造访其他行星</p>
<p>And it was this explosion of complexity, bureaucracy, and ultimately data,</p>
<p>复杂度的增高导致数据量暴增</p>
<p>that drove an increasing need for automation and computation.</p>
<p>人们需要更多自动化更强的计算能力</p>
<p>Soon those cabinet-sized electro-mechanical computers grew into room-sized behemoths</p>
<p>很快，柜子大小的计算机变成房间大小</p>
<p>that were expensive to maintain and prone to errors.</p>
<p>维护费用高而且容易出错</p>
<p>And it was these machines that would set the stage for future innovation.</p>
<p>而正是这些机器为未来的创新打下基础</p>
<p>One of the largest electro-mechanical computers built was the Harvard Mark I,</p>
<p>最大的机电计算机之一是哈佛马克一号</p>
<p>completed in 1944 by IBM for the Allies during World War 2.</p>
<p>IBM 在 1944 完成建造，给二战同盟国建造的.</p>
<p>It contained 765,000 components, three million connections, and five hundred miles of wire.</p>
<p>它有76万5千个组件，300万个连接点和500英里长的导线</p>
<p>To keep its internal mechanics synchronized,</p>
<p>为了保持内部机械装置同步</p>
<p>it used a 50-foot shaft running right through the machine driven by a five horsepower motor.</p>
<p>它有一个50英尺的传动轴，由一个 5 马力的电机驱动</p>
<p>One of the earliest uses for this technology was running simulations for the Manhattan Project.</p>
<p>这台机器最早的用途之一是给"曼哈顿计划"跑模拟</p>
<p>The brains of these huge electro-mechanical beasts were relays:</p>
<p>这台机器的大脑是"继电器"</p>
<p>electrically-controlled mechanical switches.</p>
<p>继电器是：用电控制的机械开关</p>
<p>In a relay, there is a control wire that determines whether a circuit is opened or closed.</p>
<p>继电器里，有根"控制线路"，控制电路是开还是关</p>
<p>The control wire connects to a coil of wire inside the relay.</p>
<p>"控制线路" 连着一个线圈</p>
<p>When current flows through the coil, an electromagnetic field is created,</p>
<p>当电流流过线圈，线圈产生电磁场</p>
<p>which in turn, attracts a metal arm inside the relay, snapping it shut and completing the circuit.</p>
<p>吸引金属臂，从而闭合电路</p>
<p>You can think of a relay like a water faucet.</p>
<p>你可以把继电器想成水龙头</p>
<p>The control wire is like the faucet handle.</p>
<p>把控制线路想成水龙头把</p>
<p>Open the faucet, and water flows through the pipe.</p>
<p>打开水龙头，水会流出来</p>
<p>Close the faucet, and the flow of water stops.</p>
<p>关闭水龙头，水就没有了</p>
<p>Relays are doing the same thing, just with electrons instead of water.</p>
<p>继电器是一样的，只不过控制的是电子而不是水</p>
<p>The controlled circuit can then connect to other circuits, or to something like a motor,</p>
<p>这个控制电路可以连到其他电路，比如马达</p>
<p>which might increment a count on a gear,</p>
<p>马达让计数齿轮 +1</p>
<p>like in Hollerith's tabulating machine we talked about last episode.</p>
<p>就像上集中 Hollerith 的制表机一样</p>
<p>Unfortunately, the mechanical arm inside of a relay *has mass*,</p>
<p>不幸的是，继电器内的机械臂 *有质量*</p>
<p>and therefore can't move instantly between opened and closed states.</p>
<p>因此无法快速开关</p>
<p>A good relay in the 1940's might be able to flick back and forth fifty times in a second.</p>
<p>1940 年代一个好的继电器 1 秒能翻转 50 次</p>
<p>That might seem pretty fast, but it's not fast enough to be useful at solving large, complex problems.</p>
<p>看起来好像很快，但还不够快，不足以解决复杂的大问题</p>
<p>The Harvard Mark I could do 3 additions or subtractions per second;</p>
<p>哈佛马克一号，1 秒能做 3 次加法或减法运算</p>
<p>multiplications took 6 seconds, and divisions took 15.</p>
<p>一次乘法要花 6 秒，除法要花 15 秒</p>
<p>And more complex operations, like a trigonometric function, could take over a minute.</p>
<p>更复杂的操作比如三角函数，可能要一分钟以上</p>
<p>In addition to slow switching speed, another limitation was wear and tear.</p>
<p>除了速度慢，另一个限制是齿轮磨损</p>
<p>Anything mechanical that moves will wear over time.</p>
<p>任何会动的机械都会随时间磨损</p>
<p>Some things break entirely, and other things start getting sticky, slow, and just plain unreliable.</p>
<p>有些部件会完全损坏，有些则是变黏，变慢，变得不可靠</p>
<p>And as the number of relays increases, the probability of a failure increases too.</p>
<p>并且随着继电器数量增加，故障概率也会增加</p>
<p>The Harvard Mark I had roughly 3500 relays.</p>
<p>哈佛马克一号有大约 3500 个继电器</p>
<p>Even if you assume a relay has an operational life of 10 years,</p>
<p>哪怕假设继电器的使用寿命是 10 年</p>
<p>this would mean you'd have to replace, on average, one faulty relay every day!</p>
<p>也意味着平均每天得换一个故障继电器！</p>
<p>That's a big problem when you are in the middle of running some important, multi-day calculation.</p>
<p>这个问题很严重，因为有些重要运算要运行好几天</p>
<p>And that's not all engineers had to contend with.</p>
<p>而且还有更多其他问题要考虑</p>
<p>These huge, dark, and warm machines also attracted insects.</p>
<p>这些巨大，黑色，温暖的机器也会吸引昆虫</p>
<p>In September 1947, operators on the Harvard Mark II pulled a dead moth from a malfunctioning relay.</p>
<p>1947年9月，哈佛马克2型的操作员从故障继电器中，拔出一只死虫</p>
<p>Grace Hopper who we'll talk more about in a later episode noted,</p>
<p>Grace Hopper（这位我们以后还会提到）曾说</p>
<p>"From then on, when anything went wrong with a computer,</p>
<p>"从那时起，每当电脑出了问题，</p>
<p>we said it had bugs in it."</p>
<p>我们就说它出了 bug（虫子）"</p>
<p>And that's where we get the term computer bug.</p>
<p>这就是术语 "bug" 的来源</p>
<p>It was clear that a faster, more reliable alternative to electro-mechanical relays was needed</p>
<p>显然，如果想进一步提高计算能力</p>
<p>if computing was going to advance further,</p>
<p>我们需要更快更可靠的东西，来替代继电器</p>
<p>and fortunately that alternative already existed!</p>
<p>幸运的是，替代品已经存在了！</p>
<p>In 1904, English physicist John Ambrose Fleming</p>
<p>在 1904 年，英国物理学家 "约翰·安布罗斯·弗莱明"</p>
<p>developed a new electrical component called a thermionic valve,</p>
<p>开发了一种新的电子组件，叫"热电子管"</p>
<p>which housed two electrodes inside an airtight glass bulb</p>
<p>把两个电极装在一个气密的玻璃灯泡里</p>
<p>this was the first vacuum tube.</p>
<p>这是世上第一个真空管</p>
<p>One of the electrodes could be heated, which would cause it to emit electrons</p>
<p>其中一个电极可以加热，从而发射电子</p>
<p>a process called thermionic emission.</p>
<p>这叫 "热电子发射"</p>
<p>The other electrode could then attract these electrons to create the flow of our electric faucet,</p>
<p>另一个电极会吸引电子，形成"电龙头"的电流</p>
<p>but only if it was positively charged</p>
<p>但只有带正电才行</p>
<p>if it had a negative or neutral charge, the electrons would no longer be attracted across the vacuum</p>
<p>如果带负电荷或中性电荷，电子就没办法被吸引，越过真空区域</p>
<p>so no current would flow.</p>
<p>因此没有电流</p>
<p>An electronic component that permits the one-way flow of current is called a diode,</p>
<p>电流只能单向流动的电子部件叫 "二极管"</p>
<p>but what was really needed was a switch to help turn this flow on and off.</p>
<p>但我们需要的是，一个能开关电流的东西</p>
<p>Luckily, shortly after, in 1906, American inventor Lee de Forest</p>
<p>幸运的是，不久之后在 1906 年，美国发明家 "李·德富雷斯特"</p>
<p>added a third "control" electrode that sits between the two electrodes in Fleming's design.</p>
<p>他在"弗莱明"设计的两个电极之间，加入了第三个 "控制" 电极</p>
<p>By applying a positive charge to the control electrode, it would permit the flow of electrons as before.</p>
<p>向"控制"电极施加正电荷，它会允许电子流动</p>
<p>But if the control electrode was given a negative charge,</p>
<p>但如果施加负电荷</p>
<p>it would prevent the flow of electrons.</p>
<p>它会阻止电子流动</p>
<p>So by manipulating the control wire, one could open or close the circuit.</p>
<p>因此通过控制线路，可以断开或闭合电路</p>
<p>It's pretty much the same thing as a relay</p>
<p>和继电器的功能一样</p>
<p>but importantly, vacuum tubes have no moving parts.</p>
<p>但重要的是，真空管内没有会动的组件</p>
<p>This meant there was less wear,</p>
<p>这意味着更少的磨损</p>
<p>and more importantly, they could switch thousands of times per second.</p>
<p>更重要的是，每秒可以开闭数千次</p>
<p>These triode vacuum tubes would become the basis of radio, long distance telephone,</p>
<p>因此这些"三极真空管"成为了无线电，长途电话</p>
<p>and many other electronic devices for nearly a half century.</p>
<p>以及其他电子设备的基础，持续了接近半个世纪</p>
<p>I should note here that vacuum tubes weren't perfect</p>
<p>我应该提到，真空管不是完美的</p>
<p>they're kind of fragile, and can burn out like light bulbs,</p>
<p>-它们有点脆弱，并且像灯泡一样会烧坏</p>
<p>they were a big improvement over mechanical relays.</p>
<p>但比起机械继电器是一次巨大进步</p>
<p>Also, initially vacuum tubes were expensive</p>
<p>起初，真空管非常昂贵</p>
<p>a radio set often used just one,</p>
<p>收音机一般只用一个</p>
<p>but a computer might require hundreds or thousands of electrical switches.</p>
<p>但计算机可能要上百甚至上千个电气开关</p>
<p>But by the 1940s,</p>
<p>但到了 1940 年代</p>
<p>their cost and reliability had improved to the point where they became feasible for use in computers….</p>
<p>它的成本和可靠性得到改进，可以用在计算机里</p>
<p>at least by people with deep pockets, like governments.</p>
<p>至少有钱人负担得起，比如政府</p>
<p>This marked the shift from electro-mechanical computing to electronic computing.</p>
<p>这标志着计算机从机电转向电子</p>
<p>Let's go to the Thought Bubble.</p>
<p>我们来进入思想泡泡</p>
<p>The first large-scale use of vacuum tubes for computing was the Colossus MK 1,</p>
<p>第一个大规模使用真空管的计算机是 "巨人1号"</p>
<p>designed by engineer Tommy Flowers and completed in December of 1943.</p>
<p>由工程师 Tommy Flowers 设计，完工于1943年12月</p>
<p>The Colossus was installed at Bletchley Park, in the UK,</p>
<p>巨人1号在英国的"布莱切利园", 用于破解纳粹通信</p>
<p>and helped to decrypt Nazi communications.</p>
<p>巨人1号在英国的"布莱切利园", 用于破解纳粹通信</p>
<p>This may sound familiar because two years prior Alan Turing,</p>
<p>听起来可能有点熟，因为 2 年前阿兰·图灵</p>
<p>often called the father of computer science,</p>
<p>他经常被称为"计算机科学之父"</p>
<p>had created an electromechanical device, also at Bletchley Park, called the Bombe.</p>
<p>图灵也在"布莱切利园"做了台机电装置，叫 "Bombe"</p>
<p>It was an electromechanical machine designed to break Nazi Enigma codes,</p>
<p>这台机器的设计目的是破解纳粹"英格码"通讯加密设备</p>
<p>but the Bombe wasn't technically a computer,</p>
<p>但 Bombe 严格来说不算计算机</p>
<p>and we'll get to Alan Turing's contributions later.</p>
<p>我们之后会讨论"阿兰·图灵"的贡献</p>
<p>Anyway, the first version of Colossus contained 1,600 vacuum tubes,</p>
<p>总之，巨人1号有 1600 个真空管</p>
<p>and in total, ten Colossi were built to help with code-breaking.</p>
<p>总共造了 10 台巨人计算机，来帮助破解密码</p>
<p>Colossus is regarded as the first programmable, electronic computer.</p>
<p>巨人被认为是第一个可编程的电子计算机</p>
<p>Programming was done by plugging hundreds of wires into plugboards,</p>
<p>编程的方法是把几百根电线插入插板</p>
<p>sort of like old school telephone switchboards,</p>
<p>有点像老电话交换机</p>
<p>in order to set up the computer to perform the right operations.</p>
<p>这是为了让计算机执行正确操作</p>
<p>So while "programmable", it still had to be configured to perform a specific computation.</p>
<p>虽然"可编程" ，但还是要配置它</p>
<p>Enter the The Electronic Numerical Integrator and Calculator or ENIAC -</p>
<p>电子数值积分计算机 "ENIAC"</p>
<p>completed a few years later in 1946 at the University of Pennsylvania.</p>
<p>几年后在 1946 年，在"宾夕法尼亚大学"完成建造</p>
<p>Designed by John Mauchly and J. Presper Eckert,</p>
<p>设计者是 John Mauchly 和 J. Presper Eckert</p>
<p>this was the world's first truly general purpose, programmable, electronic computer.</p>
<p>这是世上第一个真正的通用，可编程，电子计算机</p>
<p>ENIAC could perform 5000 ten-digit additions or subtractions per second,</p>
<p>ENIAC 每秒可执行 5000 次十位数加减法</p>
<p>many, many times faster than any machine that came before it.</p>
<p>比前辈快了很多倍</p>
<p>It was operational for ten years,</p>
<p>它运作了十年</p>
<p>and is estimated to have done more arithmetic than the entire human race up to that point.</p>
<p>据估计，它完成的运算，比全人类加起来还多</p>
<p>But with that many vacuum tubes failures were common,</p>
<p>因为真空管很多，所以故障很常见</p>
<p>and ENIAC was generally only operational for about half a day at a time before breaking down.</p>
<p>ENIAC 运行半天左右就会出一次故障</p>
<p>Thanks Thought Bubble.</p>
<p>谢了思想泡泡</p>
<p>By the 1950's, even vacuum-tube-based computing was reaching its limits.</p>
<p>到 1950 年代，真空管计算机都达到了极限</p>
<p>The US Air Force's AN/FSQ-7 computer, which was completed in 1955,</p>
<p>美国空军的 AN/FSQ-7 计算机于 1955 年完成</p>
<p>was part of the "SAGE" air defense computer system,</p>
<p>是 "SAGE" 防空计算机系统的一部分</p>
<p>which we'll talk more about in a later episode.</p>
<p>之后的视频还会提到.</p>
<p>To reduce cost and size, as well as improve reliability and speed,</p>
<p>为了降低成本和大小，同时提高可靠性和速度</p>
<p>a radical new electronic switch would be needed.</p>
<p>我们需要一种新的电子开关</p>
<p>In 1947, Bell Laboratory scientists John Bardeen, Walter Brattain, and William Shockley</p>
<p>1947 年，贝尔实验室科学家，John Bardeen，Walter Brattain，William Shockley</p>
<p>invented the transistor,</p>
<p>发明了晶体管</p>
<p>and with it, a whole new era of computing was born!</p>
<p>一个全新的计算机时代诞生了！</p>
<p>The physics behind transistors is pretty complex, relying on quantum mechanics,</p>
<p>晶体管的物理学相当复杂，牵扯到量子力学</p>
<p>so we're going to stick to the basics.</p>
<p>所以我们只讲基础</p>
<p>A transistor is just like a relay or vacuum tube</p>
<p>晶体管就像之前提过的"继电器"或"真空管"</p>
<p>it's a switch that can be opened or closed by applying electrical power via a control wire.</p>
<p>-它是一个开关，可以用控制线路来控制开或关</p>
<p>Typically, transistors have two electrodes separated by a material that sometimes can conduct electricity,</p>
<p>晶体管有两个电极，电极之间有一种材料隔开它们，这种材料有时候导电</p>
<p>and other times resist it</p>
<p>有时候不导电</p>
<p>a semiconductor.</p>
<p>这叫"半导体"</p>
<p>In this case, the control wire attaches to a "gate" electrode.</p>
<p>控制线连到一个 "门" 电极</p>
<p>By changing the electrical charge of the gate,</p>
<p>通过改变 "门" 的电荷</p>
<p>the conductivity of the semiconducting material can be manipulated,</p>
<p>我们可以控制半导体材料的导电性</p>
<p>allowing current to flow or be stopped</p>
<p>来允许或不允许电流流动</p>
<p>like the water faucet analogy we discussed earlier.</p>
<p>就像之前的水龙头比喻</p>
<p>Even the very first transistor at Bell Labs showed tremendous promise</p>
<p>贝尔实验室的第一个晶体管就展示了巨大的潜力</p>
<p>it could switch between on and off states 10,000 times per second.</p>
<p>每秒可以开关 10,000 次</p>
<p>Further, unlike vacuum tubes made of glass and with carefully suspended, fragile components,</p>
<p>而且，比起玻璃制成，小心易碎的真空管</p>
<p>transistors were solid material known as a solid state component.</p>
<p>晶体管是固态的</p>
<p>Almost immediately, transistors could be made smaller than the smallest possible relays or vacuum tubes.</p>
<p>晶体管可以远远小于继电器或真空管</p>
<p>This led to dramatically smaller and cheaper computers, like the IBM 608, released in 1957</p>
<p>导致更小更便宜的计算机，比如1957年发布的IBM 608</p>
<p>the first fully transistor-powered, commercially-available computer.</p>
<p>第一个完全用晶体管，而且消费者也可以买到的计算机</p>
<p>It contained 3000 transistors and could perform 4,500 additions,</p>
<p>它有 3000 个晶体管，每秒执行 4500 次加法</p>
<p>or roughly 80 multiplications or divisions, every second.</p>
<p>每秒能执行 80 次左右的乘除法</p>
<p>IBM soon transitioned all of its computing products to transistors,</p>
<p>IBM 很快把所有产品都转向了晶体管</p>
<p>bringing transistor-based computers into offices, and eventually, homes.</p>
<p>把晶体管计算机带入办公室，最终引入家庭</p>
<p>Today, computers use transistors that are smaller than 50 nanometers in size</p>
<p>如今，计算机里的晶体管小于 50 纳米</p>
<p>for reference, a sheet of paper is roughly 100,000 nanometers thick.</p>
<p>而一张纸的厚度大概是 10 万纳米</p>
<p>And they're not only incredibly small, they're super fast</p>
<p>晶体管不仅小，还超级快</p>
<p>they can switch states millions of times per second, and can run for decades.</p>
<p>每秒可以切换上百万次，并且能工作几十年</p>
<p>A lot of this transistor and semiconductor development happened</p>
<p>很多晶体管和半导体的开发在"圣克拉拉谷"</p>
<p>in the Santa Clara Valley, between San Francisco and San Jose, California.</p>
<p>这个地方在加州，位于"旧金山"和"圣荷西"之间</p>
<p>As the most common material used to create semiconductors is silicon,</p>
<p>而生产半导体最常见的材料是 "硅"</p>
<p>this region soon became known as Silicon Valley.</p>
<p>所以这个地区被称为 "硅谷"</p>
<p>Even William Shockley moved there, founding Shockley Semiconductor,</p>
<p>甚至 William Shockley 都搬了过去，创立了"肖克利半导体"</p>
<p>whose employees later founded Fairchild Semiconductors,</p>
<p>里面的员工后来成立了"仙童半导体"</p>
<p>whose employees later founded Intel the world's largest computer chip maker today.</p>
<p>这里面的员工后来创立了英特尔当今世界上最大的计算机芯片制造商</p>
<p>Ok, so we've gone from relays to vacuum tubes to transistors.</p>
<p>好了，我们从"继电器"到"真空管"到"晶体管"</p>
<p>We can turn electricity on and off really, really, really fast.</p>
<p>我们可以让电路开闭得非常非常快</p>
<p>But how do we get from transistors to actually computing something,</p>
<p>但我们是如何用晶体管做计算的？</p>
<p>especially if we don't have motors and gears?</p>
<p>我们没有马达和齿轮啊？</p>
<p>That's what we're going to cover over the next few episodes.</p>
<p>我们接下来几集会讲</p>
<p>Thanks for watching. See you next week.</p>
<p>感谢观看下周见</p>
<p>03. 布尔逻辑和逻辑门</p>
<p>Boolean Logic & Logic Gates</p>
<p>Hi, I'm Carrie Anne and welcome to Crash Course Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>Today we start our journey up the ladder of abstraction,</p>
<p>今天我们开始"抽象"的旅程</p>
<p>where we leave behind the simplicity of being able to see every switch and gear,</p>
<p>不用管底层细节，把精力用来构建更复杂的系统</p>
<p>but gain the ability to assemble increasingly complex systems.</p>
<p>不用管底层细节，把精力用来构建更复杂的系统</p>
<p>Last episode, we talked about how computers evolved from electromechanical devices,</p>
<p>上集，我们谈了计算机最早是机电设备</p>
<p>that often had decimal representations of numbers</p>
<p>一般用十进制计数</p>
<p>like those represented by teeth on a gear</p>
<p>比如用齿轮数来代表十进制</p>
<p>to electronic computers with transistors that can turn the flow of electricity on or off.</p>
<p>再到晶体管计算机</p>
<p>And fortunately, even with just two states of electricity,</p>
<p>幸运的是，只用开/关两种状态也可以代表信息</p>
<p>we can represent important information.</p>
<p>幸运的是，只用开/关两种状态也可以代表信息</p>
<p>We call this representation Binary</p>
<p>这叫二进制</p>
<p>which literally means "of two states",</p>
<p>意思是"用两种状态表示"</p>
<p>in the same way a bicycle has two wheels or a biped has two legs.</p>
<p>就像自行车有两个轮，双足动物有两条腿</p>
<p>You might think two states isn't a lot to work with, and you'd be right!</p>
<p>你可能觉得两种状态不多，你是对的！</p>
<p>But, it's exactly what you need for representing the values "true" and "false".</p>
<p>但如果只需要表示 true 和 false，两个值就够了</p>
<p>In computers, an "on" state, when electricity is flowing, represents true.</p>
<p>电路闭合，电流流过，代表 "真"</p>
<p>The off state, no electricity flowing, represents false.</p>
<p>电路断开，无电流流过，代表"假"</p>
<p>We can also write binary as 1's and 0's instead of true's and false's</p>
<p>二进制也可以写成 1 和 0 而不是 true 和 false</p>
<p>they are just different expressions of the same signal</p>
<p>只是不同的表达方式罢了</p>
<p>but we'll talk more about that in the next episode.</p>
<p>我们下集会讲更多细节</p>
<p>Now it is actually possible to use transistors for more than just turning electrical current on and off,</p>
<p>晶体管的确可以不只是开/关，还可以让不同大小的电流通过</p>
<p>and to allow for different levels of current.</p>
<p>晶体管的确可以不只是开/关，还可以让不同大小的电流通过</p>
<p>Some early electronic computers were ternary, that's three states,</p>
<p>一些早期电子计算机是三进制的，有 3 种状态</p>
<p>and even quinary, using 5 states.</p>
<p>甚至五进制，5 种状态</p>
<p>The problem is, the more intermediate states there are,</p>
<p>问题是，状态越多，越难区分信号</p>
<p>the harder it is to keep them all seperate</p>
<p>问题是，状态越多，越难区分信号</p>
<p>if your smartphone battery starts running low or there's electrical noise</p>
<p>如果手机快没电了或者附近有电噪音</p>
<p>because someone's running a microwave nearby,</p>
<p>因为有人在用微波炉，</p>
<p>the signals can get mixed up...</p>
<p>信号可能会混在一起...</p>
<p>and this problem only gets worse with transistors changing states millions of times per second!</p>
<p>而每秒百万次变化的晶体管会让这个问题变得更糟！</p>
<p>So, placing two signals as far apart as possible</p>
<p>所以我们把两种信号尽可能分开</p>
<p>using just 'on and off' gives us the most distinct signal to minimize these issues.</p>
<p>只用"开"和"关"两种状态，可以尽可能减少这类问题</p>
<p>Another reason computers use binary</p>
<p>计算机用二进制的另一个原因是</p>
<p>is that an entire branch of mathematics already existed that dealt exclusively with true and false values.</p>
<p>有一整个数学分支存在，专门处理"真"和"假"</p>
<p>And it had figured out all of the necessary rules and operations for manipulating them.</p>
<p>它已经解决了所有法则和运算</p>
<p>It's called Boolean Algebra!</p>
<p>叫"布尔代数"！</p>
<p>George Boole, from which Boolean Algebra later got its name,</p>
<p>乔治·布尔（George Boole）是布尔二字的由来</p>
<p>was a self-taught English mathematician in the 1800s.</p>
<p>是一位 19 世纪自学成才的英国数学家</p>
<p>He was interested in representing logical statements that went "under, over, and beyond"</p>
<p>他有兴趣用数学式子</p>
<p>Aristotle's approach to logic, which was, unsurprisingly, grounded in philosophy.</p>
<p>扩展亚里士多德基于哲学的逻辑方法</p>
<p>Boole's approach allowed truth to be systematically and formally proven, through logic equations</p>
<p>布尔用逻辑方程系统而正式的证明真理(truth)</p>
<p>which he introduced in his first book, "The Mathematical Analysis of Logic" in 1847.</p>
<p>他在 1847 年的第一本书"逻辑的数学分析"中介绍过</p>
<p>In "regular" algebra -the type you probably learned in high school -the values of variables</p>
<p>在"常规"代数里你在高中学的那种变量的值</p>
<p>are numbers, and operations on those numbers are things like addition and multiplication.</p>
<p>是数字，可以进行加法或乘法之类的操作</p>
<p>But in Boolean Algebra, the values of variables are true and false, and the operations are logical.</p>
<p>但在布尔代数中，变量的值是 true 和 false，能进行逻辑操作</p>
<p>There are three fundamental operations in Boolean Algebra: a NOT, an AND, and an OR operation.</p>
<p>布尔代数中有三个基本操作：NOT, AND 和 OR</p>
<p>And these operations turn out to be really useful so we're going to look at them individually.</p>
<p>这些操作非常有用，我们一个个来看</p>
<p>A NOT takes a single boolean value, either true or false, and negates it.</p>
<p>NOT 操作把布尔值反转，把 true 进行 NOT 就会变成 false，反之亦然</p>
<p>It flips true to false, and false to true.</p>
<p>NOT 操作把布尔值反转，把 true 进行 NOT 就会变成 false，反之亦然</p>
<p>We can write out a little logic table that shows the original value under Input,</p>
<p>我们可以根据 NOT 操作的输入和输出，做出这个表</p>
<p>and the outcome after applying the operation under Output.</p>
<p>我们可以根据 NOT 操作的输入和输出，做出这个表</p>
<p>Now here's the cool part -we can easily build boolean logic out of transistors.</p>
<p>酷的地方是用晶体管可以轻松实现这个逻辑</p>
<p>As we discussed last episode, transistors are really just little electrically controlled switches.</p>
<p>上集说过，晶体管只是电控制的开关</p>
<p>They have three wires: two electrodes and one control wire.</p>
<p>有 3 根线：2 根电极和 1 根控制线</p>
<p>When you apply electricity to the control wire,</p>
<p>控制线通电时</p>
<p>it lets current flow through from one electrode, through the transistor, to the other electrode.</p>
<p>电流就可以从一个电极流到另一个电极</p>
<p>This is a lot like a spigot on a pipe</p>
<p>就像水龙头一样</p>
<p>open the tap, water flows,</p>
<p>打开水龙头，就有水流出来</p>
<p>close the tap, water shuts off.</p>
<p>关掉水龙头，就没水了</p>
<p>You can think of the control wire as an input,</p>
<p>可以把控制线，当做输入 ( input )，底部的电极，当做输出（output）</p>
<p>and the wire coming from the bottom electrode as the output.</p>
<p>可以把控制线，当做输入 ( input )，底部的电极，当做输出（output）</p>
<p>So with a single transistor, we have one input and one output.</p>
<p>所以 1 个晶体管，有一个输入和一个输出</p>
<p>If we turn the input on, the output is also on because the current can flow through it.</p>
<p>如果我们打开输入（input on)，输出也会打开（output on），因为电流可以流过</p>
<p>If we turn the input off, the output is also off and the current can no longer pass through.</p>
<p>如果关闭输入（input off），输出也会关闭（output off），因为电流无法通过</p>
<p>Or in boolean terms, when the input is true, the output is true.</p>
<p>或者用布尔术语来说，输入为真，输出为真</p>
<p>And when the input is false, the output is also false.</p>
<p>输入为假，输出为假</p>
<p>Which again we can show on a logic table.</p>
<p>我们也可以把这个做成"真值表"</p>
<p>This isn't a very exciting circuit though because its not doing anything</p>
<p>这个电路没什么意思，因为它没做什么事</p>
<p>the input and output are the same.</p>
<p>输入和输出是一样的</p>
<p>But, we can modify this circuit just a little bit to create a NOT.</p>
<p>但我们可以稍加修改，实现 NOT</p>
<p>Instead of having the output wire at the end of the transistor, we can move it before.</p>
<p>与其把下面那根线当做输出，我们可以把输出放到上面</p>
<p>If we turn the input on, the transistor allows current to pass through it to the "ground",</p>
<p>如果打开输入，电流可以流过然后 "接地"</p>
<p>and the output wire won't receive that current</p>
<p>输出就没有电流，所以输出是 off</p>
<p>so it will be off.</p>
<p>输出就没有电流，所以输出是 off</p>
<p>In our water metaphor grounding would be like</p>
<p>如果用水来举例</p>
<p>if all the water in your house was flowing out of a huge hose</p>
<p>就像家里的水都从一个大管子流走了</p>
<p>so there wasn't any water pressure left for your shower.</p>
<p>打开淋浴头一点水也没有</p>
<p>So in this case if the input is on, output is off.</p>
<p>如果输入是 on，输出是 off</p>
<p>When we turn off the transistor, though, current is prevented from flowing down it to the ground,</p>
<p>当输入是 off，电流没法接地，就流过了输出，所以输出是 on</p>
<p>so instead, current flows through the output wire.</p>
<p>当输入是 off，电流没法接地，就流过了输出，所以输出是 on</p>
<p>So the input will be off and the output will be on.</p>
<p>如果输入是 off，输出是 on</p>
<p>And this matches our logic table for NOT, so congrats, we just built a circuit that computes NOT!</p>
<p>和 NOT 操作表一样！太棒了！我们做了个有点用的电路！</p>
<p>We call them NOT gates we call them gates because they're controlling the path of our current.</p>
<p>我们叫它 "NOT 门"，之所以叫 "门"，是因为它能控制电流的路径</p>
<p>The AND Boolean operation takes two inputs, but still has a single output.</p>
<p>"AND"操作有 2 个输入，1 个输出</p>
<p>In this case the output is only true if both inputs are true.</p>
<p>如果 2 个输入都是 true，输出才是 true</p>
<p>Think about it like telling the truth.</p>
<p>你可以想成是说真话</p>
<p>You're only being completely honest if you don't lie even a little.</p>
<p>如果完全不说谎，才是诚实</p>
<p>For example, let's take the statement,</p>
<p>举例，看如下这个句子</p>
<p>"My name is Carrie Anne AND I'm wearing a blue dress".</p>
<p>我叫 Carrie Anne "而且"我穿着蓝色的衣服</p>
<p>Both of those facts are true, so the whole statement is true.</p>
<p>2 个都是真的，所以整个是真的</p>
<p>But if I said, "My name is Carrie Anne AND I'm wearing pants" that would be false,</p>
<p>但如果说，我叫 Carrie Anne"而且"我穿了裤子, 就是假的</p>
<p>because I'm not wearing pants.</p>
<p>因为我没穿裤子</p>
<p>Or trousers.</p>
<p>或长裤，如果你是英国人你会用这个词……（英/美单词不同梗）</p>
<p>If you're in England.</p>
<p>或长裤，如果你是英国人你会用这个词……（英/美单词不同梗）</p>
<p>The Carrie Anne part is true, but a true AND a false, is still false.</p>
<p>虽然前半句是真的，但是真 "AND" 假，还是假</p>
<p>If I were to reverse that statement it would still obviously be false,</p>
<p>就算把前后顺序反过来，也依然是假</p>
<p>and if I were to tell you two complete lies that is also false,</p>
<p>如果我说 2 个假的事情，那么结果是假。</p>
<p>and again we can write all of these combinations out in a table.</p>
<p>和上次一样，可以给"AND"做个表</p>
<p>To build an AND gate, we need two transistors connected together</p>
<p>为了实现 "AND 门"，我们需要 2 个晶体管连在一起</p>
<p>so we have our two inputs and one output.</p>
<p>这样有 2 个输入和 1 个输出</p>
<p>If we turn on just transistor A, current won't flow because the current is stopped by transistor B.</p>
<p>如果只打开 A，不打开 B，电流无法流到 output，所以输出是 false</p>
<p>Alternatively, if transistor B is on, but the transistor A is off,</p>
<p>如果只打开 B，不打开 A ，也一样，电流无法流到 output</p>
<p>the same thing, the current can't get through.</p>
<p>如果只打开 B，不打开 A ，也一样，电流无法流到 output</p>
<p>Only if transistor A AND transistor B are on does the output wire have current.</p>
<p>只有 A 和 B 都打开了，output 才有电流</p>
<p>The last boolean operation is OR</p>
<p>最后一个是 OR （前面讲了 NOT 和 AND)</p>
<p>where only one input has to be true for the output to be true.</p>
<p>只要 2 个输入里，其中 1 个是 true，输出就是 true</p>
<p>For example, my name is Margaret Hamilton OR I'm wearing a blue dress.</p>
<p>比如，我叫 Margaret Hamilton"或"我穿着蓝色衣服</p>
<p>This is a true statement because although I'm not Margaret Hamilton unfortunately,</p>
<p>结果是 true，虽然我不是 Margaret Hamilton</p>
<p>I am wearing a blue dress, so the overall statement is true.</p>
<p>但是我穿着蓝色衣服，所以结果是 true</p>
<p>An OR statement is also true if both facts are true.</p>
<p>对于"OR 操作"来说，如果 2 个输入都是 true，输出也是 true</p>
<p>The only time an OR statement is false is if both inputs are false.</p>
<p>只有 2 个输入都是 false，OR 的结果才是 false</p>
<p>Building an OR gate from transistors needs a few extra wires.</p>
<p>实现 "OR 门" 除了晶体管还要额外的线</p>
<p>Instead of having two transistors in series -one after the other --</p>
<p>不是串联起来。</p>
<p>we have them in parallel.</p>
<p>而是并联</p>
<p>We run wires from the current source to both transistors.</p>
<p>然后左边这条线有电流输入</p>
<p>We use this little arc to note that the wires jump over one another and aren't connected,</p>
<p>我们用"小拱门"代表 2 条线没连在一起，只是跨过而已</p>
<p>even though they look like they cross.</p>
<p>虽然看起来像连在一起</p>
<p>If both transistors are turned off, the current is prevented from flowing to the output,</p>
<p>如果 A 和 B 都是 off，电流无法流过</p>
<p>so the output is also off.</p>
<p>所以输出是 off</p>
<p>Now, if we turn on just Transistor A, current can flow to the output.</p>
<p>如果打开 A，电流可以流过。输出是 on</p>
<p>Same thing if transistor A is off, but Transistor B in on.</p>
<p>如果只打开 B 也一样</p>
<p>Basically if A OR B is on, the output is also on.</p>
<p>只要 A OR B 是 on，输出就是 on</p>
<p>Also, if both transistors are on, the output is still on.</p>
<p>如果 A 和 B 都 on，结果是 on</p>
<p>Ok, now that we've got NOT, AND, and OR gates,</p>
<p>好，现在 NOT 门, AND 门, OR 门都搞定了</p>
<p>and we can leave behind the constituent transistors and move up a layer of abstraction.</p>
<p>我们可以进行一次抽象</p>
<p>The standard engineers use for these gates are a triangle with a dot for a NOT,</p>
<p>NOT 门的画法是三角形前面一个圆点</p>
<p>a D for the AND, and a spaceship for the OR.</p>
<p>AND 门用 D 表示，OR 门用太空船表示</p>
<p>Those aren't the official names, but that's howI like to think of them.</p>
<p>"D 形状和太空船"不是标准叫法, 只是我喜欢这样叫而已</p>
<p>Representing them and thinking about them this way allows us to build even bigger components</p>
<p>我们可以用这种方法表示它们，构建更大的组件</p>
<p>while keeping the overall complexity relatively the same</p>
<p>就不会变得很复杂</p>
<p>just remember that that mess of transistors and wires is still there.</p>
<p>晶体管和电线依然在那里，我们只是用符号来代表而已</p>
<p>For example, another useful boolean operation in computation is called an Exclusive OR</p>
<p>除了前面说的三个，另一个有用的布尔操作叫 "异或"</p>
<p>or XOR for short.</p>
<p>简称 XOR</p>
<p>XOR is like a regular OR, but with one difference:</p>
<p>XOR 就像普通 OR，但有一个区别：</p>
<p>if both inputs are true, the XOR is false.</p>
<p>如果 2 个输入都是 true，XOR 输出 false</p>
<p>The only time an XOR is true is when one input is true and the other input is false.</p>
<p>想要 XOR 输出 true，一个输入必须是 true，另一个必须是 false</p>
<p>It's like when you go out to dinner and your meal comes with a side salad OR a soup</p>
<p>就像你出去吃晚饭，你点的饭要么配沙拉，要么配汤</p>
<p>sadly, you can't have both!</p>
<p>你不能两个都要！</p>
<p>And building this from transistors is pretty confusing,</p>
<p>用晶体管实现 XOR 门有点烧脑子</p>
<p>but we can show how an XOR is created from our three basic boolean gates.</p>
<p>但我可以展示一下，怎么用前面提到的 3 种门来做 XOR 门</p>
<p>We know we have two inputs again -A and B -and one output.</p>
<p>我们有 2 个输入，A 和 B ，还有 1 个输出.</p>
<p>Let's start with an OR gate, since the logic table looks almost identical to an OR.</p>
<p>我们先放一个 OR 门. 因为 OR 和 XOR 的逻辑表很像</p>
<p>There's only one problem when A and B are true, the logic is different from OR,</p>
<p>只有 1 个问题当 A 和 B 都是 true 时，OR 的输出和想要的 XOR 输出不一样</p>
<p>and we need to output "false".</p>
<p>我们想要 false</p>
<p>And XOR turns out to be a very useful component,</p>
<p>XOR 超有用的</p>
<p>and we'll get to it in another episode,</p>
<p>我们下次再说它</p>
<p>so useful in fact engineers gave it its own symbol too -an OR gate with a smile :)</p>
<p>因为超有用，工程师给了它一个符号，一个 OR 门 + 一个笑脸</p>
<p>But most importantly, we can now put XOR into our metaphorical toolbox</p>
<p>重要的是，现在可以把 XOR 放入"工具箱"了</p>
<p>and not have to worry about the individual logic gates that make it up,</p>
<p>不用担心 XOR 具体用了几个门</p>
<p>or the transistors that make up those gates,</p>
<p>这几个门又是怎么用晶体管拼的</p>
<p>or how electrons are flowing through a semiconductor.</p>
<p>或电子是怎么流过半导体的</p>
<p>Moving up another layer of abstraction.</p>
<p>再次向上抽象</p>
<p>When computer engineers are designing processors, they rarely work at the transistor level,</p>
<p>工程师设计处理器时，很少在晶体管的层面上思考，</p>
<p>and instead work with much larger blocks, like logic gates, and even larger components</p>
<p>而是用更大的组件，比如逻辑门，或者由逻辑门组成的更大组件，</p>
<p>made up of logic gates, which we'll discuss in future episodes.</p>
<p>我们以后会讲</p>
<p>And even if you are a professional computer programmer,</p>
<p>就算是专业程序员</p>
<p>it's not often that you think about</p>
<p>也不用考虑</p>
<p>how the logic that you are programming is actually implemented</p>
<p>逻辑是怎样在物理层面实现的</p>
<p>in the physical world by these teeny tiny components.</p>
<p>也不用考虑逻辑是怎样在物理层面实现的</p>
<p>We've also moved from thinking about raw electrical signals to our first representation of data</p>
<p>我们从电信号开始，到现在第一次表示数据</p>
<p>true and false and we've even gotten a little taste of computation.</p>
<p>真和假开始有点"计算"的感觉了</p>
<p>With just the logic gates in this episode,</p>
<p>仅用这集讲的逻辑门</p>
<p>we could build a machine that evaluates complex logic statements,</p>
<p>我们可以判断复杂的语句比如：</p>
<p>like if "Name is John Green AND after 5pm OR is Weekend AND near Pizza Hut",</p>
<p>[如果是 John Green] AND [下午 5 点后]，OR [周末] AND [在比萨店附近]</p>
<p>then "John will want pizza" equals true.</p>
<p>那么 "John 想要比萨" = 真</p>
<p>And with that, I'm starving, I'll see you next week.</p>
<p>我都说饿了，下周见</p>
<p>04. 二进制</p>
<p>Representing Numbers and Letters with Binary</p>
<p>Hi I'm Carrie Anne, this is Crash Course Computer Science</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>and today we're going to talk about how computers store and represent numerical data.</p>
<p>今天，我们讲计算机如何存储和表示数字</p>
<p>Which means we've got to talk about Math!</p>
<p>所以会有一些数学</p>
<p>But don't worry.</p>
<p>不过别担心</p>
<p>Every single one of you already knows exactly what you need to know to follow along.</p>
<p>你们的数学水平绝对够用了</p>
<p>So, last episode we talked about how transistors can be used to build logic gates,</p>
<p>上集我们讲了，怎么用晶体管做逻辑门</p>
<p>which can evaluate boolean statements.</p>
<p>逻辑门可以判断布尔语句</p>
<p>And in boolean algebra, there are only two, binary values: true and false.</p>
<p>布尔代数只有两个值：True 和 False</p>
<p>But if we only have two values,</p>
<p>但如果只有两个值，</p>
<p>how in the world do we represent information beyond just these two values?</p>
<p>我们怎么表达更多东西？</p>
<p>That's where the Math comes in.</p>
<p>这就需要数学了</p>
<p>So, as we mentioned last episode, a single binary value can be used to represent a number.</p>
<p>上集提到，1 个二进制值可以代表 1 个数</p>
<p>Instead of true and false, we can call these two states 1 and 0 which is actually incredibly useful.</p>
<p>我们可以把真和假，当做 1 和 0</p>
<p>And if we want to represent larger things we just need to add more binary digits.</p>
<p>如果想表示更多东西，加位数就行了</p>
<p>This works exactly the same way as the decimal numbers that we're all familiar with.</p>
<p>和我们熟悉的十进制一样</p>
<p>With decimal numbers there are "only" 10 possible values a single digit can be; 0 through 9,</p>
<p>十进制只有 10 个数（0到9）</p>
<p>and to get numbers larger than 9 we just start adding more digits to the front.</p>
<p>要表示大于 9 的数，加位数就行了</p>
<p>We can do the same with binary.</p>
<p>二进制也可以这样玩</p>
<p>For example, let's take the number two hundred and sixty three.</p>
<p>拿 263 举例</p>
<p>What does this number actually represent?</p>
<p>这个数字 "实际" 代表什么？</p>
<p>Well, it means we've got 2 one-hundreds, 6 tens, and 3 ones.</p>
<p>2 个 100 ，6 个 10，3 个 1</p>
<p>If you add those all together, we've got 263.</p>
<p>加在一起，就是 263</p>
<p>Notice how each column has a different multiplier.</p>
<p>注意每列有不同的乘数</p>
<p>In this case, it's 100, 10, and 1.</p>
<p>100, 10, 1</p>
<p>Each multiplier is ten times larger than the one to the right.</p>
<p>每个乘数都比右边大十倍</p>
<p>That's because each column has ten possible digits to work with, 0 through 9,</p>
<p>因为每列有 10 个可能的数字（0到9）</p>
<p>after which you have to carry one to the next column.</p>
<p>如果超过 9，要在下一列进 1.</p>
<p>For this reason, it's called base-ten notation, also called decimal since deci means ten.</p>
<p>因此叫 "基于十的表示法"  或十进制</p>
<p>AND Binary works exactly the same way, it's just base-two.</p>
<p>二进制也一样，只不过是基于 2 而已</p>
<p>That's because there are only two possible digits in binary 1 and 0.</p>
<p>因为二进制只有两个可能的数，1 和 0</p>
<p>This means that each multiplier has to be two times larger than the column to its right.</p>
<p>意味着每个乘数必须是右侧乘数的两倍</p>
<p>Instead of hundreds, tens, and ones, we now have fours, twos and ones.</p>
<p>就不是之前的 100, 10, 1，而是 4, 2, 1</p>
<p>Take for example the binary number: 101.</p>
<p>拿二进制数 101 举例</p>
<p>This means we have 1 four, 0 twos, and 1 one.</p>
<p>意味着有，1个 "4" ，0个 "2" ，1个 "1"</p>
<p>Add those all together and we've got the number 5 in base ten.</p>
<p>加在一起，得到十进制的 5</p>
<p>But to represent larger numbers, binary needs a lot more digits.</p>
<p>为了表示更大的数字，二进制需要更多位数</p>
<p>Take this number in binary 10110111.</p>
<p>拿二进制数 10110111 举例</p>
<p>We can convert it to decimal in the same way.</p>
<p>我们可以用相同的方法转成十进制</p>
<p>We have 1 x 128, 0 x 64, 1 x 32, 1 x 16, 0 x 8, 1 x 4, 1 x 2, and 1 x 1.</p>
<p>1 x 128 ，0 x 64 ，1 x 32 ，1 x 16，0 x 8 ，1 x 4 ，1 x 2 ，1 x 1</p>
<p>Which all adds up to 183.</p>
<p>加起来等于 183</p>
<p>Math with binary numbers isn't hard either.</p>
<p>二进制数的计算也不难</p>
<p>Take for example decimal addition of 183 plus 19.</p>
<p>以十进制数 183 加 19 举例</p>
<p>First we add 3 + 9, that's 12, so we put 2 as the sum and carry 1 to the ten's column.</p>
<p>首先 3 + 9，得到 12，然后位数记作 2，向前进 1</p>
<p>Now we add 8 plus 1 plus the 1 we carried, thats 10, so the sum is 0 carry 1.</p>
<p>现在算 8+1+1=10，所以位数记作0，再向前进 1</p>
<p>Finally we add 1 plus the 1 we carried, which equals 2.</p>
<p>最后 1+1=2，位数记作2</p>
<p>So the total sum is 202.</p>
<p>所以和是202</p>
<p>Here's the same sum but in binary.</p>
<p>二进制也一样</p>
<p>Just as before, we start with the ones column.</p>
<p>和之前一样，从个位开始</p>
<p>Adding 1+1 results in 2, even in binary.</p>
<p>1+1=2，在二进制中也是如此</p>
<p>But, there is no symbol "2" so we use 10 and put 0 as our sum and carry the 1.</p>
<p>但二进制中没有 2，所以位数记作 0 ，进 1</p>
<p>Just like in our decimal example.</p>
<p>就像十进制的例子一样</p>
<p>1 plus 1, plus the 1 carried,</p>
<p>1+1，再加上进位的1</p>
<p>equals 3 or 11 in binary,</p>
<p>等于 3，用二进制表示是 11</p>
<p>so we put the sum as 1 and we carry 1 again, and so on.</p>
<p>所以位数记作 1，再进 1，以此类推</p>
<p>We end up with this number, which is the same as the number 202 in base ten.</p>
<p>最后得到这个数字，跟十进制 202 是一样的</p>
<p>Each of these binary digits, 1 or 0, is called a "bit".</p>
<p>二进制中，一个 1 或 0  叫一"位"</p>
<p>So in these last few examples, we were using 8-bit numbers with their lowest value of zero</p>
<p>上个例子我们用了 8 位 , 8 位能表示的最小数是 0,  8位都是0</p>
<p>and highest value is 255, which requires all 8 bits to be set to 1.</p>
<p>最大数是 255，8 位都是 1</p>
<p>Thats 256 different values, or 2 to the 8th power.</p>
<p>能表示 256 个不同的值，2 的 8 次方</p>
<p>You might have heard of 8-bit computers, or 8-bit graphics or audio.</p>
<p>你可能听过 8 位机，8 位图像，8 位音乐</p>
<p>These were computers that did most of their operations in chunks of 8 bits.</p>
<p>意思是计算机里，大部分操作都是 8 位 8 位这样处理的</p>
<p>But 256 different values isn't a lot to work with, so it meant things like 8-bit games</p>
<p>但 256 个值不算多，意味着 8位游戏只能用 256 种颜色</p>
<p>were limited to 256 different colors for their graphics.</p>
<p>但 256 个值不算多，意味着 8位游戏只能用 256 种颜色</p>
<p>And 8-bits is such a common size in computing, it has a special word: a byte.</p>
<p>8 位是如此常见，以至于有专门的名字：字节</p>
<p>A byte is 8 bits.</p>
<p>1 字节 = 8 位，1 bytes = 8 bits</p>
<p>If you've got 10 bytes, it means you've really got 80 bits.</p>
<p>如果有 10 个字节，意味着有 80 位</p>
<p>You've heard of kilobytes, megabytes, gigabytes and so on.</p>
<p>你听过千字节（KB）兆字节（MB）千兆字节（GB）等等</p>
<p>These prefixes denote different scales of data.</p>
<p>不同前缀代表不同数量级</p>
<p>Just like one kilogram is a thousand grams,</p>
<p>就像 1 千克 = 1000 克，</p>
<p>1 kilobyte is a thousand bytes.</p>
<p>1 千字节 = 1000 字节</p>
<p>or really 8000 bits.</p>
<p>或 8000 位</p>
<p>Mega is a million bytes (MB), and giga is a billion bytes (GB).</p>
<p>Mega 是百万字节（MB）, Giga 是十亿字节（GB）</p>
<p>Today you might even have a hard drive that has 1 terabyte (TB) of storage.</p>
<p>如今你可能有 1 TB 的硬盘</p>
<p>That's 8 trillion ones and zeros.</p>
<p>8 万亿个1和0</p>
<p>But hold on!</p>
<p>等等，我们有另一种计算方法</p>
<p>That's not always true.</p>
<p>等等，我们有另一种计算方法</p>
<p>In binary, a kilobyte has two to the power of 10 bytes, or 1024.</p>
<p>二进制里，1 千字节 = 2的10次方 = 1024 字节</p>
<p>1000 is also right when talking about kilobytes,</p>
<p>1000 也是千字节（KB）的正确单位</p>
<p>but we should acknowledge it isn't the only correct definition.</p>
<p>1000 和 1024 都对</p>
<p>You've probably also heard the term 32-bit or 64-bit computers</p>
<p>你可能听过 32 位或 64 位计算机</p>
<p>you're almost certainly using one right now.</p>
<p>你现在用的电脑几乎肯定是其中一种</p>
<p>What this means is that they operate in chunks of 32 or 64 bits.</p>
<p>意思是一块块处理数据，每块是 32 位或 64 位</p>
<p>That's a lot of bits!</p>
<p>这可是很多位</p>
<p>The largest number you can represent with 32 bits is just under 4.3 billion.</p>
<p>32 位能表示的最大数，是 43 亿左右</p>
<p>Which is thirty-two 1's in binary.</p>
<p>也就是 32 个 1</p>
<p>This is why our Instagram photos are so smooth and pretty</p>
<p>所以 Instagram 照片很清晰</p>
<p>they are composed of millions of colors,</p>
<p>它们有上百万种颜色</p>
<p>because computers today use 32-bit color graphics</p>
<p>因为如今都用 32 位颜色</p>
<p>Of course, not everything is a positive number</p>
<p>当然，不是所有数都是正数</p>
<p>like my bank account in college.</p>
<p>比如我上大学时的银行账户 T_T</p>
<p>So we need a way to represent positive and negative numbers.</p>
<p>我们需要有方法表示正数和负数</p>
<p>Most computers use the first bit for the sign:</p>
<p>大部分计算机用第一位表示正负：</p>
<p>1 for negative, 0 for positive numbers,</p>
<p>1 是负，0 是正</p>
<p>and then use the remaining 31 bits for the number itself.</p>
<p>用剩下 31 位来表示符号外的数值</p>
<p>That gives us a range of roughly plus or minus two billion.</p>
<p>能表示的数的范围大约是正 20 亿到负 20 亿</p>
<p>While this is a pretty big range of numbers, it's not enough for many tasks.</p>
<p>虽然是很大的数，但许多情况下还不够用</p>
<p>There are 7 billion people on the earth, and the US national debt is almost 20 trillion dollars after all.</p>
<p>全球有 70 亿人口，美国国债近 20 万亿美元</p>
<p>This is why 64-bit numbers are useful.</p>
<p>所以 64 位数很有用</p>
<p>The largest value a 64-bit number can represent is around 9.2 quintillion!</p>
<p>64 位能表达最大数大约是 9.2×10 ^ 18</p>
<p>That's a lot of possible numbers and will hopefully stay above the US national debt for a while!</p>
<p>希望美国国债在一段时间内不会超过这个数！</p>
<p>Most importantly, as we'll discuss in a later episode,</p>
<p>重要的是（我们之后的视频会深入讲）</p>
<p>computers must label locations in their memory,</p>
<p>计算机必须给内存中每一个位置，做一个 "标记"</p>
<p>known as addresses, in order to store and retrieve values.</p>
<p>这个标记叫 "地址", 目的是为了方便存取数据</p>
<p>As computer memory has grown to gigabytes and terabytes that's trillions of bytes</p>
<p>如今硬盘已经增长到 GB 和 TB，上万亿个字节！</p>
<p>it was necessary to have 64-bit memory addresses as well.</p>
<p>内存地址也应该有 64 位</p>
<p>In addition to negative and positive numbers,</p>
<p>除了负数和正数，计算机也要处理非整数</p>
<p>computers must deal with numbers that are not whole numbers,</p>
<p>除了负数和正数，计算机也要处理非整数</p>
<p>like 12.7 and 3.14, or maybe even stardate: 43989.1.</p>
<p>比如 12.7 和 3.14，或"星历 43989.1"</p>
<p>These are called "floating point" numbers,</p>
<p>这叫浮点数</p>
<p>because the decimal point can float around in the middle of number.</p>
<p>因为小数点可以在数字间浮动</p>
<p>Several methods have been developed to represent floating point numbers.</p>
<p>有好几种方法表示浮点数</p>
<p>The most common of which is the IEEE 754 standard.</p>
<p>最常见的是 IEEE 754 标准</p>
<p>And you thought historians were the only people bad at naming things!</p>
<p>你以为只有历史学家取名很烂吗？</p>
<p>In essence, this standard stores decimal values sort of like scientific notation.</p>
<p>它用类似科学计数法的方法，来存十进制值</p>
<p>For example, 625.9 can be written as 0.6259 x 10^3.</p>
<p>例如，625.9 可以写成 0.6259×10 ^ 3</p>
<p>There are two important numbers here: the .6259 is called the significand.</p>
<p>这里有两个重要的数：.6259 叫 "有效位数" , 3 是指数</p>
<p>And 3 is the exponent.</p>
<p>这里有两个重要的数：.6259 叫 "有效位数" , 3 是指数</p>
<p>In a 32-bit floating point number,</p>
<p>在 32 位浮点数中</p>
<p>the first bit is used for the sign of the number -positive or negative.</p>
<p>第 1 位表示数的符号——正或负</p>
<p>The next 8 bits are used to store the exponent</p>
<p>接下来 8 位存指数</p>
<p>and the remaining 23 bits are used to store the significand.</p>
<p>剩下 23 位存有效位数</p>
<p>Ok, we've talked a lot about numbers, but your name is probably composed of letters,</p>
<p>好了，聊够数了，但你的名字是字母组成的</p>
<p>so it's really useful for computers to also have a way to represent text.</p>
<p>所以我们也要表示文字</p>
<p>However, rather than have a special form of storage for letters,</p>
<p>与其用特殊方式来表示字母，</p>
<p>computers simply use numbers to represent letters.</p>
<p>计算机可以用数表示字母</p>
<p>The most straightforward approach might be to simply number the letters of the alphabet:</p>
<p>最直接的方法是给字母编号：</p>
<p>A being 1, B being 2, C 3, and so on.</p>
<p>A是1，B是2，C是3，以此类推</p>
<p>In fact, Francis Bacon, the famous English writer,</p>
<p>著名英国作家弗朗西斯·培根（Francis Bacon）</p>
<p>used five-bit sequences to encode all 26 letters of the English alphabet</p>
<p>曾用 5位序列来编码英文的 26 个字母</p>
<p>to send secret messages back in the 1600s.</p>
<p>在十六世纪传递机密信件</p>
<p>And five bits can store 32 possible values so that's enough for the 26 letters,</p>
<p>五位（bit）可以存 32 个可能值（2^5） 这对26个字母够了</p>
<p>but not enough for punctuation, digits, and upper and lower case letters.</p>
<p>但不能表示标点符号，数字和大小写字母</p>
<p>Enter ASCII, the American Standard Code for Information Interchange.</p>
<p>ASCII，美国信息交换标准代码</p>
<p>Invented in 1963, ASCII was a 7-bit code, enough to store 128 different values.</p>
<p>发明于 1963 年，ASCII 是 7 位代码，足够存 128 个不同值</p>
<p>With this expanded range, it could encode capital letters, lowercase letters,</p>
<p>范围扩大之后，可以表示大写字母，小写字母,</p>
<p>digits 0 through 9, and symbols like the @ sign and punctuation marks.</p>
<p>数字 0 到 9, @ 这样的符号, 以及标点符号</p>
<p>For example, a lowercase 'a' is represented by the number 97, while a capital 'A' is 65.</p>
<p>举例，小写字母 a 用数字 97 表示，大写字母 A 是 65</p>
<p>A colon is 58 and a closed parenthesis is 41.</p>
<p>: 是58 ，) 是41</p>
<p>ASCII even had a selection of special command codes,</p>
<p>ASCII 甚至有特殊命令符号</p>
<p>such as a newline character to tell the computer where to wrap a line to the next row.</p>
<p>比如换行符，用来告诉计算机换行</p>
<p>In older computer systems,</p>
<p>在老计算机系统中</p>
<p>the line of text would literally continue off the edge of the screen if you didn't include a new line character!</p>
<p>如果没换行符，文字会超出屏幕</p>
<p>Because ASCII was such an early standard,</p>
<p>因为 ASCII 是个很早的标准</p>
<p>it became widely used,</p>
<p>所以它被广泛使用</p>
<p>and critically, allowed different computers built by different companies to exchange data.</p>
<p>让不同公司制作的计算机，能互相交换数据</p>
<p>This ability to universally exchange information is called "interoperability".</p>
<p>这种通用交换信息的能力叫 "互操作性"</p>
<p>However, it did have a major limitation: it was really only designed for English.</p>
<p>但有个限制：它是为英语设计的</p>
<p>Fortunately, there are 8 bits in a byte, not 7,</p>
<p>幸运的是，一个字节有8位，而不是7位</p>
<p>and it soon became popular to use codes 128 through 255,</p>
<p>128 到 255 的字符渐渐变得常用</p>
<p>previously unused, for "national" characters.</p>
<p>这些字符以前是空的，是给各个国家自己  "保留使用的"</p>
<p>In the US, those extra numbers were largely used to encode additional symbols,</p>
<p>在美国，这些额外的数字主要用于编码附加符号</p>
<p>like mathematical notation, graphical elements, and common accented characters.</p>
<p>比如数学符号，图形元素和常用的重音字符</p>
<p>On the other hand, while the Latin characters were used universally,</p>
<p>另一方面，虽然拉丁字符被普遍使用</p>
<p>Russian computers used the extra codes to encode Cyrillic characters,</p>
<p>在俄罗斯，他们用这些额外的字符表示西里尔字符</p>
<p>and Greek computers, Greek letters, and so on.</p>
<p>而希腊电脑用希腊字母，等等</p>
<p>And national character codes worked pretty well for most countries.</p>
<p>这些保留下来给每个国家自己安排的空位，对大部分国家都够用</p>
<p>The problem was,</p>
<p>问题是</p>
<p>if you opened an email written in Latvian on a Turkish computer,</p>
<p>如果在土耳其电脑上打开拉脱维亚语写的电子邮件</p>
<p>the result was completely incomprehensible.</p>
<p>会显示乱码</p>
<p>And things totally broke with the rise of computing in Asia,</p>
<p>随着计算机在亚洲兴起，这种做法彻底失效了</p>
<p>as languages like Chinese and Japanese have thousands of characters.</p>
<p>中文和日文这样的语言有数千个字符</p>
<p>There was no way to encode all those characters in 8-bits!</p>
<p>根本没办法用 8 位来表示所有字符！</p>
<p>In response, each country invented multi-byte encoding schemes,</p>
<p>为了解决这个问题，每个国家都发明了多字节编码方案</p>
<p>all of which were mutually incompatible.</p>
<p>但相互不兼容</p>
<p>The Japanese were so familiar with this encoding problem that they had a special name for it:</p>
<p>日本人总是碰到编码问题，以至于专门有词来称呼：</p>
<p>"mojibake", which means "scrambled text".</p>
<p>"mojibake" 意思是乱码</p>
<p>And so it was born Unicode one format to rule them all.</p>
<p>所以 Unicode 诞生了统一所有编码的标准</p>
<p>Devised in 1992 to finally do away with all of the different international schemes</p>
<p>设计于 1992 年，解决了不同国家不同标准的问题</p>
<p>it replaced them with one universal encoding scheme.</p>
<p>Unicode 用一个统一编码方案</p>
<p>The most common version of Unicode uses 16 bits with space for over a million codes -</p>
<p>最常见的 Unicode 是 16 位的，有超过一百万个位置 -</p>
<p>enough for every single character from every language ever used</p>
<p>对所有语言的每个字符都够了</p>
<p>more than 120,000 of them in over 100 types of script</p>
<p>100 多种字母表加起来占了 12 万个位置。</p>
<p>plus space for mathematical symbols and even graphical characters like Emoji.</p>
<p>还有位置放数学符号，甚至 Emoji</p>
<p>And in the same way that ASCII defines a scheme for encoding letters as binary numbers,</p>
<p>就像 ASCII 用二进制来表示字母一样</p>
<p>other file formats like MP3s or GIFs -</p>
<p>其他格式比如 MP3 或 GIF  -</p>
<p>use binary numbers to encode sounds or colors of a pixel in our photos, movies, and music.</p>
<p>用二进制编码声音/颜色，表示照片,电影,音乐</p>
<p>Most importantly, under the hood it all comes down to long sequences of bits.</p>
<p>重要的是，这些标准归根到底是一长串位</p>
<p>Text messages, this YouTube video, every webpage on the internet,</p>
<p>短信，这个 YouTube 视频，互联网上的每个网页</p>
<p>and even your computer's operating system, are nothing but long sequences of 1s and 0s.</p>
<p>甚至操作系统，只不过是一长串 1 和 0</p>
<p>So next week,</p>
<p>下周</p>
<p>we'll start talking about how your computer starts manipulating those binary sequences,</p>
<p>我们会聊计算机怎么操作二进制</p>
<p>for our first true taste of computation.</p>
<p>初尝"计算"的滋味</p>
<p>Thanks for watching. See you next week.</p>
<p>感谢观看，下周见</p>
<p>5 算术逻辑单元</p>
<p>How Computers Calculate - the ALU</p>
<p>Hi, I'm Carrie Ann and this is Crash Course Computer Science.</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课</p>
<p>So last episode, we talked about how numbers can be represented in binary.</p>
<p>上集，我们谈了如何用二进制表示数字</p>
<p>Representing Like, 00101010 is 42 in decimal.</p>
<p>比如二进制 00101010 是十进制的 42</p>
<p>Representing and storing numbers is an important function of a computer,</p>
<p>表示和存储数字是计算机的重要功能</p>
<p>but the real goal is computation, or manipulating numbers in a structured and purposeful way,</p>
<p>但真正的目标是计算，有意义的处理数字</p>
<p>like adding two numbers together.</p>
<p>比如把两个数字相加</p>
<p>These operations are handled by a computer's Arithmetic and Logic Unit,</p>
<p>这些操作由计算机的 "算术逻辑单元 "处理</p>
<p>but most people call it by its street name:</p>
<p>但大家会简称：ALU</p>
<p>the ALU.</p>
<p>但大家会简称：ALU</p>
<p>The ALU is the mathematical brain of a computer.</p>
<p>ALU 是计算机的数学大脑</p>
<p>When you understand an ALU's design and function,</p>
<p>等你理解了 ALU 的设计和功能之后</p>
<p>you'll understand a fundamental part of modern computers.</p>
<p>你就理解了现代计算机的基石</p>
<p>It is THE thing that does all of the computation in a computer,</p>
<p>ALU *就是* 计算机里负责运算的组件，</p>
<p>so basically everything uses it.</p>
<p>基本其他所有部件都用到了它</p>
<p>First though, look at this beauty.</p>
<p>先来看看这个美人</p>
<p>This is perhaps the most famous ALU ever, the Intel 74181.</p>
<p>这可能是最著名的 ALU，英特尔 74181</p>
<p>When it was released in 1970,</p>
<p>1970 年发布时，它是第一个封装在单个芯片内的完整 ALU</p>
<p>it was It was the first complete ALU that fit entirely inside of a single chip -</p>
<p>1970 年发布时，它是第一个封装在单个芯片内的完整 ALU</p>
<p>Which was a huge engineering feat at the time.</p>
<p>这在当时是惊人的工程壮举</p>
<p>So today we're going to take those Boolean logic gates we learned about last week</p>
<p>今天我们用上周学的布尔逻辑门</p>
<p>to build a simple ALU circuit with much of the same functionality as the 74181.</p>
<p>做一个简单的 ALU 电路，功能和 74181 一样</p>
<p>And over the next few episodes we'll use this to construct a computer from scratch.</p>
<p>然后接下来几集，用它从头做出一台电脑</p>
<p>So it's going to get a little bit complicated,</p>
<p>所以会有点复杂</p>
<p>but I think you guys can handle it.</p>
<p>但我觉得你们搞的定</p>
<p>An ALU is really two units in one</p>
<p>ALU 有 2 个单元，</p>
<p>there's an arithmetic unit and a logic unit.</p>
<p>1 个算术单元和 1 个逻辑单元</p>
<p>Let's start with the arithmetic unit,</p>
<p>我们先讲"算术单元"，</p>
<p>which is responsible for handling all numerical operations in a computer,</p>
<p>它负责计算机里的所有数字操作</p>
<p>like addition and subtraction.</p>
<p>比如加减法</p>
<p>It also does a bunch of other simple things like add one to a number,</p>
<p>它还做很多其他事情，比如给某个数字+1</p>
<p>which is called an increment operation, but we'll talk about those later.</p>
<p>这叫增量运算，我们之后会说</p>
<p>Today, we're going to focus on the piece of rsistance, the crme de la crme of operations</p>
<p>今天的重点是一切的根本 </p>
<p>that underlies almost everything else a computer does adding two numbers together.</p>
<p>"把两个数字相加"</p>
<p>We could build this circuit entirely out of individual transistors,</p>
<p>我们可以用单个晶体管一个个拼，把这个电路做出来，</p>
<p>but that would get confusing really fast.</p>
<p>但很快就会复杂的难以理解</p>
<p>So instead as we talked about in Episode 3</p>
<p>所以与其用晶体管，我们会像第 3 集</p>
<p>we can use a high-level of abstraction and build our components out of logic gates,</p>
<p>用更高层的抽象，用逻辑门来做</p>
<p>in this case: AND, OR, NOT and XOR gates.</p>
<p>我们会用到 AND，OR，NOT 和 XOR 逻辑门</p>
<p>The simplest adding circuit that we can build takes two binary digits, and adds them together.</p>
<p>最简单的加法电路，是拿 2 个 bit 加在一起（bit 是 0 或 1）</p>
<p>So we have two inputs, A and B, and one output, which is the sum of those two digits.</p>
<p>有 2 个输入：A 和 B，1 个输出：就是两个数字的和</p>
<p>Just to clarify: A, B and the output are all single bits.</p>
<p>需要注意的是：A, B, 输出，这3个都是单个 Bit （ 0 或 1 ）</p>
<p>There are only four possible input combinations.</p>
<p>输入只有四种可能</p>
<p>The first three are: 0+0 = 0</p>
<p>前三个是，0 + 0 = 0</p>
<p>1+0 = 1 0+1 = 1</p>
<p>1 + 0 = 1，0 + 1 = 1</p>
<p>Remember that in binary, 1 is the same as true, and 0 is the same as false.</p>
<p>记住二进制里，1 与 true 相同，0 与 false 相同</p>
<p>So this set of inputs exactly matches the boolean logic of an XOR gate,</p>
<p>这组输入和输出，和 XOR 门的逻辑完全一样</p>
<p>and we can use it as our 1-bit adder.</p>
<p>所以我们可以把 XOR 用作 1 位加法器（adder）</p>
<p>But the fourth input combination, 1 + 1, is a special case. 1 + 1 is 2 (obviously)</p>
<p>但第四个输入组合，1+1，是个特例，1+1=2（显然）</p>
<p>but there's no 2 digit in binary,</p>
<p>但二进制里没有 2</p>
<p>so as we talked about last episode, the result is 0 and the 1 is carried to the next column.</p>
<p>上集说过，二进制 1+1 的结果是0，1进到下一位</p>
<p>So the sum is really 10 in binary.</p>
<p>和是 10 (二进制)</p>
<p>Now, the output of our XOR gate is partially correct 1 plus 1, outputs 0.</p>
<p>XOR 门的输出，只对了一部分，1+1 输出 0</p>
<p>But, we need an extra output wire for that carry bit.</p>
<p>但我们需要一根额外的线代表 "进位"</p>
<p>The carry bit is only "true" when the inputs are 1 AND 1,</p>
<p>只有输入是 1 和 1 时，进位才是 "true"</p>
<p>because that's the only time when the result (two) is bigger than 1 bit can store</p>
<p>因为算出来的结果用 1 个 bit 存不下</p>
<p>and conveniently we have a gate for that!</p>
<p>方便的是，我们刚好有个逻辑门能做这个事！</p>
<p>It's not that complicated just two logic gates -</p>
<p>没那么复杂就两个逻辑门而已</p>
<p>but let's abstract away even this level of detail</p>
<p>让我们抽象化</p>
<p>and encapsulate our newly minted half adder as its own component,</p>
<p>把 "半加器" 封装成一个单独组件</p>
<p>with two inputs bits A and B and two outputs, the sum and the carry bits.</p>
<p>两个输入   A 和 B 都是 1 位，两个输出  "总和" 与 "进位"</p>
<p>This takes us to another level of abstraction</p>
<p>这进入了另一层抽象</p>
<p>heh I feel like I say that a lot.</p>
<p>我好像说了很多次，</p>
<p>I wonder if this is going to become a thing.</p>
<p>说不定会变成一个梗</p>
<p>Anyway, If you want to add more than 1 + 1</p>
<p>如果想处理超过 1+1 的运算，</p>
<p>we're going to need a "Full Adder."</p>
<p>我们需要"全加器"</p>
<p>That half-adder left us with a carry bit as output.</p>
<p>半加器输出了进位</p>
<p>That means that when we move on to the next column in a multi-column addition,</p>
<p>意味着，我们算下一列的时候</p>
<p>and every column after that, we are going to have to add three bits together, no two.</p>
<p>还有之后的每一列，我们得加 3 个位在一起，并不是 2 个</p>
<p>A full adder is a bit more complicated</p>
<p>全加器复杂了一点点</p>
<p>it takes three bits as inputs: A, B and C.</p>
<p>有 3 个输入：A, B, C （都是 1 个 bit)</p>
<p>So the maximum possible input is 1 + 1 + 1,</p>
<p>所以最大的可能是 1 + 1 + 1</p>
<p>which equals 1 carry out 1, so we still only need two output wires: sum and carry.</p>
<p>"总和"1 "进位"1，所以要两条输出线： "总和"和"进位"</p>
<p>We can build a full adder using half adders.</p>
<p>我们可以用半加器做 全加器</p>
<p>To do this, we use a half adder to add A plus B</p>
<p>我们先用半加器将 A 和 B 相加</p>
<p>just like before but then feed that result and input C into a second half adder.</p>
<p>然后把 C 输入到第二个半加器</p>
<p>Lastly, we need a OR gate to check if either one of the carry bits was true.</p>
<p>最后用一个 OR 门检查进位是不是 true</p>
<p>That's it, we just made a full adder!</p>
<p>这样就做出了一个全加器！</p>
<p>Again,we can go up a level of abstraction and wrap up this full adder as its own component.</p>
<p>我们可以再提升一层抽象，把全加器作为独立组件</p>
<p>It takes three inputs, adds them, and outputs the sum and the carry, if there is one.</p>
<p>全加器会把 A，B，C 三个输入加起来，输出 "总和" 和 "进位"</p>
<p>Armed with our new components, we can now build a circuit that takes two, 8-bit numbers</p>
<p>现在有了新组件，我们可以相加两个 8 位数字</p>
<p>Let's call them A and B  and adds them together.</p>
<p>叫两个数字叫 A 和 B 好了</p>
<p>Let's start with the very first bit of A and B,</p>
<p>我们从 A  和 B 的第一位开始</p>
<p>which we'll call A0 and B0.</p>
<p>叫 A0 和 B0 好了</p>
<p>At this point, there is no carry bit to deal with,</p>
<p>现在不用处理任何进位，</p>
<p>because this is our first addition.</p>
<p>因为是第一次加法</p>
<p>So we can use our half adder to add these two bits together.</p>
<p>所以我们可以用半加器，来加这2个数字</p>
<p>The output is sum0.</p>
<p>输出叫 sum0</p>
<p>Now we want to add A1 and B1 together.</p>
<p>现在加 A1 和 B1</p>
<p>It's possible there was a carry from the previous addition of A0 and B0,</p>
<p>因为 A0 和 B0 的结果有可能进位</p>
<p>so this time we need to use a full adder that also inputs the carry bit.</p>
<p>所以这次要用全加器，除了 A1 和 B1，还要连上进位</p>
<p>We output this result as sum1.</p>
<p>输出叫 sum1</p>
<p>Then, we take any carry from this full adder,</p>
<p>然后，把这个全加器的进位，</p>
<p>and run it into the next full adder that handles A2 and B2.</p>
<p>连到下个全加器的输入，处理 A2 和 B2</p>
<p>And we just keep doing this in a big chain until all 8 bits have been added.</p>
<p>以此类推，把 8 个 bit 都搞定</p>
<p>Notice how the carry bits ripple forward to each subsequent adder.</p>
<p>注意每个进位是怎么连到下一个全加器的</p>
<p>For this reason, this is called an 8-bit ripple carry adder.</p>
<p>所以叫 "8位行波进位加法器"</p>
<p>Notice how our last full adder has a carry out.</p>
<p>注意最后一个全加器有 "进位" 的输出</p>
<p>If there is a carry into the 9th bit, it means the sum of the two numbers is too large to fit into 8-bits.</p>
<p>如果第 9 位有进位，代表着 2 个数字的和太大了，超过了 8 位</p>
<p>This is called an overflow.</p>
<p>这叫 "溢出" (overflow)</p>
<p>In general, an overflow occurs when the result of an addition is too large</p>
<p>一般来说 "溢出" 的意思是, 两个数字的和太大了</p>
<p>to be represented by the number of bits you are using.</p>
<p>超过了用来表示的位数</p>
<p>This can usually cause errors and unexpected behavior.</p>
<p>这会导致错误和不可预期的结果</p>
<p>Famously, the original PacMan arcade game used 8 bits to keep track of what level you were on.</p>
<p>著名的例子是，吃豆人用 8 位存当前关卡数</p>
<p>This meant that if you made it past level 255 the largest number storablein 8 bits to level 256,</p>
<p>如果你玩到了第 256 关（ 8 位 bit 最大表示 255）</p>
<p>the ALU overflowed.</p>
<p>ALU 会溢出</p>
<p>This caused a bunch of errors and glitches making the level unbeatable.</p>
<p>造成一连串错误和乱码，使得该关卡无法进行</p>
<p>The bug became a rite of passage for the greatest PacMan players.</p>
<p>这个 bug 成了厉害吃豆人玩家的代表</p>
<p>So if we want to avoid overflows,</p>
<p>如果想避免溢出</p>
<p>we can extend our circuit with more full adders, allowing us to add 16 or 32 bit numbers.</p>
<p>我们可以加更多全加器，可以操作 16 或 32 位数字</p>
<p>This makes overflows less likely to happen, but at the expense of more gates.</p>
<p>让溢出更难发生，但代价是更多逻辑门</p>
<p>An additional downside is that it takes a little bit of time for each of the carries to ripple forward.</p>
<p>另外一个缺点是，每次进位都要一点时间</p>
<p>Admittedly, not very much time, electrons move pretty fast,</p>
<p>当然时间不久，因为电子移动的很快</p>
<p>so we're talking about billionths of a second,</p>
<p>但如今的量级是每秒几十亿次运算，</p>
<p>but that's enough to make a difference in today's fast computers.</p>
<p>所以会造成影响</p>
<p>For this reason, modern computers use a slightly different adding circuit</p>
<p>所以，现代计算机用的加法电路有点不同</p>
<p>called a 'carry-look-ahead' adder</p>
<p>叫 "超前进位加法器"</p>
<p>which is faster, but ultimately does exactly the same thing</p>
<p>它更快，做的事情是一样的 </p>
<p>adds binary numbers.</p>
<p>把二进制数相加</p>
<p>The ALU's arithmetic unit also has circuits for other math operations</p>
<p>ALU 的算术单元，也能做一些其他数学运算</p>
<p>and in general these 8 operations are always supported.</p>
<p>一般支持这 8 个操作</p>
<p>And like our adder, these other operations are built from individual logic gates.</p>
<p>就像加法器一样，这些操作也是由逻辑门构成的</p>
<p>Interestingly, you may have noticed that there are no multiply and divide operations.</p>
<p>有趣的是，你可能注意到没有乘法和除法</p>
<p>That's because simple ALUs don't have a circuit for this,</p>
<p>因为简单的 ALU 没有专门的电路来处理</p>
<p>and instead just perform a series of additions.</p>
<p>而是把乘法用多次加法来实现</p>
<p>Let's say you want to multiply 12 by 5.</p>
<p>假设想算 12x5</p>
<p>That's the same thing as adding 12 to itself 5 times.</p>
<p>这和把 "12" 加 5 次是一样的</p>
<p>So it would take 5 passes through the ALU to do this one multiplication.</p>
<p>所以要 5 次 ALU 操作来实现这个乘法</p>
<p>And this is how many simple processors,</p>
<p>很多简单处理器都是这样做的</p>
<p>like those in your thermostat, TV remote, and microwave, do multiplication.</p>
<p>比如恒温器，电视遥控器和微波炉</p>
<p>It's slow, but it gets the job done.</p>
<p>慢是慢，但是搞的定</p>
<p>However, fancier processors, like those in your laptop or smartphone,</p>
<p>然而笔记本和手机有更好的处理器</p>
<p>have arithmetic units with dedicated circuits for multiplication.</p>
<p>有专门做乘法的算术单元</p>
<p>And as you might expect, the circuit is more complicated than addition</p>
<p>你可能猜到了，乘法电路比加法复杂</p>
<p>there's no magic, it just takes a lot more logic gates</p>
<p>没什么魔法，只是更多逻辑门</p>
<p>which is why less expensive processors don't have this feature.</p>
<p>所以便宜的处理器没有.</p>
<p>Ok, let's move on to the other half of the ALU:</p>
<p>好了，我们现在讲 ALU 的另一半：</p>
<p>the Logic Unit.</p>
<p>逻辑单元</p>
<p>Instead of arithmetic operations, the Logic Unit performs well...</p>
<p>逻辑单元执行逻辑操作</p>
<p>logical operations, like AND, OR and NOT, which we've talked about previously.</p>
<p>比如之前讨论过的 AND，OR 和 NOT 操作</p>
<p>It also performs simple numerical tests,</p>
<p>它也能做简单的数值测试</p>
<p>like checking if a number is negative.</p>
<p>比如一个数字是不是负数</p>
<p>For example, here's a circuit that tests if the output of the ALU is zero.</p>
<p>例如，这是检查 ALU 输出是否为 0 的电路</p>
<p>It does this using a bunch of OR gates to see if any of the bits are 1.</p>
<p>它用一堆 OR 门检查其中一位是否为 1</p>
<p>Even if one single bit is 1,</p>
<p>哪怕只有一个 Bit (位) 是1，</p>
<p>we know the number can't be zero and then we use a final NOT gate to flip this input</p>
<p>我们就知道那个数字肯定不是 0，然后用一个 NOT 门取反</p>
<p>so the output is 1 only if the input number is 0.</p>
<p>所以只有输入的数字是 0，输出才为 1</p>
<p>So that's a high level overview of what makes up an ALU.</p>
<p>以上就是 ALU 的一个高层次概括</p>
<p>We even built several of the main components from scratch, like our ripple adder.</p>
<p>我们甚至从零做了几个主要组件，比如行波进位加法器</p>
<p>As you saw, it's just a big bunch of logic gates connected in clever ways.</p>
<p>它们只是一大堆逻辑门巧妙的连在一起而已.</p>
<p>Which brings us back to that ALU you admired so much at the beginning of the episode.</p>
<p>让我们回到视频开始时的 ALU，</p>
<p>The Intel 74181.</p>
<p>英特尔 74181</p>
<p>Unlike the 8-bit ALU we made today, the 74181 could only handle 4-bit inputs,</p>
<p>和我们刚刚做的 8 位 ALU 不同，74181 只能处理 4 位输入</p>
<p>which means</p>
<p>也就是说</p>
<p>YOU BUILT AN ALU THAT'S LIKE TWICE AS GOOD AS THAT SUPER FAMOUS ONE. WITH YOUR MIND!</p>
<p>你刚做了一个比英特尔 74181 还好的 ALU ！</p>
<p>Well.. sort of.</p>
<p>其实差不多啦..</p>
<p>We didn't build the whole thing</p>
<p>我们虽然没有全部造出来</p>
<p>but you get the idea.</p>
<p>但你理解了整体概念</p>
<p>The 74181 used about 70 logic gates, and it couldn't multiply or divide.</p>
<p>74181 用了大概 70 个逻辑门，但不能执行乘除.</p>
<p>But it was a huge step forward in miniaturization,</p>
<p>但它向小型化迈出了一大步</p>
<p>opening the doors to more capable and less expensive computers.</p>
<p>让计算机可以更强大更便宜</p>
<p>This 4-bit ALU circuit is already a lot to take in,</p>
<p>4 位 ALU 已经要很多逻辑门了</p>
<p>but our 8-bit ALU would require hundreds of logic gates to fully build</p>
<p>但我们的 8 位 ALU 会需要数百个逻辑门</p>
<p>and engineers don't want to see all that complexity when using an ALU,</p>
<p>工程师不想在用 ALU 时去想那些事情,</p>
<p>so they came up with a special symbol to wrap it all up, which looks like a big V'.</p>
<p>所以想了一个特殊符号来代表它，看起来像一个大 "V"</p>
<p>Just another level of abstraction!</p>
<p>又一层抽象！</p>
<p>Our 8-bit ALU has two inputs, A and B, each with 8 bits.</p>
<p>我们的 8 位  ALU 有两个输入，A和B，都是 8 位 (bits)</p>
<p>We also need a way to specify what operation the ALU should perform,</p>
<p>我们还需要告诉 ALU 执行什么操作</p>
<p>for example, addition or subtraction.</p>
<p>例如加法或减法</p>
<p>For that, we use a 4-bit operation code.</p>
<p>所以我们用 4 位的操作代码</p>
<p>We'll talk about this more in a later episode,</p>
<p>我们之后的视频会再细说</p>
<p>but in brief, 1000 might be the command to add, while 1100 is the command for subtract.</p>
<p>简言之,"1000"可能代表加法命令，"1100"代表减法命令</p>
<p>Basically, the operation code tells the ALU what operation to perform.</p>
<p>操作代码告诉 ALU 执行什么操作</p>
<p>And the result of that operation on inputs A and B is an 8-bit output.</p>
<p>输出结果是 8 位的</p>
<p>ALUs also output a series of Flags,</p>
<p>ALU 还会输出一堆标志（Flag）</p>
<p>which are 1-bit outputs for particular states and statuses.</p>
<p>"标志"是1位的，代表特定状态.</p>
<p>For example, if we subtract two numbers, and the result is 0,</p>
<p>比如相减两个数字，结果为 0</p>
<p>our zero-testing circuit, the one we made earlier, sets the Zero Flag to True (1).</p>
<p>我们的零测试电路（前面做的），会将零标志设为 True（1）</p>
<p>This is useful if we are trying to determine if two numbers are are equal.</p>
<p>如果想知道两个数字是否相等，这个非常有用</p>
<p>If we wanted to test if A was less than B,</p>
<p>如果想知道： A 是否小于 B</p>
<p>we can use the ALU to calculate A subtract B and look to see if the Negative Flag was set to true.</p>
<p>可以用 ALU 来算 A 减 B，看负标志是否为 true</p>
<p>If it was, we know that A was smaller than B.</p>
<p>如果是 true，我们就知道 A 小于 B</p>
<p>And finally, there's also a wire attached to the carry out on the adder we built,</p>
<p>最后，还有一条线连到加法器的进位</p>
<p>so if there is an overflow, we'll know about it.</p>
<p>如果有溢出，我们就知道</p>
<p>This is called the Overflow Flag.</p>
<p>这叫溢出标志</p>
<p>Fancier ALUs will have more flags,</p>
<p>高级 ALU 有更多标志</p>
<p>but these three flags are universal and frequently used.</p>
<p>但这 3 个标志是 ALU 普遍用的</p>
<p>In fact, we'll be using them soon in a future episode.</p>
<p>其实，我们之后的视频会用到它们</p>
<p>So now you know how your computer does all its basic mathematical operations digitally</p>
<p>现在你知道了，计算机是怎样在没有齿轮或杠杆的情况下 </p>
<p>with no gears or levers required.</p>
<p>进行运算</p>
<p>We're going to use this ALU when we construct our CPU two episodes from now.</p>
<p>接下来两集我们会用 ALU 做 CPU</p>
<p>But before that, our computer is going to need some memory!</p>
<p>但在此之前，计算机需要一些 "记忆" ！</p>
<p>We'll talk about that next week.</p>
<p>我们下周会讲</p>
<p>6 寄存器&内存</p>
<p>Registers and RAM</p>
<p>Hi, I'm Carrie Anne and welcome to Crash Course Computer Science.</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课</p>
<p>So last episode, using just logic gates, we built a simple ALU,</p>
<p>上集，我们用逻辑门做了个简单 ALU</p>
<p>which performs arithmetic and logic operations, hence the 'A' and the 'L'.</p>
<p>它能执行算术(Arithmetic)和逻辑(Logic)运算，ALU 里的 A 和 L 因此得名</p>
<p>But of course, there's not much point in calculating a result only to throw it away</p>
<p>当然，算出来之后如果扔掉就没什么意义了</p>
<p>it would be useful to store that value somehow,</p>
<p>得找个方法存起来</p>
<p>and maybe even run several operations in a row.</p>
<p>可能还要进行多个连续操作</p>
<p>That's where computer memory comes in!</p>
<p>这就用到计算机内存了</p>
<p>If you've ever been in the middle of a long RPG campaign on your console,</p>
<p>如果你在主机上打过一场长时间的对局</p>
<p>or slogging through a difficult level on Minesweeper on your desktop,</p>
<p>或玩困难模式的 "扫雷"</p>
<p>and your dog came by, tripped and pulled the power cord out of the wall,</p>
<p>然后狗跑过来，被电源线绊倒，把插头拔了出来</p>
<p>you know the agony of losing all your progress.</p>
<p>你知道失去进度的痛苦</p>
<p>Condolences.</p>
<p>真同情你 :</p>
<p>But the reason for your loss is that your console, your laptop and your computers</p>
<p>你损失数据的原因是，</p>
<p>make use of Random Access Memory, or RAM,</p>
<p>电脑用的是"随机存取存储器"，简称"RAM"</p>
<p>which stores things like game state as long as the power stays on.</p>
<p>它只能在有电的情况下存储东西，比如游戏状态</p>
<p>Another type of memory, called persistent memory, can survive without power,</p>
<p>另一种存储 (memory) 叫持久存储，电源关闭时数据也不会丢失</p>
<p>and it's used for different things;</p>
<p>它用来存其他东西.</p>
<p>We'll talk about the persistence of memory in a later episode.</p>
<p>我们之后会讨论存储 (memory) 的持久性问题</p>
<p>Today, we're going to start small</p>
<p>今天我们从简单开始</p>
<p>literally by building a circuit that can store one.. single.. bit of information.</p>
<p>做只能存储 1 位的电路</p>
<p>After that, we'll scale up, and build our very own memory module,</p>
<p>之后再扩大，做出我们的内存模块</p>
<p>and we'll combine it with our ALU next time, when we finally build our very own CPU!</p>
<p>下次和 ALU 结合起来，做出 CPU！</p>
<p>All of the logic circuits we've discussed so far go in one direction</p>
<p>我们至今说过的电路都是单向的</p>
<p>always flowing forward.</p>
<p>总是向前流动</p>
<p>like our 8-bit ripple adder from last episode.</p>
<p>比如上集的 8 位 "脉动进位加法器"</p>
<p>But we can also create circuits that loop back on themselves.</p>
<p>但也可以做回向电路，把输出连回输入</p>
<p>Let's try taking an ordinary OR gate, and feed the output back into one of its inputs</p>
<p>我们拿一个 OR 门试试，把输出连回输入</p>
<p>and see what happens.</p>
<p>看看会发生什么</p>
<p>First, let's set both inputs to 0.</p>
<p>首先，两个输入都设为 0</p>
<p>So 0 OR 0 is 0, and so this circuit always outputs 0.</p>
<p>"0 OR 0" 是 0，所以电路输出0</p>
<p>If we were to flip input A to 1.</p>
<p>如果将 A 变成1</p>
<p>1 OR 0 is 1, so now the output of the OR gate is 1.</p>
<p>"1 OR 0" 为 1，所以输出 1</p>
<p>A fraction of a second later, that loops back around into input B,</p>
<p>一转眼的功夫，输出回到 B</p>
<p>so the OR gate sees that both of its inputs are now 1.</p>
<p>OR 门看到两个输入都是 1</p>
<p>1 OR 1 is still 1, so there is no change in output.</p>
<p>"1 OR 1" 仍然为1，所以输出不变</p>
<p>If we flip input A back to 0, the OR gate still outputs 1.</p>
<p>如果将 A 变成 0，OR 门依然输出 1</p>
<p>So now we've got a circuit that records a "1" for us.</p>
<p>现在我们有个电路能记录 "1"</p>
<p>Except, we've got a teensy tiny problem this change is permanent!</p>
<p>然而有个小问题：这是永久的！</p>
<p>No matter how hard we try, there's no way to get this circuit to flip back from a 1 to a 0.</p>
<p>无论怎么试，都没法从 1 变回 0</p>
<p>Now let's look at this same circuit, but with an AND gate instead.</p>
<p>我们换成 AND 门看看会怎样</p>
<p>We'll start inputs A and B both at 1.</p>
<p>开始时，A 和 B 都设 1</p>
<p>1 AND 1 outputs 1 forever.</p>
<p>"1 AND 1" 永远输出 1</p>
<p>But, if we then flip input A to 0, because it's an AND gate, the output will go to 0.</p>
<p>如果之后 A 设为 0，由于是 AND 门，输出会变成 0</p>
<p>So this circuit records a 0, the opposite of our other circuit.</p>
<p>这个电路能记录 0，和之前那个相反</p>
<p>Like before, no matter what input we apply to input A afterwards, the circuit will always output 0.</p>
<p>就像之前，无论 A 设什么值，电路始终输出 0</p>
<p>Now we've got circuits that can record both 0s and 1s.</p>
<p>现在有了能存 0 和 1 的电路</p>
<p>The key to making this a useful piece of memory is to combine our two circuits into what is</p>
<p>为了做出有用的存储 (memory)，我们把两个电路结合起来</p>
<p>called the AND-OR Latch.</p>
<p>这叫 "AND-OR 锁存器"</p>
<p>It has two inputs, a "set" input, which sets the output to a 1，called the AND-OR Latch.</p>
<p>它有两个输入， "设置"输入, 把输出变成 1，称为AND-OR锁存器。</p>
<p>and a "reset" input, which resets the output to a 0.</p>
<p>"复位"输入, 把输出变成 0</p>
<p>If set and reset are both 0, the circuit just outputs whatever was last put in it.</p>
<p>如果"设置"和"复位"都是 0，电路会输出最后放入的内容</p>
<p>In other words, it remembers a single bit of information!</p>
<p>也就是说，它存住了 1 位的信息！</p>
<p>Memory!</p>
<p>存储！</p>
<p>This is called a "latch" because it "latches onto" a particular value and stays that way.</p>
<p>这叫"锁存", 因为它"锁定"了一个值</p>
<p>The action of putting data into memory is called writing, whereas getting the data out is called reading.</p>
<p>放入数据的动作叫 "写入"  ，拿出数据的动作叫 "读取"</p>
<p>Ok, so we've got a way to store a single bit of information!</p>
<p>现在我们终于有办法存一个位了！</p>
<p>Great!</p>
<p>超棒！</p>
<p>Unfortunately, having two different wires for input set and reset is a bit confusing.</p>
<p>麻烦的是, 用两条线 "设置"和"复位" 来输入, 有点难理解</p>
<p>To make this a little easier to use, we really want a single wire to input data,</p>
<p>为了更容易用，我们希望只有一条输入线</p>
<p>that we can set to either 0 or 1 to store the value.</p>
<p>将它设为 0 或 1 来存储值</p>
<p>Additionally, we are going to need a wire that enables the memory</p>
<p>还需要一根线来"启用"内存</p>
<p>to be either available for writing or "locked" down</p>
<p>启用时允许写入，没启用时就 "锁定"</p>
<p>which is called the write enable line.</p>
<p>这条线叫 "允许写入线"</p>
<p>By adding a few extra logic gates, we can build this circuit,</p>
<p>加一些额外逻辑门，可以做出这个电路</p>
<p>which is called a Gated Latch since the "gate" can be opened or closed.</p>
<p>这叫"门锁"，因为门可以打开和关上</p>
<p>Now this circuit is starting to get a little complicated.</p>
<p>现在有点复杂了</p>
<p>We don't want to have to deal with all the individual logic gates...</p>
<p>我们不想关心单独的逻辑门</p>
<p>so as before, we're going to bump up a level of abstraction,</p>
<p>所以我们提升一层抽象</p>
<p>and put our whole Gated Latch circuit in a box -a box that stores one bit.</p>
<p>把 "门锁" 放到盒子里这个盒子能存一个 bit</p>
<p>Let's test out our new component!</p>
<p>我们来测一下新组件！</p>
<p>Let's start everything at 0.</p>
<p>一切从 0 开始</p>
<p>If we toggle the Data wire from 0 to 1 or 1 to 0,</p>
<p>数据输入从0换到1, 从1换到0</p>
<p>nothing happens the output stays at 0.</p>
<p>什么也不会发生输出依然是 0</p>
<p>That's because the write enable wire is off, which prevents any change to the memory.</p>
<p>因为 "允许写入线" 是关闭的，所以内容不会变化</p>
<p>So we need to "open" the "gate" by turning the write enable wire to 1.</p>
<p>所以要给 "允许写入线" 输入 1, "打开" 门</p>
<p>Now we can put a 1 on the data line to save the value 1 to our latch.</p>
<p>现在往 "数据线" 放 1，1 就能存起来了</p>
<p>Notice how the output is now 1.</p>
<p>注意输出现在是 1 了</p>
<p>Now we can put a 1 on the data line to save the value 1 to our latch.</p>
<p>现在我们可以在数据线上加一个1，将值1保存到锁存器中。</p>
<p>Success!</p>
<p>成功！</p>
<p>We can turn off the enable line and the output stays as 1.</p>
<p>现在可以关掉  "允许写入线" ，输出会保持 1</p>
<p>Once again, we can toggle the value on the data line all we want,</p>
<p>现在不管给 "数据线" 什么值</p>
<p>but the output will stay the same.</p>
<p>输出都不会变</p>
<p>The value is saved in memory.</p>
<p>值存起来了</p>
<p>Now let's turn the enable line on again use our data line to set the latch to 0.</p>
<p>现在又打开 "允许写入线" ，"数据线" 设为0</p>
<p>Done.</p>
<p>完成</p>
<p>Enable line off, and the output is 0.</p>
<p>"允许写入线" 关闭，输出 0</p>
<p>And it works!</p>
<p>成功了！</p>
<p>Now, of course, computer memory that only stores one bit of information isn't very useful</p>
<p>当然，只能存 1 bit 没什么大用</p>
<p>definitely not enough to run Frogger.</p>
<p>肯定玩不了游戏</p>
<p>Or anything, really.</p>
<p>或做其它事情</p>
<p>But we're not limited to using only one latch.</p>
<p>但我们没限制只能用一个锁存器</p>
<p>If we put 8 latches side-by-side, we can store 8 bits of information like an 8-bit number.</p>
<p>如果我们并排放 8 个锁存器，可以存 8 位信息，比如一个 8 bit 数字</p>
<p>A group of latches operating like this is called a register,</p>
<p>一组这样的锁存器叫 "寄存器"</p>
<p>which holds a single number, and the number of bits in a register is called its width.</p>
<p>寄存器能存一个数字，这个数字有多少位，叫"位宽"</p>
<p>Early computers had 8-bit registers, then 16, 32,</p>
<p>早期电脑用 8 位寄存器，然后是 16 位，32 位</p>
<p>and today, many computers have registers that are 64-bits wide.</p>
<p>如今许多计算机都有 64 位宽的寄存器</p>
<p>To write to our register, we first have to enable all of the latches.</p>
<p>写入寄存器前，要先启用里面所有锁存器</p>
<p>We can do this with a single wire that connects to all of their enable inputs, which we set to 1.</p>
<p>我们可以用一根线连接所有 "允许输入线", 把它设为 1</p>
<p>We then send our data in using the 8 data wires, and then set enable back to 0,</p>
<p>然后用 8 条数据线发数据，然后将 "允许写入线" 设回 0</p>
<p>and the 8 bit value is now saved in memory.</p>
<p>现在 8 位的值就存起来了</p>
<p>Putting latches side-by-side works ok for a small-ish number of bits.</p>
<p>如果只有很少的位(bits)，把锁存器并排放置，也勉强够用了.</p>
<p>A 64-bit register would need 64 wires running to the data pins, and 64 wires running to the outputs.</p>
<p>64 位寄存器要 64 根数据线，64 根连到输出端</p>
<p>Luckily we only need 1 wire to enable all the latches, but that's still 129 wires.</p>
<p>幸运的是，我们只要 1 根线启用所有锁存器，但加起来也有 129 条线了</p>
<p>For 256 bits, we end up with 513 wires!</p>
<p>如果存 256 位要 513 条线！</p>
<p>The solution is a matrix!</p>
<p>解决方法是矩阵！</p>
<p>In this matrix, we don't arrange our latches in a row,</p>
<p>在矩阵中，我们不并列排放锁存器</p>
<p>we put them in a grid.</p>
<p>而是做成网格</p>
<p>For 256 bits, we need a 16 by 16 grid of latches with 16 rows and columns of wires.</p>
<p>存 256 位，我们用 16x16 网格的锁存器，有 16 行 16 列</p>
<p>To activate any one latch, we must turn on the corresponding row AND column wire.</p>
<p>要启用某个锁存器，就打开相应的行线和 列线</p>
<p>Let's zoom in and see how this works.</p>
<p>放大看看怎么做的</p>
<p>We only want the latch at the intersection of the two active wires to be enabled,</p>
<p>我们只想打开交叉处锁存器的 "允许写入线"</p>
<p>but all of the other latches should stay disabled.</p>
<p>所有其他锁存器，保持关闭</p>
<p>For this, we can use our trusty AND gate!</p>
<p>我们可以用 AND 门！</p>
<p>The AND gate will output a 1 only if the row and the column wires are both 1.</p>
<p>只有行线和列线均为 1 ，AND 门才输出 1</p>
<p>So we can use this signal to uniquely select a single latch.</p>
<p>所以可以用选择单个锁存器</p>
<p>This row/column setup connects all our latches with a single, shared, write enable wire.</p>
<p>这种行/列排列法，用一根 "允许写入线" 连所有锁存器</p>
<p>In order for a latch to become write enabled,</p>
<p>为了让锁存器变成 "允许写入"</p>
<p>the row wire, the column wire, and the write enable wire must all be 1.</p>
<p>行线，列线和 "允许写入线" 都必须是 1</p>
<p>That should only ever be true for one single latch at any given time.</p>
<p>每次只有 1 个锁存器会这样</p>
<p>This means we can use a single, shared wire for data.</p>
<p>代表我们可以只用一根 "数据线" ，连所有锁存器来传数据</p>
<p>Because only one latch will ever be write enabled, only one will ever save the data</p>
<p>因为只有一个锁存器会启用，只有那个会存数据</p>
<p>the rest of the latches will simply ignore values on the data wire because they are not write enabled.</p>
<p>其他锁存器会忽略数据线上的值，因为没有 "允许写入"</p>
<p>We can use the same trick with a read enable wire to read the data later,</p>
<p>我们可以用类似的技巧, 做"允许读取线"来读数据</p>
<p>to get the data out of one specific latch.</p>
<p>从一个指定的锁存器，读取数据</p>
<p>This means in total, for 256 bits of memory,</p>
<p>所以对于 256 位的存储</p>
<p>we only need 35 wires 1 data wire, 1 write enable wire, 1 read enable wire,</p>
<p>只要 35 条线，1条"数据线", 1条"允许写入线", 1条"允许读取线"</p>
<p>and 16 rows and columns for the selection.</p>
<p>还有16行16列的线用于选择锁存器，（16+16=32, 32+3=35）</p>
<p>That's significant wire savings!</p>
<p>这省了好多线！</p>
<p>But we need a way to uniquely specify each intersection.</p>
<p>但我们需要某种方法来唯一指定交叉路口</p>
<p>We can think of this like a city,</p>
<p>我们可以想成城市</p>
<p>where you might want to meet someone at 12th avenue and 8th street</p>
<p>你可能想和别人在第 12 大道和第 8 街的交界碰面</p>
<p>that's an address that defines an intersection.</p>
<p>这是一个交叉点的地址</p>
<p>The latch we just saved our one bit into has an address of row 12 and column 8.</p>
<p>我们刚刚存了一位的地址是 "12行 8列"</p>
<p>Since there is a maximum of 16 rows, we store the row address in a 4 bit number.</p>
<p>由于最多 16 行, 用 4 位就够了</p>
<p>12 is 1100 in binary.</p>
<p>12 用二进制表示为 1100</p>
<p>We can do the same for the column address: 8 is 1000 in binary.</p>
<p>列地址也可以这样： 8 用二进制表示为 1000</p>
<p>So the address for the particular latch we just used can be written as 11001000.</p>
<p>刚才说的"12行 8列"可以写成 11001000</p>
<p>To convert from an address into something that selects the right row or column,</p>
<p>为了将地址转成行和列</p>
<p>we need a special component called a multiplexer</p>
<p>我们需要 "多路复用器"</p>
<p>which is the computer component with a pretty cool name at least compared to the ALU.</p>
<p>这个名字起码比 ALU 酷一点</p>
<p>Multiplexers come in all different sizes,</p>
<p>多路复用器有不同大小</p>
<p>but because we have 16 rows, we need a 1 to 16 multiplexer.</p>
<p>因为有 16 行，我们需要 1 到 16 多路复用器</p>
<p>It works like this.</p>
<p>工作方式是</p>
<p>You feed it a 4 bit number, and it connects the input line to a corresponding output line.</p>
<p>输入一个 4 位数字，它会把那根线，连到相应的输出线</p>
<p>So if we pass in 0000, it will select the very first column for us.</p>
<p>如果输入 0000，它会选择第一列</p>
<p>If we pass in 0001, the next column is selected, and so on.</p>
<p>如果输入 0001，会选择下一列，依此类推</p>
<p>We need one multiplexer to handle our rows and another multiplexer to handle the columns.</p>
<p>一个多路复用器处理行(row)，另一个多路复用器处理列(column)</p>
<p>Ok, it's starting to get complicated again,</p>
<p>好吧，开始有点复杂了</p>
<p>so let's make our 256-bit memory its own component.</p>
<p>那么把 256 位内存当成一个整体好了</p>
<p>Once again a new level of abstraction!</p>
<p>又提升了一层抽象！</p>
<p>It takes an 8-bit address for input the 4 bits for the column and 4 for the row.</p>
<p>它输入一个 8 位地址：4 位代表列，4 位代表行</p>
<p>We also need write and read enable wires.</p>
<p>我们还需要 "允许写入线" 和 "允许读取线"</p>
<p>And finally, we need just one data wire, which can be used to read or write data.</p>
<p>最后，还需要一条数据线，用于读/写数据</p>
<p>Unfortunately, even 256-bits of memory isn't enough to run much of anything,</p>
<p>不幸的是，256 位的内存也没法做什么事</p>
<p>so we need to scale up even more!</p>
<p>所以还要扩大规模</p>
<p>We're going to put them in a row.</p>
<p>把它们并排放置</p>
<p>Just like with the registers.</p>
<p>就像寄存器一样</p>
<p>We'll make a row of 8 of them, so we can store an 8 bit number also known as a byte.</p>
<p>一行8个，可以存一个 8 位数字，8 位也叫一个字节（byte）</p>
<p>To do this, we feed the exact same address into all 8 of our 256-bit memory components at the same time,</p>
<p>为了存一个 8 位数字，我们同时给 8 个 256 位内存一样的地址</p>
<p>and each one saves one bit of the number.</p>
<p>每个地址存 1 位</p>
<p>That means the component we just made can store 256 bytes at 256 different addresses.</p>
<p>意味着这里总共能存 256 个字节 （byte）</p>
<p>Again, to keep things simple, we want to leave behind this inner complexity.</p>
<p>再次，为了简单，我们不管内部</p>
<p>Instead of thinking of this as a series of individual memory modules and circuits,</p>
<p>不看作是一堆独立的存储模块和电路</p>
<p>we'll think of it as a uniform bank of addressable memory.</p>
<p>而是看成一个整体的可寻址内存</p>
<p>We have 256 addresses,</p>
<p>我们有 256 个地址</p>
<p>and at each address, we can read or write an 8-bit value.</p>
<p>每个地址能读或写一个 8 位值</p>
<p>We're going to use this memory component next episode when we build our CPU.</p>
<p>我们下集做 CPU 时会用到这个内存</p>
<p>The way that modern computers scale to megabytes and gigabytes of memory</p>
<p>现代计算机的内存，扩展到上兆字节（MB）和千兆字节（GB）的方式</p>
<p>is by doing the same thing we've been doing here</p>
<p>和我们这里做的一样</p>
<p>keep packaging up little bundles of memory into larger, and larger, and larger arrangements.</p>
<p>不断把内存打包到更大规模</p>
<p>As the number of memory locations grow, our addresses have to grow as well.</p>
<p>随着内存地址增多，内存地址也必须增长</p>
<p>8 bits hold enough numbers to provide addresses for 256 bytes of our memory,</p>
<p>8 位最多能代表 256 个内存地址，（1111 1111 是255，0~255 一共 256 个数字）</p>
<p>but that's all.</p>
<p>只有这么多</p>
<p>To address a gigabyte or a billion bytes of memory we need 32-bit addresses.</p>
<p>要给千兆或十亿字节的内存寻址，需要 32 位的地址</p>
<p>An important property of this memory is that we can access any memory location, at any time, and in a random order.</p>
<p>内存的一个重要特性是：可以随时访问任何位置</p>
<p>For this reason, it's called Random-Access Memory or RAM.</p>
<p>因此叫 "随机存取存储器" ，简称 RAM</p>
<p>When you hear people talking about how much RAM a computer has</p>
<p>当你听到有人说 RAM 有多大</p>
<p>that's the computer's memory.</p>
<p>他的意思是内存有多大</p>
<p>RAM is like a human's short term or working memory,</p>
<p>RAM 就像人类的短期记忆</p>
<p>where you keep track of things going on right now</p>
<p>记录当前在做什么事</p>
<p>like whether or not you had lunch or paid your phone bill.</p>
<p>比如吃了午饭没，或有没有交电话费</p>
<p>Here's an actual stick of RAM with 8 memory modules soldered onto the board.</p>
<p>这是一条真的内存，上面焊了 8 个内存模块</p>
<p>If we carefully opened up one of these modules and zoomed in,</p>
<p>如果打开其中一个，然后放大</p>
<p>The first thing you would see are 32 squares of memory.</p>
<p>会看到 32 个内存方块</p>
<p>Zoom into one of those squares, and we can see each one is comprised of 4 smaller blocks.</p>
<p>放大其中一个方块，可以看到有 4 个小块</p>
<p>If we zoom in again, we get down to the matrix of individual bits.</p>
<p>如果再放大，可以看到存一个"位"的矩阵</p>
<p>This is a matrix of 128 by 64 bits.</p>
<p>这个矩阵是 128 位 x 64 位</p>
<p>That's 8192 bits in total.</p>
<p>总共 8192 位</p>
<p>Each of our 32 squares has 4 matrices, so that's 32 thousand, 7 hundred and 68 bits.</p>
<p>每个方格 4 个矩阵，所以一个方格有 32768 个位 （8192 x 4 = 32768）</p>
<p>And there are 32 squares in total.</p>
<p>而一共 32 个方格</p>
<p>So all in all, that's roughly 1 million bits of memory in each chip.</p>
<p>总而言之，1 个芯片大约存 100 万位</p>
<p>Our RAM stick has 8 of these chips, so in total, this RAM can store 8 millions bits,</p>
<p>RAM 有 8 个芯片，所以总共 800 万位</p>
<p>otherwise known as 1 megabyte.</p>
<p>也就是 1 兆字节（1 MB）</p>
<p>That's not a lot of memory these days -this is a RAM module from the 1980's.</p>
<p>1 MB 如今不算大这是 1980 年代的 RAM</p>
<p>Today you can buy RAM that has a gigabyte or more of memory</p>
<p>如今你可以买到千兆字节（GB）的 RAM</p>
<p>that's billions of bytes of memory.</p>
<p>那可是数十亿字节的内存</p>
<p>So, today, we built a piece of SRAM Static Random-Access Memory which uses latches.</p>
<p>今天，我们用锁存器做了一块 SRAM（静态随机存取存储器）</p>
<p>There are other types of RAM, such as DRAM, Flash memory, and NVRAM.</p>
<p>还有其他类型的 RAM，如 DRAM，闪存和 NVRAM</p>
<p>These are very similar in function to SRAM,</p>
<p>它们在功能上与 SRAM 相似</p>
<p>but use different circuits to store the individual bits</p>
<p>但用不同的电路存单个位</p>
<p>for example, using different logic gates, capacitors, charge traps, or memristors.</p>
<p>比如用不同的逻辑门，电容器，电荷捕获或忆阻器</p>
<p>But fundamentally, all of these technologies store bits of information</p>
<p>但根本上这些技术都是矩阵层层嵌套，</p>
<p>in massively nested matrices of memory cells.</p>
<p>来存储大量信息</p>
<p>Like many things in computing, the fundamental operation is relatively simple.</p>
<p>就像计算机中的很多事情，底层其实都很简单</p>
<p>it's the layers and layers of abstraction that's mind blowing</p>
<p>让人难以理解的，是一层层精妙的抽象</p>
<p>like a russian doll that keeps getting smaller and smaller and smaller.</p>
<p>像一个越来越小的俄罗斯套娃</p>
<p>I'll see you next week.</p>
<p>下周见</p>
<p>07. 中央处理器</p>
<p>The Central Processing Unit(CPU)</p>
<p>Hi, I'm Carrie Anne, this is Crash Course Computer Science</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>and today, we're talking about processors.</p>
<p>今天我们讲处理器</p>
<p>Just a warning though this is probably the most complicated episode in the series.</p>
<p>提示下这集可能是最难的一集</p>
<p>So once you get this, you're golden.</p>
<p>所以一旦你理解了，就会变得超厉害der~</p>
<p>We've already made a Arithmetic and Logic Unit,</p>
<p>我们已经做了一个算术逻辑单元（ALU）</p>
<p>which takes in binary numbers and performs calculations,</p>
<p>输入二进制，它会执行计算</p>
<p>and we've made two types of computer memory:</p>
<p>我们还做了两种内存：</p>
<p>Registers -small, linear chunks of memory, useful for storing a single value</p>
<p>寄存器很小的一块内存，能存一个值</p>
<p>and then we scaled up, and made some RAM,</p>
<p>之后我们增大做出了 RAM</p>
<p>a larger bank of memory that can store a lot of numbers located at different addresses.</p>
<p>RAM 是一大块内存，能在不同地址存大量数字</p>
<p>Now it's time to put it all together and build ourselves the heart of any computer,</p>
<p>现在是时候把这些放在一起，组建计算机的 "心脏" 了</p>
<p>but without any of the emotional baggage that comes with human hearts.</p>
<p>但这个 "心脏" 不会有任何包袱，比如人类情感.</p>
<p>For computers, this is the Central Processing Unit, most commonly called the CPU.</p>
<p>计算机的心脏是"中央处理单元"，简称 "CPU"</p>
<p>A CPU's job is to execute programs.</p>
<p>CPU 负责执行程序</p>
<p>Programs, like Microsoft Office, Safari, or your beloved copy of Half Life: 2,</p>
<p>比如 Office，Safari 浏览器，你最爱的 《半条命2》</p>
<p>are made up of a series of individual operations,</p>
<p>程序由一个个操作组成</p>
<p>called instructions, because they "instruct" the computer what to do.</p>
<p>这些操作叫"指令"(Instruction)，因为它们"指示"计算机要做什么</p>
<p>If these are mathematical instructions, like add or subtract,</p>
<p>如果是数学指令，比如加/减</p>
<p>the CPU will configure its ALU to do the mathematical operation.</p>
<p>CPU 会让 ALU 进行数学运算</p>
<p>Or it might be a memory instruction,</p>
<p>也可能是内存指令，</p>
<p>in which case the CPU will talk with memory to read and write values.</p>
<p>CPU 会和内存通信，然后读/写值</p>
<p>There are a lot of parts in a CPU,</p>
<p>CPU 里有很多组件.</p>
<p>so we're going to lay it out piece by piece, building up as we go.</p>
<p>所以我们一边说一边建</p>
<p>We'll focus on functional blocks, rather than showing every single wire.</p>
<p>我们把重点放在功能，而不是一根根线具体怎么连</p>
<p>When we do connect two components with a line,</p>
<p>当我们用一条线连接两个组件时</p>
<p>this is an abstraction for all of the necessary wires.</p>
<p>这条线只是所有必须线路的一个抽象</p>
<p>This high level view is called the microarchitecture.</p>
<p>这种高层次视角叫 "微体系架构"</p>
<p>OK, first, we're going to need some memory.</p>
<p>好，我们首先要一些内存，</p>
<p>Lets drop in the RAM module we created last episode.</p>
<p>把上集做的 RAM 拿来就行</p>
<p>To keep things simple, we'll assume it only has 16 memory locations, each containing 8 bits.</p>
<p>为了保持简单，假设它只有 16 个位置，每个位置存 8 位</p>
<p>Let's also give our processor four, 8-bit memory registers, labeled A, B, C and D</p>
<p>再来四个 8 位寄存器，叫 A，B，C，D</p>
<p>which will be used to temporarily store and manipulate values.</p>
<p>寄存器用来临时存数据和 操作数据</p>
<p>We already know that data can be stored in memory as binary values</p>
<p>我们已经知道数据是以二进制值存在内存里</p>
<p>and programs can be stored in memory too.</p>
<p>程序也可以存在内存里</p>
<p>We can assign an ID to each instruction supported by our CPU.</p>
<p>我们可以给 CPU 支持的所有指令，分配一个 ID</p>
<p>In our hypothetical example, we use the first four bits to store the "operation code",</p>
<p>在这个假设的例子，我们用前四位存 "操作代码" （operation code）</p>
<p>or opcode for short.</p>
<p>简称 "操作码" （opcode）</p>
<p>The final four bits specify where the data for that operation should come from -</p>
<p>后四位代表数据来自哪里</p>
<p>this could be registers or an address in memory.</p>
<p>可以是寄存器或内存地址</p>
<p>We also need two more registers to complete our CPU.</p>
<p>我们还需要两个寄存器，来完成 CPU.</p>
<p>First, we need a register to keep track of where we are in a program.</p>
<p>1 一个寄存器追踪程序运行到哪里了，</p>
<p>For this, we use an instruction address register,</p>
<p>我们叫它  "指令地址寄存器"</p>
<p>which as the name suggests, stores the memory address of the current instruction.</p>
<p>顾名思义，存当前指令的内存地址</p>
<p>And then we need the other register to store the current instruction,</p>
<p>2 另一个寄存器存当前指令，</p>
<p>which we'll call the instruction register.</p>
<p>叫  "指令寄存器"</p>
<p>When we first boot up our computer, all of our registers start at 0.</p>
<p>当启动计算机时，所有寄存器从 0 开始</p>
<p>As an example, we've initialized our RAM with a simple computer program that we'll to through today.</p>
<p>为了举例，我们在 RAM 里放了一个程序，我们今天会过一遍</p>
<p>The first phase of a CPU's operation is called the fetch phase.</p>
<p>CPU 的第一个阶段叫 "取指令阶段"</p>
<p>This is where we retrieve our first instruction.</p>
<p>负责拿到指令</p>
<p>First, we wire our Instruction Address Register to our RAM module.</p>
<p>首先，将 "指令地址寄存器" 连到 RAM</p>
<p>The register's value is 0, so the RAM returns whatever value is stored in address 0.</p>
<p>寄存器的值为 0，因此 RAM 返回地址 0 的值</p>
<p>In this case, 0010 1110.</p>
<p>0010 1110 </p>
<p>Then this value is copied into our instruction register.</p>
<p>会复制到 "指令寄存器" 里</p>
<p>Now that we've fetched an instruction from memory,</p>
<p>现在指令拿到了</p>
<p>we need to figure out what that instruction is</p>
<p>要弄清是什么指令，</p>
<p>so we can execute it.</p>
<p>才能执行（execute）</p>
<p>That is run it.</p>
<p>只是运行它</p>
<p>Not kill it.</p>
<p>而不是杀死（kill）它</p>
<p>This is called the decode phase.</p>
<p>这是 "解码阶段"</p>
<p>In this case the opcode, which is the first four bits, is: 0010.</p>
<p>前 4 位 0010 </p>
<p>This opcode corresponds to the "LOAD A" instruction,</p>
<p>是 LOAD A 指令</p>
<p>which loads a value from RAM into Register A.</p>
<p>意思是，把 RAM 的值放入寄存器 A</p>
<p>The RAM address is the last four bits of our instruction which are 1110, or 14 in decimal.</p>
<p>后 4 位 1110 是 RAM 的地址, 转成十进制是 14</p>
<p>Next, instructions are decoded and interpreted by a Control Unit.</p>
<p>接下来，指令由 "控制单元" 进行解码</p>
<p>Like everything else we've built, it too is made out of logic gates.</p>
<p>就像之前的所有东西，"控制单元" 也是逻辑门组成的</p>
<p>For example, to recognize a LOAD A instruction,</p>
<p>比如，为了识别 "LOAD A" 指令</p>
<p>we need a circuit that checks if the opcode matches 0010</p>
<p>需要一个电路，检查操作码是不是 0010</p>
<p>which we can do with a handful of logic gates.</p>
<p>我们可以用很少的逻辑门来实现.</p>
<p>Now that we know what instruction we're dealing with,</p>
<p>现在知道了是什么指令</p>
<p>we can go ahead and perform that instruction which is the beginning of the execute phase!</p>
<p>就可以开始执行了，开始 "执行阶段"</p>
<p>Using the output of our LOAD_A checking circuit,</p>
<p>用 "检查是否 LOAD A 指令的电路"</p>
<p>we can turn on the RAM's read enable line and send in address 14.</p>
<p>可以打开 RAM 的 "允许读取线", 把地址 14 传过去</p>
<p>The RAM retrieves the value at that address, which is 00000011, or 3 in decimal.</p>
<p>RAM 拿到值，0000 0011，十进制的 3</p>
<p>Now, because this is a LOAD_A instruction,</p>
<p>因为是 LOAD_A 指令，</p>
<p>we want that value to only be saved into Register A and not any of the other registers.</p>
<p>我们想把这个值只放到寄存器 A，其他寄存器不受影响</p>
<p>So if we connect the RAM's data wires to our four data registers,</p>
<p>所以需要一根线，把 RAM 连到 4 个寄存器</p>
<p>we can use our LOAD_A check circuit to enable the write enable only for Register A.</p>
<p>用 "检查是否 LOAD_A 指令的电路"，启用寄存器 A 的 "允许写入线"</p>
<p>And there you have it</p>
<p>这就成功了</p>
<p>we've successfully loaded the value at RAM address 14 into Register A.</p>
<p>把 RAM 地址 14 的值，放到了寄存器 A.</p>
<p>We've completed the instruction, so we can turn all of our wires off,</p>
<p>既然指令完成了，我们可以关掉所有线路</p>
<p>and we are ready to fetch the next instruction in memory.</p>
<p>去拿下一条指令</p>
<p>To do this, we increment the Instruction Address Register by 1 which completes the execute phase.</p>
<p>我们把 "指令地址寄存器"+1，"执行阶段"就此结束.</p>
<p>LOAD_A is just one of several possible instructions that our CPU can execute.</p>
<p>LOAD_A 只是 CPU 可以执行的各种指令之一</p>
<p>Different instructions are decoded by different logic circuits,</p>
<p>不同指令由不同逻辑电路解码</p>
<p>which configure the CPU's components to perform that action.</p>
<p>这些逻辑电路会配置 CPU 内的组件来执行对应操作</p>
<p>Looking at all those individual decode circuits is too much detail,</p>
<p>具体分析这些解码电路太繁琐了</p>
<p>so since we looked at one example,</p>
<p>既然已经看了 1 个例子，</p>
<p>we're going to go head and package them all up as a single Control Unit to keep things simple.</p>
<p>干脆把 "控制单元 "包成一个整体，简洁一些.</p>
<p>That's right a new level of abstraction.</p>
<p>没错，一层新抽象</p>
<p>The Control Unit is comparable to the conductor of an orchestra,</p>
<p>控制单元就像管弦乐队的指挥</p>
<p>directing all of the different parts of the CPU.</p>
<p>"指挥" CPU 的所有组件</p>
<p>Having completed one full fetch/decode/execute cycle,</p>
<p>"取指令→解码→执行" 完成后</p>
<p>we're ready to start all over again, beginning with the fetch phase.</p>
<p>现在可以再来一次，从 "取指令" 开始</p>
<p>The Instruction Address Register now has the value 1 in it,</p>
<p>"指令地址寄存器" 现在的值是 1</p>
<p>so the RAM gives us the value stored at address 1, which is 0001 1111.</p>
<p>所以 RAM 返回地址 1 里的值：0001 1111</p>
<p>On to the decode phase!</p>
<p>到 "解码" 阶段！</p>
<p>0001 is the "LOAD B" instruction, which moves a value from RAM into Register B.</p>
<p>0001 是 LOAD B 指令，从 RAM 里把一个值复制到寄存器 B</p>
<p>The memory location this time is 1111, which is 15 in decimal.</p>
<p>这次内存地址是 1111，十进制的 15</p>
<p>Now to the execute phase!</p>
<p>现在到 "执行阶段"！</p>
<p>The Control Unit configures the RAM to read address 15 and configures Register B to receive the data.</p>
<p>"控制单元" 叫 RAM 读地址 15，并配置寄存器 B 接收数据</p>
<p>Bingo, we just saved the value 00001110, or the number 14 in decimal, into Register B.</p>
<p>成功，我们把值 0000 1110，也就是十进制的 14 存到了寄存器 B</p>
<p>Last thing to do is increment our instruction address register by 1,</p>
<p>最后一件事是 "指令地址寄存器" +1</p>
<p>and we're done with another cycle.</p>
<p>我们又完成了一个循环</p>
<p>Our next instruction is a bit different.</p>
<p>下一条指令有点不同</p>
<p>Let's fetch it.</p>
<p>来取它吧</p>
<p>1000 0100.</p>
<p>1000 0100</p>
<p>That opcode 1000 is an ADD instruction.</p>
<p>1000 是 ADD 指令</p>
<p>Instead of an 4-bit RAM address, this instruction uses two sets of 2 bits.</p>
<p>这次后面的 4 位不是 RAM 地址，而是 2 位 2 位分别代表 2 个寄存器</p>
<p>Remember that 2 bits can encode 4 values,</p>
<p>2 位可以表示 4 个值</p>
<p>so 2 bits is enough to select any one of our 4 registers.</p>
<p>所以足够表示 4 个寄存器</p>
<p>The first set of 2 bits is 01, which in this case corresponds to Register B,</p>
<p>第一个地址是 01, 代表寄存器B</p>
<p>and 00, which is Register A.</p>
<p>第二个地址是 00, 代表寄存器A</p>
<p>So "1000 01 00" is the instruction for adding the value in Register B into the value in register A.</p>
<p>因此，1000 0100，代表把寄存器 B 的值，加到寄存器 A 里</p>
<p>So to execute this instruction, we need to integrate the ALU we made in Episode 5 into our CPU.</p>
<p>为了执行这个指令，我们要整合第 5 集的 ALU</p>
<p>The Control Unit is responsible for selecting the right registers to pass in as inputs,</p>
<p>"控制单元" 负责选择正确的寄存器作为输入</p>
<p>and configuring the ALU to perform the right operation.</p>
<p>并配置 ALU 执行正确的操作</p>
<p>For this ADD instruction, the Control Unit enables Register B</p>
<p>对于 "ADD" 指令，"控制单元" 会</p>
<p>and feeds its value into the first input of the ALU.</p>
<p>启用寄存器 B，作为 ALU 的第一个输入</p>
<p>It also enables Register A and feeds it into the second ALU input.</p>
<p>还启用寄存器 A，作为 ALU 的第二个输入</p>
<p>As we already discussed, the ALU itself can perform several different operations,</p>
<p>之前说过，ALU 可以执行不同操作</p>
<p>so the Control Unit must configure it to perform an ADD operation by passing in the ADD opcode.</p>
<p>所以控制单元必须传递 ADD 操作码告诉它要做什么</p>
<p>Finally, the output should be saved into Register A.</p>
<p>最后，结果应该存到寄存器 A</p>
<p>But it can't be written directly</p>
<p>但不能直接写入寄存器 A</p>
<p>because the new value would ripple back into the ALU and then keep adding to itself.</p>
<p>这样新值会进入 ALU ，不断和自己相加</p>
<p>So the Control Unit uses an internal register to temporarily save the output,</p>
<p>因此，控制单元用一个自己的寄存器暂时保存结果</p>
<p>turn off the ALU, and then write the value into the proper destination register.</p>
<p>关闭 ALU，然后把值写入正确的寄存器</p>
<p>In this case, our inputs were 3 and 14, and so the sum is 17, or 00010001 in binary,</p>
<p>这里 3+14=17，二进制是 0001 0001</p>
<p>which is now sitting in Register A.</p>
<p>现在存到了寄存器 A</p>
<p>As before, the last thing to do is increment our instruction address by 1,</p>
<p>和之前一样，最后一件事是把指令地址 + 1</p>
<p>and another cycle is complete.</p>
<p>这个循环就完成了</p>
<p>Okay, so let's fetch one last instruction: 0100 1101.</p>
<p>好，来看最后一个指令：0100 1101</p>
<p>When we decode it we see that 0100 is a STORE_A instruction, with a RAM address of 13.</p>
<p>解码得知是 STORE A 指令（把寄存器 A 的值放入内存），RAM 地址 13</p>
<p>As usual, we pass the address to the RAM module,</p>
<p>接下来，把地址传给 RAM</p>
<p>but instead of read-enabling the memory, we write-enable it.</p>
<p>但这次不是 "允许读取" ，而是 "允许写入"</p>
<p>At the same time, we read-enable Register A.</p>
<p>同时，打开寄存器 A 的 "允许读取"</p>
<p>This allows us to use the data line to pass in the value stored in register A.</p>
<p>这样就可以把寄存器 A 里的值，传给 RAM</p>
<p>Congrats, we just ran our first computer program!</p>
<p>恭喜，我们刚运行了第一个电脑程序！</p>
<p>It loaded two values from memory, added them together,</p>
<p>它从内存中加载两个值，相加，然后把结果放回内存</p>
<p>and then saved that sum back into memory.</p>
<p>它从内存中加载两个值，相加，然后把结果放回内存</p>
<p>Of course, by me talking you through the individual steps,</p>
<p>刚刚是我一步步来讲的,</p>
<p>I was manually transitioning the CPU through its fetch, decode and execute phases.</p>
<p>我们人工切换 CPU 的状态 "取指令→解码→执行"</p>
<p>But there isn't a mini Carrie Anne inside of every computer.</p>
<p>但不是每台电脑里都有一个迷你 Carrie Anne</p>
<p>So the responsibility of keeping the CPU ticking along falls to a component called the clock.</p>
<p>其实是 "时钟" 来负责管理 CPU 的节奏</p>
<p>As it's name suggests, the clock triggers an electrical signal at a precise and regular interval.</p>
<p>时钟以精确的间隔触发电信号</p>
<p>Its signal is used by the Control Unit to advance the internal operation of the CPU,</p>
<p>控制单元会用这个信号，推进 CPU 的内部操作</p>
<p>keeping everything in lock-step</p>
<p>确保一切按步骤进行</p>
<p>like the dude on a Roman galley drumming rhythmically at the front,</p>
<p>就像罗马帆船的船头，有一个人负责按节奏的击鼓,</p>
<p>keeping all the rowers synchronized... or a metronome.</p>
<p>让所有划船的人同步... 就像节拍器一样</p>
<p>Of course you can't go too fast,</p>
<p>节奏不能太快</p>
<p>because even electricity takes some time to travel down wires and for the signal to settle.</p>
<p>因为就算是电也要一定时间来传输</p>
<p>The speed at which a CPU can carry out each step of the fetch-decode-execute cycle</p>
<p>CPU "取指令→解码→执行" 的速度</p>
<p>is called its Clock Speed.</p>
<p>叫 "时钟速度"</p>
<p>This speed is measured in Hertz a unit of frequency.</p>
<p>单位是赫兹赫兹是用来表示频率的单位</p>
<p>One Hertz means one cycle per second.</p>
<p>1 赫兹代表一秒 1 个周期</p>
<p>Given that it took me about 6 minutes to talk you through 4 instructions</p>
<p>因为我花了大概 6 分钟，给你讲了 4 条指令</p>
<p>LOAD, LOAD, ADD and STORE</p>
<p>读取→读取→相加→存储</p>
<p>that means I have an effective clock speed of roughly .03 Hertz.</p>
<p>所以我的时钟速度大概是 0.03 赫兹</p>
<p>Admittedly, I'm not a great computer</p>
<p>我承认我算数不快</p>
<p>but even someone handy with math might only be able to do one calculation in their head every second or 1 Hertz.</p>
<p>但哪怕有人算数很快，最多也就是一秒一次，或 1 赫兹</p>
<p>The very first, single-chip CPU was the Intel 4004, a 4-bit CPU released in 1971.</p>
<p>第一个单芯片 CPU 是 "英特尔 4004"，1971 年发布的 4 位CPU</p>
<p>It's microarchitecture is actually pretty similar to our example CPU.</p>
<p>它的微架构很像我们之前说的 CPU</p>
<p>Despite being the first processor of its kind,</p>
<p>虽然是第一个单芯片的处理器</p>
<p>it had a mind-blowing clock speed of 740 Kilohertz</p>
<p>但它的时钟速度达到了 740 千赫兹</p>
<p>that's 740 thousand cycles per second.</p>
<p>每秒 74 万次</p>
<p>You might think that's fast,</p>
<p>你可能觉得很快</p>
<p>but it's nothing compared to the processors that we use today.</p>
<p>但和如今的处理器相比不值一提</p>
<p>One megahertz is one million clock cycles per second,</p>
<p>一兆赫兹是 1 秒 1 百万个时钟周期</p>
<p>and the computer or even phone that you are watching this video on right now is no doubt a few gigahertz</p>
<p>你现在看视频的电脑或手机，肯定有几千兆赫兹</p>
<p>that's BILLIONs of CPU cycles every single... second.</p>
<p>1 秒 10 亿次时钟周期</p>
<p>Also, you may have heard of people overclocking their computers.</p>
<p>你可能听过有人会把计算机超频</p>
<p>This is when you modify the clock to speed up the tempo of the CPU</p>
<p>意思是修改时钟速度，加快 CPU 的速度</p>
<p>like when the drummer speeds up when the Roman Galley needs to ram another ship.</p>
<p>就像罗马帆船要撞另一艘船时，鼓手会加快敲鼓速度</p>
<p>Chip makers often design CPUs with enough tolerance to handle a little bit of overclocking,</p>
<p>芯片制造商经常给 CPU 留一点余地，可以接受一点超频</p>
<p>but too much can either overheat the CPU,</p>
<p>但超频太多会让 CPU 过热</p>
<p>or produce gobbledygook as the signals fall behind the clock.</p>
<p>或产生乱码，因为信号跟不上时钟</p>
<p>And although you don't hear very much about underclocking,</p>
<p>你可能很少听说降频</p>
<p>it's actually super useful.</p>
<p>但降频其实很有用</p>
<p>Sometimes it's not necessary to run the processor at full speed...</p>
<p>有时没必要让处理器全速运行</p>
<p>maybe the user has stepped away, or just not running a particularly demanding program.</p>
<p>可能用户走开了，或者在跑一个性能要求较低的程序</p>
<p>By slowing the CPU down, you can save a lot of power,</p>
<p>把 CPU 的速度降下来，可以省很多电</p>
<p>which is important for computers that run on batteries, like laptops and smartphones.</p>
<p>省电对用电池的设备很重要，比如笔记本和手机</p>
<p>To meet these needs,</p>
<p>为了尽可能省电</p>
<p>many modern processors can increase or decrease their clock speed based on demand,</p>
<p>很多现代处理器可以按需求加快或减慢时钟速度</p>
<p>which is called dynamic frequency scaling.</p>
<p>这叫 "动态调整频率"</p>
<p>So, with the addition of a clock, our CPU is complete.</p>
<p>加上时钟后，CPU 才是完整的.</p>
<p>We can now put a box around it, and make it its own component.</p>
<p>现在可以放到盒子里，变成一个独立组件</p>
<p>Yup.</p>
<p>对</p>
<p>A new level of abstraction!</p>
<p>一层新的抽象！</p>
<p>RAM, as I showed you last episode,</p>
<p>RAM，上集说过，</p>
<p>lies outside the CPU as its own component,</p>
<p>是在 CPU 外面的独立组件</p>
<p>and they communicate with each other using address, data and enable wires.</p>
<p>CPU 和 RAM 之间，用 "地址线"  "数据线" 和 "允许读/写线" 进行通信</p>
<p>Although the CPU we designed today is a simplified example,</p>
<p>虽然今天我们设计的 CPU 是简化版的,</p>
<p>many of the basic mechanics we discussed are still found in modern processors.</p>
<p>但我们提到的很多机制，依然存在于现代处理器里</p>
<p>Next episode, we're going to beef up our CPU,</p>
<p>下一集，我们要加强 CPU，给它扩展更多指令.</p>
<p>extending it with more instructions as we take our first baby steps into software.</p>
<p>同时开始讲软件.</p>
<p>I'll see you next week.</p>
<p>下周见</p>
<p>Instructions & Programs</p>
<p>8 指令和程序</p>
<p>Hi, I’m Carrie Anne and this is Crash Course Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>Last episode, we combined an ALU, control unit, some memory, and a clock together to</p>
<p>上集我们把 ALU, 控制单元, RAM, 时钟结合在一起</p>
<p>make a basic, but functional Central Processing Unit – or CPU</p>
<p>做了个基本，但可用的"中央处理单元", 简称 CPU</p>
<p>the beating, ticking heart of a computer.</p>
<p>它是计算机的核心</p>
<p>We’ve done all the hard work of building many of these components from the electronic</p>
<p>我们已经用电路做了很多组件.</p>
<p>circuits up, and now it’s time to give our CPU some actual instructions to process!</p>
<p>这次我们给 CPU 一些指令来运行!</p>
<p>The thing that makes a CPU powerful is the fact that it is programmable –</p>
<p>CPU 之所以强大，是因为它是可编程的 -</p>
<p>if you write a different sequence of instructions, then the CPU will perform a different task.</p>
<p>如果写入不同指令，就会执行不同任务</p>
<p>So the CPU is a piece of hardware which is controlled by easy-to-modify software!</p>
<p>CPU 是一块硬件，可以被软件控制!</p>
<p>Let’s quickly revisit the simple program that we stepped through last episode.</p>
<p>我们重新看一下上集的简单程序</p>
<p>The computer memory looked like this.</p>
<p>内存里有这些值</p>
<p>Each address contained 8 bits of data.</p>
<p>每个地址可以存 8 位数据</p>
<p>For our hypothetical CPU, the first four bits specified the operation code, or opcode, and</p>
<p>因为我们的 CPU 是假设的，这里前4位是"操作码"</p>
<p>the second set of four bits specified an address or registers.</p>
<p>后4位指定一个内存地址，或寄存器.</p>
<p>In memory address zero we have 0010 1110.</p>
<p>内存地址 0 是 0010 1110</p>
<p>Again, those first four bits are our opcode which corresponds to a "LOAD_A" instruction.</p>
<p>前 4 位代表 LOAD_A 指令</p>
<p>This instruction reads data from a location of memory specified in those last four bits</p>
<p>意思是：把后 4 位指定的内存地址的值，放入寄存器 A</p>
<p>of the instruction and saves it into Register A. In this case, 1110, or 14 in decimal.</p>
<p>后 4 位是 1110，十进制的 14</p>
<p>So let’s not think of this of memory address 0 as "0010 1110", but rather as the instruction</p>
<p>我们来把 0010 1110 看成 "LOAD_A 14" 指令</p>
<p>"LOAD_A 14".</p>
<p>我们来把 0010 1110 看成 "LOAD_A 14" 指令</p>
<p>That’s much easier to read and understand!</p>
<p>这样更好理解！</p>
<p>And for me to say!</p>
<p>也更方便说清楚</p>
<p>And we can do the same thing for the rest of the data in memory.</p>
<p>可以对内存里剩下的数也这样转换.</p>
<p>In this case, our program is just four instructions long,</p>
<p>这里，我们的程序只有4个指令</p>
<p>and we’ve put some numbers into memory too, 3 and 14.</p>
<p>还有数字 3 和 14</p>
<p>So now let’s step through this program:</p>
<p>现在一步步看</p>
<p>First is LOAD_A 14, which takes the value in address 14, which is the number 3,</p>
<p>"LOAD_A 14" 是从地址 14 中拿到数字3，</p>
<p>and stores it into Register A.</p>
<p>放入寄存器A</p>
<p>Then we have a "LOAD_B 15" instruction, which takes the value in memory location 15,</p>
<p>"LOAD_B 15" 是从地址 15 中拿到数字14，</p>
<p>which is the number 14, and saves it into Register B.</p>
<p>放入寄存器B</p>
<p>Okay.</p>
<p>好.</p>
<p>Easy enough.</p>
<p>挺简单的！</p>
<p>But now we have an "ADD" instruction.</p>
<p>下一个是 ADD 指令</p>
<p>This tells the processor to use the ALU to add two registers together,</p>
<p>"ADD B A" 告诉 ALU，</p>
<p>in this case, B and A are specified.</p>
<p>把寄存器 B 和寄存器 A 里的数字加起来</p>
<p>The ordering is important, because the resulting sum is saved into the second register that’s specified.</p>
<p>（B和A的）顺序很重要，因为结果会存在第二个寄存器</p>
<p>So in this case, the resulting sum is saved into Register A.</p>
<p>也就是寄存器 A</p>
<p>And finally, our last instruction is "STORE_A 13", which instructs the CPU to write whatever</p>
<p>最后一条指令是 "STORE_A 13"，</p>
<p>value is in Register A into memory location 13.</p>
<p>把寄存器 A 的值存入内存地址 13</p>
<p>Yesss!</p>
<p>好棒！</p>
<p>Our program adds two numbers together.</p>
<p>我们把 2 个数加在了一起!</p>
<p>That’s about as exciting as it gets when we only have four instructions to play with.</p>
<p>毕竟只有4个指令，也只能做这个了.</p>
<p>So let’s add some more!</p>
<p>加多一些指令吧!</p>
<p>Now we’ve got a subtract function, which like ADD, specifies two registers to operate on.</p>
<p>SUB 是减法，和 ADD 一样也要 2 个寄存器来操作.</p>
<p>We’ve also got a fancy new instruction called JUMP.</p>
<p>还有 JUMP（跳转）</p>
<p>As the name implies, this causes the program to "jump" to a new location.</p>
<p>让程序跳转到新位置</p>
<p>This is useful if we want to change the order of instructions, or choose to skip some instructions.</p>
<p>如果想改变指令顺序，或跳过一些指令，这个很实用</p>
<p>For example, a JUMP 0, would cause the program to go back to the beginning.</p>
<p>举例, JUMP 0 可以跳回开头</p>
<p>At a low level, this is done by writing the value specified in the last four bits into</p>
<p>JUMP 在底层的实现方式是，把指令后 4 位代表的内存地址的值</p>
<p>the instruction address register, overwriting the current value.</p>
<p>覆盖掉 "指令地址寄存器" 里的值</p>
<p>We’ve also added a special version of JUMP called JUMP_NEGATIVE.</p>
<p>还有一个特别版的 JUMP 叫 JUMP_NEGATIVE</p>
<p>"This only jumps the program if the ALU’s negative flag is set to true.</p>
<p>它只在 ALU 的 "负数标志" 为真时，进行 JUMP</p>
<p>As we talked about in Episode 5, the negative flag is only set</p>
<p>第5集讲过，算术结果为负，</p>
<p>when the result of an arithmetic operation is negative.</p>
<p>"负数标志"才是真</p>
<p>If the result of the arithmetic was zero or positive, the negative flag would not be set.</p>
<p>结果不是负数时, "负数标志"为假</p>
<p>So the JUMP NEGATIVE won’t jump anywhere, and the CPU will just continue on to the next instruction.</p>
<p>如果是假，JUMP_NEGATIVE 就不会执行，程序照常进行</p>
<p>Our previous program really should have looked like this to be correct,</p>
<p>我们之前的例子程序，其实应该是这样，才能正确工作.</p>
<p>otherwise the CPU would have just continued on after the STORE instruction, processing all those 0’s.</p>
<p>否则跑完  STORE_A 13 之后，CPU 会不停运行下去，处理后面的 0</p>
<p>But there is no instruction with an opcode of 0, and so the computer would have crashed!</p>
<p>因为 0 不是操作码，所以电脑会崩掉!</p>
<p>It’s important to point out here that we’re storing</p>
<p>我还想指出一点，</p>
<p>both instructions and data in the same memory.</p>
<p>指令和数据都是存在同一个内存里的.</p>
<p>There is no difference fundamentally -it’s all just binary numbers.</p>
<p>它们在根本层面上毫无区别都是二进制数</p>
<p>So the HALT instruction is really important because it allows us to separate the two.</p>
<p>HALT 很重要，能区分指令和数据</p>
<p>Okay, so let’s make our program a bit more interesting, by adding a JUMP.</p>
<p>好，现在用 JUMP 让程序更有趣一些.</p>
<p>We’ll also modify our two starting values in memory to 1 and 1.</p>
<p>我们还把内存中 3 和 14 两个数字，改成 1 和 1</p>
<p>Lets step through this program just as our CPU would.</p>
<p>现在来从 CPU 的视角走一遍程序</p>
<p>First, LOAD_A 14 loads the value 1 into Register A.</p>
<p>首先 LOAD_A 14，把 1 存入寄存器A ，（因为地址 14 里的值是 1）</p>
<p>Next, LOAD_B 15 loads the value 1 into Register B.</p>
<p>然后 LOAD_B 15，把 1 存入寄存器B，（因为地址 15 里的值也是 1）</p>
<p>As before, we ADD registers B and A together, with the sum going into Register A. 1+1 = 2,</p>
<p>然后 ADD B A 把寄存器 B 和 A 相加，结果放到寄存器 A 里</p>
<p>so now Register A has the value 2 in it (stored in binary of course)</p>
<p>现在寄存器 A 的值是 2，(当然是以二进制存的）</p>
<p>Then the STORE instruction saves that into memory location 13.</p>
<p>然后 STORE_A 13 指令，把寄存器 A 的值存入内存地址 13</p>
<p>Now we hit a "JUMP 2" instruction.</p>
<p>现在遇到 JUMP 2 指令</p>
<p>This causes the processor to overwrite the value in the instruction address register,</p>
<p>CPU 会把"指令地址寄存器"的值，</p>
<p>which is currently 4, with the new value, 2.</p>
<p>现在是 4，改成 2</p>
<p>Now, on the processor’s next fetch cycle, we don’t fetch HALT,</p>
<p>因此下一步不再是 HALT</p>
<p>instead we fetch the instruction at memory location 2, which is ADD B A.</p>
<p>而是读内存地址 2 里的指令，也就是 ADD B A</p>
<p>We’ve jumped!</p>
<p>我们跳转了!</p>
<p>Register A contains the value 2, and register B contains the value 1.</p>
<p>寄存器 A 里是 2，寄存器 B 里是 1</p>
<p>So 1+2 = 3, so now Register A has the value 3.</p>
<p>1+2=3，寄存器 A 变成 3</p>
<p>We store that into memory.</p>
<p>存入内存</p>
<p>And we’ve hit the JUMP again, back to ADD B A.</p>
<p>又碰到 JUMP 2，又回到 ADD B A.</p>
<p>1+3=4</p>
<p>1+3=4</p>
<p>So now register A has the value 4.</p>
<p>现在寄存器 A 是 4</p>
<p>See what's happening here?</p>
<p>发现了吗？</p>
<p>Every loop, we’re adding one.</p>
<p>每次循环都+1</p>
<p>Its counting up!</p>
<p>不断增多</p>
<p>Cooooool.</p>
<p>酷</p>
<p>But notice there’s no way to ever escape.</p>
<p>但没法结束啊</p>
<p>We’re never.. ever.. going to get to that halt instruction,</p>
<p>永远不会碰到 HALT</p>
<p>because we’re always going to hit that JUMP.</p>
<p>总是会碰到 JUMP</p>
<p>This is called an infinite loop – a program that runs forever… ever… ever… ever…</p>
<p>这叫无限循环这个程序会永远跑下去.. 下去.. 下去.. 下去</p>
<p>ever</p>
<p>下去</p>
<p>To break the loop, we need a conditional jump.</p>
<p>为了停下来，我们需要有条件的 JUMP</p>
<p>A jump that only happens if a certain condition is met.</p>
<p>只有特定条件满足了，才执行 JUMP.</p>
<p>Our JUMP_NEGATIVE is one example of a conditional jump,</p>
<p>比如 JUMP NEGATIVE 就是条件跳转的一个例子</p>
<p>but computers have other types too like JUMP IF EQUAL and JUMP IF GREATER.</p>
<p>还有其他类型的条件跳转，比如， JUMP IF EQUAL（如果相等），JUMP IF GREATER（如果更大）</p>
<p>So let’s make our code a little fancier and step through it.</p>
<p>现在把代码弄花哨一点，再过一遍代码</p>
<p>Like before, the program starts by loading values from memory into registers A and B.</p>
<p>就像之前，程序先把内存值放入寄存器 A 和 B.</p>
<p>In this example, the number 11 gets loaded into Register A, and 5 gets loaded into Register B.</p>
<p>寄存器 A 是 11，寄存器 B 是 5</p>
<p>Now we subtract register B from register A. That’s 11 minus 5, which is 6,</p>
<p>SUB B A，用 A 减 B，11-5=6</p>
<p>and so 6 gets saved into Register A.</p>
<p>6 存入寄存器 A</p>
<p>Now we hit our JUMP NEGATIVE.</p>
<p>JUMP NEGATIVE 出场</p>
<p>The last ALU result was 6.</p>
<p>上一次 ALU 运算的结果是 6</p>
<p>That’s a positive number, so the the negative flag is false.</p>
<p>是正数，所以 "负数标志" 是假</p>
<p>That means the processor does not jump.</p>
<p>因此处理器不会执行 JUMP</p>
<p>So we continue on to the next instruction...</p>
<p>继续下一条指令</p>
<p>...which is a JUMP 2.</p>
<p>JUMP 2</p>
<p>No conditional on this one, so we jump to instruction 2 no matter what.</p>
<p>JUMP 2 没有条件，直接执行！</p>
<p>Ok, so we’re back at our SUBTRACT Register B from Register A. 6 minus 5 equals 1.</p>
<p>又回到寄存器 A-B，6-5=1</p>
<p>So 1 gets saved into register A.</p>
<p>A 变成 1</p>
<p>Next instruction.</p>
<p>下一条指令</p>
<p>We’re back again at our JUMP NEGATIVE.</p>
<p>又是 JUMP NEGATIVE</p>
<p>1 is also a positive number, so the CPU continues on to the JUMP 2, looping back around again</p>
<p>因为 1 还是正数，因此 JUMP NEGATIVE 不会执行，来到下一条指令，JUMP 2</p>
<p>to the SUBTRACT instruction.</p>
<p>又来减一次</p>
<p>This time is different though.</p>
<p>这次就不一样了</p>
<p>1 minus 5 is negative 4.</p>
<p>1-5=-4</p>
<p>And so the ALU sets its negative flag to true for the first time.</p>
<p>这次ALU的 "负数标志" 是真</p>
<p>Now, when we advance to the next instruction,</p>
<p>现在下一条指令</p>
<p>JUMP_NEGATIVE 5, the CPU executes the jump to memory location 5.</p>
<p>JUMP NEGATIVE 5, CPU 的执行跳到内存地址 5</p>
<p>We’re out of the infinite loop!</p>
<p>跳出了无限循环！</p>
<p>Now we have a ADD B to A. Negative 4 plus 5, is positive 1, and we save that into Register A.</p>
<p>现在的指令是 ADD B A，-4+5=1，1 存入寄存器 A</p>
<p>Next we have a STORE instruction that saves Register A into memory address 13.</p>
<p>下一条指令  STORE_A 13，把 A 的值存入内存地址 13</p>
<p>Lastly, we hit our HALT instruction and the computer rests.</p>
<p>最后碰到 HALT 指令，停下来.</p>
<p>So even though this program is only 7 instructions long, the CPU ended up executing 13 instructions,</p>
<p>虽然程序只有 7 个指令，但 CPU 执行了 13 个指令,</p>
<p>and that's because it looped twice internally.</p>
<p>因为在内部循环了 2 次.</p>
<p>This code calculated the remainder if we divide 5 into 11, which is one.</p>
<p>这些代码其实是算余数的，11除5余1</p>
<p>With a few extra lines of code, we could also keep track of how many loops we did, the count</p>
<p>如果加多几行指令，我们还可以跟踪循环了多少次</p>
<p>of which would be how many times 5 went into 11… we did two loops, so that means 5 goes</p>
<p>11除5，循环2次</p>
<p>into 11 two times... with a remainder of 1.</p>
<p>余1</p>
<p>And of course this code could work for any two numbers, which we can just change in memory</p>
<p>当然，我们可以用任意2个数，7和81，18和54，什么都行</p>
<p>to whatever we want: 7 and 81, 18 and 54, it doesn’t matter</p>
<p>当然，我们可以用任意2个数，7和81，18和54，什么都行</p>
<p>that’s the power of software!</p>
<p>这就是软件的强大之处</p>
<p>Software also allowed us to do something our hardware could not.</p>
<p>软件还让我们做到硬件做不到的事</p>
<p>Remember, our ALU didn’t have the functionality to divide two numbers,</p>
<p>ALU 可没有除法功能</p>
<p>instead it’s the program we made that gave us that functionality.</p>
<p>是程序给了我们这个功能.</p>
<p>And then other programs can use our divide program to do even fancier things.</p>
<p>别的程序也可以用我们的除法程序，来做其他事情</p>
<p>And you know what that means.</p>
<p>这意味着</p>
<p>New levels of abstraction!</p>
<p>一层新抽象！</p>
<p>So, our hypothetical CPU is very basic – all of its instructions are 8 bits long,</p>
<p>我们这里假设的 CPU 很基础，所有指令都是 8 位,</p>
<p>with the opcode occupying only the first four bits.</p>
<p>操作码只占了前面 4 位</p>
<p>So even if we used every combination of 4 bits, our CPU would only be able to support</p>
<p>即便用尽 4 位，</p>
<p>a maximum of 16 different instructions.</p>
<p>也只能代表 16 个指令</p>
<p>On top of that, several of our instructions used the last 4 bits to specify a memory location.</p>
<p>而且我们有几条指令，是用后 4 位来指定内存地址</p>
<p>But again, 4 bits can only encode 16 different values,</p>
<p>因为 4 位最多只能表示 16 个值，</p>
<p>meaning we can address a maximum of 16 memory locations that’s not a lot to work with.</p>
<p>所以我们只能操作 16 个地址，这可不多.</p>
<p>For example, we couldn’t even JUMP to location 17,</p>
<p>我们甚至不能 JUMP 17</p>
<p>because we literally can’t fit the number 17 into 4 bits.</p>
<p>因为 4 位二进制无法表示数字 17</p>
<p>For this reason, real, modern CPUs use two strategies.</p>
<p>因此，真正的现代 CPU 用两种策略</p>
<p>The most straightforward approach is just to have bigger instructions, with more bits,</p>
<p>最直接的方法是用更多位来代表指令，</p>
<p>like 32 or 64 bits.</p>
<p>比如 32 位或 64 位</p>
<p>This is called the instruction length.</p>
<p>这叫指令长度</p>
<p>Unsurprisingly.</p>
<p>毫不意外</p>
<p>The second approach is to use variable length instructions.</p>
<p>第二个策略是 "可变指令长度"</p>
<p>For example, imagine a CPU that uses 8 bit opcodes.</p>
<p>举个例子，比如某个 CPU 用 8 位长度的操作码</p>
<p>When the CPU sees an instruction that needs no extra values, like the HALT instruction,</p>
<p>如果看到 HALT 指令，HALT 不需要额外数据</p>
<p>it can just execute it immediately.</p>
<p>那么会马上执行.</p>
<p>However, if it sees something like a JUMP instruction, it knows it must also fetch</p>
<p>如果看到 JUMP，它得知道位置值</p>
<p>the address to jump to, which is saved immediately behind the JUMP instruction in memory.</p>
<p>这个值在 JUMP 的后面</p>
<p>This is called, logically enough, an Immediate Value.</p>
<p>这叫 "立即值"</p>
<p>In such processor designs, instructions can be any number of bytes long,</p>
<p>这样设计，指令可以是任意长度</p>
<p>which makes the fetch cycle of the CPU a tad more complicated.</p>
<p>但会让读取阶段复杂一点点</p>
<p>Now, our example CPU and instruction set is hypothetical,</p>
<p>要说明的是，我们拿来举例的 CPU 和指令集都是假设的,</p>
<p>designed to illustrate key working principles.</p>
<p>是为了展示核心原理</p>
<p>So I want to leave you with a real CPU example.</p>
<p>所以我们来看个真的 CPU 例子.</p>
<p>In 1971, Intel released the 4004 processor.</p>
<p>1971年，英特尔发布了 4004 处理器.</p>
<p>It was the first CPU put all into a single chip</p>
<p>这是第一次把 CPU 做成一个芯片，</p>
<p>and paved the path to the intel processors we know and love today.</p>
<p>给后来的英特尔处理器打下了基础</p>
<p>It supported 46 instructions, shown here.</p>
<p>它支持 46 个指令</p>
<p>Which was enough to build an entire working computer.</p>
<p>足够做一台能用的电脑</p>
<p>And it used many of the instructions we’ve talked about like JUMP ADD SUBTRACT and LOAD.</p>
<p>它用了很多我们说过的指令，比如 JUMP ADD SUB LOAD</p>
<p>It also uses 8-bit immediate values, like we just talked about, for things like JUMPs,</p>
<p>它也用 8 位的"立即值"来执行 JUMP, </p>
<p>in order to address more memory.</p>
<p>以表示更多内存地址.</p>
<p>And processors have come a long way since 1971.</p>
<p>处理器从 1971 年到现在发展巨大.</p>
<p>A modern computer processor, like an Intel Core i7, has thousands of different instructions</p>
<p>现代 CPU, 比如英特尔酷睿 i7, 有上千个指令和指令变种</p>
<p>and instruction variants, ranging from one to fifteen bytes long.</p>
<p>长度从1到15个字节.</p>
<p>For example, there’s over a dozens different opcodes just for variants of ADD!</p>
<p>举例，光 ADD 指令就有很多变种!</p>
<p>And this huge growth in instruction set size is due in large part to extra bells and whistles</p>
<p>指令越来越多，是因为给 CPU 设计了越来越多功能</p>
<p>that have been added to processor designs overtime, which we’ll talk about next episode.</p>
<p>下集我们会讲</p>
<p>See you next week!</p>
<p>下周见</p>
<p>Advanced CPU Designs</p>
<p>9 高级CPU设计</p>
<p>Hi, I’m Carrie Anne and welcome to CrashCourse Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>As we’ve discussed throughout the series, computers have come a long way from mechanical devices</p>
<p>随着本系列进展，我们知道计算机进步巨大</p>
<p>capable of maybe one calculation per second,</p>
<p>从 1 秒 1 次运算，</p>
<p>to CPUs running at kilohertz and megahertz speeds.</p>
<p>到现在有千赫甚至兆赫的CPU</p>
<p>The device you’re watching this video on right now is almost certainly running at Gigahertz speeds</p>
<p>你现在看视频的设备八成也有 GHz 速度</p>
<p>that’s billions of instructions executed every second.</p>
<p>1 秒十亿条指令</p>
<p>Which, trust me, is a lot of computation!</p>
<p>这是很大的计算量！</p>
<p>In the early days of electronic computing, processors were typically made faster by</p>
<p>早期计算机的提速方式是  </p>
<p>improving the switching time of the transistors inside the chip</p>
<p>减少晶体管的切换时间.</p>
<p>the ones that make up all the logic gates, ALUs</p>
<p>晶体管组成了逻辑门，</p>
<p>and other stuff we’ve talked about over the past few episodes.</p>
<p>ALU 以及前几集的其他组件</p>
<p>But just making transistors faster and more efficient only went so far, so processor designers</p>
<p>但这种提速方法最终会碰到瓶颈，所以处理器厂商</p>
<p>have developed various techniques to boost performance allowing not only simple instructions</p>
<p>发明各种新技术来提升性能，不但让简单指令运行更快</p>
<p>to run fast, but also performing much more sophisticated operations.</p>
<p>也让它能进行更复杂的运算</p>
<p>Last episode, we created a small program for our CPU that allowed us to divide two numbers.</p>
<p>上集我们写了个做除法的程序，给 CPU 执行</p>
<p>We did this by doing many subtractions in a row... so, for example, 16 divided by 4</p>
<p>方法是做一连串减法，比如16除4 会变成</p>
<p>could be broken down into the smaller problem of 16 minus 4, minus 4, minus 4, minus 4.</p>
<p>16-4 -4 -4 -4</p>
<p>When we hit zero, or a negative number, we knew that we we’re done.</p>
<p>碰到 0 或负数才停下.</p>
<p>But this approach gobbles up a lot of clock cycles, and isn’t particularly efficient.</p>
<p>但这种方法要多个时钟周期，很低效</p>
<p>So most computer processors today have divide as one of the instructions</p>
<p>所以现代 CPU 直接在硬件层面设计了除法，</p>
<p>that the ALU can perform in hardware.</p>
<p>可以直接给 ALU 除法指令</p>
<p>Of course, this extra circuitry makes the ALU bigger and more complicated to design,</p>
<p>这让 ALU 更大也更复杂一些</p>
<p>but also more capable a complexity-for-speed tradeoff that</p>
<p>但也更厉害，复杂度 vs 速度的平衡</p>
<p>has been made many times in computing history.</p>
<p>在计算机发展史上经常出现</p>
<p>For instance, modern computer processors now have special circuits for things like</p>
<p>举例，现代处理器有专门电路来处理，</p>
<p>graphics operations, decoding compressed video, and encrypting files</p>
<p>图形操作, 解码压缩视频, 加密文档等等</p>
<p>all of which are operations that would take many many many clock cycles to perform with standard operations.</p>
<p>如果用标准操作来实现，要很多个时钟周期.</p>
<p>You may have even heard of processors with MMX, 3DNow!, or SSE.</p>
<p>你可能听过某些处理器有 MMX, 3DNOW, SEE</p>
<p>These are processors with additional, fancy circuits that allow them to</p>
<p>它们有额外电路做更复杂的操作</p>
<p>execute additional fancy instructions for things like gaming and encryption.</p>
<p>用于游戏和加密等场景</p>
<p>These extensions to the instruction set have grown, and grown over time, and once people</p>
<p>指令不断增加，</p>
<p>have written programs to take advantage of them, it’s hard to remove them.</p>
<p>人们一旦习惯了它的便利就很难删掉</p>
<p>So instruction sets tend to keep getting larger and larger keeping all the old opcodes around for backwards compatibility.</p>
<p>所以为了兼容旧指令集，指令数量越来越多</p>
<p>The Intel 4004, the first truly integrated CPU, had 46 instructions</p>
<p>英特尔 4004，第一个集成CPU，有 46 条指令</p>
<p>which was enough to build a fully functional computer.</p>
<p>足够做一台能用的计算机</p>
<p>But a modern computer processor has thousands of different instructions,</p>
<p>但现代处理器有上千条指令，</p>
<p>which utilize all sorts of clever and complex internal circuitry.</p>
<p>有各种巧妙复杂的电路</p>
<p>Now, high clock speeds and fancy instruction sets lead to another problem</p>
<p>超高的时钟速度带来另一个问题</p>
<p>getting data in and out of the CPU quickly enough.</p>
<p>如何快速传递数据给 CPU</p>
<p>It’s like having a powerful steam locomotive, but no way to shovel in coal fast enough.</p>
<p>就像有强大的蒸汽机但无法快速加煤</p>
<p>In this case, the bottleneck is RAM.</p>
<p>RAM 成了瓶颈</p>
<p>RAM is typically a memory module that lies outside the CPU.</p>
<p>RAM 是 CPU 之外的独立组件</p>
<p>This means that data has to be transmitted to and from RAM along sets of data wires,</p>
<p>意味着数据要用线来传递，</p>
<p>called a bus.</p>
<p>叫"总线"</p>
<p>This bus might only be a few centimeters long,</p>
<p>总线可能只有几厘米</p>
<p>and remember those electrical signals are traveling near the speed of light,</p>
<p>别忘了电信号的传输接近光速</p>
<p>but when you are operating at gigahertz speeds</p>
<p>但 CPU 每秒可以处理上亿条指令</p>
<p>that’s billionths of a second – even this small delay starts to become problematic.</p>
<p>很小的延迟也会造成问题</p>
<p>It also takes time for RAM itself to lookup the address, retrieve the data</p>
<p>RAM 还需要时间找地址，取数据，</p>
<p>and configure itself for output.</p>
<p>配置，输出数据</p>
<p>So a “load from RAM” instruction might take dozens of clock cycles to complete, and during</p>
<p>一条"从内存读数据"的指令可能要多个时钟周期</p>
<p>this time the processor is just sitting there idly waiting for the data.</p>
<p>CPU 空等数据</p>
<p>One solution is to put a little piece of RAM right on the CPU -called a cache.</p>
<p>解决延迟的方法之一是，给 CPU 加一点 RAM 叫"缓存"</p>
<p>There isn’t a lot of space on a processor’s chip,</p>
<p>因为处理器里空间不大，</p>
<p>so most caches are just kilobytes or maybe megabytes in size,</p>
<p>所以缓存一般只有 KB 或 MB</p>
<p>where RAM is usually gigabytes.</p>
<p>而 RAM 都是 GB 起步</p>
<p>Having a cache speeds things up in a clever way.</p>
<p>缓存提高了速度</p>
<p>When the CPU requests a memory location from RAM, the RAM can transmit</p>
<p>CPU 从 RAM 拿数据时，</p>
<p>not just one single value, but a whole block of data.</p>
<p>RAM 不用传一个，可以传一批</p>
<p>This takes only a little bit more time,</p>
<p>虽然花的时间久一点，</p>
<p>but it allows this data block to be saved into the cache.</p>
<p>但数据可以存在缓存</p>
<p>This tends to be really useful because computer data is often arranged and processed sequentially.</p>
<p>这很实用，因为数据常常是一个个按顺序处理</p>
<p>For example, let say the processor is totalling up daily sales for a restaurant.</p>
<p>举个例子，算餐厅的当日收入</p>
<p>It starts by fetching the first transaction from RAM at memory location 100.</p>
<p>先取 RAM 地址 100 的交易额</p>
<p>The RAM, instead of sending back just that one value, sends a block of data, from memory</p>
<p>RAM 与其只给1个值，直接给一批值</p>
<p>location 100 through 200, which are then all copied into the cache.</p>
<p>把地址100到200都复制到缓存</p>
<p>Now, when the processor requests the next transaction to add to its running total, the</p>
<p>当处理器要下一个交易额时</p>
<p>value at address 101, the cache will say “Oh, I’ve already got that value right here,</p>
<p>地址 101，缓存会说："我已经有了，</p>
<p>so I can give it to you right away!”</p>
<p>现在就给你"</p>
<p>And there’s no need to go all the way to RAM.</p>
<p>不用去 RAM 取数据</p>
<p>Because the cache is so close to the processor,</p>
<p>因为缓存离 CPU 近, </p>
<p>it can typically provide the data in a single clock cycle -no waiting required.</p>
<p>一个时钟周期就能给数据 CPU 不用空等！</p>
<p>This speeds things up tremendously over having to go back and forth to RAM every single time.</p>
<p>比反复去 RAM 拿数据快得多</p>
<p>When data requested in RAM is already stored in the cache like this it’s called a</p>
<p>如果想要的数据已经在缓存，</p>
<p>cache hit,</p>
<p>叫缓存命中</p>
<p>and if the data requested isn’t in the cache, so you have to go to RAM, it’s a called</p>
<p>如果想要的数据不在缓存，</p>
<p>a cache miss.</p>
<p>叫缓存未命中</p>
<p>The cache can also be used like a scratch space,</p>
<p>缓存也可以当临时空间，</p>
<p>storing intermediate values when performing a longer, or more complicated calculation.</p>
<p>存一些中间值，适合长/复杂的运算</p>
<p>Continuing our restaurant example, let’s say the processor has finished totalling up</p>
<p>继续餐馆的例子，假设 CPU 算完了一天的销售额</p>
<p>all of the sales for the day, and wants to store the result in memory address 150.</p>
<p>想把结果存到地址 150</p>
<p>Like before, instead of going back all the way to RAM to save that value,</p>
<p>就像之前，数据不是直接存到 RAM</p>
<p>it can be stored in cached copy, which is faster to save to,</p>
<p>而是存在缓存，这样不但存起来快一些</p>
<p>and also faster to access later if more calculations are needed.</p>
<p>如果还要接着算，取值也快一些</p>
<p>But this introduces an interesting problem -</p>
<p>但这样带来了一个有趣的问题</p>
<p>the cache’s copy of the data is now different to the real version stored in RAM.</p>
<p>缓存和 RAM 不一致了.</p>
<p>This mismatch has to be recorded, so that at some point everything can get synced up.</p>
<p>这种不一致必须记录下来，之后要同步</p>
<p>For this purpose, the cache has a special flag for each block of memory it stores, called</p>
<p>因此缓存里每块空间有一个特殊标记</p>
<p>the dirty bit</p>
<p>叫 "脏位"</p>
<p>which might just be the best term computer scientists have ever invented.</p>
<p>这可能是计算机科学家取的最贴切的名字</p>
<p>Most often this synchronization happens when the cache is full,</p>
<p>同步一般发生在当缓存满了</p>
<p>but a new block of memory is being requested by the processor.</p>
<p>而 CPU 又要缓存时</p>
<p>Before the cache erases the old block to free up space, it checks its dirty bit,</p>
<p>在清理缓存腾出空间之前，会先检查 "脏位"</p>
<p>and if it’s dirty, the old block of data is written back to RAM before loading in the new block.</p>
<p>如果是"脏"的, 在加载新内容之前, 会把数据写回 RAM</p>
<p>Another trick to boost cpu performance is called instruction pipelining.</p>
<p>另一种提升性能的方法叫 "指令流水线"</p>
<p>Imagine you have to wash an entire hotel’s worth of sheets,</p>
<p>想象下你要洗一整个酒店的床单</p>
<p>but you’ve only got one washing machine and one dryer.</p>
<p>但只有 1 个洗衣机, 1 个干燥机</p>
<p>One option is to do it all sequentially: put a batch of sheets in the washer</p>
<p>选择1：按顺序来，</p>
<p>and wait 30 minutes for it to finish.</p>
<p>放洗衣机等 30 分钟洗完</p>
<p>Then take the wet sheets out and put them in the dryer and wait another 30 minutes for that to finish.</p>
<p>然后拿出湿床单，放进干燥机等 30 分钟烘干</p>
<p>This allows you to do one batch of sheets every hour.</p>
<p>这样1小时洗一批</p>
<p>Side note: if you have a dryer that can dry a load of laundry in 30 minutes,</p>
<p>另外一说：如果你有 30 分钟就能烘干的干燥机</p>
<p>Please tell me the brand and model in the comments, because I’m living with 90 minute dry times, minimum.</p>
<p>请留言告诉我是什么牌子，我的至少要 90 分钟.</p>
<p>But, even with this magic clothes dryer,</p>
<p>即使有这样的神奇干燥机, </p>
<p>you can speed things up even more if you parallelize your operation.</p>
<p>我们可以用"并行处理"进一步提高效率</p>
<p>As before, you start off putting one batch of sheets in the washer.</p>
<p>就像之前，先放一批床单到洗衣机</p>
<p>You wait 30 minutes for it to finish.</p>
<p>等 30 分钟洗完</p>
<p>Then you take the wet sheets out and put them in the dryer.</p>
<p>然后把湿床单放进干燥机</p>
<p>But this time, instead of just waiting 30 minutes for the dryer to finish,</p>
<p>但这次，与其干等 30 分钟烘干，</p>
<p>you simultaneously start another load in the washing machine.</p>
<p>可以放另一批进洗衣机</p>
<p>Now you’ve got both machines going at once.</p>
<p>让两台机器同时工作</p>
<p>Wait 30 minutes, and one batch is now done, one batch is half done,</p>
<p>30 分钟后，一批床单完成, 另一批完成一半</p>
<p>and another is ready to go in.</p>
<p>另一批准备开始</p>
<p>This effectively doubles your throughput.</p>
<p>效率x2！</p>
<p>Processor designs can apply the same idea.</p>
<p>处理器也可以这样设计</p>
<p>In episode 7, our example processor performed the fetch-decode-execute cycle sequentially</p>
<p>第7集，我们演示了 CPU 按序处理</p>
<p>and in a continuous loop: Fetch-decode-execute, fetch-decode-execute, fetch-decode-execute, and so on</p>
<p>取指 → 解码 → 执行, 不断重复</p>
<p>This meant our design required three clock cycles to execute one instruction.</p>
<p>这种设计，三个时钟周期执行 1 条指令</p>
<p>But each of these stages uses a different part of the CPU,</p>
<p>但因为每个阶段用的是 CPU 的不同部分</p>
<p>meaning there is an opportunity to parallelize!</p>
<p>意味着可以并行处理！</p>
<p>While one instruction is getting executed, the next instruction could be getting decoded,</p>
<p>"执行"一个指令时，同时"解码"下一个指令</p>
<p>and the instruction beyond that fetched from memory.</p>
<p>"读取"下下个指令</p>
<p>All of these separate processes can overlap</p>
<p>不同任务重叠进行，</p>
<p>so that all parts of the CPU are active at any given time.</p>
<p>同时用上 CPU 里所有部分.</p>
<p>In this pipelined design, an instruction is executed every single clock cycle</p>
<p>这样的流水线每个时钟周期执行1个指令</p>
<p>which triples the throughput.</p>
<p>吞吐量 x 3</p>
<p>But just like with caching this can lead to some tricky problems.</p>
<p>和缓存一样，这也会带来一些问题</p>
<p>A big hazard is a dependency in the instructions.</p>
<p>第一个问题是指令之间的依赖关系</p>
<p>For example, you might fetch something that the currently executing instruction is just about to modify,</p>
<p>举个例子，你在读某个数据，而正在执行的指令会改这个数据</p>
<p>which means you’ll end up with the old value in the pipeline.</p>
<p>也就是说拿的是旧数据</p>
<p>To compensate for this, pipelined processors have to look ahead for data dependencies,</p>
<p>因此流水线处理器要先弄清数据依赖性</p>
<p>and if necessary, stall their pipelines to avoid problems.</p>
<p>必要时停止流水线，避免出问题</p>
<p>High end processors, like those found in laptops and smartphones,</p>
<p>高端 CPU，比如笔记本和手机里那种</p>
<p>go one step further and can dynamically reorder instructions with dependencies</p>
<p>会更进一步，动态排序有依赖关系的指令</p>
<p>in order to minimize stalls and keep the pipeline moving,</p>
<p>最小化流水线的停工时间</p>
<p>which is called out-of-order execution.</p>
<p>这叫 "乱序执行"</p>
<p>As you might imagine, the circuits that figure this all out are incredibly complicated.</p>
<p>和你猜的一样，这种电路非常复杂</p>
<p>Nonetheless, pipelining is tremendously effective and almost all processors implement it today.</p>
<p>但因为非常高效，几乎所有现代处理器都有流水线</p>
<p>Another big hazard are conditional jump instructions -we talked about one example, a JUMP NEGATIVE,last episode.</p>
<p>第二个问题是 "条件跳转"，比如上集的 JUMP NEGATIVE</p>
<p>These instructions can change the execution flow of a program depending on a value.</p>
<p>这些指令会改变程序的执行流</p>
<p>A simple pipelined processor will perform a long stall when it sees a jump instruction,</p>
<p>简单的流水线处理器，看到 JUMP 指令会停一会儿，</p>
<p>waiting for the value to be finalized.</p>
<p>等待条件值确定下来</p>
<p>Only once the jump outcome is known, does the processor start refilling its pipeline.</p>
<p>一旦 JUMP 的结果出了，处理器就继续流水线</p>
<p>But, this can produce long delays, so high-end processors have some tricks to deal with this problem too.</p>
<p>因为空等会造成延迟，所以高端处理器会用一些技巧</p>
<p>Imagine an upcoming jump instruction as a fork in a road a branch.</p>
<p>可以把 JUMP 想成是 "岔路口"</p>
<p>Advanced CPUs guess which way they are going to go, and start filling their pipeline with</p>
<p>高端 CPU 会猜哪条路的可能性大一些</p>
<p>instructions based off that guess – a technique called speculative execution.</p>
<p>然后提前把指令放进流水线，这叫 "推测执行"</p>
<p>When the jump instruction is finally resolved, if the CPU guessed correctly,</p>
<p>当 JUMP 的结果出了，如果 CPU 猜对了</p>
<p>then the pipeline is already full of the correct instructions and it can motor along without delay.</p>
<p>流水线已经塞满正确指令，可以马上运行</p>
<p>However, if the CPU guessed wrong, it has to discard all its speculative results and</p>
<p>如果 CPU 猜错了，就要清空流水线</p>
<p>perform a pipeline flush sort of like when you miss a turn and have to do a u-turn to</p>
<p>就像走错路掉头</p>
<p>get back on route, and stop your GPS’s insistent shouting.</p>
<p>让 GPS 不要再！叫！了！</p>
<p>To minimize the effects of these flushes, CPU manufacturers have developed sophisticated</p>
<p>为了尽可能减少清空流水线的次数，CPU 厂商开发了复杂的方法</p>
<p>ways to guess which way branches will go, called branch prediction.</p>
<p>来猜测哪条分支更有可能，叫"分支预测"</p>
<p>Instead of being a 50/50 guess, today’s processors can often guess with over 90% accuracy!</p>
<p>现代 CPU 的正确率超过 90%</p>
<p>In an ideal case, pipelining lets you complete one instruction every single clock cycle,</p>
<p>理想情况下，流水线一个时钟周期完成 1 个指令</p>
<p>but then superscalar processors came along</p>
<p>然后"超标量处理器"出现了，</p>
<p>which can execute more than one instruction per clock cycle.</p>
<p>一个时钟周期完成多个指令</p>
<p>During the execute phase even in a pipelined design,</p>
<p>即便有流水线设计，在指令执行阶段</p>
<p>whole areas of the processor might be totally idle.</p>
<p>处理器里有些区域还是可能会空闲</p>
<p>For example, while executing an instruction that fetches a value from memory,</p>
<p>比如，执行一个 "从内存取值" 指令期间</p>
<p>the ALU is just going to be sitting there, not doing a thing.</p>
<p>ALU 会闲置</p>
<p>So why not fetch-and-decode several instructions at once, and whenever possible, execute instructions</p>
<p>所以一次性处理多条指令（取指令+解码） 会更好.</p>
<p>that require different parts of the CPU all at the same time</p>
<p>如果多条指令要 ALU 的不同部分，就多条同时执行</p>
<p>But we can take this one step further and add duplicate circuitry</p>
<p>我们可以再进一步，加多几个相同的电路，</p>
<p>for popular instructions.</p>
<p>执行出现频次很高的指令</p>
<p>For example, many processors will have four, eight or more identical ALUs,</p>
<p>举例，很多 CPU 有四个, 八个甚至更多完全相同的ALU</p>
<p>so they can execute many mathematical instructions all in parallel!</p>
<p>可以同时执行多个数学运算</p>
<p>Ok, the techniques we’ve discussed so far primarily optimize the execution throughput</p>
<p>好了，目前说过的方法，</p>
<p>of a single stream of instructions,</p>
<p>都是优化 1 个指令流的吞吐量</p>
<p>but another way to increase performance is to run several streams of instructions at once</p>
<p>另一个提升性能的方法是同时运行多个指令流</p>
<p>with multi-core processors.</p>
<p>用多核处理器</p>
<p>You might have heard of dual core or quad core processors.</p>
<p>你应该听过双核或四核处理器</p>
<p>This means there are multiple independent processing units inside of a single CPU chip.</p>
<p>意思是一个 CPU 芯片里，有多个独立处理单元</p>
<p>In many ways, this is very much like having multiple separate CPUs,</p>
<p>很像是有多个独立 CPU</p>
<p>but because they’re tightly integrated, they can share some resources,</p>
<p>但因为它们整合紧密，可以共享一些资源</p>
<p>like cache, allowing the cores to work together on shared computations.</p>
<p>比如缓存，使得多核可以合作运算</p>
<p>But, when more cores just isn’t enough, you can build computers with multiple independent CPUs!</p>
<p>但多核不够时，可以用多个 CPU</p>
<p>High end computers, like the servers streaming this video from YouTube’s datacenter, often</p>
<p>高端计算机，比如现在给你传视频的 Youtube 服务器</p>
<p>need the extra horsepower to keep it silky smooth for the hundreds of people watching simultaneously.</p>
<p>需要更多马力，让上百人能同时流畅观看</p>
<p>Twoand four-processor configuration are the most common right now,</p>
<p>2个或4个CPU是最常见的</p>
<p>but every now and again even that much processing power isn’t enough.</p>
<p>但有时人们有更高的性能要求</p>
<p>So we humans get extra ambitious and build ourselves a supercomputer!</p>
<p>所以造了超级计算机！</p>
<p>If you’re looking to do some really monster calculations</p>
<p>如果要做怪兽级运算</p>
<p>like simulating the formation of the universe you’ll need some pretty serious compute power.</p>
<p>比如模拟宇宙形成，你需要强大的计算能力</p>
<p>A few extra processors in a desktop computer just isn’t going to cut it.</p>
<p>给普通台式机加几个 CPU 没什么用</p>
<p>You’re going to need a lot of processors.</p>
<p>你需要很多处理器！</p>
<p>No.. no... even more than that.</p>
<p>不…不…还要更多</p>
<p>A lot more!</p>
<p>更多</p>
<p>When this video was made, the world’s fastest computer was located in</p>
<p>截止至视频发布，世上最快的计算机在</p>
<p>The National Supercomputing Center in Wuxi, China.</p>
<p>中国无锡的国家超算中心</p>
<p>The Sunway TaihuLight contains a brain-melting 40,960 CPUs, each with 256 cores!</p>
<p>神威·太湖之光有 40960 个CPU，每个 CPU 有 256 个核心</p>
<p>Thats over ten million cores in total... and each one of those cores runs at 1.45 gigahertz.</p>
<p>总共超过1千万个核心，每个核心的频率是 1.45GHz</p>
<p>In total, this machine can process 93 Quadrillion -that’s 93 million-billions</p>
<p>每秒可以进行 9.3 亿亿次浮点数运算</p>
<p>floating point math operations per second, knows as FLOPS.</p>
<p>也叫每秒浮点运算次数 (FLOPS)</p>
<p>And trust me, that’s a lot of FLOPS!!</p>
<p>相信我这个速度很可怕</p>
<p>No word on whether it can run Crysis at max settings, but I suspect it might.</p>
<p>没人试过跑最高画质的《孤岛危机》但我估计没问题</p>
<p>So long story short, not only have computer processors gotten a lot faster over the years,</p>
<p>长话短说，这些年处理器不但大大提高了速度</p>
<p>but also a lot more sophisticated, employing all sorts of clever tricks to squeeze out</p>
<p>而且也变得更复杂，用各种技巧</p>
<p>more and more computation per clock cycle.</p>
<p>榨干每个时钟周期做尽可能多运算</p>
<p>Our job is to wield that incredible processing power to do cool and useful things.</p>
<p>我们的任务是利用这些运算能力，做又酷又实用的事</p>
<p>That’s the essence of programming, which we’ll start discussing next episode.</p>
<p>编程就是为了这个，我们下集说</p>
<p>See you next week.</p>
<p>下周见</p>
<p>10 早期的编程方式</p>
<p>Early Programming</p>
<p>Hi, I'm Carrie Anne and welcome to Crash Course Computer Science.</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>Over the last few episodes,</p>
<p>前几集</p>
<p>We've talked a lot about the mechanics of how computers work.</p>
<p>我们把重点放在计算机的原理</p>
<p>How they use complex circuits to save and retrieve values from memory,</p>
<p>怎么从内存读写数据，执行操作</p>
<p>and perform operations on those values</p>
<p>怎么从内存读写数据，执行操作</p>
<p>like adding two numbers together.</p>
<p>比如把两个数字加在一起</p>
<p>We've even briefly talked about sequences of operations,</p>
<p>还简单讲了下指令的执行，</p>
<p>which is a computer program</p>
<p>也就是计算机程序</p>
<p>What we haven't talked about is how a program gets into a computer?</p>
<p>但我们还没讲的是：程序如何"进入"计算机</p>
<p>You might remember in episode 7 and 8 ,</p>
<p>你应该记得在第 7, 8 集，</p>
<p>we step through some simple example programs for the CPU that we had created</p>
<p>我们一步步讲了例子程序</p>
<p>For simplicity, we just waved our hands and said that the program was already magically in memory</p>
<p>当时为了简单，我们假设程序已经魔法般在内存里了</p>
<p>But in reality, programs have to be loaded into a computer's memory.</p>
<p>但事实是，程序需要加载进内存</p>
<p>It's not magic. It's computer science</p>
<p>这不是魔法，是计算机科学！</p>
<p>The need to program machines existed way before the development of computers.</p>
<p>给机器编程这个需求，早在计算机出现之前就有了</p>
<p>The most famous example of this was in textile manufacturing</p>
<p>最著名的例子来自纺织业</p>
<p>If you just wanted to weave a big red tablecloth</p>
<p>如果你只想织一块红色大桌布</p>
<p>You could simply feed red thread into a loom and let it run</p>
<p>可以直接放红线进织布机</p>
<p>What about if you wanted the cloth to have a pattern like stripes or plaid?</p>
<p>但如果想要图案怎么办? 比如条纹或者方格</p>
<p>Workers would have to periodically reconfigure the loom as dictated by the pattern,</p>
<p>工人要每隔一会儿调整一次织布机</p>
<p>but this was labor intensive which made patterned fabrics expensive.</p>
<p>因为非常消耗劳动力，所以图案纺织品很贵</p>
<p>The presence or absence of a hole in the card determined if a specific thread was held high or low in the loom</p>
<p>特定位置有没有穿孔，决定了线是高是低</p>
<p>Such as the cross thread, called the weft,  passed above or below the thread</p>
<p>横线是从上/从下穿过</p>
<p>To vary the pattern across rows these punch cards were arranged in long chains</p>
<p>为了让每行图案不同，纸卡连成长条</p>
<p>Forming a sequence of commands for the loom.</p>
<p>形成连续指令</p>
<p>Sound familiar?</p>
<p>听起来很熟？</p>
<p>Many consider Jacquard loom to be one of the earliest forms of programming.</p>
<p>很多人认为雅卡尔织布机是最早的编程</p>
<p>Punched cards, turned out to be a cheap, reliable, fairly human-readable way to store data.</p>
<p>事实证明穿孔纸卡便宜、可靠、也易懂</p>
<p>Nearly a century later,</p>
<p>近一个世纪后</p>
<p>punch cards were used to help tabulate the 1890 US census</p>
<p>穿孔纸卡用于 1890 年美国人口普查</p>
<p>which we talked about in episode 1</p>
<p>我们在第一集提过</p>
<p>Each card held an individual person's data.</p>
<p>一张卡存一个人的信息</p>
<p>things like race</p>
<p>比如种族</p>
<p>marital status</p>
<p>婚姻状况</p>
<p>number of children</p>
<p>子女数量</p>
<p>country of birth and so on</p>
<p>出生国家等等</p>
<p>for each demographic question</p>
<p>针对每个问题，</p>
<p>a census worker would punch out a hole of the appropriate position</p>
<p>人口普查工作者会在对应位置打孔</p>
<p>when a card was fed into the tabulating machine</p>
<p>当卡片插入汇总机</p>
<p>a hole would cause the running total for that specific answer to be increased by one</p>
<p>孔会让对应总和值+1</p>
<p>in this way you could afeed the entire counties worth of people</p>
<p>可以插入整个国家人口的卡片</p>
<p>and at the end you'd have running totals for all of the questions that you ask</p>
<p>在结束后得到各个总值</p>
<p>It is important to note here that early tabulating machines were not truly computers</p>
<p>值得注意的是，早期汇总机不算计算机</p>
<p>as they can only do one thing-tabulate</p>
<p>因为它们只做一件事汇总数据</p>
<p>their operation was fixed and not programmable</p>
<p>操作是固定的，不能编程</p>
<p>punched cards stored data, but not a program</p>
<p>穿孔纸卡存的是数据，不是程序.</p>
<p>over the next 60 years, these business machines grew in capability</p>
<p>之后60年，这些机器被加强，可以做减、乘、除</p>
<p>Adding features to subtract multiply divide</p>
<p>之后60年，这些机器被加强，可以做减、乘、除</p>
<p>and even make simple decisions about when to perform certain operations.</p>
<p>甚至可以做一些小决定，决定何时执行某指令</p>
<p>To trigger these functions appropriately</p>
<p>为了正确执行不同计算，</p>
<p>so that different calculations could be performed, a programmer accessed a control panel</p>
<p>程序员需要某种控制面板</p>
<p>this panel was full of little sockets into which a programmer would plug cables</p>
<p>面板有很多小插孔，程序员可以插电线</p>
<p>to pass values and signals between different parts of the machine</p>
<p>让机器的不同部分互相传数据和信号</p>
<p>for this reason they were also called plug boards</p>
<p>因此也叫 "插线板"</p>
<p>Unfortunately this meant having to rewire the machine each time a different program needed to be run</p>
<p>不幸的是, 这意味着运行不同程序要重新接线</p>
<p>And so by the 1920s these plug boards were made swappable</p>
<p>所以到 1920 年代，控制面板变成了可拔插</p>
<p>This not only made programming a lot more comfortable</p>
<p>让编程更方便</p>
<p>but also allowed for different programs be plugged into a machine</p>
<p>可以给机器插入不同程序</p>
<p>For example one board might be wired to calculate sales tax</p>
<p>比如，一个插线板算销售税，</p>
<p>While another helps with payroll</p>
<p>另一个算工资单</p>
<p>But plug boards were fiendishly complicated to program</p>
<p>但给插线板编程很复杂</p>
<p>This tangle of wires is a program for calculating a profit loss summary using an IBM 402 accounting machine</p>
<p>图中乱成一团的线负责算盈亏总额，用于 IBM 402 核算机</p>
<p>which were popular in the 1940s</p>
<p>在 1940 年代这样做很流行</p>
<p>And this style of plug board programming wasn't unique through electromechanical computers</p>
<p>用插线板编程不只在机电计算机流行</p>
<p>The world's first general-purpose electronic computer, the ENIAC, completed in 1946</p>
<p>世上第一台通用电子计算机，ENIAC，完成于 1946 年</p>
<p>used a ton of them</p>
<p>用了一大堆插线板</p>
<p>Even after a program had been completely figured out on paper</p>
<p>程序在纸上设计好之后</p>
<p>Physically wiring up the ENIAC and getting the program to run could take upwards of three weeks</p>
<p>给 ENIAC 连线，最多可能花三个星期</p>
<p>Given the enormous cost of these early computers, weeks of downtime simply to switch programs was unacceptable</p>
<p>因为早期计算机非常昂贵，停机几个星期只为换程序完全无法接受</p>
<p>and the new faster more flexible way to program machines was badly needed</p>
<p>人们急需更快、更灵活的新方式来编程</p>
<p>Fortunately by the late 1940s and into the 50s</p>
<p>幸运的是，到 1940 年代晚期 1950 年代初</p>
<p>electronic memory was becoming feasible</p>
<p>内存变得可行</p>
<p>As costs fell, memory size grew, instead of storing a program as a physical plug board of wires</p>
<p>价格下降, 容量上升.  与其把程序存在插线板</p>
<p>it became possible to store a program entirely in a computer's memory</p>
<p>存在内存变得可行</p>
<p>where it could be easily changed by programmers and quickly accessed by the CPU</p>
<p>这样程序易于修改、方便 CPU 快速读取</p>
<p>these machines were called Stored-program Computers</p>
<p>这类机器叫 "存储程序计算机"</p>
<p>With enough computer memory you could store not only the program you wanted to run</p>
<p>如果内存足够，不仅可以存要运行的程序</p>
<p>but also any data your program would need</p>
<p>还可以存程序需要的数据</p>
<p>including new values it created along the way</p>
<p>包括程序运行时产生的新数据</p>
<p>Unifying the program and data into a single shared memory is called the Von Neumann Architecture</p>
<p>程序和数据都存在一个地方，叫 "冯诺依曼结构"</p>
<p>named after John Von Neumann</p>
<p>命名自约翰·冯·诺依曼</p>
<p>a prominent mathematician and physicist who worked on the Manhattan project and several early electronic computers</p>
<p>杰出的数学家和物理学家，参与了曼哈顿计划和早期电子计算机项目</p>
<p>and once said I am thinking about something much more important than Bombs</p>
<p>他曾说：我在思考比炸弹重要得多的东西</p>
<p>I'm thinking about computers</p>
<p>计算机</p>
<p>The hallmarks of a Von Neumann computer are a processing unit containing an arithmetic logic unit</p>
<p>冯诺依曼计算机的标志是，一个处理器(有算术逻辑单元)+</p>
<p>data registers and instruction register and instruction address register</p>
<p>数据寄存器+指令寄存器+指令地址寄存器 +</p>
<p>And finally a memory to store both data and instructions</p>
<p>内存（负责存数据和指令)</p>
<p>Hopefully this sounds familiar</p>
<p>希望这听起来很耳熟</p>
<p>Because we actually built a Von Neumann computer in episode 7</p>
<p>因为第7集我们造了一个冯诺依曼计算机</p>
<p>The very first Von Neumann Architecture Stored-program computer</p>
<p>第一台冯诺依曼架构的"储存程序计算机"</p>
<p>was constructed in 1948 by the University of Manchester, nicknamed Baby.</p>
<p>由曼彻斯特大学于 1948 年建造完成，绰号"宝宝"</p>
<p>and even the computer you are watching this video right now</p>
<p>甚至你现在看视频的计算机，</p>
<p>uses the same architecture</p>
<p>也在用一样的架构</p>
<p>Now electronic computer memory is great and all</p>
<p>虽然有内存很棒</p>
<p>but you still have to load the program and data into the computer before it can run</p>
<p>但程序和数据依然需要某种方式输入计算机</p>
<p>and for this reason punch cards were used</p>
<p>所以用穿孔纸卡</p>
<p>Let's get to the Thought bubbles</p>
<p>让我们进入思维泡泡</p>
<p>Well into the 1980s almost all computers have a punch card reader</p>
<p>到1980年代，几乎所有的计算机都有穿孔纸卡读取器</p>
<p>which could suck in a single punch card at a time</p>
<p>可以吸入一张卡片，</p>
<p>and write the contents of the card into the computer's memory</p>
<p>把卡片内容写进内存</p>
<p>If you load it in a stack of punch cards,</p>
<p>如果放了一叠卡片，</p>
<p>the reader would load them all into memory sequentially as a big block</p>
<p>读取器会一个个写进内存</p>
<p>once the program and data were in memory, the computer would be told to execute it</p>
<p>一旦程序和数据写入完毕，电脑会开始执行</p>
<p>Of course even simple computer programs might have hundreds of instructions</p>
<p>即便简单程序也有几百条指令，</p>
<p>which meant that programs were stored as stacks of punch cards</p>
<p>要用一叠纸卡来存</p>
<p>So if you ever have the misfortune of accidentally dropping your program on the floor</p>
<p>如果不小心摔倒弄撒了</p>
<p>it could take you hours days or even weeks to put the code back in the right order</p>
<p>要花上几小时、几天、甚至几周来整理</p>
<p>A common trick was to draw a diagonal line on the side of the card stack called striping,</p>
<p>有个小技巧是在卡片侧面画对角线</p>
<p>so you'd have at least some clue how to get it back into the right order</p>
<p>如果弄散了，整理起来会方便很多</p>
<p>The largest program ever punched into punch cards was the US Air Force's SAGE air defense system, completed in 1955.</p>
<p>用纸卡的最大型程序，是美国空军的 SAGE 防空系统，于 1955 年完成</p>
<p>and its peak, the project is said to have employed 20% of the world's programmers</p>
<p>据称顶峰时期雇佣了世上 20% 程序员</p>
<p>Its main control program was stored on a whopping 62,500 punch cards</p>
<p>主控制程序用了 62500 张穿孔纸卡</p>
<p>which is equivalent to roughly 5 megabytes of data</p>
<p>等同于大约 5MB 的数据</p>
<p>Pretty underwhelming by today's standards</p>
<p>以如今的标准，不值一提</p>
<p>And punch cards weren't only useful for getting data into computers</p>
<p>穿孔纸卡不仅可以往计算机放数据</p>
<p>but also getting data out of them</p>
<p>还可以取出数据</p>
<p>At the end of a program results could be written out of computer memory and onto punch cards by, well, punching cards</p>
<p>程序运行到最后，结果可以输到纸卡上，方式嘛，当然是打孔</p>
<p>then this data could be analyzed by humans or loaded into a second program for additional computation</p>
<p>然后人可以分析结果，或者再次放进计算机，做进一步计算</p>
<p>Thanks, thought-bubble</p>
<p>谢了思维泡泡</p>
<p>A close cousin to punch cards was punched paper tape</p>
<p>穿孔纸卡的亲戚是纸带</p>
<p>Which is basically the same idea, but continuous instead of being on individual cards</p>
<p>基本是一回事，只不过更连续，不是一张张卡.</p>
<p>And of course we haven't talked about Hard Drives, CD-ROMs, DVDs, USB-Thumb drives and other similar goodies</p>
<p>当然我们还没提硬盘, 只读光盘, DVD, U盘等等</p>
<p>We'll get to those more advanced types of data storage in a future episode</p>
<p>以后我们会讲这些更先进的存储方法</p>
<p>Finally in addition to plug boards and punch paper</p>
<p>最后，除了插线板和穿孔纸卡</p>
<p>there was another common way to program and control computers in pre-1980</p>
<p>在 1980 年代前，还有一种常见编程方式</p>
<p>Panel programming</p>
<p>面板编程</p>
<p>Rather than having to physically plug in cables to activate certain functions</p>
<p>与其插一堆线到插线板</p>
<p>this could also be done with huge panels full of switches and buttons</p>
<p>可以用一大堆开关和按钮，做到一样的效果</p>
<p>And there were indicator lights to display the status of various functions and values in memory</p>
<p>面板上有指示灯，代表各种函数的状态和内存中的值</p>
<p>Computers of the 50s and 60s often featured huge control consoles that look like this</p>
<p>50和60年代的计算机，一般都有这样巨大的控制台</p>
<p>Although it was rare to input a whole program using just switches,it was possible</p>
<p>很少有人只用开关来输入一整个程序，但技术上是可行的</p>
<p>And early home computers made for the hobbyist market use switches extensively</p>
<p>早期针对计算机爱好者的家用计算机，大量使用了开关</p>
<p>because most home users couldn't afford expensive peripherals like punch card readers</p>
<p>因为大多数家庭用户负担不起昂贵的外围设备，比如穿孔纸卡读取器</p>
<p>The first commercially successful home computer was the Altair 8800</p>
<p>第一款取得商业成功的家用计算机是 Altair 8800</p>
<p>which sold in two versions: Pre-assembled and the Kit</p>
<p>有两种版本可以买：预先装好的整机和需要组装的组件</p>
<p>the Kit which was popular with amateur computing enthusiasts,</p>
<p>计算机爱好者喜欢买组件版</p>
<p>sold for the then unprecedented low price are around $400 in 1975</p>
<p>售价极低，在 1975 年卖 400 美元左右</p>
<p>Or about $2,000 in 2017</p>
<p>相当于 2017 年的 2000 美元</p>
<p>To program the 8800, you'd literally toggle the switches on the front panel</p>
<p>为了给 8800 编程，你要拨动面板上的开关</p>
<p>to enter the binary op-codes for the instruction you wanted</p>
<p>输入二进制操作码</p>
<p>Then you press the deposit button to write that value into memory</p>
<p>然后按 "存储键" 把值存入内存</p>
<p>Then in the next location in memory you toggle the switches again</p>
<p>然后会到下一个内存位置，你可以再次拨开关，写下一个指令</p>
<p>for your next instruction deposit it and so on</p>
<p>重复这样做</p>
<p>When you finally entered your whole program into memory</p>
<p>把整个程序都写入内存之后</p>
<p>you would toggle the switches moves back to memory address 0</p>
<p>可以推动开关，回到内存地址0</p>
<p>press the run button and watch the little lights blink</p>
<p>然后按运行按钮，灯会闪烁</p>
<p>That was home computing in 1975, Wow.</p>
<p>这就是 1975 年的家用计算机, 哇.</p>
<p>Whether it was plug board, switches or punched paper</p>
<p>不管是插线板、开关或穿孔纸卡</p>
<p>Programming these early computers was the realm of experts</p>
<p>早期编程都是专家活</p>
<p>either professionals who did this for living or technology enthusiasts</p>
<p>不管是全职还是技术控，</p>
<p>you needed intimate knowledge of the underlying hardware,</p>
<p>都要非常了解底层硬件</p>
<p>so things like processor op-codes and register wits, to write programs</p>
<p>比如操作码, 寄存器等, 才能写程序</p>
<p>This meant programming was hard and tedious and even professional engineers</p>
<p>所以编程很难，很烦</p>
<p>and scientists struggled to take full advantage of what computing could offer</p>
<p>哪怕工程师和科学家都无法完全发挥计算机的能力</p>
<p>What was needed was a simpler way to tell computers what to do,</p>
<p>我们需要一种更简单方式告诉计算机要做什么</p>
<p>a simpler way to write programs</p>
<p>一种更简单的编程方式</p>
<p>And that brings us to programming languages, which we'll talk about next episode</p>
<p>这带领我们到下一个话题编程语言, 我们下集会讲</p>
<p>See you next week</p>
<p>下周见</p>
<p>This episode is brought to you by CuriosityStream.</p>
<p>本集由 CuriosityStream 赞助播出</p>
<p>11 编程语言发展史</p>
<p>The First Programming Languages</p>
<p>Hi, I'm Carrie Anne and welcome to Crash Course Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>So far, for most of this series, we've focused on hardware</p>
<p>之前我们把重点放在硬件 </p>
<p>the physical components of computing --</p>
<p>组成计算机的物理组件</p>
<p>things like: electricity and circuits, registers and RAM, ALUs and CPUs.</p>
<p>比如电，电路，寄存器，RAM，ALU，CPU</p>
<p>But programming at the hardware level is cumbersome and inflexible,</p>
<p>但在硬件层面编程非常麻烦</p>
<p>so programmers wanted a more versatile way to program computers</p>
<p>所以程序员想要一种更通用的方法编程</p>
<p>what you might call a "softer" medium.</p>
<p>一种"更软的"媒介</p>
<p>That's right, we're going to talk about Software!</p>
<p>没错，我们要讲软件！</p>
<p>In episode 8, we walked through a simple program for the CPU we designed.</p>
<p>第 8 集我们一步步讲了一个简单程序</p>
<p>The very first instruction to be executed, the one at memory address 0, was 0010 1110.</p>
<p>第一条指令在内存地址 0：0010 1110</p>
<p>As we discussed, the first four bits of an instruction is the operation code,</p>
<p>之前说过，前 4 位是操作码</p>
<p>or OPCODE for short.</p>
<p>简称 OPCODE</p>
<p>On our hypothetical CPU, 0010 indicated a LOAD_A instruction</p>
<p>对于这个假设 CPU，0010 代表 LOAD_A 指令</p>
<p>which moves a value from memory into Register A.</p>
<p>把值从内存复制到寄存器 A</p>
<p>The second set of four bits defines the memory location,</p>
<p>后 4 位是内存地址，</p>
<p>in this case, 1110, which is 14 in decimal.</p>
<p>1110 是十进制的 14</p>
<p>So what these eight numbers really mean is "LOAD Address 14 into Register A".</p>
<p>所以这 8 位表达的意思是，"读内存地址 14，放入寄存器 A"</p>
<p>We're just using two different languages.</p>
<p>只是用了两种不同语言</p>
<p>You can think of it like English and Morse Code.</p>
<p>可以想成是英语和摩尔斯码的区别</p>
<p>"Hello" and ".... . .-.. .-.. ---" mean the same thing -hello! --</p>
<p>"你好" 和 ".... . .-.. .-.. ---" 是一个意思：你好</p>
<p>they're just encoded differently.</p>
<p>只是编码方式不同</p>
<p>English and Morse Code also have different levels of complexity.</p>
<p>英语和摩尔斯码的复杂度也不同</p>
<p>English has 26 different letters in its alphabet and way more possible sounds.</p>
<p>英文有 26 个字母以及各种发音</p>
<p>Morse only has dots and dashes.</p>
<p>摩尔斯码只有"点"和"线"</p>
<p>But, they can convey the same information, and computer languages are similar.</p>
<p>但它们可以传达相同的信息，计算机语言也类似.</p>
<p>As we've seen, computer hardware can only handle raw, binary instructions.</p>
<p>计算机能处理二进制，</p>
<p>This is the "language" computer processors natively speak.</p>
<p>二进制是处理器的"母语"</p>
<p>In fact, it's the only language they're able to speak.</p>
<p>事实上，它们*只能*理解二进制</p>
<p>It's called Machine Language or Machine Code.</p>
<p>这叫"机器语言"或"机器码"</p>
<p>In the early days of computing, people had to write entire programs in machine code.</p>
<p>在计算机早期阶段，必须用机器码写程序</p>
<p>More specifically, they'd first write a high-level version of a program on paper, in English,</p>
<p>具体来讲，会先在纸上用英语写一个"高层次版"</p>
<p>For example "retrieve the next sale from memory,</p>
<p>举例："从内存取下一个销售额，</p>
<p>then add this to the running total for the day, week and year,</p>
<p>然后加到天、周、年的总和</p>
<p>then calculate any tax to be added"</p>
<p>然后算税"</p>
<p>...and so on.</p>
<p>等等...</p>
<p>An informal, high-level description of a program like this is called Pseudo-Code.</p>
<p>这种对程序的高层次描述，叫 "伪代码"</p>
<p>Then, when the program was all figured out on paper,</p>
<p>在纸上写好后</p>
<p>they'd painstakingly expand and translate it into binary machine code by hand,</p>
<p>用"操作码表"把伪代码</p>
<p>using things like opcode tables.</p>
<p>转成二进制机器码</p>
<p>After the translation was complete, the program could be fed into the computer and run.</p>
<p>翻译完成后，程序可以喂入计算机并运行</p>
<p>As you might imagine, people quickly got fed up with this process.</p>
<p>你可能猜到了，很快人们就厌烦了</p>
<p>So, by the late 1940s and into the 50s,</p>
<p>所以在 1940~1950 年代</p>
<p>programmers had developed slightly higher-level languages that were more human-readable.</p>
<p>程序员开发出一种新语言，更可读更高层次</p>
<p>Opcodes were given simple names, called mnemonics,</p>
<p>每个操作码分配一个简单名字，叫"助记符"</p>
<p>which were followed by operands, to form instructions.</p>
<p>"助记符"后面紧跟数据，形成完整指令</p>
<p>So instead of having to write instructions as a bunch of 1's and 0's,</p>
<p>与其用 1 和 0 写代码，</p>
<p>programmers could write something like "LOAD_A 14".</p>
<p>程序员可以写"LOAD_A 14"</p>
<p>We used this mnemonic in Episode 8 because it's so much easier to understand!</p>
<p>我们在第 8 集用过这个助记符，因为容易理解得多！</p>
<p>Of course, a CPU has no idea what "LOAD_A 14" is.</p>
<p>当然，CPU 不知道 LOAD_A 14 是什么</p>
<p>It doesn't understand text-based language, only binary.</p>
<p>它不能理解文字，只能理解二进制</p>
<p>And so programmers came up with a clever trick.</p>
<p>所以程序员想了一个技巧，</p>
<p>They created reusable helper programs, in binary,</p>
<p>写二进制程序来帮忙</p>
<p>that read in text-based instructions,</p>
<p>它可以读懂文字指令，</p>
<p>and assemble them into the corresponding binary instructions automatically.</p>
<p>自动转成二进制指令</p>
<p>This program is called</p>
<p>这种程序叫</p>
<p>you guessed it --</p>
<p>你可能猜到了</p>
<p>an Assembler.</p>
<p>汇编器</p>
<p>It reads in a program written in an Assembly Language</p>
<p>汇编器读取用"汇编语言"写的程序，</p>
<p>and converts it to native machine code.</p>
<p>然后转成"机器码"</p>
<p>"LOAD_A 14" is one example of an assembly instruction.</p>
<p>"LOAD_A 14" 是一个汇编指令的例子</p>
<p>Over time, Assemblers gained new features that made programming even easier.</p>
<p>随着时间推移，汇编器有越来越多功能，让编程更容易</p>
<p>One nifty feature is automatically figuring out JUMP addresses.</p>
<p>其中一个功能是自动分析 JUMP 地址</p>
<p>This was an example program I used in episode 8:</p>
<p>这里有一个第8集用过的例子：</p>
<p>Notice how our JUMP NEGATIVE instruction jumps to address 5,</p>
<p>注意, JUMP NEGATIVE 指令跳到地址 5</p>
<p>and our regular JUMP goes to address 2.</p>
<p>JUMP 指令跳到地址 2</p>
<p>The problem is, if we add more code to the beginning of this program,</p>
<p>问题是，如果在程序开头多加一些代码</p>
<p>all of the addresses would change.</p>
<p>所有地址都会变</p>
<p>That's a huge pain if you ever want to update your program!</p>
<p>更新程序会很痛苦！</p>
<p>And so an assembler does away with raw jump addresses,</p>
<p>所以汇编器不用固定跳转地址</p>
<p>and lets you insert little labels that can be jumped to.</p>
<p>而是让你插入可跳转的标签</p>
<p>When this program is passed into the assembler,</p>
<p>当程序被传入汇编器，</p>
<p>it does the work of figuring out all of the jump addresses.</p>
<p>汇编器会自己搞定跳转地址</p>
<p>Now the programmer can focus more on programming</p>
<p>程序员可以专心编程，</p>
<p>and less on the underlying mechanics under the hood</p>
<p>不用管底层细节</p>
<p>enabling more sophisticated things to be built by hiding unnecessary complexity.</p>
<p>隐藏不必要细节来做更复杂的工作</p>
<p>As we've done many times in this series,</p>
<p>正如我们在本系列中所做的那样，</p>
<p>we're once again moving up another level of abstraction.</p>
<p>我们又提升了一层抽象</p>
<p>However, even with nifty assembler features like auto-linking JUMPs to labels,</p>
<p>然而，即使汇编器有这些厉害功能，比如自动跳转</p>
<p>Assembly Languages are still a thin veneer over machine code.</p>
<p>汇编只是修饰了一下机器码</p>
<p>In general, each assembly language instruction converts directly</p>
<p>一般来说，一条汇编指令</p>
<p>to a corresponding machine instruction a one-to-one mapping -</p>
<p>对应一条机器指令</p>
<p>so it's inherently tied to the underlying hardware.</p>
<p>所以汇编码和底层硬件的连接很紧密</p>
<p>And the assembler still forces programmers to think about</p>
<p>汇编器仍然强迫程序员思考</p>
<p>which registers and memory locations they will use.</p>
<p>用什么寄存器和内存地址</p>
<p>If you suddenly needed an extra value,</p>
<p>如果你突然要一个额外的数，</p>
<p>you might have to change a lot of code to fit it in.</p>
<p>可能要改很多代码</p>
<p>Let's go to the Thought Bubble.</p>
<p>让我们进入思考泡泡</p>
<p>This problem did not escape Dr. Grace Hopper.</p>
<p>葛丽丝·霍普博士也遇到了这个问题</p>
<p>As a US naval officer, she was one of the first programmers on the Harvard Mark 1 computer,</p>
<p>作为美国海军军官，她是哈佛1号计算机的首批程序员之一</p>
<p>which we talked about in Episode 2.</p>
<p>这台机器我们在第 2 集提过</p>
<p>This was a colossal, electro-mechanical beast</p>
<p>这台巨大机电野兽</p>
<p>completed in 1944 as part of the allied war effort.</p>
<p>在 1944 年战时建造完成，帮助盟军作战</p>
<p>Programs were stored and fed into the computer on punched paper tape.</p>
<p>程序写在打孔纸带上，放进计算机执行</p>
<p>By the way, as you can see,</p>
<p>顺便一说，</p>
<p>they "patched" some bugs in this program</p>
<p>如果程序里有漏洞</p>
<p>by literally putting patches of paper over the holes on the punch tape.</p>
<p>真的就直接用胶带来补"漏洞"</p>
<p>The Mark 1's instruction set was so primitive,</p>
<p>Mark 1 的指令集非常原始，</p>
<p>there weren't even JUMP instructions.</p>
<p>甚至没有 JUMP 指令</p>
<p>To create code that repeated the same operation multiple times,</p>
<p>如果代码要跑不止一次</p>
<p>you'd tape the two ends of the punched tape together, creating a physical loop.</p>
<p>得把带子的两端连起来做成循环</p>
<p>In other words, programming the Mark 1 was kind of a nightmare!</p>
<p>换句话说，给 Mark 1 编程简直是噩梦！</p>
<p>After the war, Hopper continued to work at the forefront of computing.</p>
<p>战后，霍普继续在计算机前沿工作</p>
<p>To unleash the potential of computers,</p>
<p>为了释放电脑的潜力</p>
<p>she designed a high-level programming language called "Arithmetic Language Version 0",</p>
<p>她设计了一个高级编程语言，叫"算术语言版本 0"</p>
<p>or A-0 for short.</p>
<p>简称"A-0"</p>
<p>Assembly languages have direct, one-to-one mapping to machine instructions.</p>
<p>汇编与机器指令是一一对应的</p>
<p>But, a single line of a high-level programming language</p>
<p>但一行高级编程语言</p>
<p>might result in dozens of instructions being executed by the CPU.</p>
<p>可能会转成几十条二进制指令</p>
<p>To perform this complex translation, Hopper built the first compiler in 1952.</p>
<p>为了做到这种复杂转换，Hopper 在 1952 年创造了第一个编译器</p>
<p>This is a specialized program</p>
<p>编译器专门把高级语言</p>
<p>that transforms "source" code written in a programming language into a low-level language,</p>
<p>转成低级语言</p>
<p>like assembly or the binary "machine code" that the CPU can directly process.</p>
<p>比如汇编或机器码（CPU 可以直接执行机器码）</p>
<p>Thanks, Thought Bubble.</p>
<p>谢了思想泡泡</p>
<p>So, despite the promise of easier programming,</p>
<p>尽管"使编程更简单"很诱人</p>
<p>many people were skeptical of Hopper's idea.</p>
<p>但很多人对霍普的点子持怀疑态度</p>
<p>She once said, "I had a running compiler and nobody would touch it.</p>
<p>她曾说"我有能用的编译器，但没人愿意用</p>
<p>they carefully told me, computers could only do arithmetic;</p>
<p>他们告诉我计算机只能做算术,</p>
<p>they could not do programs."</p>
<p>不能运行程序"</p>
<p>But the idea was a good one,</p>
<p>但这个点子是好的</p>
<p>and soon many efforts were underway to craft new programming languages</p>
<p>不久，很多人尝试创造新编程语言</p>
<p>today there are hundreds!</p>
<p>如今有上百种语言！</p>
<p>Sadly, there are no surviving examples of A-0 code,</p>
<p>可惜的是，没有任何 A-0 的代码遗留下来</p>
<p>so we'll use Python, a modern programming language, as an example.</p>
<p>所以我们用 Python 举例（一门现代编程语言）</p>
<p>Let's say we want to add two numbers and save that value.</p>
<p>假设我们想相加两个数字，保存结果</p>
<p>Remember, in assembly code,</p>
<p>记住，如果用汇编代码</p>
<p>we had to fetch values from memory, deal with registers, and other low-level details.</p>
<p>我们得从内存取值，和寄存器打交道，以及其他底层细节</p>
<p>But this same program can be written in python like so:</p>
<p>但同样的程序可以用 Python 这样写：</p>
<p>Notice how there are no registers or memory locations to deal with</p>
<p>不用管寄存器或内存位置</p>
<p>the compiler takes care of that stuff, abstracting away a lot of low-level and unnecessary complexity.</p>
<p>编译器会搞定这些细节，不用管底层细节</p>
<p>The programmer just creates abstractions for needed memory locations, known as variables,</p>
<p>程序员只需要创建代表内存地址的抽象，叫"变量"</p>
<p>and gives them names.</p>
<p>给变量取名字</p>
<p>So now we can just take our two numbers, store them in variables we give names to</p>
<p>现在可以把两个数存在变量里</p>
<p>in this case, I picked a and b but those variables could be anything -</p>
<p>这里取名 A 和 B, 实际编程时你可以随便取名</p>
<p>and then add those together, saving the result in c, another variable I created.</p>
<p>然后相加两个数，把结果存在变量 C</p>
<p>It might be that the compiler assigns Register A under the hood to store the value in a,</p>
<p>底层操作时，编译器可能把变量 A 存在寄存器 A</p>
<p>but I don't need to know about it!</p>
<p>但我不需要知道这些！</p>
<p>Out of sight, out of mind!</p>
<p>眼不见心不烦</p>
<p>It was an important historical milestone,</p>
<p>这是个重要历史里程碑</p>
<p>but A-0 and its later variants weren't widely used.</p>
<p>但 A-0 和之后的版本没有广泛使用</p>
<p>FORTRAN, derived from "Formula Translation",</p>
<p>FORTRAN，名字来自 "公式翻译"</p>
<p>was released by IBM a few years later, in 1957,</p>
<p>这门语言数年后由 IBM 在 1957 年发布</p>
<p>and came to dominate early computer programming.</p>
<p>主宰了早期计算机编程</p>
<p>John Backus, the FORTRAN project director,</p>
<p>FORTRAN 项目总监 John Backus 说过</p>
<p>said: "Much of my work has come from being lazy.</p>
<p>"我做的大部分工作都是因为懒</p>
<p>I didn't like writing programs,</p>
<p>我不喜欢写程序</p>
<p>and so ... I started work on a programming system to make it easier to write programs."</p>
<p>所以我写这门语言，让编程更容易"</p>
<p>You know, typical lazy person.</p>
<p>你懂的，典型的"懒人"</p>
<p>They're always creating their own programming systems.</p>
<p>（白眼）创造自己的编程语言</p>
<p>Anyway, on average, programs written in FORTRAN</p>
<p>平均来说，FORTRAN 写的程序</p>
<p>were 20 times shorter than equivalent handwritten assembly code.</p>
<p>比等同的手写汇编代码短 20 倍</p>
<p>Then the FORTRAN Compiler would translate and expand that into native machine code.</p>
<p>然后 FORTRAN 编译器会把代码转成机器码</p>
<p>The community was skeptical that the performance would be as good as hand written code,</p>
<p>人们怀疑性能是否比得上手写代码</p>
<p>but the fact that programmers could write more code more quickly,</p>
<p>但因为能让程序员写程序更快，</p>
<p>made it an easy choice economically:</p>
<p>所以成了一个更经济的选择</p>
<p>trading a small increase in computation time for a significant decrease in programmer time.</p>
<p>运行速度慢一点点，编程速度大大加快</p>
<p>Of course, IBM was in the business of selling computers,</p>
<p>当时 IBM 在卖计算机</p>
<p>and so initially, FORTRAN code could only be compiled and run on IBM computers.</p>
<p>因此最初 FORTRAN 代码只能跑在 IBM 计算机上</p>
<p>And most programing languages and compilers of the 1950s</p>
<p>1950 年代大多数编程语言和编译器</p>
<p>could only run on a single type of computer.</p>
<p>只能运行在一种计算机上</p>
<p>So, if you upgraded your computer,</p>
<p>如果升级电脑</p>
<p>you'd often have to re-write all the code too!</p>
<p>可能要重写所有代码！</p>
<p>In response, computer experts from industry,</p>
<p>因此工业界，</p>
<p>academia and government formed a consortium in 1959</p>
<p>学术界，政府的计算机专家，在 1959 年组建了一个联盟</p>
<p>the Committee on Data Systems Languages, advised by our friend Grace Hopper --</p>
<p>数据系统语言委员会，Grace Hopper 担任顾问</p>
<p>to guide the development of a common programming language</p>
<p>开发一种通用编程语言，</p>
<p>that could be used across different machines.</p>
<p>可以在不同机器上通用</p>
<p>The result was the high-level, easy to use,</p>
<p>最后诞生了一门高级，易于使用，</p>
<p>Common Business-Oriented Language, or COBOL for short.</p>
<p>"普通面向商业语言"，简称 COBOL</p>
<p>To deal with different underlying hardware,</p>
<p>为了兼容不同底层硬件</p>
<p>each computing architecture needed its own COBOL compiler.</p>
<p>每个计算架构需要一个 COBOL 编译器</p>
<p>But critically, these compilers could all accept the same COBOL source code,</p>
<p>最重??要的是，这些编译器都可以接收相同 COBOL 代码</p>
<p>no matter what computer it was run on.</p>
<p>不管是什么电脑</p>
<p>This notion is called write once, run anywhere.</p>
<p>这叫"一次编写，到处运行"</p>
<p>It's true of most programming languages today,</p>
<p>如今大多数编程语言都是这样</p>
<p>a benefit of moving away from assembly and machine code,</p>
<p>不必接触 CPU 特有的</p>
<p>which is still CPU specific.</p>
<p>汇编码和机器码</p>
<p>The biggest impact of all this was reducing computing's barrier to entry.</p>
<p>减小了使用门槛</p>
<p>Before high level programming languages existed,</p>
<p>在高级编程语言出现之前</p>
<p>it was a realm exclusive to computer experts and enthusiasts.</p>
<p>编程只是计算机专家和爱好者才会做的事</p>
<p>And it was often their full time profession.</p>
<p>而且通常是主职</p>
<p>But now, scientists, engineers, doctors, economists, teachers,</p>
<p>但现在，科学家，工程师，医生，经济学家，教师</p>
<p>and many others could incorporate computation into their work .</p>
<p>等等，都可以把计算机用于工作</p>
<p>Thanks to these languages,</p>
<p>感谢这些语言</p>
<p>computing went from a cumbersome and esoteric discipline</p>
<p>计算机科学从深奥学科 </p>
<p>to a general purpose and accessible tool.</p>
<p>变成了大众化工具</p>
<p>At the same time, abstraction in programming allowed those computer experts</p>
<p>同时，编程的抽象也让计算机专家</p>
<p>now "professional programmers" -</p>
<p>现在叫"专业程序员"</p>
<p>to create increasingly sophisticated programs,</p>
<p>制作更复杂的程序</p>
<p>which would have taken millions, tens of millions, or even more lines of assembly code.</p>
<p>如果用汇编写可能要上百万行</p>
<p>Now, this history didn't end in 1959.</p>
<p>当然，计算机的历史没有在 1959 年结束</p>
<p>In fact, a golden era in programming language design jump started,</p>
<p>编程语言设计的黄金时代才刚刚开始</p>
<p>evolving in lockstep with dramatic advances in computer hardware.</p>
<p>和硬件一起飞速发展</p>
<p>In the 1960s, we had languages like ALGOL, LISP and BASIC.</p>
<p>在 1960 年代，有 ALGOL, LISP 和 BASIC 等语言</p>
<p>In the 70's: Pascal, C and Smalltalk were released.</p>
<p>70年代有：Pascal，C 和 Smalltalk</p>
<p>The 80s gave us C++, Objective-C, and Perl.</p>
<p>80年代有：C++，Objective-C 和 Perl</p>
<p>And the 90's: python, ruby, and Java.</p>
<p>90年代有：Python，Ruby 和 Java</p>
<p>And the new millennium has seen the rise of Swift, C#, and Go</p>
<p>新千年 Swift, C#, Go 在崛起</p>
<p>not to be confused with Let it Go and Pokemon Go.</p>
<p>不要把 Go 和，《冰雪奇缘》的 Let it Go 和游戏 Pokemon Go 弄混</p>
<p>Anyway, some of these might sound familiar</p>
<p>有些语言你可能听起来耳熟</p>
<p>many are still around today.</p>
<p>很多现在还存在</p>
<p>It's extremely likely that the web browser you're using right now</p>
<p>你现在用的浏览器很可能是</p>
<p>was written in C++ or Objective-C.</p>
<p> C++ 或 Objective-C 写的</p>
<p>That list I just gave is the tip of the iceberg.</p>
<p>我刚才说的编程语言名字只是冰山一角</p>
<p>And languages with fancy, new features are proposed all the time.</p>
<p>新的编程语言在不断诞生</p>
<p>Each new language attempts to leverage new and clever abstractions</p>
<p>新语言想用更聪明的抽象</p>
<p>to make some aspect of programming easier or more powerful,</p>
<p>让某些方面更容易或更强大</p>
<p>or take advantage of emerging technologies and platforms,</p>
<p>或利用新技术和新平台带来的优势</p>
<p>so that more people can do more amazing things, more quickly.</p>
<p>让更多人能快速做出美妙的事情</p>
<p>Many consider the holy grail of programming to be the use of "plain ol' English",</p>
<p>许多人认为编程的"圣杯"是直接用英文</p>
<p>where you can literally just speak what you want the computer to do,</p>
<p>直接对计算机说话，然后它会理解并执行</p>
<p>it figures it out, and executes it.</p>
<p>直接对计算机说话，然后它会理解并执行</p>
<p>This kind of intelligent system is science fiction for now.</p>
<p>这种智能系统目前只存在于科幻小说</p>
<p>And fans of 2001: A Space Odyssey may be okay with that.</p>
<p>"2001：太空漫游" 的粉丝可能没什么意见</p>
<p>Now that you know all about programming languages,</p>
<p>现在你理解了编程语言,</p>
<p>we're going to deep dive for the next couple of episodes,</p>
<p>接下来几集</p>
<p>and we'll continue to build your understanding</p>
<p>我们会深入了解</p>
<p>of how programming languages, and the software they create,</p>
<p>编程语言和用语言写的软件</p>
<p>are used to do cool and unbelievable things.</p>
<p>是怎么做到那些酷事</p>
<p>See you next week.</p>
<p>下周见</p>
<p>12 编程原理：语句和函数</p>
<p>Programming Basics: Statements & Functions</p>
<p>Hi, I’m Carrie Anne, and welcome to CrashCourse Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>Last episode we discussed how writing programs in native machine code,</p>
<p>上集讲到用机器码写程序,</p>
<p>and having to contend with so many low level details, was a huge impediment to writing complex programs.</p>
<p>还要处理那么多底层细节对写大型程序是个巨大障碍</p>
<p>To abstract away many of these low-level details, Programming Languages were developed that</p>
<p>为了脱离底层细节，开发了编程语言</p>
<p>let programmers concentrate on solving a problem with computation, and less on nitty gritty hardware details.</p>
<p>让程序员专心解决问题，不用管硬件细节</p>
<p>So today, we’re going to continue that discussion, and introduce some fundamental building blocks</p>
<p>今天我们讨论  </p>
<p>that almost all programming languages provide.</p>
<p>大多数编程语言都有的基本元素</p>
<p>Just like spoken languages, programming languages have statements.</p>
<p>就像口语一样，编程语言有"语句"</p>
<p>These are individual complete thoughts, like "I want tea" or "it is raining".</p>
<p>语句表达单个完整思想，比如"我想要茶"或者"在下雨"</p>
<p>By using different words, we can change the meaning;</p>
<p>用不同词汇可以代表不同含义，</p>
<p>for example, "I want tea" to "I want unicorns".</p>
<p>比如"我想要茶"变成"我想要独角兽"</p>
<p>But we can’t change "I want tea" to "I want raining" that doesn’t make grammatical sense.</p>
<p>但没法把"我想要茶"改成"我想要雨"语法毫无意义</p>
<p>The set of rules that govern the structure and composition of statements in a language</p>
<p>规定句子结构的一系列规则</p>
<p>is called syntax.</p>
<p>叫语法</p>
<p>The English language has syntax, and so do all programming languages.</p>
<p>英语有语法，所有编程语言也都有语法</p>
<p>"a = 5" is a programming language statement.</p>
<p>a=5 是一个编程语言语句</p>
<p>In this case, the statement says a variable named A has the number 5 stored in it.</p>
<p>意思是创建一个叫 a 的变量，把数字 5 放里面.</p>
<p>This is called an assignment statement because we're assigning a value to a variable.</p>
<p>这叫"赋值语句"，把一个值赋给一个变量</p>
<p>To express more complex things, we need a series of statements,</p>
<p>为了表达更复杂的含义，需要更多语句</p>
<p>like "A is 5, B is 10, C equals A plus B"</p>
<p>比如，a=5，b=10 ，c=a+b</p>
<p>This program tells the computer to set variable ‘A’ equal to 5, variable ‘B’ to 10,</p>
<p>意思是，变量 a 设为5，变量 b 设为10</p>
<p>and finally to add ‘A’ and ‘B’ together, and put that result, which is 15, into -you guessed it -variable C.</p>
<p>把 a 和 b 加起来，把结果 15 放进变量 c</p>
<p>Note that we can call variables whatever we want.</p>
<p>注意，变量名可以随意取</p>
<p>Instead of A, B and C, it could be apples, pears, and fruits.</p>
<p>除了 a b c，也可以叫苹果、梨、水果</p>
<p>The computer doesn’t care, as long as variables are uniquely named.</p>
<p>计算机不在乎你取什么名，只要不重名就行</p>
<p>But it’s probably best practice to name them things that make sense</p>
<p>当然取名最好还是有点意义，</p>
<p>in case someone else is trying to understand your code.</p>
<p>方便别人读懂</p>
<p>A program, which is a list of instructions, is a bit like a recipe:</p>
<p>程序由一个个指令组成，有点像菜谱：</p>
<p>boil water, add noodles, wait 10 minutes, drain and enjoy.</p>
<p>烧水、加面，等10分钟，捞出来就可以吃了</p>
<p>In the same way, the program starts at the first statement</p>
<p>程序也是这样，从第一条语句开始</p>
<p>and runs down one at a time until it hits the end.</p>
<p>一句一句运行到结尾</p>
<p>So far, we’ve added two numbers together.</p>
<p>刚才我们只是把两个数字加在一起</p>
<p>Boring.</p>
<p>无聊</p>
<p>Let’s make a video game instead!</p>
<p>我们来做一款游戏吧</p>
<p>Of course, it’s way too early to think about coding an entire game,</p>
<p>当然，现在这个学习阶段，来编写一整个游戏还太早了</p>
<p>so instead, we’ll use our example to write little snippets of code</p>
<p>所以我们只写一小段一小段的代码</p>
<p>that cover some programming fundamentals.</p>
<p>来讲解一些基础知识</p>
<p>Imagine we’re building an old-school arcade game where Grace Hopper has to capture bugs</p>
<p>假设我们在写一款老派街机游戏：Grace Hopper 拍虫子</p>
<p>before they get into the Harvard Mark 1 and crash the computer!</p>
<p>阻止虫子飞进计算机造成故障</p>
<p>On every level, the number of bugs increases.</p>
<p>关卡越高，虫子越多</p>
<p>Grace has to catch them before they wear out any relays in the machine.</p>
<p>Grace 要在虫子损坏继电器之前抓住虫子</p>
<p>Fortunately, she has a few extra relays for repairs.</p>
<p>好消息是她有几个备用继电器</p>
<p>To get started, we’ll need to keep track of a bunch of values that are important for gameplay</p>
<p>开始编写时，我们需要一些值来保存游戏数据</p>
<p>like what level the player is on, the score, the number of bugs remaining,</p>
<p>比如当前关卡数、分数、剩余虫子数、</p>
<p>as well as the number of spare relays in Grace’s inventory.</p>
<p>Grace 还剩几个备用继电器</p>
<p>So, we must "initialize" our variables, that is, set their initial value:</p>
<p>所以我们要"初始化"变量，"初始化"的意思是设置最开始的值.</p>
<p>"level equals 1, score equals 0, bugs equals 5, spare relays equals 4, and player name equals "Andre".</p>
<p>关卡=1  分数=0  虫子数=5，备用继电器=4   玩家名=Andre</p>
<p>To create an interactive game, we need to control the flow of the program</p>
<p>为了做成交互式游戏，程序的执行顺序要更灵活</p>
<p>beyond just running from top to bottom.</p>
<p>不只是从上到下执行</p>
<p>To do this, we use Control Flow Statements.</p>
<p>因此用 "控制流语句"</p>
<p>There are several types, but If Statements are the most common.</p>
<p>控制流语句有好几种，最常见的是 if 语句</p>
<p>You can think of them as "If X is true, then do Y".</p>
<p>可以想成是 "如果 X 为真，那么执行 Y"</p>
<p>An English language example is: "If I am tired, then get tea"</p>
<p>用英语举例就是 "如果累了, 就去喝茶"</p>
<p>So if "I am tired" is a true statement, then I will go get tea</p>
<p>如果 "累了" 为真，就去喝茶</p>
<p>If "I am tired" is false, then I will not go get tea.</p>
<p>如果 "累了" 为假，就不喝茶</p>
<p>An IF statement is like a fork in the road.</p>
<p>if 语句就像岔路口</p>
<p>Which path you take is conditional on whether the expression is true or false</p>
<p>走哪条路取决于 "表达式" 的真假，</p>
<p>so these expressions are called Conditional Statements.</p>
<p>因此这些表达式又叫 "条件语句"</p>
<p>In most programming languages, an if statement looks something like</p>
<p>在大多数编程语言中，if 语句看起来像这样：</p>
<p>"If, expression, then, some code, then end the if statement".</p>
<p>if [条件], then [一些代码]，结束 if 语句.</p>
<p>For example, if "level" is 1, then we set the score to zero, because the player is just starting.</p>
<p>比如，if [第一关]，then [分数设为0]，因为玩家才刚开始游戏</p>
<p>We also set the number of bugs to 1, to keep it easy for now.</p>
<p>同时把虫子数设为 1，让游戏简单些</p>
<p>Notice the lines of code that are conditional on the if-statement are nested between the</p>
<p>注意, 依赖于 if 条件的代码，</p>
<p>IF and END IF.</p>
<p>要放在 IF 和 END IF 之间</p>
<p>Of course, we can change the conditional expression to whatever we want to test, like</p>
<p>当然，条件表达式可以改成别的，比如：</p>
<p>"is score greater than 10"  or "is bugs less than 1".</p>
<p>"分数 >10" 或者 "虫子数 &lt;1"</p>
<p>And If-Statements can be combined with an ELSE statement, which acts as a catch-all if the expression is false.</p>
<p>if 还可以和 else 结合使用，条件为假会执行 else 里的代码</p>
<p>If the level is not 1, the code inside the ELSE block will be executed instead, and the</p>
<p>如果不是第1关，else 里的指令就会被执行</p>
<p>number of bugs that Grace has to battle is set to 3 times the level number.</p>
<p>Grace 要抓的虫子数，是当前关卡数 * 3</p>
<p>So on level 2, it would be six bugs, and on level 3 there’s 9, and so on.</p>
<p>所以第 2 关有 6 个虫子，第 3 关有 9 个虫子，以此类推</p>
<p>Score isn’t modified in the ELSE block, so Grace gets to keep any points earned.</p>
<p>else 中没有改分数，所以 Grace 的分数不会变</p>
<p>Here are some examples of if-then-else statements from some popular programming languages</p>
<p>这里列了一些热门编程语言  if-then-else 的具体语法</p>
<p>you can see the syntax varies a little, but the underlying structure is roughly the same.</p>
<p>具体语法略有不同，但主体结构一样</p>
<p>If-statements are executed once, a conditional path is chosen, and the program moves on.</p>
<p>if 语句根据条件执行一次</p>
<p>To repeat some statements many times, we need to create a conditional loop.</p>
<p>如果希望根据条件执行多次，需要"条件循环"</p>
<p>One way is a while statement, also called a while loop.</p>
<p>比如 while 语句，也叫 "while 循环"</p>
<p>As you might have guessed, this loops a piece of code "while" a condition is true.</p>
<p>当 while 条件为真，代码会重复执行</p>
<p>Regardless of the programming language, they look something like this:</p>
<p>不管是哪种编程语言，结构都是这样</p>
<p>In our game, let’s say at certain points, a friendly colleague restocks Grace with relays!</p>
<p>假设到达一定分数会冒出一个同事，给 Grace 补充继电器</p>
<p>Hooray!</p>
<p>棒极了！</p>
<p>To animate him replenishing our stock back up to a maximum of 4, we can use a while loop.</p>
<p>把继电器补满到最大数 4 个，我们可以用 while 语句来做</p>
<p>Let’s walk through this code.</p>
<p>来过一遍代码</p>
<p>First we’ll assume that Grace only has 1 tube left when her colleague enters.</p>
<p>假设同事入场时，Grace 只剩一个继电器</p>
<p>When we enter the while loop, the first thing the computer does is test its conditional…</p>
<p>当执行 while 循环，第一件事是检查条件</p>
<p>is relays less than 4?</p>
<p>继电器数量&lt;4?</p>
<p>Well, relays is currently 1, so yes.</p>
<p>继电器数量现在是1，所以是真</p>
<p>Now we enter the loop!</p>
<p>进入循环！</p>
<p>Then, we hit the line of code: "relays equals relays plus 1".</p>
<p>碰到这一行：继电器数量=继电器数量+1</p>
<p>This is a bit confusing because the variable is using itself in an assignment statement,</p>
<p>看起来有点怪，变量的赋值用到了自己</p>
<p>so let's unpack it.</p>
<p>我们讲下这个</p>
<p>You always start by figuring out the right side of the equals sign first,</p>
<p>总是从等号右边开始，</p>
<p>so what does "relays plus 1" come out to be?</p>
<p>"继电器数量+1" 是多少？</p>
<p>Well, relays is currently the value 1, so 1 plus 1 equals 2.</p>
<p>当前值是1，所以 1+1=2</p>
<p>Then, this result gets saved back into the variable relays, writing over the old value,</p>
<p>结果存到"继电器数量"，覆盖旧的值</p>
<p>so now relays stores the value 2.</p>
<p>所以现在继电器数量是 2</p>
<p>We’ve hit the end of the while loop, which jumps the program back up.</p>
<p>现在到了结尾，跳回开始点</p>
<p>Just as before, we test the conditional to see if we’re going to enter the loop.</p>
<p>和之前一样，先判断条件，看要不要进入循环</p>
<p>Is relays less than 4?</p>
<p>继电器数量&lt;4？</p>
<p>Well, yes, relays now equals 2, so we enter the loop again!</p>
<p>是，继电器数量是2，所以再次进入循环!</p>
<p>2 plus 1 equals 3.</p>
<p>2+1=3</p>
<p>so 3 is saved into relays.</p>
<p>3 存入"继电器数量"</p>
<p>Loop again.</p>
<p>回到开头</p>
<p>Is 3 less than 4?</p>
<p>3&lt;4？</p>
<p>Yes it is!</p>
<p>是!</p>
<p>Into the loop again.</p>
<p>进入循环</p>
<p>3 plus 1 equals 4.</p>
<p>3+1=4</p>
<p>So we save 4 into relays.</p>
<p>4 存入"继电器数量"</p>
<p>Loop again.</p>
<p>回到开头</p>
<p>Is 4 less than 4?....</p>
<p>4&lt;4?</p>
<p>No!</p>
<p>不！</p>
<p>So the condition is now false, and thus we exit the loop and move on to any remaining code</p>
<p>现在条件为假，退出循环，执行后面的代码</p>
<p>That’s how a while loop works!</p>
<p>while 循环就是这样运作的!</p>
<p>There’s also the common For Loop.</p>
<p>另一种常见的叫 "for 循环"</p>
<p>Instead of being a condition-controlled loop that can repeat forever until the condition is false</p>
<p>不判断条件，</p>
<p>a FOR loop is count-controlled; it repeats a specific number of times.</p>
<p>判断次数，会循环特定次数</p>
<p>They look something like this:</p>
<p>看起来像上图</p>
<p>Now, let’s put in some real values.</p>
<p>现在放些真正的值进去</p>
<p>This example loops 10 times, because we’ve specified that variable ‘i’</p>
<p>上图例子会循环10次，因为设了变量 i</p>
<p>starts at the value 1 and goes up to 10.</p>
<p>从 1 开始，一直到 10</p>
<p>The unique thing about a FOR loop is that each time it hits NEXT, it adds one to ‘i’.</p>
<p>for 的特点是，每次结束，i 会 +1</p>
<p>When ‘i’ equals 10, the computer knows it’s been looped 10 times, and the loop exits</p>
<p>当 i 等于10，就知道循环了10次，然后退出.</p>
<p>We can set the number to whatever we want -10, 42, or a billion -it’s up to us.</p>
<p>我们可以用任何数字，10, 42, 10 亿</p>
<p>Let’s say we want to give the player a bonus at the end of each level</p>
<p>假设每关结束后给玩家一些奖励分</p>
<p>for the number of vacuum relays they have left over.</p>
<p>奖励分多少取决于继电器剩余数量</p>
<p>As the game gets harder, it takes more skill to have unused relays,</p>
<p>随着难度增加，剩下继电器会越来越难</p>
<p>so we want the bonus to go up exponentially based on the level.</p>
<p>因此奖励分会根据当前关卡数，指数级增长</p>
<p>We need to write a piece of code that calculates exponents -</p>
<p>我们要写一小段代码来算指数</p>
<p>that is, multiplying a number by itself a specific number of times.</p>
<p>指数是一个数乘自己，乘特定次数</p>
<p>A loop is perfect for this!</p>
<p>用循环来实现简直完美!</p>
<p>First lets initialize a new variable called "bonus" and set it to 1.</p>
<p>首先，创建一个叫"奖励分"的新变量，设为 1 </p>
<p>Then, we create a FOR loop starting at 1, and looping up to the level number.</p>
<p>然后 for 循环，从 1 到 [当前关卡数]</p>
<p>Inside that loop, we multiply bonus times the number of relays,</p>
<p>[奖励分] x [继电器剩余数]，结果存入 [奖励分]</p>
<p>and save that new value back into bonus.</p>
<p>[奖励分] x [继电器剩余数]，结果存入 [奖励分]</p>
<p>For example, let’s say relays equals 2, and level equals 3.</p>
<p>比如继电器数是2，关卡数是3</p>
<p>So the FOR loop will loop three times, which means bonus is going to get multiplied by</p>
<p>for 会循环3次，奖励分会乘</p>
<p>relays... by relays... by relays.</p>
<p>继电器数量 x 继电器数量 x 继电器数量</p>
<p>Or in this case, times 2, times 2, times 2, which is a bonus of 8!</p>
<p>也就是1×2×2×2，奖励分是8，2的3次方</p>
<p>That’s 2 to the 3rd power!</p>
<p>也就是1×2×2×2，奖励分是8，2的3次方</p>
<p>This exponent code is useful, and we might want to use it in other parts of our code.</p>
<p>这个指数代码很实用，其他地方可能会用到</p>
<p>It’d be annoying to copy and paste this everywhere, and have to update the variable names each time.</p>
<p>如果每次想用就复制粘贴，会很麻烦，每次都要改变量名</p>
<p>Also, if we found a bug, we’d have to hunt around and update every place we used it.</p>
<p>如果代码发现问题，要补漏洞时，要把每一个复制黏贴过的地方都找出来改</p>
<p>It also makes code more confusing to look at.</p>
<p>而且会让代码更难懂</p>
<p>Less is more!</p>
<p>少即是多！</p>
<p>What we want is a way to package up our exponent code so we can use it, get the result, and</p>
<p>我们想要某种方法，把代码"打包"，可以直接使用，得出结果，</p>
<p>not have to see all the internal complexity.</p>
<p>不用管内部复杂度.</p>
<p>We’re once again moving up a new level of abstraction!</p>
<p>这又提升了一层抽象！</p>
<p>To compartmentalize and hide complexity,</p>
<p>为了隐藏复杂度</p>
<p>programming languages can package pieces of code into named functions,</p>
<p>可以把代码打包成 "函数"</p>
<p>also called methods or subroutines in different programming languages.</p>
<p>也叫 "方法" 或 "子程序"，（有些编程语言这么叫）</p>
<p>These functions can then be used by any other part of that program just by calling its name.</p>
<p>其他地方想用这个函数，直接写函数名就可以了</p>
<p>Let’s turn our exponent code into a function! First, we should name it.</p>
<p>现在我们把指数代码变成函数.  第一步，取名.</p>
<p>We can call it anything we want, like HappyUnicorn,</p>
<p>叫什么都行，比如"快乐独角兽"</p>
<p>but since our code calculates exponents, let’s call it exponent.</p>
<p>但因为是算指数,  直接叫"指数"合适一些</p>
<p>Also, instead of using specific variable names, like "relays" and "levels",</p>
<p>还有，与其用特定变量名，比如 "继电器" 和 "关卡数"</p>
<p>we specify generic variable names, like Base and Exp,</p>
<p>用更通用的名字，比如底数(Base) 和指数(Exp)</p>
<p>whose initial values are going to be "passed" into our function from some other part of the program.</p>
<p>Base 和 Exp 的初始值需要外部传入</p>
<p>The rest of our code is the same as before</p>
<p>剩余代码和之前一样</p>
<p>Now tucked into our function and with new variable names.</p>
<p>现在完成了，有函数名和新变量名.</p>
<p>Finally, we need to send the result of our exponent code back to the part of the program that requested it.</p>
<p>最后, 我们还需要把结果交给使用这个函数的代码</p>
<p>For this, we use a RETURN statement, and specify that the value in ‘result’ be returned.</p>
<p>所以用 RETURN 语句，指明返回什么.</p>
<p>So our full function code looks like this:</p>
<p>完整版代码是这样</p>
<p>Now we can use this function anywhere in our program,</p>
<p>现在可以随意用这个函数</p>
<p>simply by calling its name and passing in two numbers.</p>
<p>只需要写出名字然后传入2个数字就可以了</p>
<p>For example, if we want to calculate 2 to the 44th power, we can just call "exponent 2 comma 44."</p>
<p>如果要算 2 的 44 次方，写 exponent(2,44)</p>
<p>and like 18 trillion comes back.</p>
<p>结果是 18 万亿左右</p>
<p>Behind the scenes, 2 and 44 get saved into variables Base and Exp inside the function,</p>
<p>幕后原理是，2 和 44 存进 Base 和 Exp</p>
<p>it does all its loops as necessary, and then the function returns with the result.</p>
<p>跑循环，然后返回结果</p>
<p>Let’s use our newly minted function to calculate a score bonus.</p>
<p>我们来用这个新函数算奖励分</p>
<p>First, we initialize bonus to 0.</p>
<p>首先，奖励分初始化为 0</p>
<p>Then we check if the player has any remaining relays with an if-statement.</p>
<p>然后用 if 语句，看剩不剩继电器（看上图的 > 0）</p>
<p>If they do, we call our exponent function, passing in relays and level,</p>
<p>如果还剩，用指数函数，传入 [继电器数] 和 [关卡数]</p>
<p>which calculates relays to the power of level, and returns the result, which we save into bonus.</p>
<p>它会算 [继电器数]的[关卡数]次方,  存入奖励分</p>
<p>This bonus calculating code might be useful later, so let’s wrap it up as a function too!</p>
<p>这段算奖励分的代码，之后可能还会用，也打包成一个函数</p>
<p>Yes, a function that calls a function!</p>
<p>没错，这个函数 (CalcBonus)，会调用另一个函数 (Exponent)</p>
<p>And then, wait for it…. we can use this function in an even more complex function.</p>
<p>还有！这个 CalcBonus 函数，可以用在其他更复杂的函数</p>
<p>Let’s write one that gets called everytime the player finishes a level.</p>
<p>我们来写一个函数, 每一关结束后都会调用</p>
<p>We’ll call it "LevelFinished"</p>
<p>叫 LevelFinished (关卡结束)</p>
<p>it needs to know the number of relays left, what level it was, and the current score;</p>
<p>需要传入 [剩余继电器数]  [关卡数] [当前分]</p>
<p>those values have to get passed in.</p>
<p>这些数据必须传入.</p>
<p>Inside our function, we’ll calculate the bonus, using our CalcBonus function,</p>
<p>里面用 CalcBonus 算奖励分，</p>
<p>and add that to the running score.</p>
<p>并加进总分</p>
<p>Also, if the current score is higher than the game’s high score,</p>
<p>还有，如果当前分 > 游戏最高分</p>
<p>we save the new high score and the players name.</p>
<p>把新高分和玩家名存起来</p>
<p>Now we’re getting pretty fancy.</p>
<p>现在代码变得蛮"花哨"了</p>
<p>Functions are calling functions are calling functions!</p>
<p>函数调函数调函数</p>
<p>When we call a single line of code, like this the complexity is hidden.</p>
<p>我们写这样一行代码时，复杂度都隐藏起来了</p>
<p>We don’t see all the internal loops and variables,</p>
<p>不需要知道内部的循环和变量</p>
<p>we just see the result come back as if by magic…. a total score of 53.</p>
<p>只知道结果会像魔术一样返回，总分 53</p>
<p>But it’s not magic, it’s the power of abstraction!</p>
<p>但是这不是魔术，是抽象的力量</p>
<p>If you understand this example, then you understand the power of functions,</p>
<p>如果你理解了这个例子，就明白了函数的强大之处</p>
<p>and the entire essence of modern programming.</p>
<p>和现代编程的核心</p>
<p>It’s not feasible to write, for example, a web browser as one gigantically long list of statements.</p>
<p>比如浏览器这样的复杂程序，用一长串语句来写是不可能的</p>
<p>It would be millions of lines long and impossible to comprehend!</p>
<p>会有几百万行代码，没人能理解</p>
<p>So instead, software consists of thousands of smaller functions,</p>
<p>所以现代软件由上千个函数组成</p>
<p>each responsible for different features.</p>
<p>每个负责不同的事</p>
<p>In modern programming, it’s uncommon to see functions longer than around 100 lines of code</p>
<p>如今超过100行代码的函数很少见</p>
<p>because by then, there’s probably something that</p>
<p>如果多于 100 行，</p>
<p>should be pulled out and made into its own function.</p>
<p>应该有东西可以拆出来做成一个函数</p>
<p>Modularizing programs into functions not only allows a single programmer to write an entire app</p>
<p>模块化编程不仅可以让单个程序员独立制作 App</p>
<p>but also allows teams of people to work efficiently on even bigger programs.</p>
<p>也让团队协作可以写更大型的程序</p>
<p>Different programmers can work on different functions,</p>
<p>不同程序员写不同函数</p>
<p>and if everyone makes sure their code works correctly,</p>
<p>只需要确保自己的代码工作正常</p>
<p>then when everything is put together, the whole program should work too!</p>
<p>把所有人的拼起来，整个程序也应该能正常运作！</p>
<p>And in the real world, programmers aren’t wasting time writing things like exponents.</p>
<p>现实中，程序员不会浪费时间写指数函数这种东西</p>
<p>Modern programming languages come with huge bundles of pre-written functions, called Libraries.</p>
<p>现代编程语言有很多预先写好的函数集合，叫 "库"</p>
<p>These are written by expert coders, made efficient and rigorously tested, and then given to everyone.</p>
<p>由专业人员编写，不仅效率高，而且经过了仔细检查</p>
<p>There are libraries for almost everything, including networking, graphics, and sound</p>
<p>几乎做所有事情都有库，网络、图像、声音</p>
<p>topics we’ll discuss in future episodes.</p>
<p>我们之后会讲这些主题.</p>
<p>But before we get to those, we need to talk about Algorithms.</p>
<p>但在此之前，我们先讲算法</p>
<p>Intrigued?</p>
<p>好奇吗？</p>
<p>You should be.</p>
<p>你应该才是！</p>
<p>I’ll see you next week.</p>
<p>下周见</p>
<p>13 算法入门</p>
<p>Intro to Algorithms</p>
<p>Hi, I'm Carrie Anne, and welcome to CrashCourse Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>Over the past two episodes, we got our first taste of programming in a high-level language,</p>
<p>前两集，我们"初尝"了高级编程语言，</p>
<p>like Python or Java.</p>
<p>比如 Python 和 Java</p>
<p>We talked about different types of programming language statements</p>
<p>我们讨论了几种语句</p>
<p>like assignments, ifs, and loops -</p>
<p>赋值语句，if 语句，循环语句</p>
<p>as well as putting statements into functions that perform a computation,</p>
<p>以及把代码打包成 "函数"</p>
<p>like calculating an exponent.</p>
<p>比如算指数</p>
<p>Importantly, the function we wrote to calculate exponents is only one possible solution.</p>
<p>重要的是，之前写的指数函数，只是无数解决方案的一种</p>
<p>There are other ways to write this function</p>
<p>还有其它方案</p>
<p>using different statements in different orders -</p>
<p>用不同顺序写不同语句</p>
<p>that achieve exactly the same numerical result.</p>
<p>也能得到一样结果</p>
<p>The difference between them is the algorithm,</p>
<p>不同的是 "算法"，意思是：</p>
<p>that is the specific steps used to complete the computation.</p>
<p>解决问题的具体步骤</p>
<p>Some algorithms are better than others even if they produce equal results.</p>
<p>即使结果一致，有些算法会更好</p>
<p>Generally, the fewer steps it takes to compute, the better it is,</p>
<p>一般来说，所需步骤越少越好</p>
<p>though sometimes we care about other factors, like how much memory it uses.</p>
<p>不过有时我们也会关心其他因素，比如占多少内存</p>
<p>The term algorithm comes from Persian polymath Muhammad ibn Musa al-Khwarizmi</p>
<p>"算法" 一词来自波斯博识者阿尔·花拉子密</p>
<p>who was one of the fathers of algebra more than a millennium ago.</p>
<p>1000 多年前的代数之父之一</p>
<p>The crafting of efficient algorithms</p>
<p>如何想出高效算法</p>
<p>a problem that existed long before modern computers -</p>
<p>是早在计算机出现前就有的问题</p>
<p>led to a whole science surrounding computation,</p>
<p>诞生了专门研究计算的领域，</p>
<p>which evolved into the modern discipline of...</p>
<p>然后发展成一门现代学科</p>
<p>you guessed it!</p>
<p>你猜对了！</p>
<p>Computer Science!</p>
<p>计算机科学！</p>
<p>One of the most storied algorithmic problems in all of computer science is sorting</p>
<p>记载最多的算法之一是"排序"</p>
<p>as in sorting names or sorting numbers.</p>
<p>比如给名字、数字排序</p>
<p>Computers sort all the time.</p>
<p>排序到处都是</p>
<p>Looking for the cheapest airfare,</p>
<p>找最便宜的机票</p>
<p>arranging your email by most recently sent,</p>
<p>按最新时间排邮件</p>
<p>or scrolling your contacts by last name</p>
<p>按姓氏排联系人</p>
<p>those all require sorting.</p>
<p>-这些都要排序</p>
<p>You might think</p>
<p>你可能想</p>
<p>"sorting isn't so tough how many algorithms can there possibly be?"</p>
<p>"排序看起来不怎么难… 能有几种算法呢?"</p>
<p>The answer is: a lot.</p>
<p>答案是超多</p>
<p>Computer Scientists have spent decades inventing algorithms for sorting,</p>
<p>计算机科学家花了数十年发明各种排序算法</p>
<p>with cool names like Bubble Sort and Spaghetti Sort.</p>
<p>还起了酷酷的名字，"冒泡排序"、"意面排序"</p>
<p>Let's try sorting!</p>
<p>我们来试试排序！</p>
<p>Imagine we have a set of airfare prices to Indianapolis.</p>
<p>试想有一堆机票价格，都飞往印第安纳波利斯 (美国地名)</p>
<p>We'll talk about how data like this is represented in memory next week,</p>
<p>数据具体怎么在内存中表示下周再说</p>
<p>but for now, a series of items like this is called an array.</p>
<p>上图的这样一组数据叫"数组"（Array）</p>
<p>Let's take a look at these numbers to help see how we might sort this programmatically.</p>
<p>来看看怎么排序</p>
<p>We'll start with a simple algorithm.</p>
<p>先从一种简单算法开始</p>
<p>First, let's scan down the array to find the smallest number.</p>
<p>先找到最小数，</p>
<p>Starting at the top with 307.</p>
<p>从最上面的 307 开始</p>
<p>It's the only number we've seen, so it's also the smallest.</p>
<p>因为现在只看了这一个，所以它是最小数</p>
<p>The next is 239, that's smaller than 307,</p>
<p>下一个是 239，比 307 小</p>
<p>so it becomes our new smallest number.</p>
<p>所以新的最小数变成 239</p>
<p>Next is 214, our new smallest number.</p>
<p>下一个是 214 ，新的最小数</p>
<p>250 is not, neither is 384, 299, 223 or 312.</p>
<p>250 不是，384, 299, 223, 312 都不是</p>
<p>So we've finished scanning all numbers,</p>
<p>现在扫完了所有数字</p>
<p>and 214 is the smallest.</p>
<p>214 是最小的</p>
<p>To put this into ascending order,</p>
<p>为了升序排列（从小到大排序）</p>
<p>we swap 214 with the number in the top location.</p>
<p>把 214 和最上面的数字，交换位置</p>
<p>Great! We sorted one number!</p>
<p>好棒! 刚排序了一个数字！</p>
<p>Now we repeat the same procedure,</p>
<p>现在重复同样的过程</p>
<p>but instead of starting at the top, we can start one spot below.</p>
<p>这次不从最上面开始，从第 2 个数开始</p>
<p>First we see 239, which we save as our new smallest number.</p>
<p>先看到 239，我们当作是 "最小数"</p>
<p>Scanning the rest of the array, we find 223 is the next smallest,</p>
<p>扫描剩下的部分，发现 223 最小</p>
<p>so we swap this with the number in the second spot.</p>
<p>所以把它和第 2 位交换</p>
<p>Now we repeat again, starting from the third number down.</p>
<p>重复这个过程，从第 3 位数字开始</p>
<p>This time, we swap 239 with 307.</p>
<p>让 239 和 307 互换位置</p>
<p>This process continues until we get to the very last number,</p>
<p>重复直到最后一个数字</p>
<p>and voila, the array is sorted and you're ready to book that flight to Indianapolis!</p>
<p>瞧，数字排好了，可以买机票了！</p>
<p>The process we just walked through is one way</p>
<p>刚刚这种方法，</p>
<p>or one algorithm for sorting an array.</p>
<p>或者说算法，</p>
<p>It's called Selection sort and it's pretty basic.</p>
<p>叫选择排序非常基础的一种算法</p>
<p>Here's the pseudo-code.</p>
<p>以下是"伪代码"</p>
<p>This function can be used to sort 8, 80, or 80 million numbers</p>
<p>这个函数可以排序8个, 80个或8千万个数字</p>
<p>and once you've written the function, you can use it over and over again.</p>
<p>函数写好了就可以重复使用</p>
<p>With this sort algorithm, we loop through each position in the array, from top to bottom,</p>
<p>这里用循环遍历数组</p>
<p>and then for each of those positions,</p>
<p>每个数组位置都跑一遍循环，</p>
<p>we have to loop through the array to find the smallest number to swap.</p>
<p>找最小数然后互换位置</p>
<p>You can see this in the code, where one FOR loop is nested inside of another FOR loop.</p>
<p>可以在代码中看到这一点，（一个 for 循环套另一个 for 循环）</p>
<p>This means, very roughly, that if we want to sort N items, we have to loop N times,</p>
<p>这意味着，大致来说，如果要排 N 个东西，要循环 N 次，</p>
<p>inside of which, we loop N times, for a grand total of roughly N times N loops, or N squared.</p>
<p>每次循环中再循环 N 次，共 N*N,  或 N</p>
<p>This relationship of input size to the number of steps the algorithm takes to run</p>
<p>算法的输入大小和 运行步骤之间的关系</p>
<p>characterizes the complexity of the Selection Sort algorithm.</p>
<p>叫算法的复杂度</p>
<p>It gives you an approximation of how fast, or slow, an algorithm is going to be.</p>
<p>表示运行速度的量级</p>
<p>Computer Scientists write this order of growth in something known as no joke -</p>
<p>计算机科学家们把算法复杂度叫没开玩笑</p>
<p>"big O notation".</p>
<p>大 O 表示法</p>
<p>N squared is not particularly efficient.</p>
<p>算法复杂度 O(N  ) 效率不高</p>
<p>Our example array had n = 8 items, and 8 squared is 64.</p>
<p>前面的例子有 8 个元素（n=8）, 8  = 64</p>
<p>If we increase the size of our array from 8 items to 80,</p>
<p>如果 8 个变 80 个</p>
<p>the running time is now 80 squared, which is 6,400.</p>
<p>运行时间变成 80  = 6400</p>
<p>So although our array only grew by 10 times from 8 to 80 -</p>
<p>虽然大小只增长了 10 倍（8 到 80）</p>
<p>the running time increased by 100 times from 64 to 6,400!</p>
<p>但运行时间增加了 100 倍！（64 到 6400 ）</p>
<p>This effect magnifies as the array gets larger.</p>
<p>随着数组增大，对效率的影响会越来越大</p>
<p>That's a big problem for a company like Google,</p>
<p>这对大公司来说是个问题，比如谷歌</p>
<p>which has to sort arrays with millions or billions of entries.</p>
<p>要对几十亿条信息排序</p>
<p>So, you might ask,</p>
<p>作为未来的计算机科学家你可能会问：</p>
<p>as a burgeoning computer scientist, is there a more efficient sorting algorithm?</p>
<p>有没有更高效的排序算法？</p>
<p>Let's go back to our old, unsorted array</p>
<p>回到未排序的数组</p>
<p>and try a different algorithm, merge sort.</p>
<p>试另一个算法 "归并排序"</p>
<p>The first thing merge sort does is check if the size of the array is greater than 1.</p>
<p>第一件事是检查数组大小是否 > 1</p>
<p>If it is, it splits the array into two halves.</p>
<p>如果是，就把数组分成两半</p>
<p>Since our array is size 8, it gets split into two arrays of size 4.</p>
<p>因为数组大小是 8，所以分成两个数组，大小是 4</p>
<p>These are still bigger than size 1, so they get split again, into arrays of size 2,</p>
<p>但依然大于 1，所以再分成大小是 2 的数组</p>
<p>and finally they split into 8 arrays with 1 item in each.</p>
<p>最后变成 8 个数组，每个大小为 1</p>
<p>Now we are ready to merge, which is how "merge sort" gets its name.</p>
<p>现在可以"归并"了，"归并排序"因此得名</p>
<p>Starting with the first two arrays, we read the first and only value in them,</p>
<p>从前两个数组开始，读第一个（也是唯一一个）值</p>
<p>in this case, 307 and 239.</p>
<p>307 和 239</p>
<p>239 is smaller, so we take that value first.</p>
<p>239 更小，所以放前面</p>
<p>The only number left is 307, so we put that value second.</p>
<p>剩下的唯一数字是 307 ，所以放第二位</p>
<p>We've successfully merged two arrays.</p>
<p>成功合并了两个数组</p>
<p>We now repeat this process for the remaining pairs, putting them each in sorted order.</p>
<p>重复这个过程，按序排列</p>
<p>Then the merge process repeats.</p>
<p>然后再归并一次</p>
<p>Again, we take the first two arrays, and we compare the first numbers in them.</p>
<p>同样，取前两个数组，比较第一个数</p>
<p>This time its 239 and 214.</p>
<p>239 和 214</p>
<p>214 is lowest, so we take that number first.</p>
<p>214 更小，放前面</p>
<p>Now we look again at the first two numbers in both arrays: 239 and 250.</p>
<p>再看两个数组里的第一个数：239 和 250</p>
<p>239 is lower, so we take that number next.</p>
<p>239 更小，所以放下一位</p>
<p>Now we look at the next two numbers: 307 and 250.</p>
<p>看剩下两个数：307 和 250</p>
<p>250 is lower, so we take that.</p>
<p>250 更小，所以放下一位</p>
<p>Finally, we're left with just 307, so that gets added last.</p>
<p>最后剩下 307 ，所以放最后</p>
<p>In every case, we start with two arrays,</p>
<p>每次都以 2 个数组开始</p>
<p>each individually sorted, and merge them into a larger sorted array.</p>
<p>然后合并成更大的有序数组</p>
<p>We repeat the exact same merging process for the two remaining arrays of size two.</p>
<p>我们把刚隐藏起来的，下面的数组也这样做</p>
<p>Now we have two sorted arrays of size 4.</p>
<p>现在有两个大小是 4 的有序数组</p>
<p>Just as before, we merge,</p>
<p>就像之前，</p>
<p>comparing the first two numbers in each array, and taking the lowest.</p>
<p>比较两个数组的第一个数，取最小数</p>
<p>We repeat this until all the numbers are merged,</p>
<p>重复这个过程，直到完成</p>
<p>and then our array is fully sorted again!</p>
<p>就排好了！</p>
<p>The bad news is: no matter how many times we sort these,</p>
<p>但坏消息是：无论排多少次</p>
<p>you're still going to have to pay $214 to get to Indianapolis.</p>
<p>你还是得付 214 美元到印第安纳波利斯</p>
<p>Anyway, the "Big O" computational complexity of merge sort is N times the Log of N.</p>
<p>总之，"归并排序"的算法复杂度是 O(n * log n)</p>
<p>The N comes from the number of times we need to compare and merge items,</p>
<p>n 是需要比较+合并的次数</p>
<p>which is directly proportional to the number of items in the array.</p>
<p>和数组大小成正比</p>
<p>The Log N comes from the number of merge steps.</p>
<p>log N 是合并步骤的次数</p>
<p>In our example, we broke our array of 8 items into 4,</p>
<p>例子中把大小是 8 的数组，分成四个数组</p>
<p>then 2, and finally 1.</p>
<p>然后分成 2 个，最后分成 1 个</p>
<p>That's 3 splits.</p>
<p>分了 3 次</p>
<p>Splitting in half repeatedly like this has a logarithmic relationship with the number of items</p>
<p>重复切成两半，和数量成对数关系</p>
<p>trust me!</p>
<p>相信我！</p>
<p>Log base 2 of 8 equals 3 splits.</p>
<p>Log8=3</p>
<p>If we double the size of our array to 16 that's twice as many items to sort -</p>
<p>如果数组大小变成 16 之前的两倍</p>
<p>it only increases the number of split steps by 1</p>
<p>也只要多分割 1 次</p>
<p>since log base 2 of 16 equals 4.</p>
<p>因为 Log16=4</p>
<p>Even if we increase the size of the array more than a thousand times,</p>
<p>即使扩大一千倍</p>
<p>from 8 items to 8000 items, the number of split steps stays pretty low.</p>
<p>从8到8000，分割次数也不会增大多少</p>
<p>Log base 2 of 8000 is roughly 13.</p>
<p>log8000≈13</p>
<p>That's more, but not much more than 3 -about four times larger --</p>
<p>13 比 3 只是4倍多一点</p>
<p>and yet we're sorting a lot more numbers.</p>
<p>然而排序的元素多得多</p>
<p>For this reason, merge sort is much more efficient than selection sort.</p>
<p>因此"归并排序"比"选择排序"更有效率</p>
<p>And now I can put my ceramic cat collection in name order MUCH faster!</p>
<p>这下我收藏的陶瓷猫可以更快排序了！</p>
<p>There are literally dozens of sorting algorithms we could review,</p>
<p>有好几十种排序算法，但没时间讲</p>
<p>but instead, I want to move on to my other favorite category of classic algorithmic problems:</p>
<p>所以我们来谈一个经典算法问题：</p>
<p>graph search!</p>
<p>图搜索</p>
<p>A graph is a network of nodes connected by lines.</p>
<p>"图" 是用线连起来的一堆 "节点"</p>
<p>You can think of it like a map, with cities and roads connecting them.</p>
<p>可以想成地图，每个节点是一个城市，线是公路</p>
<p>Routes between these cities take different amounts of time.</p>
<p>一个城市到另一个城市，花的时间不同</p>
<p>We can label each line with what is called a cost or weight.</p>
<p>可以用成本(cost) 或权重(weight) 来代称</p>
<p>In this case, it's weeks of travel.</p>
<p>代表要几个星期</p>
<p>Now let's say we want to find the fastest route</p>
<p>假设想找</p>
<p>for an army at Highgarden to reach the castle at Winterfell.</p>
<p>"高庭"到"凛冬城"的最快路线</p>
<p>The simplest approach would just be to try every single path exhaustively</p>
<p>最简单的方法是尝试每一条路</p>
<p>and calculate the total cost of each.</p>
<p>计算总成本</p>
<p>That's a brute force approach.</p>
<p>这是蛮力方法</p>
<p>We could have used a brute force approach in sorting,</p>
<p>假设用蛮力方法来排序数组</p>
<p>by systematically trying every permutation of the array to check if it's sorted.</p>
<p>尝试每一种组合，看是否排好序</p>
<p>This would have an N factorial complexity</p>
<p>这样的时间复杂度是 O(n!)</p>
<p>that is the number of nodes, times one less, times one less than that, and so on until 1.</p>
<p>n 是节点数，n! 是 n 乘 n-1 乘 n-2... 一直到 1</p>
<p>Which is way worse than even N squared.</p>
<p>比 O(n)还糟糕</p>
<p>But, we can be way more clever!</p>
<p>我们可以更聪明些！</p>
<p>The classic algorithmic solution to this graph problem was invented by</p>
<p>图搜索问题的经典算法发明者是</p>
<p>one of the greatest minds in computer science practice and theory, Edsger Dijkstra</p>
<p>理论计算机科学的伟人 Edsger Dijkstra</p>
<p>so it's appropriately named Dijkstra's algorithm.</p>
<p>所以叫 "Dijkstra 算法"</p>
<p>We start in Highgarden with a cost of 0, which we mark inside the node.</p>
<p>从"高庭"开始，此时成本为0，把0标在节点里</p>
<p>For now, we mark all other cities with question marks</p>
<p>其他城市标成问号，</p>
<p>we don't know the cost of getting to them yet.</p>
<p>因为不知道成本多少</p>
<p>Dijkstra's algorithm always starts with the node with lowest cost.</p>
<p>Dijkstra 算法总是从成本最低的节点开始</p>
<p>In this case, it only knows about one node, Highgarden, so it starts there.</p>
<p>目前只知道一个节点 "高庭", 所以从这里开始</p>
<p>It follows all paths from that node to all connecting nodes that are one step away,</p>
<p>跑到所有相邻节点，</p>
<p>and records the cost to get to each of them.</p>
<p>记录成本</p>
<p>That completes one round of the algorithm.</p>
<p>完成了一轮算法</p>
<p>We haven't encountered Winterfell yet,</p>
<p>但还没到"凛冬城"</p>
<p>so we loop and run Dijkstra's algorithm again.</p>
<p>所以再跑一次 Dijkstra 算法</p>
<p>With Highgarden already checked,</p>
<p>"高庭" 已经知道了</p>
<p>the next lowest cost node is King's Landing.</p>
<p>下一个成本最低的节点，是 "君临城"</p>
<p>Just as before, we follow every unvisited line to any connecting cities.</p>
<p>就像之前，记录所有相邻节点的成本</p>
<p>The line to The Trident has a cost of 5.</p>
<p>到"三叉戟河"的成本是 5</p>
<p>However, we want to keep a running cost from Highgarden,</p>
<p>然而我们想记录的是，从"高庭"到这里的成本</p>
<p>so the total cost of getting to The Trident is 8 plus 5, which is 13 weeks.</p>
<p>所以"三叉戟河"的总成本是 8+5=13周</p>
<p>Now we follow the offroad path to Riverrun,</p>
<p>现在走另一条路到"奔流城"</p>
<p>which has a high cost of 25, for a total of 33.</p>
<p>成本高达 25 ，总成本 33</p>
<p>But we can see inside of Riverrun that we've already found a path with a lower cost of just 10.</p>
<p>但 "奔流城" 中最低成本是 10</p>
<p>So we disregard our new path, and stick with the previous, better path.</p>
<p>所以无视新数字，保留之前的成本 10</p>
<p>We've now explored every line from King's Landing and didn't find Winterfell, so we move on.</p>
<p>现在看了"君临城"的每一条路，还没到"凛冬城" 所以继续.</p>
<p>The next lowest cost node is Riverrun, at 10 weeks.</p>
<p>下一个成本最低的节点，是"奔流城"，要 10 周</p>
<p>First we check the path to The Trident, which has a total cost of 10 plus 2, or 12.</p>
<p>先看 "三叉戟河" 成本： 10+2=12</p>
<p>That's slightly better than the previous path we found, which had a cost of 13,</p>
<p>比之前的 13 好一点</p>
<p>so we update the path and cost to The Trident.</p>
<p>所以更新 "三叉戟河" 为 12</p>
<p>There is also a line from Riverrun to Pyke with a cost of 3.</p>
<p>"奔流城"到"派克城"成本是 3</p>
<p>10 plus 3 is 13, which beats the previous cost of 14,</p>
<p>10+3=13，之前是14</p>
<p>and so we update Pyke's path and cost as well.</p>
<p>所以更新 "派克城" 为 13</p>
<p>That's all paths from Riverrun checked. so you guessed it, Dijkstra's algorithm loops again.</p>
<p>"奔流城"出发的所有路径都走遍了，你猜对了，再跑一次 Dijkstra 算法</p>
<p>The node with the next lowest cost is The Trident</p>
<p>下一个成本最低的节点，是"三叉戟河"</p>
<p>and the only line from The Trident that we haven't checked is a path to Winterfell!</p>
<p>从"三叉戟河"出发，唯一没看过的路，通往"凛冬城"！</p>
<p>It has a cost of 10,</p>
<p>成本是 10</p>
<p>plus we need to add in the cost of 12 it takes to get to The Trident,</p>
<p>加"三叉戟河"的成本 12</p>
<p>for a grand total cost of 22.</p>
<p>总成本 22</p>
<p>We check our last path, from Pyke to Winterfell, which sums to 31.</p>
<p>再看最后一条路，"派克城"到"凛冬城"，成本 31</p>
<p>Now we know the lowest total cost, and also the fastest route for the army to get there,</p>
<p>现在知道了最低成本路线，让军队最快到达,</p>
<p>which avoids King's Landing!</p>
<p>还绕过了"君临城"！</p>
<p>Dijkstra's original algorithm, conceived in 1956,</p>
<p>Dijkstra 算法的原始版本，构思于 1956 年</p>
<p>had a complexity of the number of nodes in the graph squared.</p>
<p>算法复杂度是 O(n)</p>
<p>And squared, as we already discussed, is never great,</p>
<p>前面说过这个效率不够好</p>
<p>because it means the algorithm can't scale to big problems</p>
<p>意味着输入不能很大</p>
<p>like the entire road map of the United States.</p>
<p>比如美国的完整路线图</p>
<p>Fortunately, Dijkstra's algorithm was improved a few years later</p>
<p>幸运的是，Dijkstra 算法几年后得到改进</p>
<p>to take the number of nodes in the graph,</p>
<p>变成 O(n log n + l)</p>
<p>times the log of the number of nodes, PLUS the number of lines.</p>
<p>n 是节点数，l 是多少条线</p>
<p>Although this looks more complicated,</p>
<p>虽然看起来更复杂</p>
<p>it's actually quite a bit faster.</p>
<p>但实际更快一些</p>
<p>Plugging in our example graph, with 6 cities and 9 lines, proves it.</p>
<p>用之前的例子，可以证明更快，（6 个节点 9 条线）</p>
<p>Our algorithm drops from 36 loops to around 14.</p>
<p>从 36 减少到 14 左右</p>
<p>As with sorting,</p>
<p>就像排序，图搜索算法也有很多，有不同优缺点</p>
<p>there are innumerable graph search algorithms, with different pros and cons.</p>
<p>就像排序，图搜索算法也有很多，有不同优缺点</p>
<p>Every time you use a service like Google Maps to find directions,</p>
<p>每次用谷歌地图时</p>
<p>an algorithm much like Dijkstra's is running on servers to figure out the best route for you.</p>
<p>类似 Dijkstra 的算法就在服务器上运行，找最佳路线</p>
<p>Algorithms are everywhere</p>
<p>算法无处不在</p>
<p>and the modern world would not be possible without them.</p>
<p>现代世界离不开它们</p>
<p>We touched only the very tip of the algorithmic iceberg in this episode,</p>
<p>这集只触及了算法的冰山一角</p>
<p>but a central part of being a computer scientist</p>
<p>但成为计算机科学家的核心</p>
<p>is leveraging existing algorithms and writing new ones when needed,</p>
<p>是根据情况合理决定用现有算法还是自己写新算法</p>
<p>and I hope this little taste has intrigued you to SEARCH further.</p>
<p>希望这集的小例子能让你体会到这点</p>
<p>I'll see you next week.</p>
<p>下周见</p>
<p>14 数据结构</p>
<p>Data Structures</p>
<p>Hi, I'm Carrie Anne, and welcome to Crash Course Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>Last episode, we discussed a few example classic algorithms,</p>
<p>上集讲了一些经典算法</p>
<p>like sorting a list of numbers and finding the shortest path in a graph.</p>
<p>比如给数组排序，找图的最短路径</p>
<p>What we didn't talk much about,</p>
<p>而上集没讲的是</p>
<p>is how the data the algorithms ran on was stored in computer memory.</p>
<p>算法处理的数据存在内存里的格式是什么</p>
<p>You don't want your data to be like John Green's college dorm room,</p>
<p>你肯定不想数据像 John Green 的大学宿舍一样乱</p>
<p>with food, clothing and papers strewn everywhere.</p>
<p>到处都是食物，衣服和纸</p>
<p>Instead, we want our data to be structured,</p>
<p>我们希望数据是结构化的，</p>
<p>so that it's organized, allowing things to be easily retrieved and read.</p>
<p>方便读取</p>
<p>For this, computer scientists use Data Structures!</p>
<p>因此计算机科学家发明了 "数据结构"！</p>
<p>We already introduced one basic data structure last episode,</p>
<p>上集已经介绍了一种基本数据结构：</p>
<p>Arrays, also called lists or Vectors in some languages.</p>
<p>数组（Array），也叫列表（list）或向量（Vector）（在其它编程语言里）</p>
<p>These are a series of values stored in memory.</p>
<p>数组的值一个个连续存在内存里</p>
<p>So instead of just a single value being saved into a variable, like 'j equals 5',</p>
<p>所以不像之前，一个变量里只存一个值（比如 j = 5）</p>
<p>we can define a whole series of numbers, and save that into an array variable.</p>
<p>我们可以把多个值存在数组变量里</p>
<p>To be able to find a particular value in this array, we have to specify an index.</p>
<p>为了拿出数组中某个值，我们要指定一个下标（index）</p>
<p>Almost all programing languages start arrays at index 0,</p>
<p>大多数编程语言里，数组下标都从 0 开始</p>
<p>and use a square bracket syntax to denote array access.</p>
<p>用方括号 [ ] 代表访问数组</p>
<p>So, for example, if we want to add the values in the first and third spots of our array 'j',</p>
<p>如果想相加数组 J 的第一个和第三个元素</p>
<p>and save that into a variable 'a', we would write a line of code like this.</p>
<p>把结果存在变量 a，可以写上图这样一行代码</p>
<p>How an array is stored in memory is pretty straightforward.</p>
<p>数组存在内存里的方式十分易懂</p>
<p>For simplicity, let's say that the compiler chose to store ours at memory location 1,000.</p>
<p>为了简单，假设编译器从内存地址 1000 开始存数组</p>
<p>The array contains 7 numbers, and these are stored one after another in memory, as seen here.</p>
<p>数组有7个数字，像上图一样按顺序存.</p>
<p>So when we write "j index of 0", the computer goes to memory location 1,000,</p>
<p>写 j[0]，会去内存地址 1000</p>
<p>with an offset of 0, and we get the value 5.</p>
<p>加 0 个偏移，得到地址 1000，拿值：5</p>
<p>If we wanted to retrieve "j index of 5", our program goes to memory location 1000,</p>
<p>如果写 j[5]，会去内存地址 1000</p>
<p>plus an offset of 5, which in this case, holds a value of 4.</p>
<p>加 5 个偏移，得到地址 1005，拿值： 4</p>
<p>It's easy to confuse the fifth number in the array with the number at index 5.</p>
<p>很容易混淆 "数组中第 5 个数" 和 "数组下标为 5 的数"</p>
<p>They are not the same.</p>
<p>它们不是一回事</p>
<p>Remember, the number at index 5 is the 6th number in the array</p>
<p>记住，下标 5 其实是数组中第 6 个数</p>
<p>because the first number is at index 0.</p>
<p>因为下标是从 0 开始算的</p>
<p>Arrays are extremely versatile data structures, used all the time,</p>
<p>数组的用途广泛</p>
<p>and so there are many functions that can handle them to do useful things.</p>
<p>所以几乎所有编程语言都自带了很多函数来处理数组</p>
<p>For example, pretty much every programming language comes with a built-in sort function,</p>
<p>举例，数组排序函数很常见</p>
<p>where you just pass in your array, and it comes back sorted.</p>
<p>只需要传入数组，就会返回排序后的数组</p>
<p>So there's no need to write that algorithm from scratch.</p>
<p>不需要写排序算法</p>
<p>Very closely related are Strings, which are just arrays of characters,</p>
<p>数组的亲戚是字符串 (string)</p>
<p>like letters, numbers, punctuation and other written symbols.</p>
<p>其实就是字母,数字,标点符号等组成的数组</p>
<p>We talked about how computers store characters way back in Episode 4.</p>
<p>第 4 集讨论过计算机怎么存储字符</p>
<p>Most often, to save a string into memory, you just put it in quotes, like so.</p>
<p>写代码时用引号括起来就行了，j = "STAN ROCKS"</p>
<p>Although it doesn't look like an array, it is.</p>
<p>虽然长的不像数组，但的确是数组</p>
<p>Behind the scenes, the memory looks like this.</p>
<p>幕后看起来像这样</p>
<p>Note that the string ends with a zero in memory.</p>
<p>注意，字符串在内存里以 0 结尾</p>
<p>It's not the character zero, but the binary value 0.</p>
<p>不是"字符0"，是"二进制值0"，</p>
<p>This is called the null character, and denotes the end of the string in memory.</p>
<p>这叫字符"null"，表示字符串结尾</p>
<p>This is important because if I call a function like "print quote",</p>
<p>这个字符非常重要，如果调用 print 函数</p>
<p>which writes the string to the screen,</p>
<p>print 在屏幕上输出字符串</p>
<p>it prints out each character in turn starting at the first memory location,</p>
<p>会从开始位置，逐个显示到屏幕</p>
<p>but it needs to know when to stop!</p>
<p>但得知道什么时候停下来！</p>
<p>Otherwise, it would print out every single thing in memory as text.</p>
<p>否则会把内存里所有东西都显示出来</p>
<p>The zero tells string functions when to stop.</p>
<p>0 告诉函数何时停下</p>
<p>Because computers work with text so often,</p>
<p>因为计算机经常处理字符串，</p>
<p>there are many functions that specifically handle strings.</p>
<p>所以有很多函数专门处理字符串</p>
<p>For example, many programming languages have a string concatenation function, or "strcat",</p>
<p>比如连接字符串的 strcat</p>
<p>which takes in two strings, and copies the second one to the end of the first.</p>
<p>strcat 接收两个字符串，把第二个放到第一个结尾.</p>
<p>We can use arrays for making one dimensional lists,</p>
<p>我们可以用数组做一维列表</p>
<p>but sometimes you want to manipulate data that is two dimensional,</p>
<p>但有时想操作二维数据</p>
<p>like a grid of numbers in a spreadsheet, or the pixels on your computer screen.</p>
<p>比如电子表格，或屏幕上的像素</p>
<p>For this, we need a Matrix.</p>
<p>那么需要矩阵（Matrix）</p>
<p>You can think of a Matrix as an array of arrays!</p>
<p>可以把矩阵看成数组的数组！</p>
<p>So a 3 by 3 matrix is really  an array of size 3, with each index storing an array of size 3.</p>
<p>一个 3x3 矩阵就是一个长度为3的数组，数组里每个元素都是一个长度为3的数组</p>
<p>We can initialize a matrix like so.</p>
<p>可以这样初始化.</p>
<p>In memory, this is packed together in order like this.</p>
<p>内存里是这样排列的</p>
<p>To access a value, you need to specify two indexes, like "J index of 2, then index of 1" -</p>
<p>为了拿一个值，需要两个下标，比如 j[2][1]</p>
<p>this tells the computer you're looking for the item in subarray 2 at position 1.</p>
<p>告诉计算机在找数组 2 里，位置是 1 的元素</p>
<p>And this would give us the value 12.</p>
<p>得到数字 12</p>
<p>The cool thing about matrices is we're not limited to 3 by 3</p>
<p>矩阵酷的地方是，不止能做 3x3 的矩阵</p>
<p>we can make them any size we want</p>
<p>任何尺寸</p>
<p>and we can also make them any number of dimensions we want.</p>
<p>任何维度都行</p>
<p>For example, we can create a five dimensional matrix and access it like this.</p>
<p>可以做一个5维矩阵，然后这样访问，a = j[2][0][18][18][3]</p>
<p>That's right, you now know how to access a five dimensional matrix</p>
<p>现在你知道了怎么读一个 5 维矩阵</p>
<p>tell your friends!</p>
<p>快去告诉你的朋友！</p>
<p>So far, we've been storing individual numbers or letters into our arrays or matrices.</p>
<p>目前我们只存过单个数字/字符，存进数组或矩阵</p>
<p>But often it's useful to store a block of related variables together.</p>
<p>但有时, 把几个有关系的变量存在一起, 会很有用</p>
<p>Like, you might want to store a bank account number along with its balance.</p>
<p>比如银行账户号和余额</p>
<p>Groups of variables like these can be bundled together into a Struct.</p>
<p>多个变量打包在一起叫结构体 (Struct)</p>
<p>Now we can create variables that aren't just single numbers,</p>
<p>现在多个不同类型数据，</p>
<p>but are compound data structures, able to store several pieces of data at once.</p>
<p>可以放在一起</p>
<p>We can even make arrays of structs that we define,</p>
<p>甚至可以做一个数组，里面放很多结构体</p>
<p>which are automatically bundled together in memory.</p>
<p>这些数据在内存里会自动打包在一起</p>
<p>If we access, for example, J index of 0, we get back the whole struct stored there,</p>
<p>如果写 j[0]，能拿到  j[0] 里的结构体</p>
<p>and we can pull the specific account number and balance data we want.</p>
<p>然后拿银行账户和余额</p>
<p>This array of structs, like any other array,</p>
<p>存结构体的数组，和其它数组一样</p>
<p>gets created at a fixed size that can't be enlarged to add more items.</p>
<p>创建时就有固定大小，不能动态增加大小</p>
<p>Also, arrays must be stored in order in memory,</p>
<p>还有，数组在内存中按顺序存储</p>
<p>making it hard to add a new item to the middle.</p>
<p>在中间插入一个值很困难</p>
<p>But, the struct data structure can be used for</p>
<p>但结构体可以创造更复杂的数据结构，</p>
<p>building more complicated data structures that avoid these restrictions.</p>
<p>消除这些限制</p>
<p>Let's take a look at this struct that's called a "node".</p>
<p>我们来看一个结构体，叫节点(node)</p>
<p>It stores a variable, like a number, and also a pointer.</p>
<p>它存一个变量，一个指针（pointer）</p>
<p>A pointer is a special variable that points, hence the name, to a location in memory.</p>
<p>"指针" 是一种特殊变量，指向一个内存地址，因此得名.</p>
<p>Using this struct, we can create a linked list,</p>
<p>用节点可以做链表（linked list）</p>
<p>which is a flexible data structure that can store many nodes.</p>
<p>链表是一种灵活数据结构，能存很多个节点 (node)</p>
<p>It does this by having each node point to the next node in the list.</p>
<p>灵活性是通过每个节点指向下一个节点实现的</p>
<p>Let's imagine we have three node structs saved in memory, at locations 1000, 1002 and 1008.</p>
<p>假设有三个节点，在内存地址 1000，1002, 1008</p>
<p>They might be spaced apart because they were created at different times,</p>
<p>隔开的原因可能是创建时间不同</p>
<p>and other data can sit between them.</p>
<p>它们之间有其他数据</p>
<p>So, you see that the first node contains the value 7, and the location 1008 in its "next" pointer.</p>
<p>可以看到第一个节 点，值是 7，指向地址 1008</p>
<p>This means that the next node in the linked list is located at memory location 1008.</p>
<p>代表下一个节点，位于内存地址 1008</p>
<p>Looking down the linked list, to the next node,</p>
<p>现在来到下一个节点</p>
<p>we see it stores the value 112 and points to another node at location 1002.</p>
<p>值是 112，指向地址 1002</p>
<p>If we follow that, we find a node that contains the value 14</p>
<p>如果跟着它，会看到一个值为 14 的节点</p>
<p>and points back to the first node at location 1000.</p>
<p>这个节点指回地址 1000，也就是第一个节 点</p>
<p>So this linked list happened to be circular,</p>
<p>这叫循环链表</p>
<p>but it could also have been terminated by using a next pointer value of 0</p>
<p>但链表也可以是非循环的，最后一个指针是 0</p>
<p>the null value -which would indicate we've reached the end of the list.</p>
<p>"null"，代表链表尽头</p>
<p>When programmers use linked lists,</p>
<p>当程序员用链表时</p>
<p>they rarely look at the memory values stored in the next pointers.</p>
<p>很少看指针具体指向哪里</p>
<p>Instead, they can use an abstraction of a linked list, that looks like this,</p>
<p>而是用链表的抽象模型，就像上图</p>
<p>which is much easier to conceptualize.</p>
<p>更容易看懂</p>
<p>Unlike an array, whose size has to be pre-defined,</p>
<p>数组大小需要预先定好</p>
<p>linked lists can be dynamically extended or shortened.</p>
<p>链表大小可以动态增减</p>
<p>For example, we can allocate a new node in memory,</p>
<p>可以创建一个新节点，通过改变指针值，把新节点插入链表</p>
<p>and insert it into this list, just by changing the next pointers.</p>
<p>可以创建一个新节点，通过改变指针值，把新节点插入链表</p>
<p>Linked Lists can also easily be re-ordered, trimmed, split, reversed, and so on.</p>
<p>链表也很容易重新排序，两端缩减，分割，倒序等</p>
<p>Which is pretty nifty!</p>
<p>超方便！</p>
<p>And pretty useful for algorithms like sorting, which we talked about last week.</p>
<p>链表也适合上集的排序算法</p>
<p>Owing to this flexibility, many more-complex data structures are built on top of linked lists</p>
<p>因为灵活，很多复杂数据结构都用链表</p>
<p>The most famous and universal are queues and stacks.</p>
<p>最出名的是队列（queue）和栈（stack）</p>
<p>A queue like the line at your post office goes in order of arrival.</p>
<p>"队列" 就像邮局排队，谁先来就排前面</p>
<p>The person who has been waiting the longest, gets served first.</p>
<p>"队列" 就像邮局排队，谁先来就排前面</p>
<p>No matter how frustrating it is that all you want to do is buy stamps</p>
<p>虽然你可能只想买邮票，</p>
<p>and the person in front of you seems to be mailing 23 packages.</p>
<p>而前面的人要寄 23 个包裹</p>
<p>But, regardless, this behavior is called First-In First-Out, or FIFO.</p>
<p>这叫先进先出（FIFO）</p>
<p>That's the first part.</p>
<p>我指队列，</p>
<p>Not the 23 packages thing.</p>
<p>不是指那 23 个包裹</p>
<p>Imagine we have a pointer, named "post office queue", that points to the first node in our linked list.</p>
<p>想象有个指针叫"邮局队列"，指向链表第一个节 点</p>
<p>Once we're done serving Hank, we can read Hank's next pointer,</p>
<p>第一个节 点是 Hank，服务完 Hank 之后，读取 Hank 的指针</p>
<p>and update our "post office queue" pointer to the next person in the line.</p>
<p>把"邮局队列"指向下一个人</p>
<p>We've successfully dequeued Hank -he's gone, done, finished.</p>
<p>这样就把 Hank "出队"（dequeue）了</p>
<p>If we want to enqueue someone, that is, add them to the line,</p>
<p>如果我们想把某人"入队"（enqueue），意思是加到队列里</p>
<p>we have to traverse down the linked list until we hit the end,</p>
<p>要遍历整个链表到结尾</p>
<p>and then change that next pointer to point to the new person.</p>
<p>然后把结尾的指针，指向新人（Nick）</p>
<p>With just a small change, we can use linked lists as stacks, which are LIFO…</p>
<p>只要稍作修改，就能用链表做栈，</p>
<p>Last-In First-Out.</p>
<p>栈是后进先出(LIFO)</p>
<p>You can think of this like a stack of pancakes...</p>
<p>可以把"栈"想成一堆松饼</p>
<p>as you make them, you add them to the top of stack.</p>
<p>做好一个新松饼，就堆在之前上面</p>
<p>And when you want to eat one, you take them from the top of the stack.</p>
<p>吃的时候，是从最上面开始</p>
<p>Delicious!</p>
<p>美味！</p>
<p>Instead of enqueueing and dequeuing,</p>
<p>栈就不叫"入队""出队"了</p>
<p>data is pushed onto the stack and popped from the stacks.</p>
<p>叫"入栈"（push） "出栈"（pop）</p>
<p>Yep, those are the official terms!</p>
<p>对，这些是正确术语！</p>
<p>If we update our node struct to contain not just one, but two pointers,</p>
<p>如果节点改一下，改成 2 个指针</p>
<p>we can build trees,</p>
<p>就能做树（tree）</p>
<p>another data structure that's used in many algorithms.</p>
<p>很多算法用了 "树" 这种数据结构</p>
<p>Again, programmers rarely look at the values of these pointers,</p>
<p>同样，程序员很少看指针的具体值</p>
<p>and instead conceptualize trees like this: The top most node is called the root.</p>
<p>而是把"树"抽象成这样：最高的节点叫"根节点"（root）</p>
<p>And any nodes that hang from other nodes are called children nodes.</p>
<p>"根节点"下的所有节点都叫"子节点"（children）</p>
<p>As you might expect, nodes above children are called parent nodes.</p>
<p>任何子节点的直属上层节点，叫"母节点"（parent node）</p>
<p>Does this example imply that Thomas Jefferson is the parent of Aaron Burr?</p>
<p>这个例子能说明托马斯·杰斐逊是 阿龙·伯尔的父亲吗？</p>
<p>I'll leave that to your fanfiction to decide.</p>
<p>我让你们的同人文来决定</p>
<p>And finally, any nodes that have no children</p>
<p>没有任何"子节点"的节点</p>
<p>where the tree ends -are called Leaf Nodes.</p>
<p>也就是"树"结束的地方，叫"叶节点"（leaf）</p>
<p>In our example, nodes can have up to two children,</p>
<p>在这里的例子中，节点最多只可以有 2 个子节点</p>
<p>and for that reason, this particular data structure is called a binary tree.</p>
<p>因此叫二叉树（binary tree）</p>
<p>But you could just as easily have trees with three, four or any number of children</p>
<p>但你可以随便改，</p>
<p>by modifying the data structure accordingly.</p>
<p>弄成 3个，4个，或更多</p>
<p>You can even have tree nodes that use linked lists to store all the nodes they point to.</p>
<p>甚至节点可以用链表存所有子节点</p>
<p>An important property of trees both in real life and in data structures is that</p>
<p>"树"的一个重要性质是（不管现实中还是数据结构中）</p>
<p>there's a one-way path from roots to leaves.</p>
<p>"根"到"叶"是单向的</p>
<p>It'd be weird if roots connected to leaves, that connected to roots.</p>
<p>如果根连到叶，叶连到根就很奇怪</p>
<p>For data that links arbitrarily, that include things like loops,</p>
<p>如果数据随意连接，包括循环</p>
<p>we can use a graph data structure instead.</p>
<p>可以用"图"表示</p>
<p>Remember our graph from last episode of cities connected by roads?</p>
<p>还记得上集用路连接城市的"图"吗？</p>
<p>This can be stored as nodes with many pointers, very much like a tree,</p>
<p>这种结构可以用有多个指针的节点表示</p>
<p>but there is no notion of roots and leaves, and children and parents…</p>
<p>因此没有根、叶、子节点、父节点这些概念</p>
<p>Anything can point to anything!</p>
<p>可以随意指向！</p>
<p>So that's a whirlwind overview</p>
<p>以上概述了计算机科学中，</p>
<p>of pretty much all of the fundamental data structures used in computer science.</p>
<p>最主要的一些数据结构</p>
<p>On top of these basic building blocks,</p>
<p>这些基本结构之上，程序员做了各种新变体，有不同性质.</p>
<p>programmers have built all sorts of clever variants, with slightly different properties</p>
<p>这些基本结构之上，程序员做了各种新变体，有不同性质.</p>
<p>data structures like red-black trees and heaps, which we don't have time to cover.</p>
<p>比如"红黑树"和"堆"，我们没时间讲</p>
<p>These different data structures have properties that are useful for particular computations.</p>
<p>不同数据结构适用于不同场景</p>
<p>The right choice of data structure can make your job a lot easier,</p>
<p>选择正确数据结构会让工作更简单</p>
<p>so it pays off to think about how you want to structure your data before you jump in.</p>
<p>所以花时间考虑用什么数据结构是值得的</p>
<p>Fortunately, most programming languages come with</p>
<p>幸运的是，大多数编程语言自带了</p>
<p>libraries packed full of ready-made data structures.</p>
<p>预先做好的数据结构</p>
<p>For example, C++ has its Standard Template Library, and Java has the Java Class Library.</p>
<p>比如，C++有"标准模板库"，Java有"Java 类库"</p>
<p>These mean programmers don't have to waste time implementing things from scratch,</p>
<p>程序员不用浪费时间从零写</p>
<p>and can instead wield the power of data structures to do more interesting things,</p>
<p>时间可以花在更有趣的事情</p>
<p>once again allowing us to operate at a new level of abstraction!</p>
<p>又提升了一层抽象！</p>
<p>I'll see you next week.</p>
<p>下周见！</p>
<p>15 阿兰·图灵</p>
<p>Alan Turing</p>
<p>Hi, I'm Carrie Anne and welcome to Crash Course computer science.</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>Over the past a few episodes,</p>
<p>前几集我们聊了基础，比如函数，算法和数据结构</p>
<p>we've been building up our understanding of computer science fundamentals,</p>
<p>前几集我们聊了基础，</p>
<p>such as functions, algorithms and data structures.</p>
<p>比如函数，算法和数据结构</p>
<p>Today, we're going to take a step back and look at the person</p>
<p>今天，我们来看一位</p>
<p>who formulated many of the theoretical concepts that underline modern computation.</p>
<p>对计算机理论贡献巨大的人</p>
<p>The father of computer science</p>
<p>计算机科学之父</p>
<p>and not quite Benedict Cumberbatch lookalike, Alan Turing.</p>
<p>长得不怎么像本尼的 阿兰·图灵</p>
<p>Alan Mathison Turing was born in London in 1912</p>
<p>阿兰·马蒂森·图灵于 1921 年出生在伦敦，</p>
<p>and showed an incredible aptitude for maths and science throughout his early education.</p>
<p>从小就表现出惊人数学和科学能力</p>
<p>His first brush of what we now call computer science came in 1935</p>
<p>他对计算机科学的建树始于 1935 年</p>
<p>while he was a master student at King's College in Cambridge.</p>
<p>当时他是剑桥国王学院的硕士生</p>
<p>He set out to solve a problem posed by German Mathematician David Hilbert</p>
<p>他开始解决德国数学家大卫·希尔伯特提出的问题</p>
<p>known as the Entscheidungsproblem</p>
<p>叫 Entscheidungsproblem （德语）</p>
<p>or decision problem,</p>
<p>即"可判定性问题":</p>
<p>which asked the following:</p>
<p>提出了以下问题：</p>
<p>is there an algorithm that takes, as input, a statement written in formal logic,</p>
<p>是否存在一种算法，输入正式逻辑语句，</p>
<p>and produces a "yes" or "no" answer that's always accurate?</p>
<p>输出准确的"是"或"否"答案？</p>
<p>If such an algorithm existed,</p>
<p>如果这样的算法存在，</p>
<p>we could use it to answer questions like, "Is there a number bigger than all numbers?"</p>
<p>可以回答比如 "是否有一个数大于所有数"</p>
<p>No, there's not. We know the answer to that one,</p>
<p>不, 没有.  我们知道答案</p>
<p>but there are many other questions in mathematics that we'd like to know the answer too.</p>
<p>但有很多其他数学问题，我们想知道答案</p>
<p>So if this algorithm existed, we'd want to know it.</p>
<p>所以如果这种算法存在,  我们想知道</p>
<p>The American mathematician Alonzo Church first presented a solution to this problem in 1935.</p>
<p>美国数学家阿隆佐·丘奇，于 1935年首先提出解决方法</p>
<p>He developed a system of mathematical expressions called Lambda Calculus</p>
<p>开发了一个叫"Lambda 算子"的数学表达系统</p>
<p>and demonstrated that no such universal algorithm could exist.</p>
<p>证明了这样的算法不存在</p>
<p>Although Lambda Calculus was capable of representing any computation,</p>
<p>虽然"Lambda 算子"能表示任何计算</p>
<p>the mathematical technique was difficult to apply and understand.</p>
<p>但它使用的数学技巧难以理解和使用</p>
<p>At pretty much the same time on the other side of the Atlantic,</p>
<p>同时在大西洋另一边</p>
<p>Alan Turing came up with his own approach to solve the decision problem.</p>
<p>阿兰·图灵想出了自己的办法来解决"可判定性问题"</p>
<p>He proposed a hypothetical computing machine, which we now call a Turing Machine.</p>
<p>提出了一种假想的计算机，现在叫"图灵机"</p>
<p>Turing Machines provided a simple, yet powerful</p>
<p>图灵机提供了简单又强大的</p>
<p>mathematical model of computation.</p>
<p>数学计算模型</p>
<p>Although using totally different mathematics,</p>
<p>虽然用的数学不一样</p>
<p>they were functionally equivalent to lambda calculus in terms of their computational power.</p>
<p>但图灵机的计算能力和 Lambda 算子一样</p>
<p>However their relative simplicity made them much more popular</p>
<p>同时因为图灵机更简单，</p>
<p>in the burgeoning field of computer science.</p>
<p>所以在新兴的计算机领域更受欢迎</p>
<p>In fact, they're simple enough that I'm going to explain it right now.</p>
<p>因为它如此简单，我现在就给你解释</p>
<p>A Turing Machine is a theoretical computing device</p>
<p>图灵机是一台理论计算设备</p>
<p>There's also a state variable in which we can hold a piece of information</p>
<p>还有一个状态变量，</p>
<p>about the current state of the machine.</p>
<p>保存当前状态</p>
<p>And a set of rules that describes what the machine does.</p>
<p>还有一组规则，描述机器做什么</p>
<p>Given a state and the current symbol the head is reading,</p>
<p>规则是根据当前状态+读写头看到的符号，决定机器做什么</p>
<p>the rule can be to write a symbol on the tape,</p>
<p>结果可能是在纸带写入一个符号</p>
<p>change the state of the machine, move the read/write head to the left or right by one spot</p>
<p>或改变状态，或把读写头移动一格</p>
<p>or any combination of these actions.</p>
<p>或执行这些动作的组合</p>
<p>To make this concrete, let's work through a simple example:</p>
<p>为了更好理解，讲个简单例子：</p>
<p>a Turing Machine that reads a string of ones ending in a zero</p>
<p>让图灵机读一个以零结尾的字符串</p>
<p>and computes whether there is an even number of ones.</p>
<p>并计算 1 的出现次数是不是偶数</p>
<p>If that's true,</p>
<p>如果是, </p>
<p>the machine will write a one to the tape</p>
<p>在纸带上写一个 1</p>
<p>and if it's false, it'll write a zero.</p>
<p>如果不是，在纸带上写一个 0</p>
<p>First we need to define our Turing machine rules.</p>
<p>首先要定义"图灵机"的规则</p>
<p>If the state is even and the current symbol of the tape is one,</p>
<p>如果当前状态是"偶数",  当前符号是1</p>
<p>then we update the machine state to odd and move the head to the right.</p>
<p>那么把状态更新为"奇数"，把读写头向右移动</p>
<p>On the other hand if the state is even and the current symbol is zero,</p>
<p>如果当前状态为偶数，当前符号是 0</p>
<p>which means we've reached the end of the string of ones,</p>
<p>意味着到了字符串结尾</p>
<p>then we write one to the tape and change the state to halt,</p>
<p>那么在纸带上写一个 1，并且把状态改成停机(halt)</p>
<p>as in we're finished and the Turing machine has completed the computation.</p>
<p>状态改为"停机" 是因为图灵机已完成计算</p>
<p>We also need rules for when the Turing machine is in an odd state,</p>
<p>但我们还需要 2 条规则，来处理状态为奇数的情况</p>
<p>one rule for the symbol on the tape is a zero and another for when it is one.</p>
<p>一条处理奇数 + 纸带是 0 的情况，一条处理奇数 + 纸带是 1 的情况</p>
<p>Lastly we need to define a Starting state, which we'll set to be even.</p>
<p>最后，要决定机器的初始状态，这里定成"偶数"</p>
<p>Now we've defined the rules in the starting state of our Turing machine,</p>
<p>定义好了起始状态+规则</p>
<p>which is comparable to a computer program, we can run it on some example input.</p>
<p>就像写好了程序，现在可以输入了</p>
<p>Let's say we store 1 1 0 onto tape.</p>
<p>假设把"1 1 0"放在纸带上，</p>
<p>That's two ones, which means there is an even number of ones,</p>
<p>有两个 1，是偶数</p>
<p>and if that's news to you,</p>
<p>如果"偶数"对你是新知识，</p>
<p>We should probably get working on crash course Math.</p>
<p>也许我们该开一门【十分钟速成课：数学】</p>
<p>Notice that our rules only ever move their head to the right</p>
<p>注意，规则只让读写头向右移动</p>
<p>so the rest of the tape is irrelevant.</p>
<p>其他部分无关紧要，</p>
<p>We'll leave it blank for simplicity.</p>
<p>为了简单所以留空</p>
<p>Our Turing machine is all ready to go so let's start it.</p>
<p>"图灵机"准备好了，开始吧</p>
<p>Our state is even and the first number we see is one.</p>
<p>机器起始状态为"偶数"，看到的第一个数是 1</p>
<p>That matches our topmost rule and so we execute the effect,</p>
<p>符合最上面那条规则，所以执行对应的步骤</p>
<p>which is to update the state to odd and move the read/write head to the right by one spot.</p>
<p>把状态更新到"奇数"，读写头向右移动一格</p>
<p>Okay, now we see another one on the tape, But this time our state is odd</p>
<p>然后又看到 1, 但机器状态是"奇数"，</p>
<p>and so we execute our third rule</p>
<p>所以执行第三条规则</p>
<p>which sets the state back to even and moves the head to the right.</p>
<p>使机器状态变回"偶数"，读写头向右移动一格</p>
<p>Now we see a 0 and our current state is even</p>
<p>现在看到 0，并且机器状态是偶数，</p>
<p>so we execute our second rule</p>
<p>所以执行第二条规则</p>
<p>which is to write a 1 to the tape signifying that yes, it's true,</p>
<p>在纸带上写 1，表示"真" </p>
<p>there is an even number of ones,</p>
<p>的确有偶数个 1</p>
<p>and finally the machine halts.</p>
<p>然后机器停机</p>
<p>That's how Turing machines work.</p>
<p>这就是图灵机的原理，</p>
<p>Pretty simple, right?</p>
<p>很简单对吧？</p>
<p>so you might be wondering why there's such a big deal.</p>
<p>你可能想知道有什么大不了的</p>
<p>Well, Turing shows that this simple hypothetical machine</p>
<p>图灵证明了这个简单假想机器</p>
<p>can perform any computation if given enough time and memory.</p>
<p>如果有足够时间和内存，可以执行任何计算</p>
<p>It's a general-purpose computer.</p>
<p>它是一台通用计算机</p>
<p>Our program was a simple example.</p>
<p>刚才的程序就是个简单例子</p>
<p>But with enough rules, states and tape,</p>
<p>只要有足够的规则，状态和纸带</p>
<p>you could build anything</p>
<p>可以创造任何东西</p>
<p>a web browser, world of warcraft, whatever!</p>
<p>浏览器, 魔兽世界任何东西！</p>
<p>Of course it would be ridiculously inefficient, but it is theoretically possible.</p>
<p>当然这样做效率很低，但理论上可行.</p>
<p>And that's why, as a model of computing,</p>
<p>所以图灵机是很强大的计算模型</p>
<p>it's such a powerful idea.</p>
<p>这是一个非常强大的思想。</p>
<p>In fact, in terms of what it can and cannot compute</p>
<p>事实上，就可计算和不可计算而言</p>
<p>there's no computer more powerful than a turing machine.</p>
<p>没有计算机比图灵机更强大</p>
<p>A computer that is as powerful is called Turing complete.</p>
<p>和图灵机一样强大的，叫 "图灵完备"</p>
<p>Every modern computing system, your laptop, your smartphone</p>
<p>每个现代计算系统比如笔记本电脑，智能手机</p>
<p>and even the little computer inside your microwave and thermostat</p>
<p>甚至微波炉和恒温器内部的小电脑</p>
<p>are all Turing Complete.</p>
<p>都是"图灵完备"的</p>
<p>To answer Hilbert's decision problem,</p>
<p>为了回答可判定性问题</p>
<p>Turing applied these new Turing machines to an intriguing computational puzzle:</p>
<p>他把图灵机用于一个有趣计算问题：</p>
<p>the halting problem.</p>
<p>"停机问题"</p>
<p>Put simply this asks</p>
<p>简单说就是</p>
<p>"Is there an algorithm that can determine,</p>
<p>"给定图灵机描述和输入纸带，</p>
<p>given a description of a turing machine and the input from its tape,</p>
<p>是否有算法可以确定</p>
<p>whether the Machine will run forever or halt?"</p>
<p>机器会永远算下去还是到某一点会停机？</p>
<p>For example we know our Turing machine will halt when given the input 1 1 0</p>
<p>我们知道输入 1 1 0，图灵机会停机</p>
<p>Because we literally walk through the example until it halted,</p>
<p>因为刚做过这个例子，它最后停机了</p>
<p>but what about a more complex problem?</p>
<p>但如果是更复杂的问题呢？</p>
<p>Is there a way to figure out if the program will halt without executing it?</p>
<p>有没有办法在不执行的情况，弄清会不会停机？</p>
<p>Some programs might take years to run</p>
<p>一些程序可能要运行好几年</p>
<p>so it would be useful to know before we run it</p>
<p>所以在运行前知道会不会出结果很有用</p>
<p>and wait and wait and wait and then start getting worried and wonder</p>
<p>否则就要一直等啊等，忧虑到底会不会出结果</p>
<p>and then decades later when you're old and gray control-alt-delete.</p>
<p>当几十年后变老了，再按强制结束</p>
<p>So much sadness!</p>
<p>好悲伤！</p>
<p>Unfortunately, Turing came up with a proof that shows the halting problem was in fact unsolvable,</p>
<p>图灵通过一个巧妙逻辑矛盾，</p>
<p>through a clever logical contradiction.</p>
<p>证明了停机问题是无法解决的</p>
<p>Let's follow his reasoning.</p>
<p>我们来看看他的推理</p>
<p>Imagine we have a hypothetical Turing machine that takes a description of a program</p>
<p>想象有一个假想图灵机，</p>
<p>and some input for his tape</p>
<p>输入：问题的描述 + 纸带的数据</p>
<p>and always outputs either Yes, it halts, or no, it doesn't.</p>
<p>输出 Yes 代表会"停机"，输出 No 代表不会</p>
<p>And I'm going to give this machine a fun name</p>
<p>我要给这台机器一个有趣的名字叫 H，</p>
<p>H for Halts.</p>
<p>来自"停机"的第一个字母</p>
<p>Don't worry about how it works.</p>
<p>不用担心它具体怎么工作</p>
<p>Let's just assume such a machine exists.</p>
<p>假设这样的机器存在就好</p>
<p>We're talking theory here.</p>
<p>毕竟重点是推论</p>
<p>Turing reasons if there existed a program whose halting behavior was not decidable by H,</p>
<p>图灵推理说： 如果有个程序，H 无法判断是否会"停机"</p>
<p>it would mean the halting problem is unsolvable.</p>
<p>意味着"停机问题"无法解决</p>
<p>To find one, Turing designed another Turing machine that built on top of H.</p>
<p>为了找到这样的程序，图灵用 H 设计了另一个图灵机</p>
<p>If H says the program halts,</p>
<p>如果 H 说程序会"停机"，</p>
<p>then we'll make our new machine loop forever.</p>
<p>那么新机器会永远运行（即不会停机）</p>
<p>If the answer is no, it doesn't the halt.</p>
<p>如果 H 的结果为 No，代表不会停机</p>
<p>That will have the new machine output no and halt.</p>
<p>那么让新机器输出 No，然后"停机"</p>
<p>In essence, we're building a machine that does the opposite of what H says.</p>
<p>实质上是一台和 H 输出相反的机器</p>
<p>Halt if the program doesn't halt</p>
<p>如果程序不停机，就停机</p>
<p>and run forever if the program halts.</p>
<p>如果程序停机，就永远运行下去</p>
<p>So this argument will also need to add a splitter to the front of our new machine.</p>
<p>我们还需要在机器前面加一个分离器</p>
<p>So it accepts only one input and passes that as both the program and input into H.</p>
<p>让机器只接收一个输入，这个输入既是程序，也是输入</p>
<p>Let's call this new Machine Bizzaro.</p>
<p>我们把这台新机器叫异魔</p>
<p>So far this seems like a plausible machine right.</p>
<p>目前为止，这个机器不难理解</p>
<p>Now it's going to get pretty complicated.</p>
<p>但接下来马上会变复杂，</p>
<p>But bear with me for a second.</p>
<p>会有点难懂</p>
<p>Look what happens when you pass bizzaro a description of itself as the input.</p>
<p>如果把异魔的描述，作为本身的输入会怎样</p>
<p>This means We're asking h what bizzaro will do when asked to evaluate itself.</p>
<p>意味着在问 H ，当异魔的输入是自己时会怎样</p>
<p>But if H says Bizzaro halts,</p>
<p>但如果 H 说异魔会停机</p>
<p>then Bizzaro enters its infinite loop and thus doesn't halt.</p>
<p>那么异魔会进入无限循环，因此不会停机</p>
<p>And if H says the Bizzaro doesn't halt, then Bizzaro outputs no and halt.</p>
<p>如果 H 说异魔不会停机，那么异魔会输出 No 然后停机</p>
<p>So H can't possibly decide the halting problem correctly</p>
<p>所以 H 不能正确判定停机问题</p>
<p>because there is no answer.</p>
<p>因为没有答案</p>
<p>It's a paradox.</p>
<p>这是一个悖论</p>
<p>And this paradox means that the halting problem cannot be solved with Turing machines.</p>
<p>意味着"停机问题"不能用图灵机解决</p>
<p>Remember Turing proves that Turing machines could implement any computation.</p>
<p>还记得刚刚说： 图灵证明了图灵机可以实现任何计算</p>
<p>So this solution to the halting problem proves</p>
<p>"停机问题"证明了，</p>
<p>that not all problems can be solved by computation.</p>
<p>不是所有问题都能用计算解决</p>
<p>Wow, that's some heavy stuff.</p>
<p>哇，好难理解</p>
<p>I might have to watch that again myself.</p>
<p>我都可能要再看一遍</p>
<p>Long story short, Church and Turing showed there were limits to the ability of computers.</p>
<p>长话短说，丘奇和图灵证明了计算机的能力有极限</p>
<p>No matter how much time or memory you have,</p>
<p>无论有多少时间或内存，</p>
<p>there are just some problems that cannot be solved ever.</p>
<p>有些问题是计算机无法解决的</p>
<p>The concurrent efforts by Church and Turing to determine the limits of computation,</p>
<p>丘奇和图灵证明了计算是有极限的，</p>
<p>and in general, formalize computability, are now called the Church-Turing Thesis.</p>
<p>起步了可计算性理论，现在叫"丘奇-图灵论题"</p>
<p>At this point in 1936, Turing was only 24 years old</p>
<p>当时是1936年，图灵只有24岁</p>
<p>and really only just beginning his career.</p>
<p>他的职业生涯才刚刚开始</p>
<p>From 1936 through 1938,</p>
<p>从1936年到1938年，在丘奇指导下，</p>
<p>he completed a PhD at Princeton University under the guidance of Church</p>
<p>他在普林斯顿拿到博士学位</p>
<p>then after graduating he returned to Cambridge.</p>
<p>毕业后回到剑桥</p>
<p>Shortly after in 1939, Britain became embroiled in World War II.</p>
<p>1939年后不久，英国卷入第二次世界大战</p>
<p>Turing's genius was quickly applied for the war effort.</p>
<p>图灵的才能很快被投入战争</p>
<p>In fact, a year before the war started,</p>
<p>事实上，在战争开始前一年</p>
<p>he was already working part-time at the UK's government Code and Cypher school,</p>
<p>他已经在英国政府的密码破译学校兼职</p>
<p>which was the British code breaking group based out of Bletchley Park.</p>
<p>位于"布莱切利园"的一个密码破译组织</p>
<p>One of his main efforts was figuring out how to decrypt German communications.</p>
<p>他的工作内容之一是破解德国的通信加密</p>
<p>Especially those that use the Enigma Machine.</p>
<p>特别是"英格玛机"加密的信息</p>
<p>In short, these machines scrambled text</p>
<p>简单说，英格玛机会加密明文</p>
<p>like you type the letters H-E-L-L-O</p>
<p>如果输入字母 H-E-L-L-O</p>
<p>and the letters X-W-D-B-J would come out.</p>
<p>机器输出 X-W-D-B-J</p>
<p>This process is called Encryption.</p>
<p>这个过程叫"加密"</p>
<p>The scrambling wasn't random.</p>
<p>文字不是随便打乱的</p>
<p>The behavior was defined by a series of real world rotors on the top of the enigma machine.</p>
<p>加密由"英格玛机"顶部的齿轮组合决定</p>
<p>Each were 26 possible rotational positions.</p>
<p>每个齿轮有26个可能位置</p>
<p>There was also a plug board at the front of the machine that allow pairs of letters to be swapped.</p>
<p>机器前面还有插板，可以将两个字母互换</p>
<p>In total, there were billions of possible settings.</p>
<p>总共有上十亿种可能</p>
<p>If you had your only enigma machine and you knew the correct rotor and plug board settings,</p>
<p>如果你有"英格玛机"，并且知道正确的齿轮和插头设置</p>
<p>you could type in X-W-D-B-J and "hello" would come out.</p>
<p>输入X-W-D-B-J，机器会输出 hello</p>
<p>In other words, you decrypted the message.</p>
<p>解密了这条消息</p>
<p>Of course, the German military wasn't sharing their enigma settings on Social Media.</p>
<p>当然，德军不会把机器设置发到微博上</p>
<p>So the allies had to break the code.</p>
<p>盟军必须自己破译密码</p>
<p>With billions of Rotor and plug board combinations,</p>
<p>有数十亿种组合，</p>
<p>there was no way to check them all by hand.</p>
<p>根本没法手工尝试所有组合</p>
<p>Fortunately for Turing, Enigma Machines and the people who operated them were not perfect.</p>
<p>幸运的是，英格玛机和操作员不是完美的</p>
<p>Like one key flaw was that a letter would never be encoded as itself,</p>
<p>一个大缺陷是：字母加密后绝不会是自己</p>
<p>as in an H was never encrypted as an H.</p>
<p>H 加密后绝对不是 H</p>
<p>Turing building on earlier work by Polish code breakers</p>
<p>图灵接着之前波兰破译专家的成果继续工作</p>
<p>designed a special-purpose electro-mechanical computer called the bombe</p>
<p>设计了一个机电计算机，叫 Bombe</p>
<p>that took advantages of this flaw.</p>
<p>利用了这个缺陷，</p>
<p>It tried lots and lots of combinations of enigma settings for a given encrypted message.</p>
<p>它对加密消息尝试多种组合</p>
<p>If the bombe found a setting that led to a letter being encoded as itself</p>
<p>如果发现字母解密后和原先一样</p>
<p>which we know no enigma machines could do.</p>
<p>我们知道英格玛机决不会这么做</p>
<p>That combination was discarded then the machine moved on to try another combination.</p>
<p>这个组合会被跳过，接着试另一个组合</p>
<p>So bombe was used to greatly narrow the number of Possible enigma settings.</p>
<p>Bombe 大幅减少了搜索量</p>
<p>This allowed human code breakers to hone their efforts on the most probable solutions,</p>
<p>让破译人员把精力花在更有可能的组合</p>
<p>looking for things like common german words in fragments of decoded text.</p>
<p>比如在解码文本中找常见的德语单词</p>
<p>Periodically, the Germans would suspect someone was decoding their communications</p>
<p>德国人时不时会怀疑有人在破解，</p>
<p>and upgrade the enigma machine,</p>
<p>然后升级英格玛机</p>
<p>like they'd add another rotor creating many more combinations.</p>
<p>比如加一个齿轮，创造更多可能组合</p>
<p>They even built entirely new encryption machines.</p>
<p>他们甚至还做了全新的加密机</p>
<p>Throughout the war, Turing and his colleagues at Bletchley Park</p>
<p>整个战争期间，图灵和同事在布莱切利园努力破解加密</p>
<p>worked tirelessly to defeat these mechanisms.</p>
<p>整个战争期间，图灵和同事在布莱切利园努力破解加密</p>
<p>And overall, the intelligence gained from decrypted German communications</p>
<p>解密得到的德国情报，</p>
<p>gave the allies an edge in many theaters</p>
<p>为盟军赢得了很多优势</p>
<p>with some historians arguing is shortened the war by years.</p>
<p>有些史学家认为他们把战争减短了好几年</p>
<p>After the war, Turing return to academia</p>
<p>战后，图灵回到学术界，</p>
<p>and contributed to many early electronic computing efforts</p>
<p>为许多早期计算机工作做出贡献</p>
<p>like the Manchester Mark 1, which was an early and influential stored-program computer.</p>
<p>比如曼彻斯特 1 号，一个早期有影响力的存储程序计算机</p>
<p>But his most famous post-war contribution was the Artificial Intelligence.</p>
<p>但他最有名的战后贡献是"人工智能"</p>
<p>A field's so new that it didn't get that name until 1956.</p>
<p>这个领域很新，直到1956年才有名字</p>
<p>It's a huge topic. So we'll get to it again in future episodes.</p>
<p>这个话题很大，以后再谈（第34集）</p>
<p>In 1950, Turing could envision a future where computers</p>
<p>1950 年，图灵设想了未来的计算机</p>
<p>were powerful enough to exhibit intelligence equivalent to</p>
<p>拥有和人类一样的智力，</p>
<p>or at least indistinguishable from that of a human.</p>
<p>或至少难以区分</p>
<p>Turing postulated that a computer would deserve to be called intelligent</p>
<p>图灵提出，如果计算机能欺骗人类相信它是人类，</p>
<p>if it could deceive a human into believing that it was human.</p>
<p>才算是智能</p>
<p>This became the basis of a simple test, now called the Turing test.</p>
<p>这成了智能测试的基础，如今叫"图灵测试"</p>
<p>Imagine that you are having a conversation with two different people</p>
<p>想像你在和两个人沟通，不用嘴或面对面，</p>
<p>not by voice or in person, but by sending type notes back and forth,</p>
<p>而是来回发消息</p>
<p>you can ask any questions you want and you get replies.</p>
<p>可以问任何问题，然后会收到回答</p>
<p>But one of those two people is actually a computer.</p>
<p>但其中一个是计算机</p>
<p>If you can't tell which one is human and which one is a computer,</p>
<p>如果你分不出哪个是人类，哪个是计算机</p>
<p>then the computer passes the test.</p>
<p>那么计算机就通过了图灵测试</p>
<p>There's a modern version of this test called</p>
<p>这个测试的现代版叫</p>
<p>a completely automated public turing test to tell computers and humans apart</p>
<p>"公开全自动图灵测试，用于区分计算机和人类"</p>
<p>or Captcha for short.</p>
<p>简称"验证码"</p>
<p>These are frequently used on the internet to prevent automated systems</p>
<p>这些在因特网上经常被用来防止自动化系统</p>
<p>from doing things like posting spam on websites.</p>
<p>防止机器人发垃圾信息等</p>
<p>I'll admit sometimes I can't read what those squiggly things say.</p>
<p>我承认有时我都认不出那些扭曲的东西是什么字</p>
<p>Does that mean I'm a computer?</p>
<p>这难道意味着我是计算机？</p>
<p>Normally in this series, we don't delve into the personal lives of these historical figures.</p>
<p>通常这个系列我们不会深入历史人物的个人生活</p>
<p>But in Turing's case his name has been inextricably tied to tragedy</p>
<p>但图灵与悲剧密不可分</p>
<p>so his story is worth mentioning.</p>
<p>所以他的故事值得一提</p>
<p>Turing was gained a time when homosexuality was illegal in the United Kingdom and much of the world.</p>
<p>图灵那个时代，同性恋是违法的，英国和大部分国家都是</p>
<p>And an investigation into a 1952 Burglary at his home</p>
<p>1952 年调查他家的入室盗窃案时，</p>
<p>revealed his sexual orientation to the authorities,</p>
<p>向当局暴露了他的性取向</p>
<p>who charged him with gross indecency.</p>
<p>被起诉 "行为严重不检点"</p>
<p>Turing was convicted and given a choice between imprisonment,</p>
<p>图灵被定罪，有2个选择：1 入狱 </p>
<p>or probation with hormonal treatments to suppress his sexuality.</p>
<p>2 接受激素来压制性欲</p>
<p>He chose the latter in part to continue his academic work,</p>
<p>他选了后者，部分原因是为了继续学术工作</p>
<p>but it altered his mood and personality.</p>
<p>但药物改变了他的情绪和性格</p>
<p>Although the exact circumstances will never be known,</p>
<p>虽然确切情况永远无法得知</p>
<p>it's most widely accepted that Alan Turing took his own life by poison in 1954.</p>
<p>图灵于1954年服毒自尽，</p>
<p>He was only 41.</p>
<p>年仅41岁</p>
<p>Many things have been named in recognition of Turing's contributions to theoretical computer science</p>
<p>由于图灵对计算机科学贡献巨大，许多东西以他命名</p>
<p>But perhaps the most prestigious among them is the Turing award</p>
<p>其中最出名的是"图灵奖"</p>
<p>the highest distinction in the field of computer science.</p>
<p>计算机领域的最高奖项</p>
<p>Equivalent to a Nobel prize in Physics, chemistry or other sciences.</p>
<p>相当于物理, 化学等其它领域的诺贝尔奖</p>
<p>Despite a life cut short, Alan inspire the first generation of computer scientists</p>
<p>虽然英年早逝，但图灵激励了第一代计算机科学家</p>
<p>and lead key groundwork that enabled a digital era that we get to enjoy today.</p>
<p>而且为如今便利的数字时代做出了重要基石性工作</p>
<p>I'll see you next week.</p>
<p>我们下周见</p>
<p>16 软件工程</p>
<p>Software Engineering</p>
<p>Hi, I'm Carrie Anne, and welcome to CrashCourse Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>So we've talked a lot about sorting in this series</p>
<p>之前花了很多时间讲排序</p>
<p>and often code to sort a list of numbers might only be ten lines long,</p>
<p>也写了些 10 行左右的排序代码</p>
<p>which is easy enough for a single programmer to write.</p>
<p>对1个程序员来说很容易写</p>
<p>Plus, it's short enough that you don't need any special tools</p>
<p>而且代码很短，不必用专门工具</p>
<p>you could do it in Notepad.</p>
<p>记事本就够了</p>
<p>Really!</p>
<p>真的！</p>
<p>But, a sorting algorithm isn't a program;</p>
<p>但排序算法很少会是独立程序，</p>
<p>it's likely only a small part of a much larger program.</p>
<p>更可能是大项目的一小部分</p>
<p>For example, Microsoft Office has roughly 40 millions lines of code.</p>
<p>举个例子，微软的 Office 大约有 4000 万代码</p>
<p>40 MILLION!</p>
<p>4000 万！</p>
<p>That's way too big for any one person to figure out and write!</p>
<p>太多了，一个人不可能做到</p>
<p>To build huge programs like this, programmers use a set of tools and practices.</p>
<p>为了写大型程序，程序员用各种工具和方法</p>
<p>Taken together, these form the discipline of Software Engineering</p>
<p>所有这些形成了"软件工程"学科</p>
<p>a term coined by engineer Margaret Hamilton,</p>
<p>这个词由工程师 Margaret Hamilton 创造</p>
<p>who helped NASA prevent serious problems during the Apollo missions to the moon.</p>
<p>她帮助 NASA 在阿波罗计划中避免了严重问题</p>
<p>She once explained it this way:</p>
<p>她曾说过：</p>
<p>"It's kind of like a root canal: you waited till the end,</p>
<p>"有点像牙根管治疗：你总是拖到最后才做，</p>
<p>[but] there are things you could have done beforehand.</p>
<p>但有些事可以预先做好</p>
<p>It's like preventative healthcare,</p>
<p>有点像预防性体检, </p>
<p>but it's preventative software."</p>
<p>只不过是预防软件出错"</p>
<p>As I mentioned in episode 12,</p>
<p>第 12 集提过</p>
<p>breaking big programs into smaller functions allows many people to work simultaneously.</p>
<p>把大项目分解成小函数可以让多人同时工作</p>
<p>They don't have to worry about the whole thing,</p>
<p>不用关心整个项目，关心自己的函数就好了</p>
<p>just the function they're working on.</p>
<p>不用关心整个项目，关心自己的函数就好了</p>
<p>So, if you're tasked with writing a sort algorithm,</p>
<p>如果你的任务是写排序算法</p>
<p>you only need to make sure it sorts properly and efficiently.</p>
<p>你只需要确保高效和正确就可以了</p>
<p>However, even packing code up into functions isn't enough.</p>
<p>然而把代码打包成函数依然不够</p>
<p>Microsoft Office probably contains hundreds of thousands of them.</p>
<p>如果只是这样，微软 Office 会有几十万个函数</p>
<p>That's better than dealing with 40 million lines of code,</p>
<p>虽然比 4000 万行代码要好一些，</p>
<p>but it's still way too many "things" for one person or team to manage.</p>
<p>但还是太多了</p>
<p>The solution is to package functions into hierarchies,</p>
<p>解决办法是：把函数打包成层级，</p>
<p>pulling related code together into "objects".</p>
<p>把相关代码都放在一起，打包成对象（objects）</p>
<p>For example, car's software might have several functions related to cruise control,</p>
<p>例如，汽车软件中可能有几个和定速巡航有关的函数</p>
<p>like setting speed, nudging speed up or down, and stopping cruise control altogether.</p>
<p>比如设定速度，逐渐加速减速，停止定速巡航</p>
<p>Since they're all related,</p>
<p>因为这些函数都相关，</p>
<p>we can wrap them up into a unified cruise control object.</p>
<p>可以包装成一个"定速巡航对象"</p>
<p>But, we don't have to stop there,</p>
<p>但不止如此，我们还可以做更多</p>
<p>cruise control is just one part of the engine's software.</p>
<p>"定速巡航"只是引擎软件的一部分</p>
<p>There might also be sets of functions that control spark plug ignition,</p>
<p>可能还有 "火花塞点火"</p>
<p>fuel pumps, and the radiator.</p>
<p>"燃油泵" 和 "散热器"</p>
<p>So we can create a "parent" Engine Object</p>
<p>我们可以做一个"引擎对象" </p>
<p>that contains all of these "children" objects.</p>
<p>来包括所有"子"对象</p>
<p>In addition to children *objects*,</p>
<p>除了子对象，</p>
<p>the engine itself might have its *own* functions.</p>
<p>"引擎对象"可能有自己的函数</p>
<p>You want to be able to stop and start it, for example.</p>
<p>比如开关引擎</p>
<p>It'll also have its own variables,</p>
<p>它也会有自己的变量，</p>
<p>like how many miles the car has traveled.</p>
<p>比如汽车行驶了多少英里</p>
<p>In general, objects can contain other objects, functions and variables.</p>
<p>总的来说，对象可以包其它对象，函数和变量</p>
<p>And of course, the engine is just one part of a Car Object.</p>
<p>当然，"引擎对象"只是"汽车对象"的一部分</p>
<p>There's also the transmission, wheels, doors, windows, and so on.</p>
<p>还有传动装置，车轮，门，窗等</p>
<p>Now, as a programmer, if I want to set the cruise control,</p>
<p>作为程序员，如果想设"定速巡航"</p>
<p>I navigate down the object hierarchy,</p>
<p>要一层层向下</p>
<p>from the outermost objects to more and more deeply nested ones.</p>
<p>从最外面的对象往里找</p>
<p>Eventually, I reach the function I want to trigger:</p>
<p>最后找到想执行的函数：</p>
<p>"Car, then engine, then cruise control, then set cruise speed to 55".</p>
<p>“汽车、然后是发动机，然后是巡航控制，然后设置巡航速度”。</p>
<p>Programming languages often use something equivalent to the syntax shown here.</p>
<p>编程语言经常用类似这样的语法</p>
<p>The idea of packing up functional units into nested objects is called</p>
<p>把函数打包成对象的思想叫 </p>
<p>Object Oriented Programming.</p>
<p> "面向对象编程"</p>
<p>This is very similar to what we've done all series long:</p>
<p>这种思想和之前类似</p>
<p>hide complexity by encapsulating low-level details in higher-order components.</p>
<p>通过封装组件，隐藏复杂度</p>
<p>Before we packed up things like transistor circuits into higher-level boolean gates.</p>
<p>之前把晶体管打包成了逻辑门</p>
<p>Now we're doing the same thing with software.</p>
<p>现在软件也这样做</p>
<p>Yet again, it's a way to move up a new level of abstraction!</p>
<p>又提升了一层抽象！</p>
<p>Breaking up a big program, like a car's software,</p>
<p>把大型软件（如汽车软件），</p>
<p>into functional units is perfect for teams.</p>
<p>拆成一个个更小单元，适合团队合作</p>
<p>One team might be responsible for the cruise control system,</p>
<p>一个团队负责定速巡航系统</p>
<p>and a single programmer on that team tackles a handful of functions.</p>
<p>团队里的一位程序员负责其中一些函数</p>
<p>This is similar to how big, physical things are built, like skyscrapers.</p>
<p>类似建摩天大楼</p>
<p>You'll have electricians running wires,</p>
<p>有电工装电线</p>
<p>plumbers fitting pipes,</p>
<p>管道工配管</p>
<p>welders welding,</p>
<p>焊接工焊接</p>
<p>painters painting,</p>
<p>油漆工涂油漆</p>
<p>and hundreds of other people teeming all over the hull.</p>
<p>还有成百上千人做其他事情</p>
<p>They work together on different parts simultaneously,</p>
<p>在不同岗位同时工作，各尽其能</p>
<p>leveraging their different skills.</p>
<p>在不同岗位同时工作，各尽其能</p>
<p>Until one day, you've got a whole working building!</p>
<p>直到整栋楼完成</p>
<p>But, returning to our cruise control example</p>
<p>回到定速巡航的例子</p>
<p>its code is going to have to make use of functions in other parts of the engine's software,</p>
<p>定速巡航要用到引擎的其它函数，</p>
<p>to, you know, keep the car at a constant speed.</p>
<p>来保持车速</p>
<p>That code isn't part of the cruise control team's responsibility.</p>
<p>定速巡航团队不负责这些代码，</p>
<p>It's another team's code.</p>
<p>另一个团队负责</p>
<p>Because the cruise control team didn't write that,</p>
<p>因为是其他团队的代码，</p>
<p>they're going to need good documentation about what each function in the code does,</p>
<p>定速巡航团队需要文档帮助理解代码都做什么</p>
<p>and a well-defined Application Programming Interface</p>
<p>以及定义好的 "程序编程接口"</p>
<p>or API for short.</p>
<p>简称 API</p>
<p>You can think of an API as the way that</p>
<p>API 帮助不同程序员合作，</p>
<p>collaborating programmers interact across various parts of the code.</p>
<p>不用知道具体细节，只要知道怎么使用就行了</p>
<p>For example, in the IgnitionControl object,</p>
<p>例如"点火控制"对象中，</p>
<p>there might be functions to set the RPM of the engine,</p>
<p>可能有"设置发动机转数"函数</p>
<p>check the spark plug voltage,</p>
<p>"检查火花塞电压"函数</p>
<p>as well as fire the individual spark plugs.</p>
<p>"点燃单个火花塞"函数</p>
<p>Being able to set the motor's RPM is really useful,</p>
<p>"设置发动机转速"非常有用</p>
<p>the cruise control team is going to need to call that function.</p>
<p>"定速巡航"团队要用到这个函数</p>
<p>But, they don't know much about how the ignition system works.</p>
<p>但他们对点火系统不怎么了解</p>
<p>It's not a good idea to let them call functions that fire the individual spark plugs.</p>
<p>让他们调用"点燃单个火花塞"函数，不是好主意</p>
<p>Or the engine might explode!</p>
<p>引擎可能会炸！</p>
<p>Maybe.</p>
<p>可能啦</p>
<p>The API allows the right people access to the right functions and data.</p>
<p>API 控制哪些函数和数据让外部访问，哪些仅供内部</p>
<p>Object Oriented Programming languages do this</p>
<p>"面向对象"的编程语言，</p>
<p>by letting you specify whether functions are public or private.</p>
<p>可以指定函数是 public 或 private，来设置权限</p>
<p>If a function is marked as "private",</p>
<p>如果函数标记成 private</p>
<p>it means only functions inside that object can call it.</p>
<p>意味着只有同一个对象内的其他函数能调用它</p>
<p>So, in this example, only other functions inside of IgnitionControl,</p>
<p>在这个例子里，只有内部函数比如 setRPM</p>
<p>like the setRPM function,</p>
<p>在这个例子里，只有内部函数比如 setRPM</p>
<p>can fire the sparkplugs.</p>
<p>才能调用 fireSparkplug 函数</p>
<p>On the other hand, because the setRPM function is marked as public,</p>
<p>而 setRPM 函数是 public ，</p>
<p>other objects can call it, like cruise control.</p>
<p>所以其它对象可以调用它，比如定速巡航</p>
<p>This ability to hide complexity, and selectively reveal it,</p>
<p>"面向对象编程"的核心是，</p>
<p>is the essence of Object Oriented Programming,</p>
<p>隐藏复杂度，选择性的公布功能</p>
<p>and it's a powerful and popular way to tackle building large and complex programs.</p>
<p>因为做大型项目很有效，所以广受欢迎</p>
<p>Pretty much every piece of software on your computer, or game running on your console,</p>
<p>计算机上几乎所有软件，游戏机里几乎所有游戏</p>
<p>was built using an Object Oriented Programming Language,</p>
<p>都是 "面向对象" 编程语言写的</p>
<p>like C++, C# or Objective-C.</p>
<p>比如 C++, C#, Objective-C 等</p>
<p>Other popular "OO" languages you may have heard of are Python and Java.</p>
<p>其他流行 OO 语言，你可能听过 Python 和 Java</p>
<p>It's important to remember that code, before being compiled, is just text.</p>
<p>有一点很重要：代码在编译前就只是文字而已</p>
<p>As I mentioned earlier,</p>
<p>前面提过，</p>
<p>you could write code in Notepad or any old word processor.</p>
<p>你可以用记事本或任何文字处理器</p>
<p>Some people do.</p>
<p>有人确实这样做</p>
<p>But generally, today's software developers use special-purpose applications for writing programs,</p>
<p>但一般来说，现代软件开发者会用专门的工具来写代码</p>
<p>ones that integrate many useful tools for writing, organizing, compiling and testing code.</p>
<p>工具里集成了很多有用功能，帮助写代码，整理，编译和测代码</p>
<p>Because they put everything you need in one place,</p>
<p>因为集成了所有东西</p>
<p>they're called Integrated Development Environments ,</p>
<p>因此叫集成开发环境，</p>
<p>or IDEs for short.</p>
<p>简称 IDE</p>
<p>All IDEs provide a text editor for writing code,</p>
<p>所有 IDE 都有写代码的界面</p>
<p>often with useful features like automatic color-coding to improve readability.</p>
<p>还带一些有用功能，比如代码高亮，来提高可读性</p>
<p>Many even check for syntax errors as you type, like spell check for code.</p>
<p>许多 IDE 提供实时检查，比如拼写</p>
<p>Big programs contain lots of individual source files,</p>
<p>大型项目有很多源代码文件</p>
<p>so IDEs allow programmers to organize and efficiently navigate everything.</p>
<p>IDE 帮助开发者整理和看代码</p>
<p>Also built right into the IDE is the ability to compile and run code.</p>
<p>很多 IDE 还可以直接编译和运行代码</p>
<p>And if your program crashes,</p>
<p>如果程序崩了，</p>
<p>because it's still a work in progress,</p>
<p>因为你还没写完呢</p>
<p>the IDE can take you back to the line of code where it happened,</p>
<p>IDE 可以定位到出错代码</p>
<p>and often provide additional information to help you track down and fix the bug,</p>
<p>还会提供信息帮你解决问题</p>
<p>which is a process called debugging.</p>
<p>这叫调试（debug）</p>
<p>This is important</p>
<p>调试很重要</p>
<p>because most programmers spend 70 to 80% of their time testing and debugging,</p>
<p>大多数程序员会花 70％~80％ 时间调试，</p>
<p>not writing new code.</p>
<p>而不是在写代码</p>
<p>Good tools, contained in IDEs,</p>
<p>好工具</p>
<p>can go a long way when it comes to helping programmers prevent and find errors.</p>
<p>能极大帮助程序员防止和解决错误</p>
<p>Many computer programmers can be pretty loyal to their IDEs though</p>
<p>很多开发者只用一款 IDE</p>
<p>But let's be honest.</p>
<p>但承认吧，</p>
<p>VIM is where it's at.</p>
<p>VIM 才是最棒的编辑器</p>
<p>Providing you know how to quit.</p>
<p>如果你知道怎么退出的话</p>
<p>In addition to coding and debugging,</p>
<p>除了写代码和调试</p>
<p>another important part of a programmer's job is documenting their code.</p>
<p>程序员工作的另一个重要部分是给代码写文档</p>
<p>This can be done in standalone files called "readme",</p>
<p>文档一般放在一个叫 README 的文件里</p>
<p>which tell other programmers to read that help file before diving in.</p>
<p>告诉其他程序员，看代码前先看这个文件</p>
<p>It can also happen right in the code itself with comment</p>
<p>文档也可以直接写成"注释"，放在源代码里</p>
<p>These are specially-marked statements that the program knows</p>
<p>注释是标记过的一段文字</p>
<p>to ignore when the code is compiled.</p>
<p>编译代码时注释会被忽略</p>
<p>They exist only to help programmers figure out what's what in the source code.</p>
<p>注释存在的唯一作用，就是帮助开发者理解代码</p>
<p>Good documentation helps programmers when they revisit code they haven't seen for awhile,</p>
<p>好文档能帮助开发者，</p>
<p>but it's also crucial for programmers who are totally new to it.</p>
<p>几个月后理解自己的代码，对其他人也很重要</p>
<p>I just want to take a second here and reiterate that it's THE WORST</p>
<p>我想花一秒再强调一下注释很重要</p>
<p>when someone parachutes a load of uncommented and undocumented code into your lap,</p>
<p>最糟糕的就是拿到一堆代码，没有任何注释和文档</p>
<p>and you literally have to go line by line to understand what the code is doing.</p>
<p>结果得逐行读代码，理解到底干嘛的</p>
<p>Seriously.</p>
<p>我是认真的</p>
<p>Don't be that person.</p>
<p>别做那种人</p>
<p>Documentation also promotes code reuse.</p>
<p>文档还可以提高复用性</p>
<p>So, instead of having programmers constantly write the same things over and over,</p>
<p>与其让程序员一遍遍写同样的东西</p>
<p>they can track down someone else's code that does what they need.</p>
<p>可以直接用别人写好的来解决问题</p>
<p>Then, thanks to documentation,</p>
<p>读文档看怎么用就行，</p>
<p>they can put it to work in their program, without ever having to read through the code.</p>
<p>不用读代码</p>
<p>"Read the docs" as they say.</p>
<p>"读文档啊"</p>
<p>In addition to IDEs,</p>
<p>除了 IDE，</p>
<p>another important piece of software that</p>
<p>还有一个重要软件</p>
<p>helps big teams work collaboratively on big coding projects is called</p>
<p>帮助团队协作</p>
<p>Source Control,</p>
<p>源代码管理</p>
<p>also known as version control or revision control.</p>
<p>也叫"版本控制"</p>
<p>Most often, at a big software company like Apple or Microsoft,</p>
<p>苹果或微软这样的大型软件公司</p>
<p>code for projects is stored on centralized servers,</p>
<p>会把代码放到一个中心服务器上</p>
<p>called a code repository .</p>
<p>叫"代码仓库"</p>
<p>When a programmer wants to work on a piece of code,</p>
<p>程序员想改一段代码时</p>
<p>they can check it out,</p>
<p>可以 check out</p>
<p>sort of like checking out a book out from a library.</p>
<p>有点像从图书馆借书</p>
<p>Often, this can be done right in an IDE.</p>
<p>一般这种操作，可以直接在 IDE 内完成</p>
<p>Then, they can edit this code all they want on their personal computer,</p>
<p>然后开发者在自己的电脑上编辑代码</p>
<p>adding new features and testing if they work.</p>
<p>加新功能，测试</p>
<p>When the programmer is confident their changes are working and there are no loose ends,</p>
<p>如果代码没问题了，所有测试通过了</p>
<p>they can check the code back into the repository,</p>
<p>可以把代码放回去</p>
<p>known as committing code, for everyone else to use.</p>
<p>这叫提交 (commit)</p>
<p>While a piece of code is checked out,</p>
<p>当代码被 check out，</p>
<p>and presumably getting updated or modified,</p>
<p>而且可能被改过了</p>
<p>other programmers leave it alone.</p>
<p>其他开发者不会动这段代码</p>
<p>This prevents weird conflicts and duplicated work.</p>
<p>防止代码冲突和重复劳动</p>
<p>In this way, hundreds of programmers can be simultaneously checking in and out pieces of code,</p>
<p>这样多名程序员可以同时写代码，</p>
<p>iteratively building up huge systems.</p>
<p>建立庞大的系统</p>
<p>Critically, you don't want someone committing buggy code,</p>
<p>重要的是，你不希望提交的代码里有问题，</p>
<p>because other people and teams may rely on it.</p>
<p>因为其他人可能用到了这些代码</p>
<p>Their code could crash, creating confusion and lost time.</p>
<p>导致他们的代码崩溃，造成困惑而且浪费时间</p>
<p>The master version of the code, stored on the server,</p>
<p>代码的主版本 (master)</p>
<p>should always compile without errors and run with minimal bugs.</p>
<p>应该总是编译正常，尽可能少 bug</p>
<p>But sometimes bugs creep in.</p>
<p>但有时 bug 还是会出现</p>
<p>Fortunately, source control software keeps track of all changes,</p>
<p>幸运的是，源代码管理可以跟踪所有变化</p>
<p>and if a bug is found,</p>
<p>如果发现 bug</p>
<p>the whole code, or just a piece,</p>
<p>全部或部分代码，</p>
<p>can be rolled back to an earlier, stable version.</p>
<p>可以"回滚"到之前的稳定版</p>
<p>It also keeps track of who made each change,</p>
<p>"源代码管理" 也记录了谁改了什么代码</p>
<p>so coworkers can send nasty,</p>
<p>所以同事可以给你发讨厌的</p>
<p>I mean, helpful</p>
<p>我是说"有帮助的" </p>
<p>and encouraging emails to the offending person.</p>
<p>邮件给写代码的人</p>
<p>Debugging goes hand in hand with writing code,</p>
<p>写代码和测代码密不可分</p>
<p>and it's most often done by an individual or small team.</p>
<p>测试一般由个人或小团队完成</p>
<p>The big picture version of debugging is Quality Assurance testing, or QA.</p>
<p>测试可以统称 "质量保证测试"，简称 QA</p>
<p>This is where a team rigorously tests out a piece of software,</p>
<p>严格测试软件的方方面面</p>
<p>attempting to create unforeseen conditions that might trip it up.</p>
<p>模拟各种可能情况，看软件会不会出错</p>
<p>Basically, they elicit bugs.</p>
<p>基本上就是找 bug</p>
<p>Getting all the wrinkles out is a huge effort,</p>
<p>解决大大小小的错误需要很多工作</p>
<p>but vital in making sure the software works</p>
<p>但对确保软件质量至关重要</p>
<p>as intended for as many users in as many situations as imaginable before it ships.</p>
<p>让软件在各种情况下按预期运行</p>
<p>You've probably heard of beta software.</p>
<p>你可能听过 "beta 版" 软件</p>
<p>This is a version of software that's mostly complete,</p>
<p>意思是软件接近完成</p>
<p>but not 100% fully tested.</p>
<p>但不是 100％ 完全测试过</p>
<p>Companies will sometimes release beta versions to the public to help them identify issues,</p>
<p>公司有时会向公众发布 beta 版，以帮助发现问题</p>
<p>it's essentially like getting a free QA team.</p>
<p>用户就像免费的 QA 团队</p>
<p>What you don't hear about as much</p>
<p>你听过比较少的是，beta 版之前的版本：</p>
<p>is the version that comes before the beta: the alpha version.</p>
<p>alpha 版本</p>
<p>This is usually so rough and buggy, it's only tested internally.</p>
<p>alpha 版一般很粗糙，错误很多，经常只在公司内部测试</p>
<p>So, that's the tip of the iceberg in terms of the tools, tricks and techniques</p>
<p>以上只是软件工程师用的工具和技巧的冰山一角</p>
<p>that allow software engineers to construct the huge pieces of software that we know and love today,</p>
<p>它们帮助软件工程师制作令人喜爱的软件</p>
<p>like YouTube, Grand Theft Auto 5, and Powerpoint.</p>
<p>如 YouTube，GTA5 和 PPT 等等</p>
<p>As you might expect,</p>
<p>如你所料</p>
<p>all those millions of lines of code needs some serious processing power to run at useful speeds,</p>
<p>这些代码要强大的处理能力才能高速速度运行</p>
<p>so next episode we'll be talking about how computers got so incredibly fast.</p>
<p>所以下集讨论，计算机怎么发展到如今这么快</p>
<p>See you then.</p>
<p>到时见</p>
<p>This episode is brought to you by Curiosity Stream.</p>
<p>本集由 Curiosity Stream 赞助播出</p>
<p>17 集成电路&摩尔定律</p>
<p>Integrated Circuits & Moore’s Law</p>
<p>Hi, I’m Carrie Anne, and welcome to CrashCourse Computer Science!</p>
<p>嗨，我是 Carrie Anne ，欢迎收看计算机科学速成课！</p>
<p>Over the past six episodes, we delved into software,</p>
<p>过去 6 集我们聊了软件，</p>
<p>from early programming efforts to modern software engineering practices.</p>
<p>从早期编程方式到现代软件工程</p>
<p>Within about 50 years, software grew in complexity from machine code punched by hand onto paper tape</p>
<p>在大概50年里软件从纸带打孔，变成面向对象编程语言</p>
<p>to object oriented programming languages, compiled in integrated development environments.</p>
<p>在集成开发环境中写程序</p>
<p>But this growth in sophistication would not have been possible without improvements in hardware.</p>
<p>但如果没有硬件的大幅度进步，软件是不可能做到这些的</p>
<p>To appreciate computing hardware’s explosive growth in power and sophistication,</p>
<p>为了体会硬件性能的爆炸性增长，</p>
<p>we need to go back to the birth of electronic computing.</p>
<p>我们要回到电子计算机的诞生年代</p>
<p>From roughly the 1940’s through the mid-1960s, every computer was built from individual parts,</p>
<p>大约 1940年代~1960年代中期这段时间里，计算机都由独立部件组成</p>
<p>called discrete components, which were all wired together.</p>
<p>叫"分立元件"，然后不同组件再用线连在一起</p>
<p>For example, the ENIAC, consisted of more than 17,000 vacuum tubes, 70,000 resistors,</p>
<p>举例, ENIAC 有1万7千多个真空管, 7万个电阻</p>
<p>10,000 capacitors, and 7,000 diodes, all of which required 5 million hand-soldered connections.</p>
<p>1万个电容器, 7千个二极管, 5百万个手工焊点</p>
<p>Adding more components to increase performance meant more connections, more wires</p>
<p>如果想提升性能，就要加更多部件，这导致更多电线，更复杂</p>
<p>and just more complexity, what was dubbed the Tyranny of Numbers.</p>
<p>这个问题叫 "数字暴政''</p>
<p>By the mid 1950s, transistors were becoming commercially available</p>
<p>1950 年代中期，晶体管开始商业化（市场上买得到），</p>
<p>and being incorporated into computers.</p>
<p>开始用在计算机里</p>
<p>These were much smaller, faster and more reliable than vacuum tubes</p>
<p>晶体管比电子管更小更快更可靠</p>
<p>but each transistor was still one discrete component.</p>
<p>但晶体管依然是分立元件</p>
<p>In 1959, IBM upgraded their vacuum-tube-based "709" computers to transistors by replacing</p>
<p>1959年，IBM 把 709 计算机从原本的电子管，</p>
<p>by replacing all the discrete vacuum tubes with discrete transistors.</p>
<p>全部换成晶体管</p>
<p>The new machine, the IBM 7090, was six times faster and half the cost.</p>
<p>诞生的新机器 IBM 7090 ，速度快 6 倍，价格只有一半</p>
<p>These transistorized computers marked the second generation of electronic computing.</p>
<p>晶体管标志着"计算 2.0 时代"的到来</p>
<p>However, although faster and smaller,</p>
<p>虽然更快更小，但晶体管的出现 </p>
<p>discrete transistors didn’t solve the Tyranny of Numbers.</p>
<p>还是没有解决"数字暴政"的问题</p>
<p>It was getting unwieldy to design,</p>
<p>有几十万个独立元件的计算机不但难设计，</p>
<p>let alone physically manufacture computers with hundreds of thousands of individual components.</p>
<p>而且难生产</p>
<p>By the the 1960s, this was reaching a breaking point.</p>
<p>1960 年代，这个问题的严重性达到顶点，</p>
<p>The insides of computers were often just huge tangles of wires.</p>
<p>电脑内部常常一大堆电线缠绕在一起</p>
<p>Just look at what the inside of a PDP-8 from 1965 looked like!</p>
<p>看看这个 1965 年 PDP-8 计算机的内部</p>
<p>The answer was to bump up a new level of abstraction, and package up underlying complexity!</p>
<p>解决办法是引入一层新抽象，封装复杂性</p>
<p>The breakthrough came in 1958, when Jack Kilby, working at Texas Instruments,</p>
<p>突破性进展在 1958 年，当时 Jack Killby 在德州仪器工作</p>
<p>demonstrated such an electronic part, "wherein all the components of the electronic circuit are completely integrated.</p>
<p>演示了一个电子部件："电路的所有组件都集成在一起"</p>
<p>Put simply: instead of building computer parts out of many discrete components</p>
<p>简单说就是：与其把多个独立部件用电线连起来，</p>
<p>and wiring them all together,</p>
<p>拼装出计算机</p>
<p>you put many components together, inside of a new, single component.</p>
<p>我们把多个组件包在一起，变成一个新的独立组件</p>
<p>These are called Integrated Circuits, or ICs.</p>
<p>这就是集成电路（IC）</p>
<p>A few months later in 1959, Fairchild Semiconductor, lead by Robert Noyce, made ICs practical.</p>
<p>几个月后，在1959年 Robert Noyce 的仙童半导体，让集成电路变为现实</p>
<p>Kilby built his ICs out of germanium, a rare and unstable material.</p>
<p>Kilby 用锗来做集成电路，锗很稀少而且不稳定</p>
<p>But, Fairchild used the abundant silicon, which makes up about a quarter of the earth's crust!</p>
<p>仙童半导体公司用硅，硅的蕴藏量丰富，占地壳四分之一</p>
<p>It’s also more stable, therefore more reliable.</p>
<p>也更稳定可靠</p>
<p>For this reason, Noyce is widely regarded as the father of modern ICs,</p>
<p>所以 Noyce 被公认为现代集成电路之父</p>
<p>ushering in the electronics era... and also Silicon Valley, where Fairchild was based</p>
<p>开创了电子时代，创造了硅谷（仙童公司所在地）</p>
<p>and where many other semiconductor companies would soon pop up.</p>
<p>之后有很多半导体企业都出现在硅谷</p>
<p>In the early days, an IC might only contain a simple circuit with just a few transistors,</p>
<p>起初，一个 IC 只有几个晶体管，</p>
<p>like this early Westinghouse example.</p>
<p>例如这块早期样品，由西屋公司制造</p>
<p>But even this allowed simple circuits, like the logic gates from Episode 3,</p>
<p>即使只有几个晶体管，也可以把简单电路，第 3 集的逻辑门，</p>
<p>to be packaged up into a single component.</p>
<p>能封装成单独组件</p>
<p>ICs are sort of like lego for computer engineers</p>
<p>IC 就像电脑工程师的乐高积木，</p>
<p>"building blocks" that can be arranged into an infinite array of possible designs.</p>
<p>可以组合出无数种设计</p>
<p>However, they still have to be wired together at some point</p>
<p>但最终还是需要连起来，</p>
<p>to create even bigger and more complex circuits, like a whole computer.</p>
<p>创造更大更复杂的电路，比如整个计算机</p>
<p>For this, engineers had another innovation: printed circuit boards, or PCB</p>
<p>所以工程师们再度创新：印刷电路板，简称 PCB</p>
<p>Instead of soldering and bundling up bazillions of wires, PCBs, which could be mass manufactured,</p>
<p>PCB 可以大规模生产，无需焊接或用一大堆线.</p>
<p>have all the metal wires etched right into them to connect components together.</p>
<p>它通过蚀刻金属线的方式，把零件连接到一起</p>
<p>By using PCBs and ICs together, one could achieve exactly the same functional circuit</p>
<p>把 PCB 和 IC 结合使用，</p>
<p>as that made from discrete components,</p>
<p>可以大幅减少独立组件和电线，</p>
<p>but with far fewer individual components and tangled wires.</p>
<p>但做到相同的功能</p>
<p>Plus, it’s smaller, cheaper and more reliable.</p>
<p>而且更小，更便宜，更可靠. </p>
<p>Triple win!</p>
<p>三赢！</p>
<p>Many early ICs were manufactured using teeny tiny discrete components</p>
<p>许多早期 IC 都是把很小的分立元件，</p>
<p>packaged up as a single unit, like this IBM example from 1964.</p>
<p>封装成一个独立单元，例如这块 1964 年的IBM样品</p>
<p>However, even when using really really itty-bitty components,</p>
<p>不过，即使组件很小，</p>
<p>it was hard to get much more than around five transistors onto a single IC.</p>
<p>塞5个以上的晶体管还是很困难</p>
<p>To achieve more complex designs, a radically different fabrication process was needed that</p>
<p>为了实现更复杂的设计，需要全新的制作工艺，</p>
<p>changed everything: Photolithography!</p>
<p>"光刻"登场！</p>
<p>In short, it’s a way to use light to transfer complex patterns to a material, like a semiconductor</p>
<p>简单说就是，用光把复杂图案印到材料上，比如半导体</p>
<p>It only has a few basic operations, but these can be used to create incredibly complex circuits.</p>
<p>它只有几个基础操作，但可以制作出复杂电路</p>
<p>Let’s walk through a simple, although extensive example, to make one of these!</p>
<p>下面用一个简单例子，来做一片这个！</p>
<p>We start with a slice of silicon, which, like a thin cookie, is called a wafer.</p>
<p>我们从一片硅开始，叫"晶圆"，长得像薄饼干一样</p>
<p>Delicious!</p>
<p>美味！</p>
<p>Silicon, as we discussed briefly in episode 2, is special because it’s a semiconductor,</p>
<p>我们在第 2 集讨论过，硅很特别，它是半导体</p>
<p>that is, a material that can sometimes conduct electricity and other times does not.</p>
<p>它有时导电，有时不导电，</p>
<p>We can control where and when this happens,</p>
<p>我们可以控制导电时机</p>
<p>making Silicon the perfect raw material for making transistors.</p>
<p>所以硅是做晶体管的绝佳材料</p>
<p>We can also use a wafer as a base to lay down complex metal circuits, so everything is integrated,</p>
<p>我们可以用晶圆做基础，把复杂金属电路放上面，集成所有东西</p>
<p>perfect for... integrated circuits!</p>
<p>非常适合做...集成电路!</p>
<p>The next step is to add a thin oxide layer on top of the silicon,</p>
<p>下一步是在硅片顶部，加一层薄薄的氧化层, </p>
<p>which acts as a protective coating.</p>
<p>作为保护层</p>
<p>Then, we apply a special chemical called a photoresist.</p>
<p>然后加一层特殊化学品, 叫 "光刻胶"，</p>
<p>When exposed to light, the chemical changes, and becomes soluble,</p>
<p>光刻胶被光照射后会变得可溶</p>
<p>so it can be washed away with a different special chemical.</p>
<p>可以用一种特殊化学药剂洗掉</p>
<p>Photoresists aren’t very useful by themselves,</p>
<p>单单光刻胶本身，并不是很有用，</p>
<p>but are super powerful when used in conjunction with a photomask.</p>
<p>但和"光掩膜"配合使用会很强大</p>
<p>This is just like a piece of photographic film, but instead of a photo of</p>
<p>光掩膜就像胶片一样，只不过不是，</p>
<p>a hamster eating a tiny burrito, it contains a pattern to be transferred onto the wafer.</p>
<p>吃墨西哥卷饼的可爱仓鼠，而是要转移到晶圆上的图案</p>
<p>We do this by putting a photomask over the wafer, and turning on a powerful light.</p>
<p>把光掩膜盖到晶圆上，用强光照射，</p>
<p>Where the mask blocks the light, the photoresist is unchanged.</p>
<p>挡住光的地方，光刻胶不会变化</p>
<p>But where the light does hit the photoresist it changes chemically ，</p>
<p>光照到的地方，光刻胶会发生化学变化，</p>
<p>which lets us wash away only the photoresist that was exposed to light, selectively revealing areas of our oxide layer.</p>
<p>洗掉它之后，暴露出氧化层</p>
<p>Now, by using another special chemical, often an acid, we can remove any exposed oxide,</p>
<p>用另一种化学物质通常是一种酸，</p>
<p>and etch a little hole the entire way down to the raw silicon.</p>
<p>可以洗掉"氧化层"露出的部分, 蚀刻到硅层</p>
<p>Note that the oxide layer under the photoresist is protected.</p>
<p>注意，氧化层被光刻胶保护住了.</p>
<p>To clean up, we use yet another special chemical that washes away any remaining photoresist.</p>
<p>为了清理光刻胶，我们用另一种化学药品洗掉它</p>
<p>Yep, there are a lot of special chemicals in photolithography,</p>
<p>是的，光刻法用很多化学品，</p>
<p>each with a very specific function!</p>
<p>每种都有特定用途</p>
<p>So now we can see the silicon again,</p>
<p>现在硅又露出来了，</p>
<p>we want to modify only the exposed areas to better conduct electricity.</p>
<p>我们想修改硅露出来的区域让它导电性更好</p>
<p>To do that, we need to change it chemically through a process called: doping.</p>
<p>所以用一种化学过程来改变它，叫"掺杂"</p>
<p>I’m not even going to make a joke. Let’s move on.</p>
<p>不是开玩笑！我们继续</p>
<p>Most often this is done with a high temperature gas, something like Phosphorus,</p>
<p>"掺杂" 通常用高温气体来做，比如磷，渗透进暴露出的硅，</p>
<p>which penetrates into the exposed area of silicon.</p>
<p>改变电学性质</p>
<p>This alters its electrical properties.</p>
<p>"掺杂" 通常用高温气体来做，比如磷，渗透进暴露出的硅，改变电学性质</p>
<p>We’re not going to wade into the physics and chemistry of semiconductors,</p>
<p>半导体的具体物理和化学性质我们不会深究,</p>
<p>but if you’re interested, there’s a link in the description to an excellent video</p>
<p>如果你感兴趣，描述里有个视频链接，视频制作者是 Derek Muller </p>
<p>by our friend Derek Muller from Veritasium.</p>
<p>他的频道叫 Veritasium</p>
<p>But, we still need a few more rounds of photolithography to build a transistor.</p>
<p>但我们还需要几轮光刻法来做晶体管</p>
<p>The process essentially starts again, first by building up a fresh oxide layer ...</p>
<p>过程基本一样，先盖氧化层，</p>
<p>which we coat in photoresist.</p>
<p>再盖光刻胶</p>
<p>Now, we use a photomask with a new and different pattern,</p>
<p>然后用新的光掩膜，这次图案不同，</p>
<p>allowing us to open a small window above the doped area.</p>
<p>在掺杂区域上方开一个缺口</p>
<p>Once again, we wash away remaining photoresist.</p>
<p>洗掉光刻胶</p>
<p>Now we dope, and avoid telling a hilarious joke, again, but with a different gas that</p>
<p>然后用另一种气体掺杂，</p>
<p>converts part of the silicon into yet a different form.</p>
<p>把一部分硅转成另一种形式</p>
<p>Timing is super important in photolithography in order to control things like doping diffusionand etch depth.</p>
<p>为了控制深度，时机很重要，</p>
<p>In this case, we only want to dope a little region nested inside the other.</p>
<p>我们不想超过之前的区域</p>
<p>Now we have all the pieces we need to create our transistor!</p>
<p>现在所有需要的组件都有了</p>
<p>The final step is to make channels in the oxide layer</p>
<p>最后一步，在氧化层上做通道，</p>
<p>so that we can run little metal wires to different parts of our transistor.</p>
<p>这样可以用细小金属导线，连接不同晶体管</p>
<p>Once more, we apply a photoresist, and use a new photomask to etch little channels.</p>
<p>再次用光刻胶和光掩膜蚀刻出小通道</p>
<p>Now, we use a new process, called metalization,</p>
<p>现在用新的处理方法叫"金属化"，</p>
<p>that allows us to deposit a thin layer of metal, like aluminium or copper.</p>
<p>放一层薄薄的金属，比如铝或铜</p>
<p>But we don’t want to cover everything in metal.</p>
<p>但我们不想用金属盖住所有东西，</p>
<p>We want to etch a very specific circuit design.</p>
<p>我们想蚀刻出具体的电路</p>
<p>So, very similar to before, we apply a photoresist, use a photomask, dissolve the exposed resist,</p>
<p>所以又是类似的步骤，用光刻胶+光掩膜，</p>
<p>and use a chemical to remove any exposed metal.</p>
<p>然后溶掉暴露的光刻胶，暴露的金属</p>
<p>Whew!</p>
<p>咻~</p>
<p>Our transistor is finally complete!</p>
<p>晶体管终于做好了！</p>
<p>It has three little wires that connect to three different parts of the silicon</p>
<p>它有三根线，连接着硅的三个不同区域</p>
<p>each doped a particular way to create, in this example, what’s called a bipolar junction transistor.</p>
<p>每个区域的掺杂方式不同，这叫双极型晶体管</p>
<p>Here’s the actual patent from 1962, an invention that changed our world forever!</p>
<p>这个 1962 年的真实专利，永远改变了世界</p>
<p>Using similar steps, photolithography can create other useful electronic elements, like</p>
<p>用类似步骤，光刻可以制作其他电子元件，</p>
<p>resistors and capacitors, all on a single piece of silicon</p>
<p>比如电阻和电容，都在一片硅上</p>
<p>plus all the wires needed to hook them up into circuits</p>
<p>而且互相连接的电路也做好了</p>
<p>Goodbye discrete components!</p>
<p>再见了，分立元件！</p>
<p>In our example, we made one transistor, but in the real world,</p>
<p>之前的例子只做了一个晶体管，但现实中，</p>
<p>photomasks lay down millions of little details all at once.</p>
<p>光刻法一次会做上百万个细节</p>
<p>Here is what an IC might look like from above, with wires crisscrossing above and below each other,</p>
<p>芯片放大是这样的，导线上下交错，</p>
<p>interconnecting all the individual elements together into complex circuits.</p>
<p>连接各个元件</p>
<p>Although we could create a photomask for an entire wafer,</p>
<p>尽管可以把光掩膜投影到一整片晶圆上，</p>
<p>we can take advantage of the fact that light can be focused and projected to any size we want.</p>
<p>但光可以投射成任意大小</p>
<p>In the same way that a film can be projected to fill an entire movie screen,</p>
<p>就像投影仪可以投满荧幕一样</p>
<p>we can focus a photomask onto a very small patch of silicon, creating incredibly fine details.</p>
<p>我们可以把光掩膜，聚焦到极小的区域，制作出非常精细的细节</p>
<p>A single silicon wafer is generally used to create dozens of ICs.</p>
<p>一片晶圆可以做很多 IC，整块都做完后，</p>
<p>Then, once you’ve got a whole wafer full, you cut them up and package them into microchips,</p>
<p>可以切割然后包进微型芯片</p>
<p>those little black rectangles you see in electronics all the time.</p>
<p>微型芯片就是在电子设备中那些小长方体</p>
<p>Just remember: at the heart of each of those chips is one of these small pieces of silicon.</p>
<p>记住，芯片的核心都是一小片 IC</p>
<p>As photolithography techniques improved, the size of transistors shrunk, allowing for greater densities.</p>
<p>随着光刻技术发展，晶体管变小密度变高</p>
<p>At the start of the 1960s, an IC rarely contained more than 5 transistors,</p>
<p>1960 年代初，IC 很少超过 5 个晶体管，</p>
<p>they just couldn’t possibly fit.</p>
<p>因为塞不下</p>
<p>But, by the mid 1960s, we were starting to see ICs with over 100 transistors on the market.</p>
<p>但 1960 年代中期，市场上开始出现超过 100 个晶体管的 IC</p>
<p>In 1965, Gordon Moore could see the trend: that approximately every two years,</p>
<p>1965年，戈登·摩尔看到了趋势：每两年左右，</p>
<p>thanks to advances in materials and manufacturing, you could fit twice the number of transistors</p>
<p>得益于材料和制造技术的发展，同样大小的空间，</p>
<p>into the same amount of space.</p>
<p>能塞进两倍数量的晶体管！</p>
<p>This is called Moore’s Law.</p>
<p>这叫摩尔定律</p>
<p>The term is a bit of a misnomer though.</p>
<p>然而这个名字不太对，</p>
<p>It’s not really a law at all, more of a trend.</p>
<p>因为它不是定律，只是一种趋势</p>
<p>But it’s a good one.</p>
<p>但它是对的</p>
<p>IC prices also fell dramatically, from an average of $50 in 1962 to around $2 in 1968.</p>
<p>芯片的价格也急剧下降，1962年平均50美元，下降到1968年2美元左右</p>
<p>Today, you can buy ICs for cents.</p>
<p>如今几美分就能买到 IC</p>
<p>Smaller transistors and higher densities had other benefits too.</p>
<p>晶体管更小密度更高还有其他好处</p>
<p>The smaller the transistor, the less charge you have to move around, allowing it to switch</p>
<p>晶体管越小，要移动的电荷量就越少，</p>
<p>states faster and consume less power.</p>
<p>能更快切换状态耗电更少</p>
<p>Plus, more compact circuits meant less delay in signals resulting in faster clock speeds.</p>
<p>电路更紧凑还意味着信号延迟更低，导致时钟速度更快</p>
<p>In 1968, Robert Noyce and Gordon Moore teamed up and founded a new company,</p>
<p>1968年，罗伯特·诺伊斯和 戈登·摩尔，联手成立了一家新公司</p>
<p>combining the words Integrated and Electronics...</p>
<p>结合 Intergrated(集成) 和 Electronics(电子) 两个词</p>
<p>Intel. the largest chip maker today.</p>
<p>取名 Intel，如今最大的芯片制造商</p>
<p>The Intel 4004 CPU, from Episodes 7 and 8, was a major milestone.</p>
<p>Intel 4004 CPU, 在第 7、8 集介绍过，是个重要里程碑</p>
<p>Released in 1971, it was the first processor that shipped as an IC, what’s called a microprocessor,</p>
<p>发布于1971年，是第一个用 IC 做的处理器，也叫微型处理器</p>
<p>because it was so beautifully small!</p>
<p>因为真的非常小！</p>
<p>It contained 2,300 transistors.</p>
<p>它有2300个晶体管</p>
<p>People marveled at the level of integration, an entire CPU in one chip,</p>
<p>人们惊叹于它的整合水平，整个 CPU 在一个芯片里</p>
<p>which just two decades earlier would have filled an entire room using discrete components.</p>
<p>而仅仅 20 年前，用分立元件会占满整个屋子</p>
<p>This era of integrated circuits, especially microprocessors, ushered in the third generation of computing.</p>
<p>集成电路的出现，尤其是用来做微处理器，开启了计算 3.0</p>
<p>And the Intel 4004 was just the start.</p>
<p>而 Intel 4004 只是个开始，</p>
<p>CPU transistor count exploded!</p>
<p>CPU 晶体管数量爆发增长</p>
<p>By 1980, CPUs contained 30 thousand transistors.</p>
<p>1980年，3 万晶体管，</p>
<p>By 1990, CPUs breached the 1 million transistor count.</p>
<p>1990年，100 万晶体管</p>
<p>By 2000, 30 million transistors,</p>
<p>2000年，3000 万个晶体管</p>
<p>and by 2010, ONE. BILLION. TRANSISTORS. IN ONE. IC. OMG!</p>
<p>2010年，10亿个晶体管！在一个芯片里！我的天啊！</p>
<p>To achieve this density, the finest resolution possible with photolithography has improved</p>
<p>为了达到这种密度，光刻的分辨率</p>
<p>from roughly 10 thousand nanometers, that’s about 1/10th the thickness of a human hair,</p>
<p>从大约一万纳米，大概是人类头发直径的 1/10</p>
<p>to around 14 nanometers today.</p>
<p>发展到如今的 14 纳米，</p>
<p>That’s over 400 times smaller than a red blood cell!</p>
<p>比血红细胞小 400 倍！</p>
<p>And of course, CPU’s weren’t the only components to benefit.</p>
<p>当然，CPU 不是唯一受益的元件</p>
<p>Most electronics advanced essentially exponentially:</p>
<p>大多数电子器件都在指数式发展：</p>
<p>RAM, graphics cards, solid state hard drives, camera sensors, you name it.</p>
<p>内存，显卡，固态硬盘，摄像头感光元件，等等</p>
<p>Today’s processors, like the A10 CPU inside Of an iPhone 7, contains a mind melting 3.3 BILLION</p>
<p>如今的处理器，比如 iPhone 7 的 A10 CPU，有33亿个晶体管</p>
<p>transistors in an IC roughly 1cm by 1cm.</p>
<p>面积仅有 1cm x 1cm，</p>
<p>That’s smaller than a postage stamp!</p>
<p>比一张邮票还小</p>
<p>And modern engineers aren’t laying out these designs by hand, one transistor at a time</p>
<p>现代工程师设计电路时，当然不是手工一个个设计晶体管，</p>
<p>it’s not humanly possible.</p>
<p>这不是人力能做到的</p>
<p>Starting in the 1970’s, very-large-scale integration, or VLSI software, has been used</p>
<p>1970年代开始，超大规模集成(VLSI)软件，</p>
<p>to automatically generate chip designs instead.</p>
<p>用来自动生成芯片设计</p>
<p>Using techniques like logic synthesis, where whole, high-level components can be laid down,like a memory cache</p>
<p>用比如 "逻辑综合" 这种技术，可以放一整个高级组件，比如内存缓存</p>
<p>the software generates the circuit in the most efficient way possible.</p>
<p>软件会自动生成电路，做到尽可能高效</p>
<p>Many consider this to be the start of fourth generation computers.</p>
<p>许多人认为这是计算 4.0 的开始</p>
<p>Unfortunately, experts have been predicting the end of Moore’s Law for decades</p>
<p>坏消息是，专家们几十年来，一直在预言摩尔定律的终结</p>
<p>and we might finally be getting close to it.</p>
<p>现在可能终于接近了</p>
<p>There are two significant issues holding us back from further miniaturization.</p>
<p>进一步做小，会面临 2 个大问题</p>
<p>First, we’re bumping into limits on how fine we can make features on a photomask and</p>
<p>1 用光掩膜把图案弄到晶圆上，</p>
<p>it’s resultant wafer due to the wavelengths of light used in photolithography.</p>
<p>因为光的波长，精度已达极限</p>
<p>In response, scientists have been developing light sources with smaller and smaller wavelengths</p>
<p>所以科学家在研制波长更短的光源，</p>
<p>that can project smaller and smaller features.</p>
<p>投射更小的形状</p>
<p>The second issue is that when transistors get really really small, where electrodes</p>
<p>2 当晶体管非常小，电极之间可能只距离几个原子，</p>
<p>might be separated by only a few dozen atoms, electrons can jump the gap, a phenomenon called</p>
<p>电子会跳过间隙，这叫：</p>
<p>quantum tunneling.</p>
<p>量子隧穿效应</p>
<p>If transistors leak current, they don’t make very good switches.</p>
<p>如果晶体管漏电，就不是好开关</p>
<p>Nonetheless, scientists and engineers are hard at work figuring out ways around these problems.</p>
<p>科学家和工程师在努力找解决方法</p>
<p>Transistors as small as 1 nanometer have been demonstrated in research labs.</p>
<p>实验室中已造出小至1纳米的晶体管</p>
<p>Whether this will ever be commercially feasible remains MASKED in mystery.</p>
<p>能不能商业量产依然未知，</p>
<p>But maybe we’ll be able to RESOLVE it in the future.</p>
<p>未来也许能解决</p>
<p>I’m DIEING to know. See you next week.</p>
<p>我非常期待！下周见！</p>
<p>This episode is supported by Hover.</p>
<p>本集由 Hover 赞助播出</p>
<p>18 操作系统</p>
<p>Operating Systems</p>
<p>Hi, I'm Carrie Anne, and welcome to Crash Course Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>Computers in the 1940s and early 50s ran one program at a time.</p>
<p>1940,1950 年代的电脑，每次只能运行一个程序</p>
<p>A programmer would write one at their desk, for example, on punch cards.</p>
<p>程序员在打孔纸卡上写程序</p>
<p>Then, they'd carry it to a room containing a room-sized computer,</p>
<p>然后拿到一个计算机房间, </p>
<p>and hand it to a dedicated computer operator.</p>
<p>交给操作员</p>
<p>That person would then feed the program into the computer when it was next available.</p>
<p>等计算机空下来了，操作员会把程序放入</p>
<p>The computer would run it, spit out some output, and halt.</p>
<p>然后运行，输出结果，停机</p>
<p>This very manual process worked OK back when computers were slow,</p>
<p>以前计算机慢，这种手动做法可以接受</p>
<p>and running a program often took hours, days or even weeks.</p>
<p>运行一个程序通常要几小时，几天甚至几周</p>
<p>But, as we discussed last episode,</p>
<p>但上集说过，</p>
<p>computers became faster... and faster... and faster</p>
<p>计算机越来越快，越来越快</p>
<p>exponentially so!</p>
<p>指数级增长！</p>
<p>Pretty soon, having humans run around and inserting programs into readers</p>
<p>很快，放程序的时间 </p>
<p>was taking longer than running the actual programs themselves.</p>
<p>比程序运行时间还长</p>
<p>We needed a way for computers to operate themselves,</p>
<p>我们需要一种方式让计算机自动运作</p>
<p>and so, operating systems were born.</p>
<p>于是"操作系统"诞生了</p>
<p>Operating systems , or OS for short, are just programs.</p>
<p>操作系统，简称 OS，其实也是程序</p>
<p>But, special privileges on the hardware let them run and manage other programs.</p>
<p>但它有操作硬件的特殊权限，可以运行和管理其它程序</p>
<p>They're typically the first one to start when a computer is turned on,</p>
<p>操作系统一般是开机第一个启动的程序</p>
<p>and all subsequent programs are launched by the OS.</p>
<p>其他所有程序都由操作系统启动</p>
<p>They got their start in the 1950s,</p>
<p>操作系统开始于 1950 年代，</p>
<p>as computers became more widespread and more powerful.</p>
<p>那时计算机开始变得更强大更流行</p>
<p>The very first OS augmented the mundane, manual task of loading programs by hand.</p>
<p>第一个操作系统加强了程序加载方式</p>
<p>Instead of being given one program at a time,</p>
<p>之前只能一次给一个程序，现在可以一次多个</p>
<p>computers could be given batches.</p>
<p>之前只能一次给一个程序，现在可以一次多个</p>
<p>When the computer was done with one,</p>
<p>当计算机运行完一个程序，</p>
<p>it would automatically and near-instantly start the next.</p>
<p>会自动运行下一个程序</p>
<p>There was no downtime while someone scurried around an office to find the next program to run.</p>
<p>这样就不会浪费时间，找下一个程序的纸卡</p>
<p>This was called batch processing .</p>
<p>这叫批处理</p>
<p>While computers got faster, they also got cheaper.</p>
<p>电脑变得更快更便宜，</p>
<p>So, they were popping up all over the world,</p>
<p>开始在出现在世界各地</p>
<p>especially in universities and government offices.</p>
<p>特别是大学和政府办公室</p>
<p>Soon, people started sharing software.</p>
<p>很快，人们开始分享软件，</p>
<p>But there was a problem</p>
<p>但有一个问题</p>
<p>In the era of one-off computers, like the Harvard Mark 1 or ENIAC,</p>
<p>在哈佛1号和 ENIAC 那个时代，计算都是一次性的</p>
<p>programmers only had to write code for that one single machine.</p>
<p>程序员只需要给那"一台"机器写代码</p>
<p>The processor, punch card readers, and printers were known and unchanging.</p>
<p>处理器，读卡器，打印机都是已知的</p>
<p>But as computers became more widespread,</p>
<p>但随着电脑越来越普遍，</p>
<p>their configurations were not always identical,</p>
<p>计算机配置并不总是相同的</p>
<p>like computers might have the same CPU, but not the same printer.</p>
<p>比如计算机可能有相同 CPU，但不同的打印机</p>
<p>This was a huge pain for programmers.</p>
<p>这对程序员很痛苦</p>
<p>Not only did they have to worry about writing their program,</p>
<p>不仅要担心写程序，</p>
<p>but also how to interface with each and every model of printer,</p>
<p>还要担心程序怎么和不同型号打印机交互</p>
<p>and all devices connected to a computer, what are called peripherals.</p>
<p>以及计算机连着的其他设备，这些统称"外部设备"</p>
<p>Interfacing with early peripherals was very low level,</p>
<p>和早期的外部设备交互，是非常底层的</p>
<p>requiring programmers to know intimate hardware details about each device.</p>
<p>程序员要了解设备的硬件细节</p>
<p>On top of that, programmers rarely had access to every model of a peripheral to test their code on.</p>
<p>加重问题的是，程序员很少能拿到所有型号的设备来测代码</p>
<p>So, they had to write code as best they could, often just by reading manuals,</p>
<p>所以一般是阅读手册来写代码，</p>
<p>and hope it worked when shared.</p>
<p>祈祷能正常运行</p>
<p>Things weren't exactly plug-and-play</p>
<p>现在是"即插即用"，</p>
<p>back then more plug-and-pray.</p>
<p>以前是"祈祷能用"</p>
<p>This was clearly terrible,</p>
<p>这很糟糕，</p>
<p>so to make it easier for programmers,</p>
<p>所以为了程序员写软件更容易</p>
<p>Operating Systems stepped in as intermediaries between software programs and hardware peripherals.</p>
<p>操作系统充当软件和硬件之间的媒介</p>
<p>More specifically, they provided a software abstraction, through APIs,</p>
<p>更具体地说，操作系统提供 API 来抽象硬件，</p>
<p>called device drivers .</p>
<p>叫"设备驱动程序"</p>
<p>These allow programmers to talk to common input and output hardware,</p>
<p>程序员可以用标准化机制</p>
<p>or I/O for short, using standardized mechanisms.</p>
<p>和输入输出硬件（I/O）交互</p>
<p>For example, programmers could call a function like "print highscore",</p>
<p>比如，程序员只需调用 print(highscore)</p>
<p>and the OS would do the heavy lifting to get it onto paper.</p>
<p>操作系统会处理输到纸上的具体细节</p>
<p>By the end of the 1950s, computers had gotten so fast,</p>
<p>到 1950 年代尾声，电脑已经非常快了</p>
<p>they were often idle waiting for slow mechanical things, like printers and punch card readers.</p>
<p>处理器经常闲着，等待慢的机械设备（比如打印机和读卡器）</p>
<p>While programs were blocked on I/O,</p>
<p>程序阻塞在 I/O 上</p>
<p>the expensive processor was just chillin'... not like a villain</p>
<p>而昂贵的处理器则在度假，就是放松啥也不做</p>
<p>you know, just relaxing.</p>
<p>而昂贵的处理器则在度假，就是放松啥也不做</p>
<p>In the late 50's, the University of Manchester, in the UK,</p>
<p>50年代后期，英国曼彻斯特大学，</p>
<p>started work on a supercomputer called Atlas, one of the first in the world.</p>
<p>开始研发世界上第一台超级计算机，Atlas</p>
<p>They knew it was going to be wicked fast,</p>
<p>他们知道机器会超级快，</p>
<p>so they needed a way to make maximal use of the expensive machine.</p>
<p>所以需要一种方式来最大限度的利用它</p>
<p>Their solution was a program called the Atlas Supervisor, finished in 1962.</p>
<p>他们的解决方案是一个程序叫 Atlas Supervisor ，于1962年完成</p>
<p>This operating system not only loaded programs automatically, like earlier batch systems,</p>
<p>这个操作系统，不仅像更早期的批处理系统那样，能自动加载程序</p>
<p>but could also run several at the same time on its single CPU.</p>
<p>还能在单个 CPU 上同时运行几个程序</p>
<p>It did this through clever scheduling.</p>
<p>它通过调度来做到这一点</p>
<p>Let's say we have a game program running on Atlas,</p>
<p>假设 Atlas 上有一个游戏在运行</p>
<p>and we call the function "print(highscore)"</p>
<p>并且我们调用一个函数 print(highscore)</p>
<p>which instructs Atlas to print the value of a variable named "highscore"</p>
<p>它让 Atlas 打印一个叫 highscore 的变量值</p>
<p>onto paper to show our friends that we're the ultimate champion of virtual tiddlywinks.</p>
<p>让朋友知道我是最高分冠军</p>
<p>That function call is going to take a while, the equivalent of thousands of clock cycles,</p>
<p>print 函数运行需要一点时间，大概上千个时钟周期</p>
<p>because mechanical printers are slow in comparison to electronic CPUs.</p>
<p>但因为打印机比 CPU 慢，</p>
<p>So instead of waiting for the I/O to finish,</p>
<p>与其等着它完成操作</p>
<p>Atlas instead puts our program to sleep,</p>
<p>Atlas 会把程序休眠，运行另一个程序</p>
<p>then selects and runs another program that's waiting and ready to run.</p>
<p>Atlas 会把程序休眠，运行另一个程序</p>
<p>Eventually, the printer will report back to Atlas that it finished printing the value of "highscore".</p>
<p>最终, 打印机会告诉 Atlas, 打印已完成</p>
<p>Atlas then marks our program as ready to go,</p>
<p>Atlas 会把程序标记成可继续运行</p>
<p>and at some point, it will be scheduled to run again on the CPU,</p>
<p>之后在某时刻会安排给 CPU 运行</p>
<p>and continue onto the next line of code following the print statement.</p>
<p>并继续 print 语句之后的下一行代码</p>
<p>In this way, Atlas could have one program running calculations on the CPU,</p>
<p>这样, Atlas 可以在 CPU 上运行一个程序</p>
<p>while another was printing out data,</p>
<p>同时另一个程序在打印数据</p>
<p>and yet another reading in data from a punch tape.</p>
<p>另一个从穿孔磁带中读取数据。</p>
<p>Atlas' engineers doubled down on this idea,</p>
<p>Atlas 的工程师做的还要多，</p>
<p>and outfitted their computer with 4 paper tape readers, 4 paper tape punches,</p>
<p>配了4台纸带读取器，4台纸带打孔机</p>
<p>and up to 8 magnetic tape drives.</p>
<p>多达8个磁带驱动器</p>
<p>This allowed many programs to be in progress all at once,</p>
<p>使多个程序可以同时运行，</p>
<p>sharing time on a single CPU.</p>
<p>在单个 CPU 上共享时间</p>
<p>This ability, enabled by the Operating System, is called</p>
<p>操作系统的这种能力叫</p>
<p>multitasking.</p>
<p>"多任务处理"</p>
<p>There's one big catch to having many programs running simultaneously on a single computer, though.</p>
<p>同时运行多个程序有个问题</p>
<p>Each one is going to need some memory,</p>
<p>每个程序都会占一些内存，</p>
<p>and we can't lose that program's data when we switch to another program.</p>
<p>当切换到另一个程序时，我们不能丢失数据</p>
<p>The solution is to allocate each program its own block of memory.</p>
<p>解决办法是给每个程序分配专属内存块</p>
<p>So, for example, let's say a computer has 10,000 memory locations in total.</p>
<p>举个例子，假设计算机一共有 10000 个内存位置</p>
<p>Program A might get allocated memory addresses 0 through 999,</p>
<p>程序 A 分配到内存地址 0 到 999</p>
<p>and Program B might get 1000 through 1999, and so on.</p>
<p>而程序 B 分配到内存地址 1000 到 1999，以此类推</p>
<p>If a program asks for more memory,</p>
<p>如果一个程序请求更多内存，</p>
<p>the operating system decides if it can grant that request,</p>
<p>操作系统会决定是否同意</p>
<p>and if so, what memory block to allocate next.</p>
<p>如果同意，分配哪些内存块</p>
<p>This flexibility is great, but introduces a quirk.</p>
<p>这种灵活性很好，但带来一个奇怪的后果</p>
<p>It means that Program A could end up being allocated non-sequential blocks of memory,</p>
<p>程序 A 可能会分配到非连续的内存块</p>
<p>in say addresses 0 through 999, and 2000 through 2999.</p>
<p>比如内存地址 0 到 999，以及 2000 到 2999</p>
<p>And this is just a simple example</p>
<p>这只是个简单例子</p>
<p>a real program might be allocated dozens of blocks scattered all over memory.</p>
<p>真正的程序可能会分配到内存中数十个地方</p>
<p>As you might imagine,</p>
<p>你可能想到了，</p>
<p>this would get really confusing for programmers to keep track of.</p>
<p>这对程序员来说很难跟踪</p>
<p>Maybe there's a long list of sales data in memory that</p>
<p>也许内存里有一长串销售额，</p>
<p>a program has to total up at the end of the day,</p>
<p>每天下班后要算销售总额</p>
<p>but this list is stored across a bunch of different blocks of memory.</p>
<p>但列表存在一堆不连续的内存块里</p>
<p>To hide this complexity, Operating Systems virtualize memory locations.</p>
<p>为了隐藏这种复杂性，操作系统会把内存地址进行 "虚拟化"</p>
<p>With Virtual Memory, programs can assume their memory always starts at address 0,</p>
<p>这叫 "虚拟内存"，程序可以假定内存总是从地址0开始</p>
<p>keeping things simple and consistent.</p>
<p>简单又一致</p>
<p>However, the actual, physical location in computer memory</p>
<p>而实际物理位置</p>
<p>is hidden and abstracted by the operating system.</p>
<p>被操作系统隐藏和抽象了</p>
<p>Just a new level of abstraction.</p>
<p>一层新的抽象</p>
<p>Let's take our example Program B,</p>
<p>用程序 B 来举例，</p>
<p>which has been allocated a block of memory from address 1000 to 1999.</p>
<p>它被分配了内存地址 1000 到 1999</p>
<p>As far as Program B can tell, this appears to be a block from 0 to 999.</p>
<p>对程序 B 而言，它看到的地址是 0 到 999</p>
<p>The OS and CPU handle the virtual-to-physical memory remapping automatically.</p>
<p>操作系统会自动处理，虚拟内存和物理内存之间的映射</p>
<p>So, if Program B requests memory location 42,</p>
<p>如果程序 B 要地址 42，</p>
<p>it really ends up reading address 1042.</p>
<p>实际上是物理地址 1042</p>
<p>This virtualization of memory addresses is even more useful for Program A,</p>
<p>这种内存地址的虚拟化对程序 A 甚至更有用</p>
<p>which in our example, has been allocated two blocks of memory</p>
<p>在例子中，A 被分配了两块隔开的内存</p>
<p>that are separated from one another.</p>
<p>在例子中，A 被分配了两块隔开的内存</p>
<p>This too is invisible to Program A.</p>
<p>程序 A 不知道这点.</p>
<p>As far as it can tell, it's been allocated a continuous block of 2000 addresses.</p>
<p>以 A 的视角，它有 2000 个连续地址</p>
<p>When Program A reads memory address 999,</p>
<p>当程序 A 读内存地址 999 时，</p>
<p>that does coincidentally map to physical memory address 999.</p>
<p>会刚好映射到物理内存地址 999</p>
<p>But if Program A reads the very next value in memory, at address 1000,</p>
<p>但如果程序 A 读下一个地址 1000</p>
<p>that gets mapped behind the scenes to physical memory address 2000.</p>
<p>会映射到物理地址 2000</p>
<p>This mechanism allows programs to have flexible memory sizes,</p>
<p>这种机制使程序的内存大小可以灵活增减，</p>
<p>called dynamic memory allocation,</p>
<p>叫"动态内存分配"</p>
<p>that appear to be continuous to them.</p>
<p>对程序来说，内存看起来是连续的.</p>
<p>It simplifies everything and offers tremendous flexibility to the Operating System</p>
<p>它简化了一切，为操作系统同时运行多个程序，</p>
<p>in running multiple programs simultaneously.</p>
<p>提供了极大的灵活性</p>
<p>Another upside of allocating each program its own memory,</p>
<p>给程序分配专用的内存范围，</p>
<p>is that they're better isolated from one another.</p>
<p>另一个好处是这样隔离起来会更好</p>
<p>So, if a buggy program goes awry, and starts writing gobbledygook,</p>
<p>如果一个程序出错，开始写乱七八糟的数据</p>
<p>it can only trash its own memory, not that of other programs.</p>
<p>它只能捣乱自己的内存，不会影响到其它程序.</p>
<p>This feature is called Memory Protection.</p>
<p>这叫 "内存保护"</p>
<p>This is also really useful in protecting against malicious software, like viruses.</p>
<p>防止恶意软件（如病毒）也很有用</p>
<p>For example, we generally don't want other programs to have the ability</p>
<p>例如，我们不希望其他程序有能力，</p>
<p>to read or modify the memory of, let say, our email,</p>
<p>读或改邮件程序的内存</p>
<p>with that kind of access,</p>
<p>如果有这种权限，</p>
<p>malware could send emails on your behalf and maybe steal personal information.</p>
<p>恶意软件可能以你的名义发邮件，甚至窃取个人信息</p>
<p>Not good!</p>
<p>一点都不好！</p>
<p>Atlas had both virtual and protected memory.</p>
<p>Atlas 既有"虚拟内存"也有"内存保护"</p>
<p>It was the first computer and OS to support these features!</p>
<p>是第一台支持这些功能的计算机和操作系统！</p>
<p>By the 1970s, computers were sufficiently fast and cheap.</p>
<p>到 1970 年代，计算机足够快且便宜</p>
<p>Institutions like a university could buy a computer and let students use it.</p>
<p>大学会买电脑让学生用</p>
<p>It was not only fast enough to run several programs at once,</p>
<p>计算机不仅能同时运行多个程序，</p>
<p>but also give several users simultaneous, interactive access.</p>
<p>还能让多用户能同时访问</p>
<p>This was done through a terminal,</p>
<p>多个用户用"终端"来访问计算机</p>
<p>which is a keyboard and screen that connects to a big computer,</p>
<p>"终端"只是键盘+屏幕，连到主计算机，终端本身没有处理能力</p>
<p>but doesn't contain any processing power itself.</p>
<p>"终端"只是键盘+屏幕，连到主计算机，终端本身没有处理能力</p>
<p>A refrigerator-sized computer might have 50 terminals connected to it,</p>
<p>冰箱大小的计算机可能有50个终端，</p>
<p>allowing up to 50 users.</p>
<p>能让50个用户使用</p>
<p>Now operating systems had to handle not just multiple programs,</p>
<p>这时操作系统不但要处理多个程序，</p>
<p>but also multiple users.</p>
<p>还要处理多个用户</p>
<p>So that no one person could gobble up all of a computer's resources,</p>
<p>为了确保其中一个人不会占满计算机资源</p>
<p>operating systems were developed that offered time-sharing.</p>
<p>开发了分时操作系统</p>
<p>With time-sharing each individual user was only allowed to utilize</p>
<p>意思是每个用户只能用</p>
<p>a small fraction of the computer's processor, memory, and so on.</p>
<p>一小部分处理器、内存等</p>
<p>Because computers are so fast,</p>
<p>因为电脑很快，</p>
<p>even getting just 1/50th of its resources was enough for individuals to complete many tasks.</p>
<p>即使拿到 1/50 的资源也足以完成许多任务</p>
<p>The most influential of early time-sharing Operating Systems was</p>
<p>早期分时操作系统中，最有影响力的是，</p>
<p>Multics,  or Multiplexed Information and Computing Service,</p>
<p>Multics（多任务信息与计算系统）</p>
<p>released in 1969.</p>
<p>于 1969 年发布</p>
<p>Multics was the first major operating system designed to be secure from the outset.</p>
<p>Multics 是第一个，从设计时就考虑到安全的操作系统</p>
<p>Developers didn't want mischievous users accessing data they shouldn't,</p>
<p>开发人员不希望恶意用户访问不该访问的数据</p>
<p>like students attempting to access the final exam on their professor's account.</p>
<p>比如学生假装成教授，访问期末考试的文件</p>
<p>Features like this meant Multics was really complicated for its time,</p>
<p>这导致 Multics 的复杂度超过当时的平均水准</p>
<p>using around 1 Megabit of memory, which was a lot back then!</p>
<p>操作系统会占大约 1 Mb 内存，这在当时很多！</p>
<p>That might be half of a computer's memory, just to run the OS!</p>
<p>可能是内存的一半，只拿来运行操作系统！</p>
<p>Dennis Ritchie, one of the researchers working on Multics, once said:</p>
<p>Multics 的研究人员之一 Dennis Ritchie 曾说过</p>
<p>"One of the obvious things that went wrong with Multics as a commercial success</p>
<p>"阻碍 Multics 获得商业成功的一个明显问题是</p>
<p>was just that it was sort of over-engineered in a sense.</p>
<p>从某种方面来说，它被过度设计了，</p>
<p>There was just too much in it."</p>
<p>功能太多了"</p>
<p>This lead Dennis, and another Multics researcher,</p>
<p>所以 Dennis 和另一个 Multics 研究员，</p>
<p>Ken Thompson, to strike out on their own and build a new, lean operating system</p>
<p>Ken Thompson 联手打造新的操作系统</p>
<p>called Unix.</p>
<p>叫 Unix</p>
<p>They wanted to separate the OS into two parts:</p>
<p>他们想把操作系统分成两部分：</p>
<p>First was the core functionality of the OS,</p>
<p>首先是操作系统的核心功能</p>
<p>things like memory management, multitasking,and dealing with I/O,</p>
<p>如内存管理，多任务和输入/输出处理，这叫"内核"</p>
<p>which is called the kernel .</p>
<p>如内存管理，多任务和输入/输出处理，这叫"内核"</p>
<p>The second part was a wide array of useful tools that came bundled with,</p>
<p>第二部分是一堆有用的工具</p>
<p>but not part of the kernel, things like programs and libraries.</p>
<p>但它们不是内核的一部分（比如程序和运行库）</p>
<p>Building a compact, lean kernel meant intentionally leaving some functionality out.</p>
<p>紧凑的内核意味着功能没有那么全面</p>
<p>Tom Van Vleck, another Multics developer, recalled:</p>
<p>Multics 的另一个开发者 Tom Van Vleck 回忆说：</p>
<p>"I remarked to Dennis that easily half the code I was writing in Multics was error recovery code."</p>
<p>"我对 Dennis 说，我在 Multics 写的一半代码都是错误恢复代码"</p>
<p>He said, "We left all that stuff out of Unix.</p>
<p>他说:"Unix 不会有这些东西</p>
<p>If there's an error, we have this routine called panic,</p>
<p>如果有错误发生，我们就让内核"恐慌"（panic）</p>
<p>and when it is called, the machine crashes,</p>
<p>当调用它时，机器会崩溃</p>
<p>and you holler down the hall, 'Hey, reboot it.'""</p>
<p>你得在走廊里大喊，"嘿，重启电脑"</p>
<p>You might have heard of kernel panics.</p>
<p>你可能听过 "内核恐慌"（kernel panic）</p>
<p>This is where the term came from.</p>
<p>这就是这个词的来源</p>
<p>It's literally when the kernel crashes, has no recourse to recover,</p>
<p>内核如果崩溃，没有办法恢复</p>
<p>and so calls a function called "panic".</p>
<p>所以调用一个叫"恐慌"（panic）的函数</p>
<p>Originally, all it did was print the word "panic" and then enter an infinite loop.</p>
<p>起初只是打印"恐慌"一词，然后无限循环</p>
<p>This simplicity meant that Unix could be run on cheaper and more diverse hardware,</p>
<p>这种简单性意味着，Unix 可以在更便宜更多的硬件上运行</p>
<p>making it popular inside Bell Labs, where Dennis and Ken worked.</p>
<p>使 Unix 在 Dennis 和 Ken 工作的，贝尔实验室大受欢迎</p>
<p>As more developers started using Unix to build and run their own programs,</p>
<p>越来越多开发人员用 Unix 写程序和运行程序</p>
<p>the number of contributed tools grew.</p>
<p>工具数量日益增长</p>
<p>Soon after its release in 1971,</p>
<p>1971 年发布后不久</p>
<p>it gained compilers for different programming languages and even a word processor,</p>
<p>就有人写了不同编程语言的编译器，甚至文字处理器</p>
<p>quickly making it one of the most popular OSes of the 1970s and 80s.</p>
<p>使得 Unix 迅速成为，1970~80年代最流行的操作系统之一</p>
<p>At the same time, by the early 1980s,</p>
<p>到 1980 年代早期</p>
<p>the cost of a basic computer had fallen to the point where individual people could afford one,</p>
<p>计算机的价格降到普通人买得起，</p>
<p>called a personal or home computer.</p>
<p>这些叫"个人电脑"或"家庭电脑"</p>
<p>These were much simpler than the big mainframes</p>
<p>这些电脑比大型主机简单得多，</p>
<p>found at universities, corporations, and governments.</p>
<p>主机一般在大学，公司和政府</p>
<p>So, their operating systems had to be equally simple.</p>
<p>因此操作系统也得简单</p>
<p>For example, Microsoft's Disk Operating System, or MS-DOS, was just 160 kilobytes,</p>
<p>举例，微软的磁盘操作系统（MS-DOS）只有 160 kB，</p>
<p>allowing it to fit, as the name suggests, onto a single disk.</p>
<p>一张磁盘就可以容纳</p>
<p>First released in 1981, it became the most popular OS for early home computers,</p>
<p>于 1981 年发布，成为早期家用电脑最受欢迎的操作系统</p>
<p>even though it lacked multitasking and protected memory.</p>
<p>虽然缺少"多任务"和"保护内存"这样功能</p>
<p>This meant that programs could,</p>
<p>意味着程序经常</p>
<p>and would, regularly crash the system.</p>
<p>使系统崩溃</p>
<p>While annoying, it was an acceptable tradeoff,</p>
<p>虽然很讨厌但还可以接受，</p>
<p>as users could just turn their own computers off and on again!</p>
<p>因为用户可以重启</p>
<p>Even early versions of Windows,</p>
<p>哪怕是微软 1985 年发布的早期 Windows，</p>
<p>first released by Microsoft in 1985  and which dominated the OS scene throughout the 1990s,</p>
<p>虽然在 90 年代很流行</p>
<p>lacked strong memory protection.</p>
<p>但却缺乏"内存保护"</p>
<p>When programs misbehaved,</p>
<p>当程序行为不当时，</p>
<p>you could get the blue screen of death,</p>
<p>就会"蓝屏"</p>
<p>a sign that a program had crashed so badly that it took down the whole operating system.</p>
<p>代表程序崩溃的非常严重，把系统也带崩溃了</p>
<p>Luckily, newer versions of Windows have better protections and usually don't crash that often.</p>
<p>幸运的是，新版Windows有更好的保护，不会经常崩溃</p>
<p>Today, computers run modern operating systems,</p>
<p>如今的计算机有现代操作系统</p>
<p>like Mac OS X, Windows 10, Linux, iOS and Android.</p>
<p>比如 Mac OS X，Windows 10 ，Linux，iOS和Android</p>
<p>Even though the computers we own are most often used by just a single person,</p>
<p>虽然大部分设备只有一个人使用</p>
<p>you!</p>
<p>你！</p>
<p>their OS all have multitasking and virtual and protected memory.</p>
<p>操作系统依然有"多任务, "虚拟内存", "内存保护"</p>
<p>So, they can run many programs at once:</p>
<p>因此可以同时运行多个程序：</p>
<p>you can watch YouTube in your web browser,</p>
<p>一边在浏览器看 YouTube，一</p>
<p>edit a photo in Photoshop,</p>
<p>一边在 Photoshop 修图</p>
<p>play music in Spotify and sync Dropbox all at the same time.</p>
<p>用 Spotify 放音乐，同步 Dropbox</p>
<p>This wouldn't be possible without those decades of research and development on Operating Systems,</p>
<p>如果没有操作系统这几十年的发展，这些都不可能,</p>
<p>and of course the proper memory to store those programs.</p>
<p>当然，我们也需要地方放程序</p>
<p>Which we'll get to next week.</p>
<p>下周会讨论</p>
<p>19 内存&储存介质</p>
<p>Memory & Storage</p>
<p>Hi, I'm Carrie Anne, and welcome to Crash Course Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>We've talked about computer memory several times in this series,</p>
<p>系列中我们多次谈到内存（Memory）</p>
<p>and we even designed some in Episode 6.</p>
<p>甚至在第 6 集设计了一个简单内存</p>
<p>In general, computer memory is non-permanent.</p>
<p>一般来说，电脑内存是 "非永久性"</p>
<p>If your xbox accidently gets unplugged and turns off,</p>
<p>如果 Xbox 电源线不小心拔掉了，</p>
<p>any data saved in memory is lost.</p>
<p>内存里所有数据都会丢失</p>
<p>For this reason, it's called volatile memory.</p>
<p>所以内存叫"易失性"存储器</p>
<p>What we haven't talked so much about this series is storage,</p>
<p>我们还没谈过的话题是存储器（Storage）</p>
<p>which is a tad different.</p>
<p>存储器（Storage）和内存（Memory）有点不同</p>
<p>Any data written to storage, like your hard drive,</p>
<p>任何写入"存储器"的数据，比如你的硬盘，</p>
<p>will stay there until it's over-written or deleted, even if the power goes out.</p>
<p>数据会一直存着，直到被覆盖或删除，断电也不会丢失</p>
<p>It's non-volatile.</p>
<p>存储器是"非易失性"的</p>
<p>It used to be that volatile memory was fast and non-volatile storage was slow,</p>
<p>以前是"易失性"的速度快，"非易失性"的速度慢</p>
<p>but as computing technologies have improved, this distinction is becoming less true,</p>
<p>但随着技术发展，两者的差异越来越小</p>
<p>and the terms have started to blend together.</p>
<p>这些术语已经开始融合在一起了。</p>
<p>Nowadays, we take for granted technologies like this little USB stick,</p>
<p>如今我们认为稀松平常的技术，比如这个 U 盘</p>
<p>which offers gigabytes of memory, reliable over long periods of time, all at low cost,</p>
<p>能低成本+可靠+长时间存储上 GB 的数据</p>
<p>but this wasn't always true.</p>
<p>但以前可不是这样的</p>
<p>The earliest computer storage was paper punch cards,</p>
<p>最早的存储介质是打孔纸卡，</p>
<p>and its close cousin, punched paper tape.</p>
<p>以及纸卡的亲戚打孔纸带</p>
<p>By the 1940s, punch cards had largely standardized into a grid of 80 columns and 12 rows,</p>
<p>到1940年代，纸卡标准是 80列x12行</p>
<p>allowing for a maximum of 960 bits of data to be stored on a single card.</p>
<p>一张卡能存 960 位数据 (80x12=960)</p>
<p>The largest program ever punched onto cards, that we know of,</p>
<p>据我们所知的最大纸卡程序</p>
<p>was the US Military's Semi-Automatic Ground Environment, or SAGE,</p>
<p>是美国军方的"半自动地面防空系统" 简称 SAGE</p>
<p>an Air Defense System that became operational in 1958.</p>
<p>一个在 1958 年投入使用的防空系统</p>
<p>The main program was stored on 62,500 punchcards,</p>
<p>主程序存储在 62,500 个纸卡上</p>
<p>roughly equivalent to 5 megabytes of data,</p>
<p>大小 5MB 左右, </p>
<p>that's the size of an average smartphone photo today.</p>
<p>大小 5MB 左右, 相当如今手机拍张照</p>
<p>Punch cards were a useful and popular form of storage for decades,</p>
<p>因为不用电而且便宜耐用</p>
<p>they didn't need power, plus paper was cheap and reasonably durable.</p>
<p>纸卡用了十几年，因为不用电而且便宜耐用</p>
<p>However, punchcards were slow and write-once,</p>
<p>然而坏处是读取慢，只能写入一次</p>
<p>you can't easily un-punch a hole.</p>
<p>打的孔无法轻易补上</p>
<p>So they were a less useful form of memory,</p>
<p>纸卡不好用</p>
<p>where a value might only be needed for a fraction of a second during a program's execution,</p>
<p>对于存临时值</p>
<p>and then discarded.</p>
<p>然后就废弃掉了</p>
<p>A faster, larger and more flexible form of computer memory was needed.</p>
<p>我们需要更快更大更灵活的存储方式</p>
<p>An early and practical approach was developed by J. Presper Eckert,</p>
<p>J. Presper Eckert 在 1944 年建造 ENIAC 时</p>
<p>as he was finishing work on ENIAC in 1944.</p>
<p>发明了一种方法</p>
<p>His invention was called Delay Line Memory, and it worked like this.</p>
<p>叫"延迟线存储器"（Delay Line Memory）原理如下</p>
<p>You take a tube and fill it with a liquid, like mercury.</p>
<p>拿一个管子装满液体，如水银</p>
<p>Then, you put a speaker at one end and microphone at the other.</p>
<p>管子一端放扬声器，另一端放麦克风</p>
<p>When you pulse the speaker, it creates a pressure wave.</p>
<p>扬声器发出脉冲时会产生压力波</p>
<p>This takes time to propagate to the other end of the tube,</p>
<p>压力波需要时间</p>
<p>where it hits the microphone,</p>
<p>传播到另一端的麦克风</p>
<p>converting it back into an electrical signal.</p>
<p>麦克风将压力波转换回电信号.</p>
<p>And we can use this propagation delay to store data!</p>
<p>我们可以用压力波的传播延迟来存储数据！</p>
<p>Imagine that the presence of a pressure wave is a 1</p>
<p>假设有压力波代表 1，</p>
<p>and the absence of a pressure wave is a 0.</p>
<p>没有代表 0</p>
<p>Our speaker can output a binary sequence like 1010 0111.</p>
<p>扬声器可以输出 1??010 0111</p>
<p>The corresponding waves will travel down the tube, in order,</p>
<p>压力波沿管子传播，过了一会儿，撞上麦克风，</p>
<p>and a little while later, hit the microphone,</p>
<p>压力波沿管子传播，过了一会儿，撞上麦克风，</p>
<p>which converts the signal back into 1's and 0's.</p>
<p>将信号转换回 1 和 0</p>
<p>If we create a circuit that connects the microphone to the speaker,</p>
<p>如果加一个电路，连接麦克风和扬声器</p>
<p>plus a little amplifier to compensate for any loss,</p>
<p>再加一个放大器（Amplifier）来弥补信号衰弱</p>
<p>we can create a loop that stores data.</p>
<p>就能做一个存储数据的循环</p>
<p>The signal traveling along the wire is near instantaneous,</p>
<p>信号沿电线传播几乎是瞬时的,</p>
<p>so there's only ever one bit of data showing at any moment in time.</p>
<p>所以任何时间点只显示  1 bit 数据</p>
<p>But in the tube, you can store many bits!</p>
<p>但管子中可以存储多个位(bit)</p>
<p>After working on ENIAC, Eckert and his colleague John Mauchly,</p>
<p>忙完 ENIAC 后，Eckert 和同事 John Mauchly</p>
<p>set out to build a bigger and better computer called EDVAC, incorporating Delay Line Memory.</p>
<p>着手做一个更大更好的计算机叫 EDVAC，使用了延迟线存储器</p>
<p>In total, the computer had 128 Delay Lines,</p>
<p>总共有 128 条延迟线，</p>
<p>each capable of storing 352 bits.</p>
<p>每条能存 352 位（bits）</p>
<p>That's a grand total of 45 thousands bits of memory,</p>
<p>总共能存 45,000 位(bit)</p>
<p>not too shabby for 1949!</p>
<p>对 1949 年来说还不错！</p>
<p>This allowed EDVAC to be one of the very earliest Stored-Program Computers,</p>
<p>这使得 EDVAC 成为最早的 "存储程序计算机" 之一</p>
<p>which we talked about in Episode 10.</p>
<p>我们在第 10 集讨论过</p>
<p>However, a big drawback with delay line memory</p>
<p>但"延迟线存储器"的一大缺点是</p>
<p>is that you could only read one bit of data from a tube at any given instant.</p>
<p>每一个时刻只能读一位 (bit) 数据</p>
<p>If you wanted to access a specific bit, like bit 112,</p>
<p>如果想访问一个特定的 bit，比如第 112 位(bit)，</p>
<p>you'd have to wait for it to come around in the loop,</p>
<p>你得等待它从循环中出现</p>
<p>what's called sequential or cyclic-access memory,</p>
<p>所以又叫 "顺序存储器"或"循环存储器"</p>
<p>whereas we really want random access memory,</p>
<p>而我们想要的是 "随机存取存储器"，</p>
<p>where we can access any bit at any time.</p>
<p>可以随时访问任何位置</p>
<p>It also proved challenging to increase the density of the memory,</p>
<p>增加内存密度也是一个挑战</p>
<p>packing waves closer together meant they were more easily mixed up.</p>
<p>把压力波变得更紧密意味着更容易混在一起</p>
<p>In response, new forms of delay line memory were invented,</p>
<p>所以出现了其他类型的 "延迟线存储器"</p>
<p>such as magnetostrictive delay lines .</p>
<p>如 "磁致伸缩延迟存储器"</p>
<p>These delay lines use a metal wire that could be twisted,</p>
<p>用金属线的振动</p>
<p>creating little torsional waves that represented data.</p>
<p>来代表数据</p>
<p>By forming the wire into a coil, you could store around 1000 bits in a 1 foot by 1 foot square.</p>
<p>通过把线卷成线圈，1英尺×1英尺的面积能存储大概 1000位(bit)</p>
<p>However, delay line memory was largely obsolete by the mid 1950s,</p>
<p>然而，延迟线存储器在 1950 年代中期就基本过时了</p>
<p>surpassed in performance, reliability and cost by a new kid on the block:</p>
<p>因为出现了新技术，性能,可靠性和成本都更好</p>
<p>magnetic core memory which was constructed out of little magnetic donuts,</p>
<p>用了像甜甜圈的小型磁圈</p>
<p>called cores.</p>
<p>"磁芯存储器"</p>
<p>If you loop a wire around this core.</p>
<p>如果给磁芯绕上电线，</p>
<p>and run an electrical current through the wire,</p>
<p>并施加电流，</p>
<p>we can magnetize the core in a certain direction.</p>
<p>可以将磁化在一个方向</p>
<p>If we turn the current off, the core will stay magnetized.</p>
<p>如果关掉电流，磁芯保持磁化</p>
<p>If we pass current through the wire in the opposite direction,</p>
<p>如果沿相反方向施加电流</p>
<p>the magnetization direction, called polarity,</p>
<p>磁化的方向（极性）</p>
<p>flips the other way.</p>
<p>会翻转</p>
<p>In this way, we can store 1's and 0's!</p>
<p>这样就可以存 1 和 0！</p>
<p>1 bit of memory isn't very useful, so these little donuts were arranged into grids.</p>
<p>如果只存 1 位不够有用，所以把小甜甜圈排列成网格</p>
<p>There were wires for selecting the right row and column, and a wire that ran through every core,</p>
<p>有电线负责选行和列，也有电线贯穿每个磁芯, </p>
<p>which could be used to read or write a bit.</p>
<p>用于读写一位(bit)</p>
<p>Here is an actual piece of core memory!</p>
<p>我手上有一块磁芯存储器</p>
<p>In each of these little yellow squares, there are 32 rows and 32 columns of tiny cores,</p>
<p>每个黄色方格有32行x32列的磁芯，</p>
<p>each one holding 1 bit of data.</p>
<p>每个磁芯存 1 位数据</p>
<p>So, each of these yellow squares could hold 1024 bits.</p>
<p>所以能存 1024 位(bit)  (32x32=1024)</p>
<p>In total, there are 9 of these,</p>
<p>总共 9 个黄色方格</p>
<p>so this memory board could hold a maximum of 9216 bits,</p>
<p>所以这块板子最多能存 9216 位(bit) (1024x9=9216)</p>
<p>which is around 9 kilobytes.</p>
<p>换算过来大约是 9 千字节，(9216 bit ~= 9 kb)</p>
<p>The first big use of core memory was MIT's Whirlwind 1 computer, in 1953,</p>
<p>磁芯内存的第一次大规模运用，是 1953 年麻省理工学院的 Whirlwind 1 计算机</p>
<p>which used a 32 by 32 core arrangement.</p>
<p>磁芯排列是 32×32</p>
<p>And, instead of just a single plane of cores, like this,</p>
<p>用了 16 块板子，</p>
<p>it was 16 boards deep, providing roughly 16 thousand bits of storage.</p>
<p>能存储大约 16000 位(bit)</p>
<p>Importantly, unlike delay line memory,</p>
<p>更重要的是，不像"延迟线存储器"，</p>
<p>any bit could be accessed at any time.</p>
<p>磁芯存储器能随时访问任何一位(bit)</p>
<p>This was a killer feature,</p>
<p>这在当时非常了不起</p>
<p>and magnetic core memory became the predominant Random Access Memory technology</p>
<p>"磁芯存储器" 从 1950 年代中期开始成为主流，</p>
<p>for two decades, beginning in the mid 1950</p>
<p>流行了 20 多年</p>
<p>even though it was typically woven by hand!</p>
<p>而且一般还是手工编织的！</p>
<p>Although starting at roughly 1 dollar per bit,</p>
<p>刚开始时存储成本大约 1 美元 1 位(bit)，</p>
<p>the cost fell to around 1 cent per bit by the 1970s.</p>
<p>到1970年代，下降到 1 美分左右</p>
<p>Unfortunately, even 1 cent per bit isn't cheap enough for storage.</p>
<p>不幸的是，即使每位 1 美分也不够便宜</p>
<p>As previously mentioned,</p>
<p>之前提过，</p>
<p>an average smartphone photo is around 5 megabytes in size,</p>
<p>现代手机随便拍张照片都有 5 MB</p>
<p>that's roughly 40 million bits.</p>
<p>5MB 约等于 4000 万 bit</p>
<p>Would you pay 4 hundred thousand dollars to store a photo on core memory?</p>
<p>你愿意花 40 万美元在"磁芯存储器"上存照片吗？</p>
<p>If you have that kind of money to drop,</p>
<p>如果你有这么多钱</p>
<p>did you know that Crash Course is on Patreon?</p>
<p>你知道 Crash Course 在 Patreon 有赞助页吗？</p>
<p>Right? Wink wink.</p>
<p>对吧？你懂的</p>
<p>Anyway, there was tremendous research into storage technologies happening at this time.</p>
<p>总之，当时对存储技术进行了大量的研究</p>
<p>By 1951, Eckert and Mauchly had started their own company,</p>
<p>到 1951 年，Eckert 和 Mauchly 创立了自己的公司</p>
<p>and designed a new computer called UNIVAC,</p>
<p>设计了一台叫 UNIVAC 的新电脑</p>
<p>one of the earliest commercially sold computers.</p>
<p>最早进行商业销售的电脑之一</p>
<p>It debuted with a new form of computer storage:</p>
<p>它推出了一种新存储：</p>
<p>magnetic tape.</p>
<p>磁带</p>
<p>This was a long, thin and flexible strip of magnetic material, stored in reels.</p>
<p>磁带是纤薄柔软的一长条磁性带子卷在轴上</p>
<p>The tape could be moved forwards or backwards inside of a machine called a tape drive.</p>
<p>磁带可以在"磁带驱动器"内前后移动</p>
<p>Inside is a write head,</p>
<p>里面有一个"写头"绕了电线，</p>
<p>which passes current through a wound wire to generate a magnetic field,</p>
<p>电流通过产生磁场</p>
<p>causing a small section of the tape to become magnetized.</p>
<p>导致磁带的一小部分被磁化</p>
<p>The direction of the current sets the polarity, again, perfect for storing 1's and 0's.</p>
<p>电流方向决定了极性，代表 1 和 0</p>
<p>There was also a separate read head could detect the polarity non-destructively.</p>
<p>还有一个"读头"，可以非破坏性地检测极性</p>
<p>The UNIVAC used half-inch-wide tape with 8 parallel data tracks,</p>
<p>UNIVAC 用了半英寸宽，8条并行的磁带</p>
<p>each able to store 128 bits of data per inch.</p>
<p>磁带每英寸可存 128 位数据</p>
<p>With each reel containing 1200 feet of tape,</p>
<p>每卷有 1200 英尺长</p>
<p>it meant you could store roughly 15 million bits</p>
<p>意味着一共可以存 1500 万位左右</p>
<p>that's almost 2 megabytes!</p>
<p>接近2兆字节！（2 MB）</p>
<p>Although tape drives were expensive,</p>
<p>虽然磁带驱动器很贵，</p>
<p>the magnetic tape itself was cheap and compact,</p>
<p>但磁带又便宜又小</p>
<p>and for this reason, they're still used today for archiving data.</p>
<p>因此磁带至今仍用于存档</p>
<p>The main drawback is access speed.</p>
<p>磁带的主要缺点是访问速度</p>
<p>Tape is inherently sequential,</p>
<p>磁带是连续的，</p>
<p>you have to rewind or fast-forward to get to data you want.</p>
<p>必须倒带或快进到达特定位置</p>
<p>This might mean traversing hundreds of feet of tape to retrieve a single byte,</p>
<p>可能要几百英尺才能得到某个字节(byte)，</p>
<p>which is slow.</p>
<p>这很慢</p>
<p>A related popular technology in the 1950s and 60s was Magnetic Drum Memory.</p>
<p>1950,60年代，有个类似技术是 "磁鼓存储器"</p>
<p>This was a metal cylinder called a drum coated in a magnetic material for recording data</p>
<p>有金属圆筒，盖满了磁性材料以记录数据</p>
<p>The drum was rotated continuously,</p>
<p>滚筒会持续旋转，</p>
<p>and positioned along its length were dozens of read and write heads.</p>
<p>周围有数十个读写头</p>
<p>These would wait for the right spot to rotate underneath them to read or write a bit of data.</p>
<p>等滚筒转到正确的位置，读写头会读或写 1 位(bit) 数据</p>
<p>To keep this delay as short as possible,</p>
<p>为了尽可能缩短延迟, </p>
<p>drums were rotated thousand of revolutions per minute!</p>
<p>鼓轮每分钟上千转！</p>
<p>By 1953, when the technology started to take off,</p>
<p>到 1953 年，磁鼓技术飞速发展，</p>
<p>you could buy units able to record 80,000 bits of data</p>
<p>可以买到存 80,000 位的"磁鼓存储器"</p>
<p>that's 10 kilobytes,</p>
<p>也就是 10 KB</p>
<p>but the manufacture of drums ceased in the 1970s.</p>
<p>但到 1970 年代 "磁鼓存储器" 不再生产</p>
<p>However, Magnetic Drums did directly lead to the development of Hard Disk Drives,</p>
<p>然而，磁鼓导致了硬盘的发展，</p>
<p>which are very similar, but use a different geometric configuration.</p>
<p>硬盘和磁鼓很相似</p>
<p>Instead of large cylinder, hard disks use,</p>
<p>不过硬盘用的是盘，</p>
<p>well disks that are hard.</p>
<p>不像磁鼓用圆柱体，</p>
<p>Hence the name!</p>
<p>因此得名</p>
<p>The storage principle is the same,</p>
<p>原理是一样的，</p>
<p>the surface of a disk is magnetic,</p>
<p>磁盘表面有磁性</p>
<p>allowing write and read heads to store and retrieve 1's and 0's.</p>
<p>写入头和读取头可以处理上面的 1 和 0</p>
<p>The great thing about disks is that they are thin,</p>
<p>硬盘的好处是薄，</p>
<p>so you can stack many of them together,</p>
<p>可以叠在一起</p>
<p>providing a lot of surface area for data storage.</p>
<p>提供更多表面积来存数据</p>
<p>That's exactly what IBM did for the world's first computer with a disk drive:</p>
<p>IBM 对世上第一台磁盘计算机就是这样做的</p>
<p>the RAMAC 305.</p>
<p>RAMAC 305</p>
<p>Sweet name BTW.</p>
<p>顺便一说名字不错</p>
<p>It contained fifty, 24-inch diameter disks,</p>
<p>它有 50 张 24 英寸直径的磁盘，</p>
<p>offering a total storage capacity of roughly 5 megabytes.</p>
<p>总共能存 5 MB 左右</p>
<p>Yess!! We've finally gotten to a technology that can store a single smartphone photo!</p>
<p>太棒啦! 终于能存一张现代手机的照片了！</p>
<p>The year was 1956.</p>
<p>这年是 1956 年</p>
<p>To access any bit of data,</p>
<p>要访问某个特定 bit</p>
<p>a read/write head would travel up or down the stack to the right disk,</p>
<p>一个读/写磁头会向上或向下移动，找到正确的磁盘</p>
<p>and then slide in between them.</p>
<p>然后磁头会滑进去</p>
<p>Like drum memory, the disks are spinning,</p>
<p>就像磁鼓存储器一样，磁盘也会高速旋转</p>
<p>so the head has to wait for the right section to come around.</p>
<p>所以读写头要等到正确的部分转过来</p>
<p>The RAMAC 305 could access any block of data, on average, in around 6/10ths of a second,</p>
<p>RAMAC 305 访问任意数据，平均只要六分之一秒左右</p>
<p>what's called the seek time.</p>
<p>也叫寻道时间</p>
<p>While great for storage, this was not nearly fast enough for memory,</p>
<p>虽然六分之一秒对存储器来说算不错，但对内存来说还不够快</p>
<p>so the RAMAC 305 also had drum memory and magnetic core memory.</p>
<p>所以 RAMAC 305 还有"磁鼓存储器"和"磁芯存储器"</p>
<p>This is an example of a memory hierarchy,</p>
<p>这是"内存层次结构"的一个例子</p>
<p>where you have a little bit of fast memory, which is expensive,</p>
<p>一小部分高速+昂贵的内存</p>
<p>slightly more medium-speed memory, which is less expensive,</p>
<p>一部分稍慢+相对便宜些的内存</p>
<p>and then a lot of slowish memory, which is cheap.</p>
<p>还有更慢+更便宜的内存</p>
<p>This mixed approach strikes a balance between cost and speed.</p>
<p>这种混合在成本和速度间取得平衡</p>
<p>Hard disk drives rapidly improved and became commonplace by the 1970s.</p>
<p>1970 年代，硬盘大幅度改进并变得普遍</p>
<p>A hard disk like this can easily hold 1 terabyte of data today</p>
<p>如今的硬盘可以轻易容纳 1TB 的数据</p>
<p>that's a trillion bytes or roughly 200,000 five megabyte photos!</p>
<p>能存 20 万张 5MB 的照片！</p>
<p>And these types of drives can be bought online for as little as 40 US dollars.</p>
<p>网上最低 40 美元就可以买到</p>
<p>That's 0.0000000005 cents per bit.</p>
<p>每 bit 成本 0.0000000005 美分</p>
<p>A huge improvement over core memory's 1 cent per bit!</p>
<p>比磁芯内存 1 美分 1 bit 好多了！</p>
<p>Also, modern drives have an average seek time of under 1/100th of a second.</p>
<p>另外，现代硬盘的平均寻道时间低于 1/100 秒</p>
<p>I should also briefly mention a close cousin of hard disks, the floppy disk,</p>
<p>我简单地提一下硬盘的亲戚，软盘</p>
<p>which is basically the same thing, but uses a magnetic medium that's, floppy.</p>
<p>除了磁盘是软的，其他基本一样</p>
<p>You might recognise it as the save icon on some of your applications,</p>
<p>你可能见过某些程序的保存图标是一个软盘</p>
<p>but it was once a real physical object!</p>
<p>软盘曾经是真实存在的东西！</p>
<p>It was most commonly used for portable storage,</p>
<p>软盘是为了便携，</p>
<p>and became near ubiquitous from the mid 1970s up to the mid 90s.</p>
<p>在 1970~1990 非常流行</p>
<p>And today it makes a pretty good coaster.</p>
<p>如今当杯垫挺不错的</p>
<p>Higher density floppy disks, like Zip Disks,</p>
<p>密度更高的软盘，如 Zip Disks，</p>
<p>became popular in the mid 1990s,</p>
<p>在90年代中期流行起来</p>
<p>but fell out of favor within a decade.</p>
<p>但十年内就消失了</p>
<p>Optical storage came onto the scene in 1972, in the form of a 12-inch "laser disc."</p>
<p>光学存储器于 1972 年出现，12 英寸的"激光盘"</p>
<p>However, you are probably more familiar with its later, smaller, are more popular cousin,</p>
<p>你可能对后来的产品更熟：</p>
<p>the Compact Disk, or CD,</p>
<p>光盘（简称 CD）</p>
<p>as well as the DVD which took off in the 90s.</p>
<p>以及 90 年代流行的 DVD</p>
<p>Functionally, these technologies are pretty similar to hard disks and floppy disks,</p>
<p>功能和硬盘软盘一样，都是存数据.</p>
<p>but instead of storing data magnetically,</p>
<p>但用的不是磁性</p>
<p>optical disks have little physical divots in their surface that cause light to be reflected differently,</p>
<p>光盘表面有很多小坑，造成光的不同反射</p>
<p>which is captured by an optical sensor, and decoded into 1's and 0's.</p>
<p>光学传感器会捕获到，并解码为 1 和 0</p>
<p>However, today, things are moving to solid state technologies, with no moving parts,</p>
<p>如今，存储技术在朝固态前进，没有机械活动部件</p>
<p>like this hard drive and also this USB stick.</p>
<p>比如这个硬盘，以及 U 盘</p>
<p>Inside are Integrated Circuits,</p>
<p>里面是集成电路，</p>
<p>which we talked about in Episode 15.</p>
<p>我们在第 15 集讨论过</p>
<p>The first RAM integrated circuits became available in 1972 at 1 cent per bit,</p>
<p>第一个 RAM 集成电路出现于 1972 年，成本每比特 1 美分</p>
<p>quickly making magnetic core memory obsolete.</p>
<p>使"磁芯存储器"迅速过时</p>
<p>Today, costs have fallen so far,</p>
<p>如今成本下降了更多，</p>
<p>that hard disk drives are being replaced with non-volatile,</p>
<p>机械硬盘被 </p>
<p>Solid State Drives, or SSDs, as the cool kids say.</p>
<p>固态硬盘逐渐替代，简称 SSD</p>
<p>Because they contain no moving parts,</p>
<p>由于 SSD 没有移动部件</p>
<p>they don't really have to seek anywhere,</p>
<p>磁头不用等磁盘转</p>
<p>so SSD access times are typically under 1/1000th of a second.</p>
<p>所以 SSD 访问时间低于 1/1000 秒</p>
<p>That's fast!</p>
<p>这很快！</p>
<p>But it's still many times slower than your computer's RAM.</p>
<p>但还是比 RAM 慢很多倍</p>
<p>For this reason, computers today still use memory hierarchies.</p>
<p>所以现代计算机仍然用存储层次结构</p>
<p>So, we've come along way since the 1940s.</p>
<p>我们从 1940 年代到现在进步巨大</p>
<p>Much like transistor count and Moore's law,</p>
<p>就像在第 14 集讨论过的</p>
<p>which we talked about in Episode 14,</p>
<p>晶体管数量和摩尔定律</p>
<p>memory and storage technologies have followed a similar exponential trend.</p>
<p>内存和存储技术也有类似的趋势</p>
<p>From early core memory costing millions of dollars per megabyte, we're steadily fallen,</p>
<p>从早期每 MB 成本上百万美元，下滑到</p>
<p>to mere cents by 2000, and only fractions of a cent today.</p>
<p>2000 年只要几分钱，如今远远低于 1 分钱</p>
<p>Plus, there's WAY less punch cards to keep track of.</p>
<p>完全没有打孔纸卡</p>
<p>Seriously, can you imagine if there was a slight breeze in that room containing the SAGE program?</p>
<p>你能想象 SEGA 的纸卡房间风一吹会怎样吗？</p>
<p>62,500 punch cards.</p>
<p>62,500 张卡</p>
<p>I don't even want to think about it.</p>
<p>我想都不敢想</p>
<p>I'll see you next week.</p>
<p>我们下周见</p>
<p>20 文件系统</p>
<p>Files & File Systems</p>
<p>Hi, I'm Carrie Anne, and welcome to Crash Course Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>Last episode we talked about data storage, how technologies like magnetic tape and hard</p>
<p>上集我们讲了数据存储，磁带和硬盘这样的技术</p>
<p>disks can store trillions of bits of data,</p>
<p>可以在断电状态</p>
<p>for long durations, even without power.</p>
<p>长时间存上万亿个位</p>
<p>Which is perfect for recording "big blobs" of related data,</p>
<p>非常合适存一整块有关系的数据，</p>
<p>what are more commonly called computer files.</p>
<p>或者说"文件"</p>
<p>You've no doubt encountered many types,</p>
<p>你肯定见过很多种文件，</p>
<p>like text files, music files, photos and videos.</p>
<p>比如文本文件，音乐文件，照片和视频</p>
<p>Today, we're going to talk about how files work,</p>
<p>今天，我们要讨论文件到底是什么，</p>
<p>and how computers keep them all organized with File Systems.</p>
<p>以及计算机怎么管理文件</p>
<p>It's perfectly legal for a file to contain arbitrary, unformatted data,</p>
<p>随意排列文件数据完全没问题，</p>
<p>but it's most useful and practical if the data inside the file is organized somehow.</p>
<p>但按格式排会更好</p>
<p>This is called a file format.</p>
<p>这叫 "文件格式"</p>
<p>You can invent your own, and programmers do that from time to time,</p>
<p>你可以发明自己的文件格式，程序员偶尔会这样做</p>
<p>but it's usually best and easiest to use an existing standard, like JPEG and MP3.</p>
<p>但最好用现成标准，比如 JPEG 和 MP3</p>
<p>Let's look at some simple file formats.</p>
<p>来看一些简单文件格式，</p>
<p>The most straightforward are text files,</p>
<p>最简单的是文本文件</p>
<p>also know as TXT file, which contain...surprise! text.</p>
<p>也叫 TXT 文件, 里面包含的是... 文字 （惊喜吧）</p>
<p>Like all computer files, this is just a huge list of numbers, stored as binary.</p>
<p>就像所有其它文件，文本文件只是一长串二进制数</p>
<p>If we look at the raw values of a text file in storage, it would look something like this:</p>
<p>原始值看起来会像这样：</p>
<p>We can view this as decimal numbers instead of binary,</p>
<p>可以转成十进制看，</p>
<p>but that still doesn't help us read the text.</p>
<p>但帮助不大</p>
<p>The key to interpreting this data is knowing that TXT files use ASCII,</p>
<p>解码数据的关键是 ASCII 编码</p>
<p>a character encoding standard we discussed way back in Episode 4.</p>
<p>一种字符编码标准，第 4 集讨论过.</p>
<p>So, in ASCII, our first value, 72, maps to the capital letter H.</p>
<p>第一个值 72，在 ASCII 中是大写字母 H</p>
<p>And in this way, we decode the whole file.</p>
<p>以此类推解码其他数字</p>
<p>Let's look at a more complicated example: a WAVE File, also called a WAV,</p>
<p>来看一个更复杂的例子：波形(Wave)文件，也叫 WAV，</p>
<p>which stores audio.</p>
<p>它存音频数据</p>
<p>Before we can correctly read the data, we need to know some information,</p>
<p>在正确读取数据前，需要知道一些信息</p>
<p>like the bit rate and whether it's a single track or stereo.</p>
<p>比如码率(bit rate)，以及是单声道还是立体声</p>
<p>Data about data, is called meta data.</p>
<p>关于数据的数据，叫"元数据"(meta data)</p>
<p>This metadata is stored at the front of the file, ahead of any actual data,</p>
<p>元数据存在文件开头，在实际数据前面，</p>
<p>in what's known as a Header.</p>
<p>因此也叫文件头(Header)</p>
<p>Here's what the first 44 bytes of a WAV file looks like.</p>
<p>WAV 文件的前 44 个字节长这样</p>
<p>Some parts are always the same, like where it spells out W-A-V-E.</p>
<p>有的部分总是一样的，比如写着 WAVE 的部分</p>
<p>Other parts contain numbers that change depending on the data contained within.</p>
<p>其他部分的内容，会根据数据变化</p>
<p>The audio data comes right behind the metadata, and it's stored as a long list of numbers.</p>
<p>音频数据紧跟在元数据后面，是一长串数字</p>
<p>These values represent the amplitude of sound captured many times per second, and if you</p>
<p>数字代表每秒捕获多次的声音幅度</p>
<p>want a primer on sound, check out our video all about it in Crash Course Physics.</p>
<p>如果想学声音的基础知识，</p>
<p>Link in the dobblydoo.</p>
<p>可以看物理速成课</p>
<p>As an example, let's look at a waveform of me saying: "hello!" Hello!</p>
<p>举个例子，看一下"你好"的波形</p>
<p>Now that we've captured some sound, let's zoom into a little snippet.</p>
<p>现在捕获到了一些声音，我们放大看一下</p>
<p>A digital microphone, like the one in your computer or smartphone,</p>
<p>电脑和手机麦克风，</p>
<p>samples the sound pressure thousands of times.</p>
<p>每秒可以对声音进行上千次采样</p>
<p>Each sample can be represented as a number.</p>
<p>每次采样可以用一个数字表示</p>
<p>Larger numbers mean higher sound pressure, what's called amplitude.</p>
<p>声压越高数字越大，也叫"振幅"</p>
<p>And these numbers are exactly what gets stored in a WAVE file!</p>
<p>WAVE 文件里存的就是这些数据！</p>
<p>Thousands of amplitudes for every single second of audio!</p>
<p>每秒上千次的振幅！</p>
<p>When it's time to play this file, an audio program needs to actuate the computer's speakers</p>
<p>播放声音文件时，</p>
<p>such that the original waveform is emitted.</p>
<p>扬声器会产生相同的波形</p>
<p>"Hello!"</p>
<p>"你好！"</p>
<p>So, now that you're getting the hang of file formats, let's talk about bitmaps or</p>
<p>现在来谈谈位图(Bitmap)，</p>
<p>BMP, which store pictures.</p>
<p>后缀 .bmp, 它存图片</p>
<p>On a computer, Pictures are made up of little tiny square elements called pixels.</p>
<p>计算机上，图片由很多个叫"像素"的方块组成</p>
<p>Each pixel is a combination of three colors: red, green and blue.</p>
<p>每个像素由三种颜色组成：红，绿，蓝</p>
<p>These are called additive primary colors, and they can be mixed together to create any</p>
<p>叫"加色三原色"，</p>
<p>other color on our electronic displays.</p>
<p>混在一起可以创造其它颜色</p>
<p>Now, just like WAV files, BMPs start with metadata,</p>
<p>就像 WAV 文件一样，BMP 文件开头也是元数据，</p>
<p>including key values like image width, image height, and color depth.</p>
<p>有图片宽度，图片高度，颜色深度</p>
<p>As an example, let's say the metadata specified an image 4 pixels wide, by 4 pixels tall,</p>
<p>举例，假设元数据说图是 4像素宽 x 4像素高</p>
<p>with a 24-bit color depth that's 8-bits for red, 8-bits for green, and 8-bits for blue.</p>
<p>颜色深度 24 位， 8 位红色，8 位绿色，8 位蓝色</p>
<p>As a reminder, 8 bits is the same as one byte.</p>
<p>提醒一下，8位 (bit) 和 1字节(byte)是一回事</p>
<p>The smallest number a byte can store is 0, and the largest is 255.</p>
<p>一个字节能表示的最小数是 0，最大 255</p>
<p>Our image data is going to look something like this:</p>
<p>图像数据看起来会类似这样：</p>
<p>Let's look at the color of our first pixel.</p>
<p>来看看第一个像素的颜色</p>
<p>It has 255 for its red value, 255 for green and 255 for blue.</p>
<p>红色是255，绿色是255，蓝色也是255</p>
<p>This equates to full intensity red, full intensity green and full intensity blue.</p>
<p>这等同于全强度红色，全强度绿色和全强度蓝色</p>
<p>These colors blend together on your computer monitor to become white.</p>
<p>混合在一起变成白色</p>
<p>So our first pixel is white!</p>
<p>所以第一个像素是白色！</p>
<p>The next pixel has a Red-Green-Blue, or RGB value of 255, 255, 0.</p>
<p>下一个像素的红绿蓝值，或 RGB 值，255,255,0 </p>
<p>That's the color yellow!</p>
<p>是黄色！</p>
<p>The pixel after that has a RGB value of 0,0,0 that's zero intensity everything, which is black.</p>
<p>下一个像素是 0,0,0 ，黑色</p>
<p>And the next one is yellow.</p>
<p>下一个是黄色</p>
<p>Because the metadata specified this was a 4 by 4 image, we know that we've reached</p>
<p>因为元数据说图片是 4x4，</p>
<p>the end of our first row of pixels.</p>
<p>我们知道现在到了第一行结尾</p>
<p>So, we need to drop down a row.</p>
<p>所以换一行</p>
<p>The next RGB value is 255,255,0 yellow again.</p>
<p>下一个 RGB 值是 255,255,0，又是黄色</p>
<p>Okay, let's go ahead and read all the pixels in our 4x4 image tada!</p>
<p>好，我们读完剩下的像素</p>
<p>A very low resolution pac-man!</p>
<p>一个低分辨率的吃豆人</p>
<p>Obviously this is a simple example of a small image,</p>
<p>刚才显然只是一个简单例子，</p>
<p>but we could just as easily store this image in a BMP.</p>
<p>但这张图片也可以用 BMP 存</p>
<p>I want to emphasize again that it doesn't matter if it's a text file, WAV,</p>
<p>我想再次强调，不管是文本文件，WAV，BMP</p>
<p>BMP, or fancier formats we don't have time to discuss,</p>
<p>或是我们没时间讨论的其他格式</p>
<p>Under the hood, they're all the same: long lists of numbers, stored as binary, on a storage device.</p>
<p>文件在底层全是一样的： 一长串二进制</p>
<p>File formats are the key to reading and understanding the data inside.</p>
<p>为了知道文件是什么，文件格式至关重要</p>
<p>Now that you understand files a little better, let's move on to</p>
<p>现在你对文件更了解了，</p>
<p>how computers go about storing them.</p>
<p>我们接下来讨论计算机怎么存文件</p>
<p>Even though the underlying storage medium might be</p>
<p>虽然硬件可能是</p>
<p>a strip of tape, a drum, a disk, or integrated circuits...</p>
<p>磁带，磁鼓，磁盘或集成电路</p>
<p>hardware and software abstractions let us think of storage as a</p>
<p>通过软硬件抽象后，</p>
<p>long line of little buckets that store values.</p>
<p>可以看成一排能存数据的桶</p>
<p>In the early days, when computers only performed one computation</p>
<p>在很早期时，计算机只做一件事，</p>
<p>like calculating artillery range tables. the entire storage operated like one big file.</p>
<p>比如算火炮射程表，整个储存器就像一整个文件</p>
<p>Data started at the beginning of storage, and then filled it up in order as output was</p>
<p>数据从头存到尾，</p>
<p>produced, up to the storage capacity.</p>
<p>直到占满</p>
<p>However, as computational power and storage capacity improved, it became possible, and</p>
<p>但随着计算能力和存储容量的提高，</p>
<p>useful, to store more than one file at a time.</p>
<p>存多个文件变得非常有用</p>
<p>The simplest option is to store files back-to-back.</p>
<p>最简单的方法是把文件连续存储</p>
<p>This can work... but how does the computer know where files begin and end?</p>
<p>这样能用，但怎么知道文件开头和结尾在哪里？</p>
<p>Storage devices have no notion of files C they're just a mechanism for storing lots of bits.</p>
<p>储存器没有文件的概念，只是存储大量位</p>
<p>So, for this to work, we need to have a special file that records where other ones are located.</p>
<p>所以为了存多个文件，需要一个特殊文件，记录其他文件的位置</p>
<p>This goes by many names, but a good general term is Directory File.</p>
<p>这个特殊文件有很多名字，这里泛称 "目录文件"</p>
<p>Most often, it's kept right at the front of storage, so we always know where to access it.</p>
<p>这个文件经常存在最开头，方便找</p>
<p>Location zero!</p>
<p>位置 0！</p>
<p>Inside the Directory File are the names of all the other files in storage.</p>
<p>目录文件里，存所有其他文件的名字</p>
<p>In our example, they each have a name, followed by a period</p>
<p>格式是文件名 + 一个句号 + </p>
<p>and end with what's called a File Extension, like "BMP" or "WAV".</p>
<p>扩展名，比如 BMP 或 WAV</p>
<p>Those further assist programs in identifying file types.</p>
<p>扩展名帮助得知文件类型</p>
<p>The Directory File also stores metadata about these files, like when they were created and</p>
<p>目录文件还存文件的元数据，比如创建时间</p>
<p>last modified, who the owner is, and if it can be read, written or both.</p>
<p>最后修改时间，文件所有者是谁，是否能读/写或读写都行</p>
<p>But most importantly, the directory file contains where these files</p>
<p>最重要的是，目录文件有</p>
<p>begin in storage, and how long they are.</p>
<p>文件起始位置和长度</p>
<p>If we want to add a file, remove a file, change a filename, or similar,</p>
<p>如果要添加文件，删除文件，更改文件名等</p>
<p>we have to update the information in the Directory File.</p>
<p>必须更新目录文件</p>
<p>It's like the Table of Contents in a book, if you make a chapter shorter, or move it</p>
<p>就像书的目录，如果缩短或移动了一个章节，</p>
<p>somewhere else, you have to update the table of contents, otherwise the page numbers won't match!</p>
<p>要更新目录，不然页码对不上</p>
<p>The Directory File, and the maintenance of it, is an example of a very basic File System,</p>
<p>目录文件，以及对目录文件的管理，是一个非常简单的文件系统例子</p>
<p>the part of an Operating System that manages and keep track of stored files.</p>
<p>文件系统专门负责管理文件</p>
<p>This particular example is a called a Flat File System, because they're all stored at one level.</p>
<p>刚刚的例子叫"平面文件系统" ，因为文件都在同一个层次</p>
<p>It's flat!</p>
<p>平的！</p>
<p>Of course, packing files together, back-to-back, is a bit of a problem,</p>
<p>当然，把文件前后排在一起有个问题</p>
<p>because if we want to add some data to let's say "todo.txt",</p>
<p>如果给 todo.txt 加一点数据，</p>
<p>there's no room to do it without overwriting part of "carrie.bmp".</p>
<p>会覆盖掉后面 carrie.bmp 的一部分</p>
<p>So modern File Systems do two things.</p>
<p>所以现代文件系统会做两件事</p>
<p>First, they store files in blocks.</p>
<p>1 把空间划分成一块块，</p>
<p>This leaves a little extra space for changes, called slack space.</p>
<p>导致有一些 "预留空间" 可以方便改动</p>
<p>It also means that all file data is aligned to a common size, which simplifies management.</p>
<p>同时也方便管理</p>
<p>In a scheme like this, our Directory File needs to keep track of</p>
<p>用这样的方案，</p>
<p>what block each one is stored in.</p>
<p>目录文件要记录文件在哪些块里</p>
<p>The second thing File Systems do, is allow files to be broken up into chunks</p>
<p>2 拆分文件，</p>
<p>and stored across many blocks.</p>
<p>存在多个块里</p>
<p>So let's say we open "todo.txt", and we add a few more items then the file becomes</p>
<p>假设打开 todo.txt 加了些内容，</p>
<p>too big to be saved in its one block.</p>
<p>文件太大存不进一块里</p>
<p>We don't want to overwrite the neighboring one, so instead, the File System allocates</p>
<p>我们不想覆盖掉隔壁的块，所以文件系统会分配，</p>
<p>an unused block, which can accommodate extra data.</p>
<p>一个没使用的块，容纳额外的数据</p>
<p>With a File System scheme like this, the Directory File needs to store</p>
<p>目录文件会记录不止一个块，</p>
<p>not just one block per file, but rather a list of blocks per file.</p>
<p>而是多个块</p>
<p>In this way, we can have files of variable sizes that can be easily</p>
<p>只要分配块，</p>
<p>expanded and shrunk, simply by allocating and deallocating blocks.</p>
<p>文件可以轻松增大缩小</p>
<p>If you watched our episode on Operating Systems, this should sound a lot like Virtual Memory.</p>
<p>如果你看了第18集操作系统，这听起来很像"虚拟内存"</p>
<p>Conceptually it's very similar!</p>
<p>概念上讲的确很像！</p>
<p>Now let's say we want to delete "carrie.bmp".</p>
<p>假设想删掉 carrie.bmp，</p>
<p>To do that, we can simply remove the entry from the Directory File.</p>
<p>只需要在目录文件删掉那条记录</p>
<p>This, in turn, causes one block to become free.</p>
<p>让一块空间变成了可用</p>
<p>Note that we didn't actually erase the file's data in storage, we just deleted the record of it.</p>
<p>注意这里没有擦除数据，只是把记录删了</p>
<p>At some point, that block will be overwritten with new data, but until then, it just sits there.</p>
<p>之后某个时候，那些块会被新数据覆盖，但在此之前，数据还在原处</p>
<p>This is one way that computer forensic teams can "recover" data from computers even</p>
<p>所以计算机取证团队可以"恢复"数据</p>
<p>though people think it has been deleted. Crafty!</p>
<p>虽然别人以为数据已经"删了", 狡猾！</p>
<p>Ok, let's say we add even more items to our todo list, which causes the File System</p>
<p>假设往 todo.txt 加了更多数据，</p>
<p>to allocate yet another block to the file, in this case,</p>
<p>所以操作系统分配了一个新块，</p>
<p>recycling the block freed from carrie.bmp.</p>
<p>用了刚刚 carrie.bmp 的块</p>
<p>Now our "todo.txt" is stored across 3 blocks, spaced apart, and also out of order.</p>
<p>现在 todo.txt 在 3 个块里，隔开了，顺序也是乱的</p>
<p>Files getting broken up across storage like this is called fragmentation.</p>
<p>这叫碎片</p>
<p>It's the inevitable byproduct of files being created, deleted and modified.</p>
<p>碎片是增/删/改文件导致的，不可避免</p>
<p>For many storage technologies, this is bad news.</p>
<p>对很多存储技术来说，碎片是坏事</p>
<p>On magnetic tape, reading todo.txt into memory would require</p>
<p>如果 todo.txt 存在磁带上，读取文件要</p>
<p>seeking to block 1, then fast forwarding to block 5, and then rewinding to block 3</p>
<p>先读块1, 然后快进到块5，然后往回转到块2</p>
<p>that's a lot of back and forth!</p>
<p>来回转个半天</p>
<p>In real world File Systems, large files might be stored across hundreds of blocks,</p>
<p>现实世界中，大文件可能存在数百个块里</p>
<p>and you don't want to have to wait five minutes for your files to open.</p>
<p>你可不想等五分钟才打开文件</p>
<p>The answer is defragmentation!</p>
<p>答案是碎片整理！</p>
<p>That might sound like technobabble, but the process is really simple,</p>
<p>这个词听起来好像很复杂，但实际过程很简单</p>
<p>and once upon a time it was really fun to watch!</p>
<p>以前看计算机做碎片整理真的很有趣！</p>
<p>The computer copies around data so that files have blocks located together</p>
<p>计算机会把数据来回移动，</p>
<p>in storage and in the right order.</p>
<p>排列成正确的顺序</p>
<p>After we've defragged, we can read our todo file,</p>
<p>整理后 todo.txt 在 1 2 3，</p>
<p>now located in blocks 1 through 3, in a single, quick read pass.</p>
<p>方便读取.</p>
<p>So far, we've only been talking about Flat File Systems,</p>
<p>目前只说了平面文件系统，</p>
<p>where they're all stored in one directory.</p>
<p>文件都在同一个目录里.</p>
<p>This worked ok when computers only had a little bit of storage,</p>
<p>如果存储空间不多，这可能就够用了，</p>
<p>and you might only have a dozen or so files.</p>
<p>因为只有十几个文件</p>
<p>But as storage capacity exploded, like we discussed last episode,</p>
<p>但上集说过，容量爆炸式增长，</p>
<p>so did the number of files on computers.</p>
<p>文件数量也飞速增长</p>
<p>Very quickly, it became impractical to store all files together at one level.</p>
<p>很快，所有文件都存在同一层变得不切实际</p>
<p>Just like documents in the real world, it's handy to store related files together in folders.</p>
<p>就像现实世界，相关文件放在同一个文件夹会方便很多</p>
<p>Then we can put connected folders into folders, and so on.</p>
<p>然后文件夹套文件夹.</p>
<p>This is a Hierarchical File System, and its what your computer uses.</p>
<p>这叫"分层文件系统"，你的计算机现在就在用这个.</p>
<p>There are a variety of ways to implement this, but let's stick with the File System example</p>
<p>实现方法有很多种，</p>
<p>we've been using to convey the main idea.</p>
<p>我们用之前的例子来讲重点好了</p>
<p>The biggest change is that our Directory File needs to be able to point not just to files,</p>
<p>最大的变化是目录文件不仅要指向文件,</p>
<p>but also other directories.</p>
<p>还要指向目录</p>
<p>To keep track of what's a file and what's a directory, we need some extra metadata.</p>
<p>我们需要额外元数据来区分开文件和目录，</p>
<p>This Directory File is the top-most one, known as the Root Directory.</p>
<p>这个目录文件在最顶层，因此叫根目录</p>
<p>All other files and folders lie beneath this directory along various file paths.</p>
<p>所有其他文件和文件夹，都在根目录下</p>
<p>We can see inside of our "Root" Directory File that we have 3 files</p>
<p>图中可以看到根目录文件有3个文件，</p>
<p>and 2 subdirectories: music and photos.</p>
<p>2个子文件夹："音乐"和"照片"</p>
<p>If we want to see what's stored in our music directory, we have to go to that block and</p>
<p>如果想知道"音乐"文件夹里有什么，</p>
<p>read the Directory File located there; the format is the same as our root directory.</p>
<p>必须去那边读取目录文件（格式和根目录文件一样）</p>
<p>There's a lot of great songs in there!</p>
<p>有很多好歌啊！</p>
<p>In addition to being able to create hierarchies of unlimited depth,</p>
<p>除了能做无限深度的文件夹，</p>
<p>this method also allows us to easily move around files.</p>
<p>这个方法也让我们可以轻松移动文件</p>
<p>So, if we wanted to move "theme.wav" from our root directory to the music directory,</p>
<p>如果想把 theme.wav 从根目录移到音乐目录</p>
<p>we don't have to re-arrange any blocks of data.</p>
<p>不用移动任何数据块</p>
<p>We can simply modify the two Directory Files, removing an entry from one and adding it to another.</p>
<p>只需要改两个目录文件，一个文件里删一条记录，另一个文件里加一条记录</p>
<p>Importantly, the theme.wav file stays in block 5.</p>
<p>theme.wav 依然在块5</p>
<p>So that's a quick overview of the key principles of File Systems.</p>
<p>文件系统的几个重要概念现在介绍完了.</p>
<p>They provide yet another way to move up a new level of abstraction.</p>
<p>它提供了一层新抽象！</p>
<p>File systems allow us to hide the raw bits stored on magnetic tape, spinning disks and</p>
<p>文件系统使我们不必关心，文件在磁带或磁盘的具体位置</p>
<p>the like, and they let us think of data as neatly organized and easily accessible files.</p>
<p>整理和访问文件更加方便</p>
<p>We even started talking about users, not programmers, manipulating data,</p>
<p>我们像普通用户一样直观操纵数据，</p>
<p>like opening files and organizing them,</p>
<p>比如打开和整理文件</p>
<p>foreshadowing where the series will be going in a few episodes.</p>
<p>接下来几集也会从用户角度看问题</p>
<p>I'll see  you next week.</p>
<p>下周见</p>
<p>This episode is brought to you by Curiosity Stream.</p>
<p>本集由 Curiosity Stream 赞助播出</p>
<p>21 压缩</p>
<p>Compression</p>
<p>Hi, I'm Carrie Anne, and welcome to Crash Course Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>Last episode we talked about Files, bundles of data, stored on a computer, that</p>
<p>上集我们讨论了文件格式，</p>
<p>are formatted and arranged to encode information, like text, sound or images.</p>
<p>如何编码文字，声音，图片</p>
<p>We even discussed some basic file formats, like text, wave, and bitmap.</p>
<p>还举了具体例子 .txt .wav .bmp</p>
<p>While these formats are perfectly fine and still used today,</p>
<p>这些格式虽然管用，而且现在还在用，</p>
<p>their simplicity also means they're not very efficient.</p>
<p>但它们的简单性意味着效率不高</p>
<p>Ideally, we want files to be as small as possible, so we can store lots of them without filling</p>
<p>我们希望文件能小一点，</p>
<p>up our hard drives, and also transmit them more quickly.</p>
<p>这样能存大量文件，传输也会快一些</p>
<p>Nothing is more frustrating than waiting for an email attachment to download. Ugh!</p>
<p>等邮件附件下载烦死人了</p>
<p>The answer is compression, which literally squeezes data into a smaller size.</p>
<p>解决方法是压缩，把数据占用的空间压得更小</p>
<p>To do this, we have to encode data using fewer bits than the original representation.</p>
<p>用更少的位(bit)来表示数据</p>
<p>That might sound like magic, but it's actually computer science!</p>
<p>听起来像魔法，但其实是计算机科学！</p>
<p>Lets return to our old friend from last episode, Mr. Pac-man!</p>
<p>我们继续用上集的吃豆人例子，</p>
<p>This image is 4 pixels by 4 pixels.</p>
<p>图像是 4像素x4像素</p>
<p>As we discussed, image data is typically stored as a list of pixel values.</p>
<p>之前说过，图像一般存成一长串像素值</p>
<p>To know where rows end, image files have metadata, which defines properties like dimensions.</p>
<p>为了知道一行在哪里结束，图像要有元数据，写明尺寸等属性</p>
<p>But, to keep it simple today, we're not going to worry about it.</p>
<p>但为了简单起见，今天忽略这些细节</p>
<p>If you mix full intensity red, green and blue that's 255 for all</p>
<p>如果红绿蓝都是 255 </p>
<p>three values you get the color white.</p>
<p>会得到白色</p>
<p>If you mix full intensity red and green, but no blue (it's 0), you get yellow.</p>
<p>如果混合 255红色和255绿色，会得到黄色</p>
<p>We have 16 pixels in our image, and each of those needs 3 bytes of color data.</p>
<p>这个图像有16个像素(4x4),  每个像素3个字节</p>
<p>That means this image's data will consume 48 bytes of storage.</p>
<p>总共占48个字节（16x3=48）</p>
<p>But, we can compress the data and pack it into a smaller number of bytes than 48!</p>
<p>但我们可以压缩到少于 48 个字节</p>
<p>One way to compress data is to reduce repeated or redundant information.</p>
<p>一种方法是减少重复信息</p>
<p>The most straightforward way to do this is called Run-Length Encoding.</p>
<p>最简单的方法叫游程编码(Run-Length Encoding)</p>
<p>This takes advantage of the fact that there are often runs of identical values in files.</p>
<p>适合经常出现相同值的文件</p>
<p>For example, in our pac-man image, there are 7 yellow pixels in a row.</p>
<p>比如吃豆人有7个连续黄色像素</p>
<p>Instead of encoding redundant data: yellow pixel, yellow pixel, yellow pixel, and so</p>
<p>与其全存下来：黄色，黄色，黄色...</p>
<p>on, we can just say "there's 7 yellow pixels in a row" by inserting</p>
<p>可以插入一个额外字节，</p>
<p>an extra byte that specifies the length of the run, like so:</p>
<p>代表有7个连续黄色像素</p>
<p>And then we can eliminate the redundant data behind it.</p>
<p>然后删掉后面的重复数据.</p>
<p>To ensure that computers don't get confused with which bytes are run lengths and which</p>
<p>为了让计算机能分辨哪些字节是"长度" </p>
<p>bytes represent color, we have to be consistent in how we apply this scheme.</p>
<p>哪些字节是"颜色"，格式要一致</p>
<p>So, we need to preface all pixels with their run-length.</p>
<p>所以我们要给所有像素前面标上长度</p>
<p>In some cases, this actually adds data, but on the whole, we've dramatically reduced</p>
<p>有时候数据反而会变多，但就这个例子而言</p>
<p>the number of bytes we need to encode this image.</p>
<p>我们大大减少了字节数，</p>
<p>We're now at 24 bytes, down from 48.</p>
<p>之前是48 现在是24</p>
<p>That's 50% smaller!</p>
<p>小了50％！</p>
<p>A huge saving!</p>
<p>省了很多空间！</p>
<p>Also note that we haven't lost any data.</p>
<p>还有，我们没有损失任何数据，</p>
<p>We can easily expand this back to the original form without any degradation.</p>
<p>我们可以轻易恢复到原来的数据</p>
<p>A compression technique that has this characteristic is called</p>
<p>这叫"无损压缩"，</p>
<p>lossless compression, because we don't lose anything.</p>
<p>没有丢失任何数据</p>
<p>The decompressed data is identical to the original before compression, bit for bit.</p>
<p>解压缩后，数据和压缩前完全一样</p>
<p>Let's take a look at another type of lossless compression, where</p>
<p>我们来看另一种无损压缩，</p>
<p>blocks of data are replaced by more compact representations.</p>
<p>它用更紧凑的方式表示数据块</p>
<p>This is sort of like " don't forget to be awesome " being replaced by DFTBA.</p>
<p>有点像 "别忘了变厉害" 简写成 DFTBA</p>
<p>To do this, we need a dictionary that stores the mapping from codes to data.</p>
<p>为此，我们需要一个字典，存储"代码"和"数据"间的对应关系</p>
<p>Lets see how this works for our example.</p>
<p>我们看个例子</p>
<p>We can view our image as not just a string of individual pixels,</p>
<p>我们可以把图像看成一块块，</p>
<p>but as little blocks of data.</p>
<p>而不是一个个像素</p>
<p>For simplicity, we're going to use pixel pairs, which are 6 bytes long,</p>
<p>为了简单，我们把2个像素当成1块（占6个字节）</p>
<p>but blocks can be any size.</p>
<p>但你也可以定成其他大小</p>
<p>In our example, there are only four pairings: White-yellow, black-yellow,</p>
<p>我们只有四对： 白黄黑黄 </p>
<p>yellow-yellow and white-white.</p>
<p>黄黄白白</p>
<p>Those are the data blocks in our dictionary we want to generate compact codes for.</p>
<p>我们会为这四对生成紧凑代码(compact codes)</p>
<p>What's interesting, is that these blocks occur at different frequencies.</p>
<p>有趣的是，这些块的出现频率不同</p>
<p>One method for generating efficient codes is building a Huffman Tree, invented by David</p>
<p>1950年代大卫·霍夫曼发明了一种高效编码方式叫，"霍夫曼树"（Huffman Tree）</p>
<p>Huffman while he was a student at MIT in the 1950s.</p>
<p>当时他是麻省理工学院的学生</p>
<p>His algorithm goes like this.</p>
<p>算法是这样的</p>
<p>First, you layout all the possible blocks and their frequencies.</p>
<p>首先，列出所有块和出现频率，</p>
<p>At every round, you select the two with the lowest frequencies.</p>
<p>每轮选两个最低的频率</p>
<p>Here, that's Black-Yellow and White-White, each with a frequency of 1.</p>
<p>这里黑黄和 白白的频率最低，它们都是 1</p>
<p>You combine these into a little tree. which have a combined frequency of 2,</p>
<p>可以把它们组成一个树，</p>
<p>so we record that.</p>
<p>总频率 2</p>
<p>And now one step of the algorithm done.</p>
<p>现在完成了一轮算法</p>
<p>Now we repeat the process.</p>
<p>现在我们重复这样做</p>
<p>This time we have three things to choose from.</p>
<p>这次有3个可选</p>
<p>Just like before, we select the two with the lowest frequency, put them into a little tree,</p>
<p>就像上次一样，选频率最低的两个，</p>
<p>and record the new total frequency of all the sub items.</p>
<p>放在一起，并记录总频率</p>
<p>Ok, we're almost done.</p>
<p>好，我们快完成了</p>
<p>This time it's easy to select the two items with the lowest frequency</p>
<p>这次很简单，</p>
<p>because there are only two things left to pick.</p>
<p>因为只有2个选择</p>
<p>We combine these into a tree, and now we're done!</p>
<p>把它们组合成一棵树就完成了！</p>
<p>Our tree looks like this, and it has a very cool property: it's arranged by frequency,</p>
<p>现在看起来像这样，它有一个很酷的属性：按频率排列</p>
<p>with less common items lower down.</p>
<p>频率低的在下面</p>
<p>So, now we have a tree, but you may be wondering how this gets us to a dictionary.</p>
<p>现在有了一棵树，你可能在想  "怎么把树变成字典？"</p>
<p>Well, we use our frequency-sorted tree to generate the codes we need</p>
<p>我们可以把每个分支用 0 和 1 标注，</p>
<p>by labeling each branch with a 0 or a 1, like so.</p>
<p>就像这样</p>
<p>With this, we can write out our code dictionary.</p>
<p>现在可以生成字典</p>
<p>Yellow-yellow is encoded as just a single 0.  White-yellow is encoded as 10</p>
<p>黄黄编码成 0 ，白黄编码成 10，</p>
<p>Black-Yellow is 1 1 0. and finally white-white is 1 1 1.</p>
<p>黑黄编码成 110，白白编码成 111</p>
<p>The really cool thing about these codewords is that there's no way to</p>
<p>酷的地方是它们绝对不会冲突</p>
<p>have conflicting codes, because each path down the tree is unique.</p>
<p>因为树的每条路径是唯一的</p>
<p>This means our codes are prefix-free, that is no code starts with another complete code.</p>
<p>意味着代码是"无前缀"的，没有代码是以另一个代码开头的</p>
<p>Now, let's return to our image data and compress it!</p>
<p>现在我们来压缩！</p>
<p>NOT BYTES -BITS!! That's less than 2 bytes of data!</p>
<p>注意是位(bit)！ 不是字节(byte)！，14位(bit) 还不到2个字节(byte)！</p>
<p>But, don't break out the champagne quite yet!</p>
<p>但，先别急着开香槟！</p>
<p>This data is meaningless unless we also save our code dictionary.</p>
<p>字典也要保存下来，否则 14 bit 毫无意义</p>
<p>So, we'll need to append it to the front of the image data, like this.</p>
<p>所以我们把字典加到 14 bit 前面，就像这样</p>
<p>Now, including the dictionary, our image data is 30 bytes long.</p>
<p>现在加上字典，图像是 30 个字节(bytes) ，</p>
<p>That's still a significant improvement over 48 bytes.</p>
<p>比 48 字节好很多</p>
<p>The two approaches we discussed,</p>
<p>"消除冗余"和"用更紧凑的表示方法"，</p>
<p>removing redundancies and using more compact representations, are often combined,</p>
<p>这两种方法通常会组合使用</p>
<p>and underlie almost all lossless compressed file formats,</p>
<p>几乎所有无损压缩格式都用了它们，</p>
<p>like GIF, PNG, PDF and ZIP files.</p>
<p>比如 GIF, PNG, PDF, ZIP</p>
<p>Both run-length encoding and dictionary coders are lossless compression techniques.</p>
<p>游程编码和 字典编码都是无损压缩</p>
<p>No information is lost; when you decompress, you get the original file.</p>
<p>压缩时不会丢失信息，解压后，数据和之前完全一样</p>
<p>That's really important for many types of files.</p>
<p>无损对很多文件很重要</p>
<p>Like, it'd be very odd if I zipped up a word document to send to you,</p>
<p>比如我给你发了个压缩的 word 文档，</p>
<p>and when you decompressed it on your computer, the text was different.</p>
<p>你解压之后发现内容变了，这就很糟糕了</p>
<p>But, there are other types of files where we can get away with little changes, perhaps</p>
<p>但其他一些文件，丢掉一些数据没什么关系</p>
<p>by removing unnecessary or less important information, especially information</p>
<p>丢掉那些人类</p>
<p>that human perception is not good at detecting.</p>
<p>看不出区别的数据</p>
<p>And this trick underlies most lossy compression techniques.</p>
<p>大多数有损压缩技术，都用到了这点</p>
<p>These tend to be pretty complicated, so we're going to attack this at a conceptual level.</p>
<p>实际细节比较复杂，所以我们讲概念就好</p>
<p>Let's take sound as an example.</p>
<p>以声音为例，</p>
<p>Your hearing is not perfect.</p>
<p>你的听力不是完美的</p>
<p>We can hear some frequencies of sound better than others.</p>
<p>有些频率我们很擅长，</p>
<p>And there are some we can't hear at all, like ultrasound.</p>
<p>其他一些我们根本听不见，比如超声波</p>
<p>Unless you're a bat.</p>
<p>除非你是蝙蝠</p>
<p>Basically, if we make a recording of music, and there's data in the ultrasonic frequency range,</p>
<p>举个例子，如果录音乐，</p>
<p>we can discard it, because we know that humans can't hear it.</p>
<p>超声波数据都可以扔掉，因为人类听不到超声波</p>
<p>On the other hand, humans are very sensitive to frequencies in the vocal range, like people</p>
<p>另一方面，人类对人声很敏感，</p>
<p>singing, so it's best to preserve quality there as much as possible.</p>
<p>所以应该尽可能保持原样</p>
<p>Deep bass is somewhere in between.</p>
<p>低音介于两者之间，</p>
<p>Humans can hear it, but we're less attuned to it.</p>
<p>人类听得到，但不怎么敏感</p>
<p>We mostly sense it.</p>
<p>一般是感觉到震动</p>
<p>Lossy audio compressors takes advantage of this, and encode different</p>
<p>有损音频压缩利用这一点，</p>
<p>frequency bands at different precisions.</p>
<p>用不同精度编码不同频段</p>
<p>Even if the result is rougher, it's likely that users won't perceive the difference.</p>
<p>听不出什么区别，</p>
<p>Or at least it doesn't dramatically affect the experience.</p>
<p>不会明显影响体验</p>
<p>And here comes the hate mail from the audiophiles!</p>
<p>音乐发烧友估计要吐槽了！</p>
<p>You encounter this type of audio compression all the time.</p>
<p>日常生活中你会经常碰到这类音频压缩</p>
<p>It's one of the reasons you sound different on a cellphone versus in person.</p>
<p>所以你在电话里的声音和现实中不一样</p>
<p>The audio data is being compressed, allowing more people to take calls at once.</p>
<p>压缩音频是为了让更多人能同时打电话</p>
<p>As the signal quality or bandwidth get worse, compression algorithms remove more data,</p>
<p>如果网速变慢了，压缩算法会删更多数据</p>
<p>further reducing precision, which is why Skype calls sometimes sound like robots talking.</p>
<p>进一步降低声音质量，所以 Skype 通话有时听起来像机器人</p>
<p>Compared to an uncompressed audio format, like a WAV or FLAC (there we go, got the audiophiles back)</p>
<p>和没压缩的音频格式相比，比如 WAV 或 FLAC，( 这下音乐发烧友满意了）</p>
<p>compressed audio files, like MP3s, are often 10 times smaller.</p>
<p>压缩音频文件如 MP3，能小10倍甚至更多.</p>
<p>That's a huge saving!</p>
<p>省了超多空间！</p>
<p>And it's why I've got a killer music collection on my retro iPod.</p>
<p>所以我的旧 iPod 上有一堆超棒的歌</p>
<p>Don't judge.</p>
<p>别批判我</p>
<p>This idea of discarding or reducing precision in a manner that aligns with human perception</p>
<p>这种删掉人类无法感知的数据的方法，</p>
<p>is called perceptual coding,</p>
<p>叫"感知编码"</p>
<p>and it relies on models of human perception,</p>
<p>它依赖于人类的感知模型，</p>
<p>which come from a field of study called Psychophysics.</p>
<p>模型来自"心理物理学"领域</p>
<p>This same idea is the basis of lossy compressed image formats, most famously JPEGs.</p>
<p>这是各种"有损压缩图像格式"的基础，最著名的是 JPEG</p>
<p>Like hearing, the human visual system is imperfect.</p>
<p>就像听力一样，人的视觉系统也不是完美的.</p>
<p>We're really good at detecting sharp contrasts, like the edges of objects,</p>
<p>我们善于看到尖锐对比，比如物体的边缘</p>
<p>but our perceptual system isn't so hot with subtle color variations.</p>
<p>但我们看不出颜色的细微变化</p>
<p>JPEG takes advantage of this by breaking images up into blocks of 8x8 pixels,</p>
<p>JPEG 利用了这一点，把图像分解成 8x8 像素块</p>
<p>then throwing away a lot of the high-frequency spatial data.</p>
<p>然后删掉大量高频率空间数据</p>
<p>For example, take this photo of our directors dog Noodle.</p>
<p>举个例子，这是导演的狗，面面</p>
<p>So cute!</p>
<p>超可爱！</p>
<p>Let's look at a patch of 8x8 pixels.</p>
<p>我们来看其中一个 8x8 像素</p>
<p>Pretty much every pixel is different from its neighbor,</p>
<p>几乎每个像素都和相邻像素不同，</p>
<p>making it hard to compress with loss-less techniques because there's just a lot going on.</p>
<p>用无损技术很难压缩，因为太多不同点了</p>
<p>Lots of little details.</p>
<p>很多小细节</p>
<p>But human perception doesn't register all those details.</p>
<p>但人眼看不出这些细节</p>
<p>So, we can discard a lot of that detail, and replace it with a simplified patch like this.</p>
<p>因此可以删掉很多，用这样一个简单的块来代替</p>
<p>This maintains the visual essence, but might only use 10% of the data.</p>
<p>这看起来一样，但可能只占10％的原始数据</p>
<p>We can do this for all the patches in the image and get this result.</p>
<p>我们可以对所有 8x8 块做一样的操作</p>
<p>You can still see it's a dog, but the image is rougher.</p>
<p>图片依然可以认出是一只狗，只是更粗糙一些</p>
<p>So, that's an extreme example, going from a slightly compressed JPEG to a highly compressed one,</p>
<p>以上例子比较极端，进行了高度压缩，</p>
<p>one-eighth the original file size.</p>
<p>只有原始大小的八分之一</p>
<p>Often, you can get away with a quality somewhere in between, and perceptually,</p>
<p>通常你可以取得平衡，图片看起来差不多，</p>
<p>it's basically the same as the original.</p>
<p>但文件小不少</p>
<p>Can you tell the difference between the two?</p>
<p>你看得出两张图的区别吗？</p>
<p>Probably not, but I should mention that video compression plays a role in that too,</p>
<p>估计看不出，但我想提一下，视频压缩也造成了影响</p>
<p>since I'm literally being compressed in a video right now.</p>
<p>毕竟你现在在看视频啊</p>
<p>Videos are really just long sequences of images, so a lot of what I said</p>
<p>视频只是一长串连续图片，</p>
<p>about them applies here too.</p>
<p>所以图片的很多方面也适用于视频</p>
<p>But videos can do some extra clever stuff, because between frames,</p>
<p>但视频可以做一些小技巧，因为帧和帧之间很多像素一样</p>
<p>a lot of pixels are going to be the same.</p>
<p>但视频可以做一些小技巧，因为帧和帧之间很多像素一样</p>
<p>Like this whole background behind me!</p>
<p>比如我后面的背景！</p>
<p>This is called temporal redundancy.</p>
<p>这叫时间冗余</p>
<p>We don't need to re-transmit those pixels every frame of the video.</p>
<p>视频里不用每一帧都存这些像素，</p>
<p>We can just copy patches of data forward.</p>
<p>可以只存变了的部分</p>
<p>When there are small pixel differences, like the readout on this frequency generator behind me,</p>
<p>当帧和帧之间有小小的差异时，比如后面这个频率发生器</p>
<p>most video formats send data that encodes just the difference between patches,</p>
<p>很多视频编码格式，只存变化的部分</p>
<p>which is more efficient than re-transmitting all the pixels afresh, again taking advantage</p>
<p>这比存所有像素更有效率，</p>
<p>of inter-frame similarity.</p>
<p>利用了帧和帧之间的相似性</p>
<p>The fanciest video compression formats go one step further.</p>
<p>更高级的视频压缩格式会更进一步</p>
<p>They find patches that are similar between frames, and not only copy them forward, with</p>
<p>找出帧和帧之间相似的补丁，</p>
<p>or without differences, but also can apply simple effects to them, like a shift or rotation.</p>
<p>然后用简单效果实现，比如移动和旋转</p>
<p>They can also lighten or darken a patch between frames.</p>
<p>变亮和变暗</p>
<p>So, if I move my hand side to side like this the video compressor will identify the similarity,</p>
<p>如果我这样摆手，视频压缩器会识别到相似性</p>
<p>capture my hand in one or more patches, then just move these patches around between frames.</p>
<p>用一个或多个补丁代表我的手，然后帧之间直接移动这些补丁</p>
<p>You're actually seeing my hand from the past kinda freaky, but it uses a lot less data.</p>
<p>所以你看到的是我过去的手（不是实时的），有点可怕但数据量少得多</p>
<p>MPEG-4 videos, a common standard, are often 20 to 200 times</p>
<p>MPEG-4 是常见标准，</p>
<p>smaller than the original, uncompressed file.</p>
<p>可以比原文件小20倍到200倍</p>
<p>However, encoding frames as translations and rotations of patches from previous frames</p>
<p>但用补丁的移动和旋转来更新画面</p>
<p>can go horribly wrong when you compress too heavily, and there isn't</p>
<p>当压缩太严重时会出错，</p>
<p>enough space to update pixel data inside of the patches.</p>
<p>没有足够空间更新补丁内的像素</p>
<p>The video player will forge ahead, applying the right motions,</p>
<p>即使补丁是错的，</p>
<p>even if the patch data is wrong.</p>
<p>视频播放器也会照样播放</p>
<p>And this leads to some hilarious and trippy effects, which I'm sure you've seen.</p>
<p>导致一些怪异又搞笑的结果，你肯定见过这些.</p>
<p>Overall, it's extremely useful to have compression techniques for all the types of data I discussed today.</p>
<p>总的来说，压缩对大部分文件类型都有用</p>
<p>(I guess our imperfect vision and hearing are "useful," too.)</p>
<p>从这个角度来讲，人类不完美的视觉和听觉也算有用</p>
<p>And it's important to know about compression because it allows users to</p>
<p>学习压缩非常重要，因为可以高效</p>
<p>store pictures, music, and videos in efficient ways.</p>
<p>存储图片，音乐，视频</p>
<p>Without it, streaming your favorite Carpool Karaoke videos on YouTube would be nearly impossible,</p>
<p>如果没有压缩，在 YouTube 看"明星拼车唱歌"几乎不可能</p>
<p>due to bandwidth and the economics of transmitting that volume of data for free.</p>
<p>因为你的带宽可能不够（会很卡），而且供应商不愿意免费传输那么多数据</p>
<p>And now when your Skype calls sound like they're being taken over by demons,</p>
<p>现在你知道为什么打 Skype 电话，</p>
<p>you'll know what's really going on.</p>
<p>有时像在和恶魔通话</p>
<p>I'll see you next week.</p>
<p>下周见</p>
<p>22 命令行界面</p>
<p>Keyboards & Command Line Interfaces</p>
<p>Hi, I'm Carrie Anne, and welcome to CrashCourse Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>We've talked a lot about inputs and outputs in this series,</p>
<p>我们之前讨论过输入输出，</p>
<p>but they've mostly been between different parts of a computer</p>
<p>但都是计算机组件互相输入输出</p>
<p>like outputting data from RAM or inputting instructions to a CPU.</p>
<p>比如 RAM 输出数据，或输指令进 CPU</p>
<p>We haven't discussed much about inputs coming from humans.</p>
<p>我们还没讲来自人类的输入</p>
<p>We also haven't learned how people get information out of a computer,</p>
<p>也没讲怎么从电脑中拿出信息，</p>
<p>other than by printing or punching it onto paper.</p>
<p>除了用打孔纸卡</p>
<p>Of course, there's a wide variety of input and output devices that</p>
<p>当然，有很多种 "输入输出设备" ，</p>
<p>allow us users to communicate with computers.</p>
<p>让我们和计算机交互</p>
<p>They provide an interface between human and computer.</p>
<p>它们在人类和机器间提供了界面</p>
<p>And today, there's a whole field of study called Human-Computer Interaction.</p>
<p>如今有整个学科专门研究这个，叫 "人机交互"</p>
<p>These interfaces are so fundamental to the user experience</p>
<p>界面对用户体验非常重要，</p>
<p>that they're the focus of the next few episodes.</p>
<p>所以是我们接下来几集的重点</p>
<p>As we discussed at the very beginning of the series,</p>
<p>在系列开头的几集，我们提过</p>
<p>the earliest mechanical and electro-mechanical computing devices</p>
<p>早期机械计算设备，</p>
<p>used physical controls for inputs and outputs, like gears, knobs and switches,</p>
<p>用齿轮，旋钮和开关等机械结构来输入输出</p>
<p>and this was pretty much the extent of the human interface.</p>
<p>这些就是交互界面</p>
<p>Even the first electronic computers, like Colossus and ENIAC,</p>
<p>甚至早期电子计算机比如 Colossus 和 ENIAC</p>
<p>were configured using huge panels of mechanical controls and patch wires.</p>
<p>也是用一大堆机械面板和线来操作</p>
<p>It could take weeks to enter in a single program, let alone run it,</p>
<p>输入一个程序可能要几星期，还没提运行时间.</p>
<p>and to get data out after running a program, results were most often printed to paper.</p>
<p>运行完毕后想拿出数据，一般是打印到纸上</p>
<p>Paper printers were so useful</p>
<p>打印机超有用</p>
<p>that even Babbage designed one for his Difference Engine,</p>
<p>甚至查尔斯·巴贝奇都给差分机专门设计了一个</p>
<p>and that was in the 1820s!</p>
<p>那可是 1820 年代!</p>
<p>However, by the 1950s, mechanical inputs were rendered obsolete</p>
<p>然而，到 1950 年代，机械输入完全消失</p>
<p>by programs and data stored entirely on mediums like punch cards and magnetic tape.</p>
<p>因为出现了打孔纸卡和磁带</p>
<p>Paper printouts were still used for the final output,</p>
<p>但输出仍然是打印到纸上</p>
<p>and huge banks of indicator lights were developed</p>
<p>还有大量指示灯，</p>
<p>to provide real time feedback while the program was in progress.</p>
<p>在运行中提供实时反馈</p>
<p>It's important to recognize that computer input of this era was</p>
<p>那个时代的特点是 </p>
<p>designed to be as simple and robust as possible for computers.</p>
<p>尽可能迁就机器，</p>
<p>Ease and understanding for users was a secondary concern.</p>
<p>对人类好不好用是其次</p>
<p>Punch tape is a great example</p>
<p>打孔纸带就是个好例子</p>
<p>this was explicitly designed to be easy for computers to read.</p>
<p>就是为了方便计算机读取</p>
<p>The continuous nature of tape made it easy to handle mechanically,</p>
<p>纸带是连续的，方便机器处理</p>
<p>and the holes could be reliably detected with a mechanical or optical system,</p>
<p>纸孔可以方便地用机械或光学手段识别</p>
<p>which encoded instructions and data.</p>
<p>纸孔可以编码程序和数据</p>
<p>But of course, humans don't think in terms of little punched holes on strips of paper.</p>
<p>当然, 人类不是以纸孔方式思考的.</p>
<p>So, the burden was on programmers.</p>
<p>所以负担放到了程序员身上</p>
<p>They had to spend the extra time and effort to convert their ideas and programs</p>
<p>他们要花额外时间和精力，</p>
<p>into a language and a format that was easy for computers of the era to understand</p>
<p>转成计算机能理解的格式</p>
<p>often with the help of additional staff and auxiliary devices.</p>
<p>一般需要额外人员和设备帮忙</p>
<p>It's also important to note that early computers, basically pre-1950,</p>
<p>要注意的是，基本上 1950 年前的早期计算机，</p>
<p>had an extremely simple notion of human input.</p>
<p>"输入"的概念很原始</p>
<p>Yes, humans input programs and data into computers,</p>
<p>是的，的确是人类负责输入程序和数据，</p>
<p>but these machines generally didn't respond interactively to humans.</p>
<p>但计算机不会交互式回应</p>
<p>Once a program was started, it typically ran until it was finished.</p>
<p>程序开始运行后会一直运行直到结束</p>
<p>That's because these machines were way too expensive to be</p>
<p>因为机器太贵了，</p>
<p>waiting around for humans to type a command or enter data.</p>
<p>不能等人类慢慢敲命令和给数据</p>
<p>Any input needed for a computation was fed in at the same time as the program.</p>
<p>要同时放入程序和数据</p>
<p>This started to change in the late 1950s.</p>
<p>这在 1950 年代晚期开始发生变化</p>
<p>On one hand, smaller-scale computers started to become cheap enough</p>
<p>一方面，小型计算机变得足够便宜</p>
<p>that it was feasible to have a human-in-the loop;</p>
<p>让人类来回和计算机交互变得可以接受</p>
<p>that is, a back and forth between human and computer.</p>
<p>交互式就是人和计算机之间来回沟通</p>
<p>And on the other hand,</p>
<p>而另一方面</p>
<p>big fancy computers became fast and sophisticated enough to support many programs and users at once,</p>
<p>大型计算机变得更快，能同时支持多个程序和多个用户</p>
<p>what were called multitasking and time-sharing systems .</p>
<p>这叫"多任务"和"分时系统"</p>
<p>But these computers needed a way to get input from users.</p>
<p>但交互式操作时，计算机需要某种方法来获得用户输入</p>
<p>For this, computers borrowed the ubiquitous data entry mechanism of the era: keyboards.</p>
<p>所以借用了当时已经存在的数据录入机制：键盘</p>
<p>At this point, typing machines had already been in use for a few centuries,</p>
<p>当时，打字机已经存在几个世纪了</p>
<p>but it was Christopher Latham Sholes, who invented the modern typewriter in 1868.</p>
<p>但现代打字机是，克里斯托弗·莱瑟姆·肖尔斯在 1868 年发明的</p>
<p>It took until 1874 to refine the design and manufacture it,</p>
<p>虽然到 1874 年才完成设计和制造</p>
<p>but it went on to be a commercial success.</p>
<p>但之后取得了商业成功</p>
<p>Sholes' typewriter adopted an unusual keyboard layout that you know well QWERTY</p>
<p>肖尔斯的打字机用了不寻常的布局，QWERTY</p>
<p>named for the top-left row of letter keys.</p>
<p>名字来自键盘左上角按键</p>
<p>There has been a lot of speculation as to why this design was used.</p>
<p>为什么这么设计有很多猜测</p>
<p>The most prevalent theory is that it put common letter pairings in English far apart</p>
<p>最流行的理论是这样设计是为了，</p>
<p>to reduce the likelihood of typebars jamming when entered in sequence.</p>
<p>把常见字母放得远一些，避免按键卡住</p>
<p>It's a convenient explanation, but it's also probably false,</p>
<p>这个解释虽然省事，但可能是错的，</p>
<p>or at least not the full story.</p>
<p>或至少不够全面</p>
<p>In fact, QWERTY puts many common letter pairs together,</p>
<p>事实上，QWERTY 把很多常见字母放在了一起，</p>
<p>like "TH" and "ER".</p>
<p>比如 TH 和 ER</p>
<p>And we know that Sholes and his team went through many iterations</p>
<p>我们知道肖尔斯和他的团队设计了很多版，</p>
<p>before arriving at this iconic arrangement.</p>
<p>才进化到这个布局</p>
<p>Regardless of the reason, the commercial success of Sholes' typewriter meant</p>
<p>总之，肖尔斯的打字机取得了成功，</p>
<p>the competitor companies that soon followed duplicated his design.</p>
<p>所以其它公司很快开始抄他的设计</p>
<p>Many alternative keyboard layouts have been proposed over the last century,</p>
<p>过去一个世纪有不少新的键盘布局被发明，</p>
<p>claiming various benefits.</p>
<p>宣称各种好处</p>
<p>But, once people had invested the time to learn QWERTY,</p>
<p>但人们已经熟悉了 QWERTY 布局，</p>
<p>they just didn't want to learn something new.</p>
<p>根本不想学新布局</p>
<p>This is what economists would call a switching barrier or switching cost.</p>
<p>这是经济学家所说的转换成本</p>
<p>And it's for this very basic human reason</p>
<p>所以现在都快1个半世纪了，我们还在用 QWERTY 键盘布局</p>
<p>that we still use QWERTY keyboards almost a century and a half later!</p>
<p>所以现在都快1个半世纪了，我们还在用 QWERTY 键盘布局</p>
<p>I should mention that QWERTY isn't universal.</p>
<p>我应该提一下，QWERTY 不是通用的</p>
<p>There are many international variants,</p>
<p>有很多变体，</p>
<p>like the French AZERTY layout,</p>
<p>比如法国 AZERTY 布局</p>
<p>or the QWERTZ layout common in central Europe.</p>
<p>以及中欧常见的 QWERTZ 布局</p>
<p>Interestingly, Sholes didn't envision that typing would ever be faster than handwriting,</p>
<p>有趣的是，肖尔斯根本没想到打字会比手写快</p>
<p>which is around 20 words per minute.</p>
<p>手写速度大约是每分钟 20 个</p>
<p>Typewriters were introduced chiefly for legibility and standardization of documents, not speed.</p>
<p>打字机主要为了易读性和标准化，而不是速度</p>
<p>However, as they became standard equipment in offices, the desire for speedy typing grew,</p>
<p>然而随着打字机成为办公室标配，对快速打字的渴望越来越大</p>
<p>and there were two big advances that unlocked typing's true potential.</p>
<p>有两个重大进步解放了打字的潜力</p>
<p>Around 1880, Elizabeth Longley, a teacher at the Cincinnati Shorthand and Type-Writer Institute,</p>
<p>1880年左右，辛辛那提速记学院，一名叫伊丽莎白·朗利的老师</p>
<p>started to promote ten-finger typing.</p>
<p>开始推广十指打字</p>
<p>This required much less finger movement than hunt-and-peck,</p>
<p>比一个手指打字要移动的距离短得多，</p>
<p>so it offered enhanced typing speeds.</p>
<p>所以速度更快</p>
<p>Then, a few years later, Frank Edward McGurrin, a federal court clerk in Salt Lake City,</p>
<p>几年后，弗兰克·爱德华·麦克格林，盐湖城的一位联邦法庭书记</p>
<p>taught himself to touch-type; as in, he didn't need to look at the keys while typing.</p>
<p>学会了盲打，打字时不用看键盘</p>
<p>In 1888, McGurrin won a highly publicized typing-speed contest,</p>
<p>1888年，麦格高林赢了备受关注的打字速度比赛</p>
<p>after which ten-finger, touch-typing began to catch on.</p>
<p>之后"十指盲打"开始流行</p>
<p>Professional typists were soon able to achieve speeds upwards of 100 words per minute,</p>
<p>专业打字员每分钟 100 字以上</p>
<p>much faster than handwriting!</p>
<p>比手写快多了！</p>
<p>And nice and neat too!</p>
<p>而且清晰又整洁！</p>
<p>So, humans are pretty good with typewriters,</p>
<p>虽然人类擅长用打字机</p>
<p>but we can't just plunk down a typewriter in front of a computer and have it type</p>
<p>但我们没法把打字机塞到计算机面前，让它打字</p>
<p>they have no fingers!</p>
<p>计算机又没有手指</p>
<p>Instead, early computers adapted a special type of typewriter that was used for telegraphs,</p>
<p>所以早期计算机用了一种特殊打字机，是专门用来发电报的,</p>
<p>called a teletype machine.</p>
<p>叫电传打字机</p>
<p>These were electromechanically-augmented typewriters</p>
<p>这些打字机是强化过的，</p>
<p>that can send and receive text over telegraph lines.</p>
<p>可以用电报线发送和接收文本</p>
<p>Pressing a letter on one teletype keyboard would cause a signal to be sent,</p>
<p>按一个字母，信号会通过电报线，</p>
<p>over telegraph wires, to a teletype machine on the other end,</p>
<p>发到另一端</p>
<p>which would then electromechanically type that letter.</p>
<p>另一端的电传打字机会打出来</p>
<p>This allowed two humans to type to one another over long distances.</p>
<p>使得两人可以长距离沟通</p>
<p>basically a steampunk version of a chat room.</p>
<p>基本是个蒸汽朋克版聊天室</p>
<p>Since these teletype machines already had an electronic interface,</p>
<p>因为电传打字机有电子接口，</p>
<p>they were easily adapted for computer use,</p>
<p>稍作修改就能用于计算机</p>
<p>and teletype computer interfaces were common in the 1960s and 70s.</p>
<p>电传交互界面在 1960~1970 很常见</p>
<p>Interaction was pretty straightforward.</p>
<p>用起来很简单</p>
<p>Users would type a command, hit enter, and then the computer would type back.</p>
<p>输入一个命令，按回车，然后计算机会输回来</p>
<p>This text "conversation" between a user and a computer went back and forth.</p>
<p>用户和计算机来回"对话"</p>
<p>These were called command line interfaces,</p>
<p>这叫"命令行界面"</p>
<p>and they remained the most prevalent form of human-computer interaction</p>
<p>它是最主要的人机交互方式，</p>
<p>up until around the 1980s.</p>
<p>一直到 1980 年代</p>
<p>Command Line interaction on a teletype machine looks something like this.</p>
<p>用电传打字机的命令行交互类似这样：</p>
<p>A user can type any number of possible commands.</p>
<p>用户可以输入各种命令</p>
<p>Let's check out a few,</p>
<p>我们来看几个命令，</p>
<p>beginning with seeing all of the files in the current directory we're in.</p>
<p>先看当前目录有什么文件</p>
<p>For this, we would type the command, "ls", which is short for list,</p>
<p>输入命令 ls，名字来自 list 的缩写</p>
<p>and the computer replies with a list of the files in our current directory.</p>
<p>然后计算机会列出当前目录里的所有文件</p>
<p>If we want to see what's in our "secretStarTrekDiscoveryCast.txt.txt file",</p>
<p>如果想看 secretStarTrekDiscoveryCast.txt 有什么</p>
<p>we use yet another command to display the contents.</p>
<p>要用另一个命令显示文件内容</p>
<p>In unix, we can call "cat" short for concatenate.</p>
<p>unix 用 cat 命令显示文件内容，cat 是连接(concatenate)的缩写</p>
<p>We need to specify which file to display, so we include that after the command, called an argument.</p>
<p>然后指定文件名，指定的方法是写在 cat 命令后面，传给命令的值叫参数</p>
<p>If you're connected to a network with other users,</p>
<p>如果同一个网络里有其他人</p>
<p>you can use a primitive version of a Find My Friends app</p>
<p>你可以用 finger 命令找朋友，</p>
<p>to get more info on them with the command "finger".</p>
<p>就像是个很原始的"找朋友" App</p>
<p>Electromechanical teletype machines</p>
<p>电传打字机 </p>
<p>were the primary computing interface for most users up until around the 1970s.</p>
<p>直到1970年代左右都是主流交互方式</p>
<p>Although computer screens first emerged in the 1950s,</p>
<p>尽管屏幕最早出现在 1950 年代，</p>
<p>and were used for graphics they were too expensive and low resolution for everyday use.</p>
<p>但对日常使用太贵而且分辨率低</p>
<p>However, mass production of televisions for the consumer market, and general improvements</p>
<p>然而因为针对普通消费者的电视机开始量产，同时处理器与内存也在发展</p>
<p>in processors and memory, meant that by 1970, it was economically viable</p>
<p>到1970年代，屏幕代替电传打字机 </p>
<p>to replace electromechanical teletype machines with screen-based equivalents.</p>
<p>变得可行</p>
<p>But rather than build a whole new standard to interface computers with these screens,</p>
<p>但与其为屏幕专门做全新的标准</p>
<p>engineers simply recycled the existing text-only, teletype protocol.</p>
<p>工程师直接用现有的电传打字机协议</p>
<p>These machines used a screen, which simulated endless paper.</p>
<p>屏幕就像无限长度的纸，</p>
<p>It was text in and text out, nothing more.</p>
<p>除了输入和输出字，没有其它东西</p>
<p>The protocol was identical, so computers couldn't even tell if it was paper or a screen.</p>
<p>协议是一样的，所以计算机分不出是纸还是屏幕</p>
<p>These virtual teletype or glass teletype machines became known as terminals .</p>
<p>这些"虚拟电传打字机"或"玻璃电传打字机"，叫终端</p>
<p>By 1971, it was estimated, in the United States,</p>
<p>到1971年，美国大约有</p>
<p>there was something on the order of 70,000 electro-mechanical teletype machines</p>
<p>7 万台电传打字机，</p>
<p>and 70,000 screen-based terminals in use.</p>
<p>以及 7 万个终端</p>
<p>Screens were so much better, faster and more flexible, though.</p>
<p>屏幕又好又快又灵活</p>
<p>Like, you could delete a mistake and it would disappear.</p>
<p>如果删一个错别字会立刻消失</p>
<p>So, by the end of the 1970s, screens were standard.</p>
<p>所以到 1970 年代末屏幕成了标配</p>
<p>You might think that command line interfaces are way too primitive to do anything interesting.</p>
<p>你也许会想，命令行界面太原始了，做不了什么有意思的事</p>
<p>But even when the only interaction was through text, programmers found a way to make it fun.</p>
<p>即便只有文字，程序员也找到了一些方法，让它变得有趣一些</p>
<p>Early interactive, text-based computer games include famous titles like Zork,</p>
<p>早期的著名交互式文字游戏  Zork</p>
<p>created in 1977.</p>
<p>出现于 1977 年</p>
<p>Players of these sorts of early games were expected to engage their limitless imaginations</p>
<p>早期游戏玩家需要丰富的想象力</p>
<p>as they visualized the fictional world around them, like what terrifying monster confronted them</p>
<p>想像自己身在虚构世界，比如"四周漆黑一片</p>
<p>when it was pitch black and you were likely to be eaten by a grue.</p>
<p>附近可能有怪物会吃掉你"</p>
<p>Let's go back to our command line, now on a fancy screen-based terminal, and play!</p>
<p>我们用命令行玩玩看</p>
<p>Just like before, we can see what's in our current directory with the "ls" command.</p>
<p>就像之前，我们可以用 ls 命令，看当前目录有什么</p>
<p>Then, let's go into our games directory by using the "cd" command,  for " change directory ".</p>
<p>然后用 cd 命令，进入游戏文件夹，cd 的意思是 "改变文件夹"</p>
<p>Now, we can use our "ls" command again to see what games are installed on our computer.</p>
<p>再用 ls 看有哪些游戏</p>
<p>Sweet, we have Adventure!</p>
<p>超棒！我们有"冒险旅程"！(adventure)</p>
<p>All we have to do to run this program is type its name.</p>
<p>想运行这个程序，只需要输入它的名字</p>
<p>Until this application halts, or we quit it, it takes over the command line.</p>
<p>在程序自行停止或我们主动退出前，它会接管命令行</p>
<p>What you're seeing here is actual interaction from "Colossal Cave Adventure",</p>
<p>你现在看到的，是"巨大洞穴冒险"这款游戏的真实输出</p>
<p>first developed by Will Crowther in 1976.</p>
<p>由 Will Crowther 在 1976 年开发</p>
<p>In the game, players can type in oneor two-word commands to move around,</p>
<p>游戏中，玩家可以输入1个词或2个词的命令，来移动人物，</p>
<p>interact with objects, pickup items and so on.</p>
<p>和其他东西交互，捡物品等</p>
<p>The program acts as the narrator, describing locations, possible actions,</p>
<p>然后游戏会像旁白一样，输出你的当前位置，告诉你能做什么动作，</p>
<p>and the results of those actions.</p>
<p>以及你的动作造成的结果</p>
<p>Certain ones resulted in death!</p>
<p>有些动作会导致死亡！</p>
<p>The original version only had 66 locations to explore,</p>
<p>原始版本只有 66 个地方可供探索</p>
<p>but it's widely considered to be the first example of interactive fiction.</p>
<p>但它被广泛认为是最早的互动式小说</p>
<p>These text adventure games later became multiplayer, called MUDs or Multi-User Dungeons.</p>
<p>游戏后来从纯文字进化成多人游戏，简称 MUD，或多人地牢游戏</p>
<p>And they're the great-forbearers of the awesome graphical MMORPG's</p>
<p>是如今 MMORPG 的前辈，</p>
<p>(massive, multiplayer online role playing games) we enjoy today.</p>
<p>（大型多人在线角色扮演游戏）</p>
<p>And if you want to know more about the history of these and other games</p>
<p>如果你想了解游戏史，我们有游戏速成课，</p>
<p>we've got a whole series on it hosted by Andre Meadows!</p>
<p>主持人 Andre Meadows</p>
<p>Command line interfaces, while simple, are very powerful.</p>
<p>命令行界面虽然简单但十分强大</p>
<p>Computer programming is still very much a written task, and as such,</p>
<p>编程大部分依然是打字活，</p>
<p>command lines are a natural interface.</p>
<p>所以用命令行比较自然</p>
<p>For this reason, even today, most programmers use</p>
<p>因此，即使是现在，</p>
<p>command line interfaces as part of their work.</p>
<p>大多数程序员工作中依然用命令行界面</p>
<p>And they're also the most common way to access computers that are far away,</p>
<p>而且用命令行访问远程计算机是最常见的方式，</p>
<p>like a server in a different country.</p>
<p>比如服务器在另一个国家</p>
<p>If you're running Windows, macOS or Linux,</p>
<p>如果你用 Windows, macOS, Linux</p>
<p>your computer has a command line interface one you may have never used.</p>
<p>你的计算机有命令行界面，但你可能从来没用过</p>
<p>Check it out by typing "cmd" in your Windows search bar,</p>
<p>你可以在 Windows 搜索栏中输入 cmd</p>
<p>or search for Terminal on Mac.</p>
<p>或在 Mac 上搜 Terminal</p>
<p>Then install a copy of Zork and play on!</p>
<p>然后你可以装 Zork 玩！</p>
<p>So, you can see how these early advancements still have an impact on computing today.</p>
<p>现在你知道了，早期计算机的发展是如何影响到现在的.</p>
<p>Just imagine if your phone didn't have a good ol' fashioned QWERTY keyboard.</p>
<p>想想要是手机没有 QWERTY 键盘，在 Instagram 给图片配标题可就麻烦了</p>
<p>It could take forever to type your Instagram captions.</p>
<p>想想要是手机没有 QWERTY 键盘，在 Instagram 给图片配标题可就麻烦了</p>
<p>But, there's still something missing from our discussion.</p>
<p>但我们还有一个重要话题没讲</p>
<p>All the sweet sweet graphics!</p>
<p>美妙的图形界面！</p>
<p>That's our topic for next week.</p>
<p>这是下周的主题</p>
<p>See you soon.</p>
<p>下周见</p>
<p>23 屏幕&2D 图形显示</p>
<p>Screens&2D Graphics</p>
<p>Hi, I'm Carrie Anne, and welcome to Crash Course Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>This 1960 PDP-1 is a great example of early computing with graphics.</p>
<p>这台 1960 年的 PDP-1，是一个早期图形计算机的好例子</p>
<p>You can see a cabinet-sized computer on the left,</p>
<p>你可以看到左边是柜子大小的电脑</p>
<p>an electromechanical teletype machine in the middle,</p>
<p>中间是电传打字机</p>
<p>and a round screen on the right.</p>
<p>右边是一个圆形的屏幕</p>
<p>Note how they're separated.</p>
<p>注意它们是分开的</p>
<p>That's because text-based tasks and graphical tasks were often distinct back then.</p>
<p>因为当时文本任务和图形任务是分开的.</p>
<p>In fact, these early computer screens had a very hard time rendering crisp text, whereas</p>
<p>事实上，早期的屏幕无法显示清晰的文字</p>
<p>typed paper offered much higher contrast and resolution.</p>
<p>而打印到纸上有更高的对比度和分辨率</p>
<p>The most typical use for early computer screens was to keep track of a program's operation,</p>
<p>早期屏幕的典型用途是跟踪程序的运行情况</p>
<p>like values in registers.</p>
<p>比如寄存器的值</p>
<p>It didn't make sense to have a teletype machine print this on paper</p>
<p>如果用打印机，一遍又一遍打印出来没有意义</p>
<p>over and over and over again -that'd waste a lot of paper, and it was slow.</p>
<p>不仅费纸而且慢</p>
<p>On the other hand, screens were dynamic and quick to update -perfect for temporary values.</p>
<p>另一方面，屏幕更新很快，对临时值简直完美</p>
<p>Computer screens were rarely considered for program output, though.</p>
<p>但屏幕很少用于输出计算结果，</p>
<p>Instead, any results from a computation were typically written to paper</p>
<p>结果一般都打印到纸上</p>
<p>or some other more permanent medium.</p>
<p>或其它更永久的东西上</p>
<p>But, screens were so darn useful</p>
<p>但屏幕超有用，到1960年代，</p>
<p>that by the early 1960s, people started to use them for awesome things.</p>
<p>人们开始用屏幕做很多酷炫的事情</p>
<p>A lot of different display technologies have been created over the decades,</p>
<p>几十年间出现了很多显示技术</p>
<p>but the most influential, and also the earliest, were Cathode Ray Tubes, or CRT</p>
<p>但最早最有影响力的是阴极射线管（CRT）</p>
<p>These work by shooting electrons out of an emitter at a phosphor-coated screen.</p>
<p>原理是把电子发射到有磷光体涂层的屏幕上</p>
<p>When electrons hit the coating, it glows for a fraction of a second.</p>
<p>当电子撞击涂层时会发光几分之一秒</p>
<p>Because electrons are charged particles,</p>
<p>由于电子是带电粒子，</p>
<p>their paths can be manipulated with electromagnetic fields.</p>
<p>路径可以用磁场控制</p>
<p>Plates or coils are used inside to steer electrons to a desired position,</p>
<p>屏幕内用板子或线圈把电子引导到想要的位置</p>
<p>both left-right and up-down.</p>
<p>上下左右都行</p>
<p>With this control, there are two ways you can draw graphics.</p>
<p>既然可以这样控制，有 2 种方法绘制图形，</p>
<p>The first option is to direct the electron beam to trace out shapes.</p>
<p>1 引导电子束描绘出形状</p>
<p>This is called Vector Scanning.</p>
<p>这叫"矢量扫描"</p>
<p>Because the glow persists for a little bit, if you repeat the path quickly enough,</p>
<p>因为发光只持续一小会儿，如果重复得足够快 </p>
<p>you create a solid image.</p>
<p>可以得到清晰的图像</p>
<p>The other option is to repeatedly follow a fixed path, scanning line by line,</p>
<p>2 按固定路径，一行行来，从上向下，</p>
<p>from top left to bottom right, and looping over and over again.</p>
<p>从左到右，不断重复</p>
<p>You only turn on the electron beam at certain points to create graphics.</p>
<p>只在特定的点打开电子束，以此绘制图形</p>
<p>This is called Raster Scanning.</p>
<p>这叫 "光栅扫描"</p>
<p>With this approach, you can display shapes... and even text... all made of little line segments.</p>
<p>用这种方法，可以用很多小线段绘制形状甚至文字</p>
<p>Eventually, as display technologies improved,</p>
<p>最后，因为显示技术的发展</p>
<p>it was possible to render crisp dots onto the screen, aka pixels.</p>
<p>我们终于可以在屏幕上显示清晰的点，叫"像素"</p>
<p>The Liquid Crystal Displays, or LCDs,</p>
<p>液晶显示器，简称 LCD</p>
<p>that we use today are quite a different technology.</p>
<p>和以前的技术相当不同</p>
<p>But, they use raster scanning too,</p>
<p>但 LCD 也用光栅扫描，</p>
<p>updating the brightness of little tiny red, green and blue pixels many times a second.</p>
<p>每秒更新多次像素里红绿蓝的颜色</p>
<p>Interestingly, most early computers didn't use pixels</p>
<p>有趣的是，很多早期计算机不用像素</p>
<p>not because they couldn't physically,</p>
<p>不是技术做不到, </p>
<p>but because it consumed way too much memory for computers of the time.</p>
<p>而是因为像素占太多内存</p>
<p>A 200 by 200 pixel image contains 40,000 pixels.</p>
<p>200像素×200像素的图像，有 40,000 个像素</p>
<p>Even if you use just one bit of data for each pixel,</p>
<p>哪怕每个像素只用一个 bit 表示，</p>
<p>that's black OR white -not grayscale!</p>
<p>代表黑色或白色，连灰度都没有！</p>
<p>the image would consume 40,000 bits of memory.</p>
<p>会占 40,000 bit 内存，</p>
<p>That would have gobbled up more than half of a PDP-1's entire RAM.</p>
<p>比 PDP-1 全部内存的一半还多</p>
<p>So, computer scientists and engineers had to come up with clever tricks to render graphics</p>
<p>所以计算机科学家和工程师，得想一些技巧来渲染图形，</p>
<p>until memory sizes caught up to our pixelicious ambitions.</p>
<p>等内存发展到足够用</p>
<p>Instead of storing tens of thousands of pixels,</p>
<p>所以早期计算机不存大量像素值，</p>
<p>early computers stored a much smaller grid of letters, most typically 80 by 25 characters.</p>
<p>而是存符号，80x25个符号最典型</p>
<p>That's 2000 characters in total.</p>
<p>总共 2000 个字符</p>
<p>And if each is encoded in 8 bits, using something like ASCII,</p>
<p>如果每个字符用 8 位表示，比如用 ASCII</p>
<p>it would consume 16,000 bits of memory for an entire screen full of text,</p>
<p>总共才 16000 位，</p>
<p>which is way more reasonable.</p>
<p>这种大小更合理</p>
<p>To pull this off, computers needed an extra piece of hardware that</p>
<p>为此，计算机需要额外硬件</p>
<p>could read characters out of RAM, and convert them into raster graphics to be drawn onto the screen.</p>
<p>来从内存读取字符，转换成光栅图形，这样才能显示到屏幕上</p>
<p>This was called a character generator, and they were basically the first graphics cards.</p>
<p>这个硬件叫 "字符生成器"，基本算是第一代显卡</p>
<p>Inside, they had a little piece of Read Only Memory, a ROM,</p>
<p>它内部有一小块只读存储器，简称 ROM</p>
<p>that stored graphics for each character, called a dot matrix pattern.</p>
<p>存着每个字符的图形，叫"点阵图案"</p>
<p>If the graphics card saw the 8-bit code for the letter "K",</p>
<p>如果图形卡看到一个 8 位二进制，发现是字母 K</p>
<p>then it would raster scan the 2D pattern for the letter K onto the screen, in the appropriate position.</p>
<p>那么会把字母 K 的点阵图案，光栅扫描显示到屏幕的适当位置</p>
<p>To do this, the character generator had special access to a portion of a computer's memory</p>
<p>为了显示，"字符生成器" 会访问内存中一块特殊区域，</p>
<p>reserved for graphics, a region called the screen buffer.</p>
<p>这块区域专为图形保留，叫屏幕缓冲区</p>
<p>Computer programs wishing to render text to the screen</p>
<p>程序想显示文字时，</p>
<p>simply manipulated the values stored in this region,</p>
<p>修改这块区域里的值就行</p>
<p>just as they could with any other data in RAM.</p>
<p>就像他们在RAM中处理其他数据一样。</p>
<p>This scheme required much less memory,</p>
<p>这个方案用的内存少得多，</p>
<p>but it also meant the only thing you could draw was text.</p>
<p>但也意味着只能画字符到屏幕上</p>
<p>Even still, people got pretty inventive with ASCII art!</p>
<p>即使有这样限制，人们用 ASCII 艺术发挥了很多创意！</p>
<p>People also tried to make rudimentary, pseudo-graphical interfaces out of this basic set of characters</p>
<p>也有人用字符模仿图形界面</p>
<p>using things like underscores and plus signs to create boxes, lines and other primitive shapes.</p>
<p>用下划线和加号来画盒子，线，和其他简单形状</p>
<p>But, the character set was really too small to do anything terribly sophisticated.</p>
<p>但字符集实在太小，做不了什么复杂的事</p>
<p>So, various extensions to ASCII were made that added new semigraphical characters,</p>
<p>因此对 ASCII 进行了各种扩展，加新字符</p>
<p>like IBM's CP437 character set, seen here, which was used in DOS.</p>
<p>比如上图的 IBM CP437 字符集，用于 DOS.</p>
<p>On some systems, the text color and background color could be defined with a few extra bits.</p>
<p>某些系统上，可以用额外的 bit 定义字体颜色和背景颜色</p>
<p>That allowed glorious interfaces like this DOS example,</p>
<p>做出这样的 DOS 界面，</p>
<p>which is built entirely out the character set you just saw.</p>
<p>这界面只用了刚刚提到的字符集</p>
<p>Character generators were a clever way to save memory.</p>
<p>字符生成器是一种省内存的技巧，</p>
<p>But, they didn't provide any way to draw arbitrary shapes.</p>
<p>但没办法绘制任意形状</p>
<p>And that's important if you want to draw content like electrical circuits, architectural</p>
<p>绘制任意形状很重要，因为电路设计，建筑</p>
<p>plans, maps, and... well pretty much everything that isn't text!</p>
<p>平面图，地图，好多东西都不是文字！</p>
<p>To do this, without resorting to memory-gobbling pixels,</p>
<p>为了绘制任意形状，同时不吃掉所有内存</p>
<p>computer scientists used the vector mode available on CRTs.</p>
<p>计算机科学家用 CRT 上的"矢量模式"</p>
<p>The idea is pretty straightforward: all content to be drawn on screen is defined by a series of lines.</p>
<p>概念非常简单：所有东西都由线组成</p>
<p>There's no text.</p>
<p>没有文字这回事</p>
<p>If you need to draw text, you have to draw it out of lines.</p>
<p>如果要显示文字，就用线条画出来</p>
<p>Don't read between the lines here. There is only lines!</p>
<p>只有线条，没有别的</p>
<p>Got it? Alright, no more word play.</p>
<p>明白了吗？好，我们举个实例吧</p>
<p>I'm drawing the line here.</p>
<p>我在这里画一条线</p>
<p>Let's pretend this video is a cartesian plane, 200 units wide and 100 tall, with the</p>
<p>假设这个视频是一个笛卡尔平面，200个单位宽，100个单位高</p>
<p>origin that's the zero-zero point in the upper left corner.</p>
<p>原点 (0,0) 在左上角</p>
<p>We can draw a shape with the following vector commands,</p>
<p>我们可以画形状，用如下矢量命令</p>
<p>which we've borrowed from the Vectrex, an early vector display system.</p>
<p>这些命令来自 Vectrex，一个早期矢量显示系统</p>
<p>First, we reset, which clears the screen,</p>
<p>首先，reset ，这个命令会清空屏幕</p>
<p>moves the drawing point of the electron gun to zero-zero,</p>
<p>把电子枪的绘图点移动到坐标 (0,0)</p>
<p>and sets the brightness of lines to zero.</p>
<p>并把线的亮度设为 0</p>
<p>Then we move the drawing point down to 50 50,</p>
<p>MOVE_TO 50 50，把绘图点移动到坐标 (50,50)</p>
<p>and set the line intensity to 100%.</p>
<p>INTENSITY 100，把强度设为 100</p>
<p>With the intensity up, now we move to 100, 50, then 60, 75 and then back to 50,50.</p>
<p>现在亮度提高了，移动到 (100,50)  然后 (60,75)  然后 (50,50)</p>
<p>The last thing to do is set our line intensity back to 0%.</p>
<p>最后把强度设回 0</p>
<p>Cool! We've got a triangle!</p>
<p>酷，我们画了一个三角形！</p>
<p>This sequence of commands would consume on the order of 160 bits, which is way more efficient</p>
<p>这些命令占 160 bit ，</p>
<p>than keeping a huge matrix of pixel values!</p>
<p>比存一个庞大的像素矩阵更好</p>
<p>Just like how characters were stored in memory and turned into graphics by a character generator,</p>
<p>就像之前的"字符生成器" ，把内存里的字符转成图形一样</p>
<p>these vector instructions were also stored in memory, and rendered to a screen using</p>
<p>这些矢量指令也存在内存中，</p>
<p>a vector graphics card.</p>
<p>通过矢量图形卡画到屏幕上</p>
<p>Hundreds of commands could be packed together, sequentially, in the screen buffer,</p>
<p>数百个命令可以按序存在屏幕缓冲区</p>
<p>and used to build up complex graphics. All made of lines!</p>
<p>画出复杂图形，全是线段组成的！</p>
<p>Because all these vectors are stored in memory, computer programs can update the values freely,</p>
<p>由于这些矢量都在内存中，程序可以更新这些值</p>
<p>allowing for graphics that change over time -Animation!</p>
<p>让图形随时间变化动画！</p>
<p>One of the very earliest video games, Spacewar!,</p>
<p>最早的电子游戏之一, Spacewar!</p>
<p>was built on a PDP-1 in 1962 using vector graphics.</p>
<p>是 1962 年在 PDP-1 上用矢量图形制作的.</p>
<p>It's credited with inspiring many later games, like Asteroids,</p>
<p>它启发了许多后来的游戏，比如爆破彗星(Asteroids)</p>
<p>and even the first commercial arcade video game: Computer Space.</p>
<p>甚至第一个商业街机游戏：太空大战</p>
<p>1962 was also a huge milestone because of Sketchpad,</p>
<p>1962 年是一个大里程碑，Sketchpad 诞生</p>
<p>an interactive graphical interface</p>
<p>一个交互式图形界面，</p>
<p>that offered Computer-Aided Design -called CAD Software today.</p>
<p>用途是计算机辅助设计 (CAD)</p>
<p>It's widely considered the earliest example of a complete graphical application.</p>
<p>它被广泛认为是第一个完整的图形程序</p>
<p>And its inventor, Ivan Sutherland, later won the Turing Award for this breakthrough.</p>
<p>发明人伊万·萨瑟兰后来因此获得图灵奖</p>
<p>To interact with graphics,</p>
<p>为了与图形界面交互，</p>
<p>Sketchpad used a recently invented input device called a light pen,</p>
<p>Sketchpad 用了当时发明不久的输入设备光笔</p>
<p>which was a stylus tethered to a computer with a wire.</p>
<p>就是一个有线连着电脑的触控笔</p>
<p>By using a light sensor in the tip, the pen detected the refresh of the computer monitor.</p>
<p>笔尖用光线传感器，可以检测到显示器刷新</p>
<p>Using the timing of the refresh,</p>
<p>通过判断刷新时间，</p>
<p>the computer could actually figure out the pen's position on the screen!</p>
<p>电脑可以知道笔的位置</p>
<p>With this light pen, and various buttons on a gigantic computer,</p>
<p>有了光笔和各种按钮，</p>
<p>users could draw lines and other simple shapes.</p>
<p>用户可以画线和其他简单形状</p>
<p>Sketchpad could do things like make lines perfectly parallel, the same length, straighten</p>
<p>Sketchpad 可以让线条完美平行，长度相同，</p>
<p>corners into perfect 90 degree intersections, and even scale shapes up and down dynamically.</p>
<p>完美垂直90度，甚至动态缩放</p>
<p>These things that were laborious on paper, a computer now did with a press of a button!</p>
<p>这些在纸上很费力，在计算机上非常简单！</p>
<p>Users were also able to save complex designs they created,</p>
<p>用户还可以保存设计结果，</p>
<p>and then paste them into later designs, and even share with other people.</p>
<p>方便以后再次使用，甚至和其他人分享</p>
<p>You could have whole libraries of shapes, like electronic components and pieces of furniture</p>
<p>你可以有一整个库，里面有电子元件和家具之类的</p>
<p>that you could just plop in and manipulate in your creations.</p>
<p>可以直接拖进来用</p>
<p>This might all sound pretty routine from today's perspective.</p>
<p>从如今的角度来看好像很普通</p>
<p>But in 1962, when computers were still cabinet-sized behemoths chugging through punch cards,</p>
<p>但在1962年，计算机还是吃纸带的大怪兽，有柜子般大小</p>
<p>Sketchpad and light pens were equal parts eye opening and brain melting.</p>
<p>Sketchpad 和光笔让人大开眼界</p>
<p>They represented a key turning point in how computers could be used.</p>
<p>它们代表了人机交互方式的关键转折点</p>
<p>They were no longer just number crunching math machines that hummed along behind closed doors.</p>
<p>电脑不再是关在门后负责算数的机器了</p>
<p>Now, they were potential assistants, interactively augmenting human tasks.</p>
<p>可以当助手帮人类做事</p>
<p>The earliest computers and displays with true pixel graphics emerged in the late 1960s.</p>
<p>最早用真正像素的计算机和显示器，出现于 1960 年代末</p>
<p>Bits in memory directly "mapped" to pixels on the screen,</p>
<p>内存中的位(Bit) 对应屏幕上的像素</p>
<p>what are called bitmapped displays.</p>
<p>这叫位图显示</p>
<p>With full pixel control, totally arbitrary graphics were possible.</p>
<p>现在我们可以绘制任意图形了</p>
<p>You can think of a screen's graphics as a huge matrix of pixel values .</p>
<p>你可以把图形想成一个巨大像素值矩阵</p>
<p>As before,</p>
<p>就像之前</p>
<p>computers reserve a special region of memory for pixel data, called the frame buffer.</p>
<p>计算机把像素数据存在内存中一个特殊区域，叫"帧缓冲区"</p>
<p>In the early days, the computer's RAM was used,</p>
<p>早期时，这些数据存在内存里，</p>
<p>but later systems used special high speed Video RAM, or VRAM,</p>
<p>后来存在高速视频内存里，简称 VRAM</p>
<p>which was located on the graphics card itself for high speed access.</p>
<p>VRAM 在显卡上，这样访问更快，</p>
<p>This is how it's done today.</p>
<p>如今就是这样做的.</p>
<p>On an 8-bit grayscale screen, we can set values from 0 intensity, which is black,</p>
<p>在 8 位灰度屏幕上，我们可用的颜色范围是 0 强度（黑色）</p>
<p>to 255 intensity, which is white.</p>
<p>到 255 强度(白色)</p>
<p>Well actually, it might be green... or orange, as many early displays couldn't do white.</p>
<p>其实更像绿色或橙色，因为许多早期显示器不能显示白色</p>
<p>Let's pretend this video is a really low resolution bitmapped screen,</p>
<p>我们假设这个视频在低分辨率的位图屏幕上</p>
<p>with a resolution of 60 by 35 pixels.</p>
<p>分辨率 60x35像素</p>
<p>If we wanted to set the pixel at 10 10 to be white,</p>
<p>如果我们想把 (10,10) 的像素设为白色，</p>
<p>we could do it with a piece of code like this.</p>
<p>可以用这样的代码</p>
<p>If we wanted to draw a line, let's say from 30, 0 to 30, 35, we can use a loop, like so.</p>
<p>如果想画一条线假设从(30,0)到(30,35)，可以用这样一个循环</p>
<p>.And this changes a whole line of pixels to white.</p>
<p>把整列像素变成白色</p>
<p>If we want to draw something more complicated, let's say a rectangle,</p>
<p>如果想画更复杂的图形，比如矩形，</p>
<p>we need to know four values.</p>
<p>那么需要四个值</p>
<p>The X and Y coordinate of its starting corner, and its width and height.</p>
<p>1 起始点X坐标；2 起始点Y坐标；3 宽度；4 高度</p>
<p>So far, we've drawn everything in white, so let's specify this rectangle to be grey.</p>
<p>目前只试了白色，这次画矩形试下灰色</p>
<p>Grey is halfway between 0 and 255, so that's a color value of 127.</p>
<p>灰色介于0到255中间，所以我们用 127 (255/2=127.5)</p>
<p>Then, with two loops C one nested in the other,</p>
<p>然后用两个循环，一个套另一个</p>
<p>so that the inner loop runs once for every iteration of the outer loop,</p>
<p>这样外部每跑一次，内部会循环多次，可以画一个矩形</p>
<p>we can draw a rectangle.</p>
<p>这样外部每跑一次，内部会循环多次，可以画一个矩形</p>
<p>When the computer executes our code as part of its draw routine, it colors in all the</p>
<p>计算机绘图时会用</p>
<p>pixels we specified.</p>
<p>指定的颜色</p>
<p>Let's wrap this up into a "draw rectangle function", like this:</p>
<p>我们来包装成 "画矩形函数"，就像这样：</p>
<p>Now, to draw a second rectangle on the other side of the screen, maybe in black this time,</p>
<p>假设要在屏幕的另一边画第二个矩形，这次可能是黑色矩形</p>
<p>we can just call our rectangle drawing function. Voila!!</p>
<p>可以直接调用 "画矩形函数", 超棒！</p>
<p>Just like the other graphics schemes we've discussed,</p>
<p>就像之前说的其他方案</p>
<p>programs can manipulate pixel data in the frame buffer, creating interactive graphics.</p>
<p>程序可以操纵"帧缓冲区"中的像素数据，实现交互式图形</p>
<p>Pong time!</p>
<p>乒乓球时间！</p>
<p>Of course, programmers aren't wasting time writing drawing functions from scratch.</p>
<p>当然，程序员不会浪费时间从零写绘图函数，</p>
<p>They use graphics libraries with ready-to-go functions</p>
<p>而是用预先写好的函数来做，</p>
<p>for drawing lines, curves, shapes, text, and other cool stuff.</p>
<p>画直线，曲线，图形，文字等</p>
<p>Just a new level of abstraction!</p>
<p>一层新抽象！</p>
<p>The flexibility of bitmapped graphics opened up a whole new world of possibilities for</p>
<p>位图的灵活性，为交互式开启了全新可能，</p>
<p>interactive computing, but it remained expensive for decades.</p>
<p>但它的高昂成本持续了十几年</p>
<p>As I mentioned last episode, by as late as 1971,</p>
<p>上集提到，1971 年，</p>
<p>it was estimated there were around 70,000 electro-mechanical teletype machines</p>
<p>整个美国也只有大约 7 万个电传打字机</p>
<p>and 70,000 terminals in use, in the United States.</p>
<p>和 7 万个终端</p>
<p>Amazingly, there were only around 1,000 computers in the US that had interactive graphical screens.</p>
<p>令人惊讶的是，只有大约 1000 台电脑有交互式图形屏幕</p>
<p>That's not a lot!</p>
<p>这可不多！</p>
<p>But the stage was set helped along by pioneering efforts like Sketchpad and Space Wars</p>
<p>Sketchpad 和太空大战这样的先驱，推动了图形界面发展</p>
<p>for computer displays to become ubiquitous,</p>
<p>帮助普及了计算机显示器，</p>
<p>and with them, the dawn of graphical user interfaces,</p>
<p>由此，图形界面的曙光初现</p>
<p>which we'll cover in a few episodes!</p>
<p>接下来讲图形界面</p>
<p>I'll see you next week.</p>
<p>下周见</p>
<p>24 冷战和消费主义</p>
<p>The Cold War and Consumerism</p>
<p>Hi, I'm Carrie Anne and welcome to Crash Course Computer Science.</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>Early in this series we covered computing history</p>
<p>之前介绍了计算机历史，</p>
<p>From roughly the dawn of civilization,</p>
<p>从人类文明的曙光开始 (第1集）</p>
<p>up to the birth of electronic general purpose computers in the mid 1940s.</p>
<p>一直到 1940 年代中期电子计算机诞生</p>
<p>A lot of the material we've discussed over the past 23 episodes</p>
<p>过去 23 集里讲的很多东西</p>
<p>like programming languages and compilers</p>
<p>比如编程语言和编译器，</p>
<p>Algorithms and integrated circuits</p>
<p>算法和集成电路</p>
<p>Floppy disks and operating systems, telly types and screens</p>
<p>软盘和操作系统，电报机和屏幕</p>
<p>all emerged over roughly a 30-year period,</p>
<p>全都是1940~1970年代，</p>
<p>From the mid 1940s up to the mid 1970s</p>
<p>大概这30年间里出现的</p>
<p>This is the era of computing before companies like Apple and Microsoft existed</p>
<p>那时苹果和微软还不存在，</p>
<p>and long before anyone Tweeted, Googled or Uber-d.</p>
<p>也没有推特，谷歌或者 Uber.</p>
<p>It was a formative period setting the stage for personal computers,</p>
<p>还没到个人电脑时代</p>
<p>worldwide web, self-driving cars, virtual reality, and many other topics</p>
<p>而万维网，无人驾驶汽车，虚拟现实等主题，</p>
<p>we'll get to in the second half of this series.</p>
<p>这个系列的后半部分会讲</p>
<p>Today we're going to step back from circuits and algorithms</p>
<p>今天, 我们不管电路和算法，</p>
<p>and review this influential period.</p>
<p>来聊聊这个影响力巨大的时代</p>
<p>We'll pay special attention to the historical backdrop of the cold war,</p>
<p>我们会把重点放在，冷战，</p>
<p>The space race and the rise of globalization and consumerism.</p>
<p>太空竞赛，全球化，消费主义的兴起.</p>
<p>Pretty much immediately after World War II concluded in 1945,</p>
<p>1945年二战结束后不久</p>
<p>there was tension between the world's two new superpowers</p>
<p>两个超级大国的关系越发紧张，</p>
<p>the United States and the USSR</p>
<p>美国和苏联开始了冷战</p>
<p>The Cold War had begun and with it,</p>
<p>因此政府往科学和工程学 </p>
<p>massive government spending on science and engineering.</p>
<p>投入大量资金</p>
<p>Computing which had already demonstrated its value</p>
<p>计算机在战时已经证明了自身的价值，</p>
<p>in wartime efforts like the Manhattan Project</p>
<p>比如曼哈顿计划</p>
<p>and code breaking Nazi communications,</p>
<p>和破解纳粹通讯加密</p>
<p>was lavished with government funding.</p>
<p>所以政府大量投入资源，</p>
<p>They enabled huge ambitious computing projects to be undertaken,</p>
<p>各种雄心勃勃的项目得以进行</p>
<p>like ENIAC, EDVAC, Atlas and Whirlwind all mentioned in previous episodes.</p>
<p>比如之前提过的 ENIAC, EDVAC, Atlas, Whirlwind</p>
<p>This spurred rapid advances that simply weren't possible in the commercial sector alone,</p>
<p>这种高速发展，如果仅靠商业运作是根本无法做到的</p>
<p>where projects were generally expected to recoup development costs through sales.</p>
<p>要依靠销售收回开发成本.</p>
<p>This began to change in the early 1950s,</p>
<p>1950年代，事情开始发生变化,</p>
<p>especially with Eckert and Buckley's Univac 1,</p>
<p>特别是 Univac 1，</p>
<p>the first commercially successful computer.</p>
<p>它是第一台取得商业成功的电脑</p>
<p>Unlike ENIAC or Atlas , this wasn't just one single computer. It was a model of computers.</p>
<p>不像 ENIAC 或 Atlas，Univanc 1 不是一台机器，而是一个型号</p>
<p>in total more than 40 were built.</p>
<p>一共造了40多台</p>
<p>Most of these Univacs went to government offices or large companies.</p>
<p>大部分 Univac 去了政府或大公司</p>
<p>Which was part of the growing military industrial complex in the United States,</p>
<p>成为美国日益增长的军事工业综合体的一部分</p>
<p>with pockets deep enough to afford the cutting edge.</p>
<p>因为政府有钱承担这些尖端科技.</p>
<p>Famously, a Univac 1 built for the U.S atomic energy commission</p>
<p>一个著名的例子是，一台给美国原子能委员会生产的 Univac 1</p>
<p>was used by CBS to predict the results of the 1952 U.S. presidential election.</p>
<p>被 CBS 用来预测 1952 年美国总统大选的结果</p>
<p>With just 1% of the vote the computer correctly predicted</p>
<p>仅用1％的选票，Univac 1 正确预测了结果.</p>
<p>Eisenhower landslide, while pundits favored Stevenson.</p>
<p>艾森豪威尔获得压倒性胜利，而专家预测史蒂文森会赢</p>
<p>It was a media event that helped propel computing to the forefront of the public's imagination</p>
<p>这次事件把计算机推到了公众面前</p>
<p>Computing was unlike machines of the past,</p>
<p>计算机和以前的机器不一样</p>
<p>which generally augmented human physical abilities.</p>
<p>以前的机器增强人类的物理能力</p>
<p>Trucks allowed us to carry more, automatic looms whoa faster,</p>
<p>比如卡车能带更多东西，自动织布机更快</p>
<p>Machine tools were more precise and so on</p>
<p>机床更精确等等. </p>
<p>for a bunch of contraptions that typify the industrial revolution.</p>
<p>这些东西代表了工业革命.</p>
<p>But computers on the other hand could augment human intellect.</p>
<p>而计算机增强的是人类智力</p>
<p>This potential wasn't lost on Vannevar Bush,</p>
<p>范内瓦·布什看到了这种潜力，</p>
<p>who in 1945 published an article on a</p>
<p>他在1945年发表了一篇文章</p>
<p>hypothetical computing device he envisioned called the Memex.</p>
<p>描述了一种假想计算设备叫 Memex</p>
<p>This was a device in which an individual stores all his books,</p>
<p>可以用这个设备，存自己所有的书, 其他资料以及和别人沟通</p>
<p>records and communications and which is mechanized,</p>
<p>而且数据是按照格式存储,</p>
<p>so it may be consulted with exceeding speed and flexibility</p>
<p>所以可以快速查询，有很大灵活性.</p>
<p>It is an enlarged intimate supplement to his memory.</p>
<p>可以辅助我们的记忆</p>
<p>He also predicted that wholly new forms of encyclopedia will appear,</p>
<p>他还预测会出现新的百科全书形式</p>
<p>ready-made, with a mesh of associative trails running through them.</p>
<p>信息之间相互链接</p>
<p>Sound familiar?</p>
<p>听起来是不是很熟悉？（维基百科）</p>
<p>Memex directly inspired several subsequent game-changing systems,</p>
<p>Memex 启发了之后几个重要里程碑</p>
<p>like Ivan Sutherland Sketchpad, which we discussed last episode,</p>
<p>比如上集伊万·萨瑟兰的 Sketchpad(画板)</p>
<p>and Dough Engelbart's online system, which we will cover soon.</p>
<p>以及后面很快会讲到，Dough Engelbart 的 oN-LINE 系统（第26集）</p>
<p>Vannevar Bush was the head of the U.S. office of Scientific Research and Development,</p>
<p>范内瓦·布什，做过"美国科学研究与开发办公室"的头头</p>
<p>which was responsible for funding and coordinating scientific research during World War 2.</p>
<p>这个部门负责在二战期间，资助和安排科学研究</p>
<p>With the Cold War brewing, Bush lobbied for a creation of a peace time equivalent,</p>
<p>冷战时范内瓦·布什到处游说，想建立一个职责类似，但是在和平时期运作的部门</p>
<p>the National Science Foundation, formed in 1950.</p>
<p>因此国家科学基金会于1950年成立</p>
<p>To this day the NSF provides federal funding to support scientific research in the United States.</p>
<p>至今，国家科学基金会，依然负责给科学研究提供政府资金</p>
<p>And it is a major reason the U.S. has continued to be a leader in the technology sector.</p>
<p>美国的科技领先全球，主要原因之一就是这个机构.</p>
<p>It was also in the 1950s that consumers started to buy transistor powered gadgets,</p>
<p>1950年代，消费者开始买晶体管设备</p>
<p>notable among them was the transistor radio,</p>
<p>其中值得注意的是收音机</p>
<p>which was small, durable and battery-powered.</p>
<p>它又小又耐用，用电池就够了，</p>
<p>And it was portable,</p>
<p>而且便携</p>
<p>unlike the vacuum tube based radio sets from the 1940s and before.</p>
<p>不像 1940 年代之前的收音机，用的是真空管.</p>
<p>It was a runaway success, the Furby or iPhone of its day.</p>
<p>收音机非常成功，卖的像"菲比精灵"和 iPhone 一样畅销.</p>
<p>The Japanese government looking for industrial opportunities,</p>
<p>日本政府也在寻求工业机会，</p>
<p>to bolster their post-war economy, soon got in on the action.</p>
<p>想振兴战后经济，</p>
<p>Licensing the rights to Transistors from Bell Labs in 1952.</p>
<p>他们很快动手从贝尔实验室取得晶体管的授权</p>
<p>Helping launch the Japanese semiconductor and electronics industry.</p>
<p>帮助振兴日本的半导体和电子行业</p>
<p>In 1955, the first Sony product was released:</p>
<p>1955年，索尼的第一款产品面世</p>
<p>The TR-55 Transistor Radio. Concentrating on quality and price,</p>
<p>TR-55 晶体管收音机. 他们把重心放在质量和价格.</p>
<p>Japanese companies captured half of the U.S. Market for portable radios in just five years.</p>
<p>因此日本公司在短短5年内，就占有了美国便携式收音机市场的一半.</p>
<p>This planted the first seeds of a major industrial rivalry in the decades to come.</p>
<p>这为日本成为美国的强大工业对手，埋下伏笔</p>
<p>In 1953, there were only around 100 computers on the entire planet</p>
<p>1953年，整个地球大概有100台计算机</p>
<p>and at this point, the USSR was only a few years behind the West in computing technology,</p>
<p>苏联这时的计算机科技只比西方落后几年</p>
<p>completing their first programmable electronic computer in 1950.</p>
<p>苏联在1950年，完成了第一个可编程电子计算机</p>
<p>But the Soviets were way ahead in the burgeoning space race.</p>
<p>但苏联在太空竞赛远远领先</p>
<p>Let's go to the thought-bubble.</p>
<p>我们进入思想泡泡</p>
<p>The Soviets launched the world's first satellite into orbit, Sputnik one,</p>
<p>苏联在1957年，把第一个卫星送上轨道，史波尼克1号</p>
<p>in 1957, and a few years later in 1961.</p>
<p>不久，在1961年</p>
<p>Soviet Cosmonaut, Yuri Gagarin became the first human in space.</p>
<p>苏联宇航员尤里·加加林第一个进入太空</p>
<p>This didn't sit well with the American public</p>
<p>美国民众对此不满</p>
<p>and prompted President Kennedy, a month after Gagarin's mission,</p>
<p>使得肯尼迪总统，在加加林太空任务一个月后</p>
<p>to encourage the nation to land a man on the moon within the decade. And it was expensive!</p>
<p>提出要登陆月球. 登月很贵的!</p>
<p>NASA's budget grew almost tenfold,</p>
<p>NASA 的预算增长了几乎十倍,</p>
<p>peaking in 1966 at roughly 4.5 percent of the U.S. Federal budget</p>
<p>在 1966 年达到顶峰，占了政府预算的4.5%</p>
<p>Today, It's around half a percent</p>
<p>如今, NASA 的预算只占 0.5%</p>
<p>NASA used this funding to tackle a huge array of enormous challenges</p>
<p>NASA 用这笔钱资助各种科学研究</p>
<p>this culminated in the Apollo program</p>
<p>阿波罗计划花的钱最多，</p>
<p>Which is peak employed roughly 400,000 people</p>
<p>雇了40万人左右</p>
<p>further supported by over 20,000 universities and companies</p>
<p>而且有2万多家大学和公司参与.</p>
<p>one of these huge challenges was navigating in space</p>
<p>其中一个挑战是怎样在太空中导航</p>
<p>NASA needed a computer to process complex trajectories</p>
<p>NASA 需要电脑计算复杂的轨道</p>
<p>and issue guidance commands to the spacecraft</p>
<p>道来引导太空船</p>
<p>For this, they built the Apollo guidance computer,</p>
<p>因此，他们造了 "阿波罗导航计算机"</p>
<p>There were three significant requirements</p>
<p>有3个重要要求</p>
<p>First, the computer had to be fast, no surprise there.</p>
<p>1 计算机要快, 这在意料之中.</p>
<p>Second, it had to be small & lightweight</p>
<p>2 计算机要又小又轻.</p>
<p>there's not a lot of room in a spacecraft</p>
<p>太空船里的空间不多</p>
<p>and every ounce is precious when you're flying a quarter million miles to the moon</p>
<p>而且要飞去月球，能轻一点是一点</p>
<p>And finally it had to be really really ridiculously reliable</p>
<p>3 要超级可靠</p>
<p>This is super important in a spacecraft</p>
<p>这对太空船非常重要，</p>
<p>Where there's lots of vibration radiation and temperature change</p>
<p>因为太空中有很多震动，辐射，极端温度变化</p>
<p>And there's no running to Best Buy, if something breaks.</p>
<p>如果东西坏掉了，可没办法去"百思买"买新的</p>
<p>the technology of the era of vacuum tubes and discrete transistors</p>
<p>那时的主流科技，真空管和晶体管 </p>
<p>Just weren't up to the task</p>
<p>无法胜任这些要求.</p>
<p>so NASA turned to a brand-new technology, integrated circuits.</p>
<p>所以 NASA 用全新科技：集成电路</p>
<p>Which we discussed a few episodes ago</p>
<p>我们几集前聊过</p>
<p>The Apollo guidance computer was the first computer to use them, a huge paradigm shift</p>
<p>阿波罗导航计算机首先使用了集成电路</p>
<p>NASA was also the only place that could afford them</p>
<p>NASA 是唯一负担得起集成电路的组织</p>
<p>Initially each chip cost around $50</p>
<p>最初，一个芯片差不多50美金</p>
<p>And the guidance computer needed thousands of them.</p>
<p>导航计算机需要上千个芯片</p>
<p>But by paying that price, the Americans were able to beat the soviets to the moon</p>
<p>但美国也因此成功登月，打败苏联</p>
<p>Thanks, thought-bubble</p>
<p>谢了思想泡泡</p>
<p>Although the Apollo Guidance computer is credited</p>
<p>虽然人们经常把集成电路的发展</p>
<p>with spurring the development and adoption of integrated circuits</p>
<p>归功于阿波罗导航计算机</p>
<p>It was a low volume, product there are only 17 Apollo missions after all.</p>
<p>但它们的产量很低，一共只有 17 次阿波罗任务</p>
<p>it was actually military applications</p>
<p>实际上是军事大大推进了集成电路发展</p>
<p>Especially the minuteman and polaris nuclear missile systems</p>
<p>特别是洲际导弹和核弹，使集成电路大规模生产</p>
<p>That allowed integrated circuits to become a mass-produced item</p>
<p>特别是洲际导弹和核弹，使集成电路大规模生产</p>
<p>This rapid Advancement was further accelerated by the U.S.</p>
<p>美国建造强大计算机时，</p>
<p>Building and buying huge powerful computers</p>
<p>也进一步推进了集成电路</p>
<p>Often called supercomputers, because they were frequently</p>
<p>一般叫"超级计算机"，</p>
<p>10 times faster than any other computer on the planet, upon their release.</p>
<p>因为它们经常比全球最快电脑还快10倍以上</p>
<p>but these machines built by companies like CDC, Cray and IBM were also</p>
<p>但 CDC，Cray，IBM 制造的计算机非常昂贵</p>
<p>super in cost, and pretty much only governments could afford to buy them.</p>
<p>几乎只有政府负担得起</p>
<p>in the U.S. these machines went to government Agencies like the NSA.</p>
<p>这些计算机用于政府机构，比如美国国家安全局</p>
<p>and government research labs like Lawrence Livermore and Los Alamos National laboratories</p>
<p>以及实验室比如，劳伦斯·利弗莫尔实验室，洛斯·阿拉莫斯国家实验室</p>
<p>Initially the U.S. semiconductor industry boomed</p>
<p>最初，美国的半导体行业，</p>
<p>buoyed by High profit government contracts</p>
<p>靠高利润政府合同起步</p>
<p>However this meant that most U.S.companies overlooked</p>
<p>因此忽略了消费者市场，</p>
<p>the consumer market where profit margins were small</p>
<p>因为利润小</p>
<p>the Japanese Semiconductor industry came to dominate this niche</p>
<p>因此日本半导体行业在1950和1960年代，</p>
<p>by having to operate with lean profit margins in the 1950s and 60s</p>
<p>靠低利润率占领了消费者市场</p>
<p>the Japanese had invested heavily in manufacturing capacity</p>
<p>日本人投入大量资金，</p>
<p>to achieve economies of scale</p>
<p>大量制造以达到规模经济</p>
<p>in research to improve quality and Yields and in automation to keep manufacturing costs low.</p>
<p>同时研究技术，提高质量和产量，以及用自动化来降低成本</p>
<p>in the 1970s with the Space Race and cold war subsiding</p>
<p>1970年代，太空竞赛和冷战逐渐消退，</p>
<p>previously juicy defense contracts began to dry up.</p>
<p>高利润的政府合同变少</p>
<p>and American semi-conductor and electronics companies found it harder to compete.</p>
<p>美国的半导体和电子设备公司发现更难竞争了</p>
<p>it didn't help the many computing components had been commoditized</p>
<p>虽然很多计算机组件商品化了，但并没有什么帮助</p>
<p>DRAM was DRAM</p>
<p>DRAM 就是 DRAM</p>
<p>So why buy expensive Intel memory when you could buy the same chip for less from Hitachi?</p>
<p>能从日立买便宜的，干嘛要从英特尔买贵的？</p>
<p>Throughout the 1970s U.S. companies began to downsize,</p>
<p>1970年代美国公司开始缩小，</p>
<p>consolidate or outright fail.</p>
<p>合并，或直接倒闭</p>
<p>Intel had to lay off a third of its workforce in 1974</p>
<p>1974年英特尔不得不裁员三分之一</p>
<p>and even the storied Fairchild semiconductor</p>
<p>知名的仙童半导体也在 1979 年濒临倒闭，</p>
<p>was acquired in 1979 after near bankruptcy</p>
<p>被其他公司收购了</p>
<p>to survive many of these companies began to outsource their manufacturing in a bid to reduce costs.</p>
<p>为了生存，很多公司把生产外包出去，降低成本</p>
<p>Intel withdrew from its main product category, Memory IC</p>
<p>英特尔不再把精力放在内存集成电路，</p>
<p>and decided to refocus on processes.</p>
<p>而是把精力放在处理器</p>
<p>Which ultimately saved the company.</p>
<p>这个决定最后挽救了公司</p>
<p>This low and U.S.</p>
<p>美国公司的无力，</p>
<p>electronics industry allowed Japanese companies like Sharp and Casio</p>
<p>导致夏普和 卡西欧这样的日本公司</p>
<p>to dominate the breakout computing product of the 1970s.</p>
<p>占领了1970年代的主流产品</p>
<p>Handheld electronic calculators.</p>
<p>手持计算器</p>
<p>by using integrated circuits, these could be made small and cheap.</p>
<p>因为集成电路，计算机又小又便宜</p>
<p>They replaced expensive desktop adding machines you find in offices.</p>
<p>取代了办公室里昂贵的桌面计算器</p>
<p>For most people it was the first time they didn't have to do math on paper, or use a slide rule</p>
<p>对大多数人，这是他们第一次不必用纸笔和计算尺来做计算</p>
<p>They were an instant hit, selling by the millions.</p>
<p>手持计算机因此大卖</p>
<p>This further drove down the cost of integrated circuits</p>
<p>进一步降低了集成电路的成本</p>
<p>and led to the development and widespread use of micro processors.</p>
<p>使得微处理器被广泛使用</p>
<p>like the Intel 4004 we've discussed previously</p>
<p>比如之前讨论过的 Intel 4004</p>
<p>This chip was built by Intel in 1971</p>
<p>Intel 在1971年，</p>
<p>at the request of Japanese calculator company Busicom.</p>
<p>应日本计算器公司 Busicom 的要求做了这个芯片</p>
<p>Soon, Japanese electronics were everywhere.</p>
<p>很快，日本电子产品到处都是</p>
<p>from televisions of VCRs to digital wristwatches and Walkmans</p>
<p>从电视到手表到随身听</p>
<p>the availability of inexpensive microprocessor</p>
<p>而廉价的微处理器，</p>
<p>Spawned in entirely new products like video arcades,</p>
<p>也催生了全新的产品，比如街机游戏</p>
<p>the world got Pong in 1972 and Breakout in 1976.</p>
<p>1972年诞生了Pong，1976年诞生了打砖块</p>
<p>as cost continued to plummet</p>
<p>因为成本不断下降</p>
<p>soon it became possible for regular people to afford computing devices</p>
<p>很快，普通人也买得起计算机了</p>
<p>during this time we see the emergence of the first successful home computers</p>
<p>这段期间，第一批家用电脑开始出现，比如1975年的 Altair 8800</p>
<p>like the 1975 Altair 8800</p>
<p>这段期间，第一批家用电脑开始出现，比如1975年的 Altair 8800</p>
<p>and also the first home gaming consoles</p>
<p>以及第一款家用游戏机，</p>
<p>like the Atari 2600 in 1977,</p>
<p>比如1977年的Atari 2600</p>
<p>Home, now I repeat that, Home.</p>
<p>家用！我再说一遍家用！</p>
<p>That seems like a small thing today.</p>
<p>如今没什么大不了的.</p>
<p>But this was the dawn of a whole new era in computing.</p>
<p>但那时是计算机的全新时代</p>
<p>in just three decades, computers have evolved from</p>
<p>在短短三十年内，计算机从大到</p>
<p>machines where you could literally walk inside of the CPU.</p>
<p>人类可以在 CPU 里走来走去</p>
<p>assuming you had government clearance</p>
<p>当然，你要有政府许可你这样做.</p>
<p>to the point where a child could play with a handheld toy</p>
<p>发展到小到小孩都能拿住的手持玩具，</p>
<p>Containing a microprocessor many times faster,</p>
<p>而且微处理器还快得多.</p>
<p>Critically, this dramatic evolution would have been but without two powerful forces at play</p>
<p>这种巨大变化是由两种力量推动的：</p>
<p>Governments and Consumers.</p>
<p>政府和消费者</p>
<p>Government funding like the United States provided during the cold war</p>
<p>政府资金，比如冷战期间美国投入的钱</p>
<p>enabled early adoption of many nascent computing technologies</p>
<p>推动了计算机的早期发展</p>
<p>This funding helped flow entire Industries relate into computing long enough</p>
<p>并且让计算机行业活得足够久，</p>
<p>for the technology to mature and become commercially feasible.</p>
<p>使得技术成熟到可以商用</p>
<p>Then businesses and ultimately consumers, provided the demand to take it mainstream.</p>
<p>然后是公司，最后是消费者，把计算机变成了主流</p>
<p>The cold war may be over, but this relationship continues today</p>
<p>冷战虽然结束了，但这种关系今天仍在继续</p>
<p>Governments are still funding science research.</p>
<p>政府依然在资助科学研究</p>
<p>intelligence agencies are still buying supercomputers.</p>
<p>情报机构依然在超级计算机</p>
<p>humans are still being launched into space.</p>
<p>人类仍然被发射到太空里</p>
<p>And you're still buying TV, Xbox, Playstation, Laptop and Smartphone</p>
<p>而你依然在买电视，Xbox，Playstation，笔记本电脑和手机</p>
<p>and for these reasons,</p>
<p>因此，</p>
<p>Computing continues to advance a lightning pace.</p>
<p>计算机会继续飞速发展</p>
<p>I'll see you next week</p>
<p>我们下周见</p>
<p>25 个人计算机革命</p>
<p>The Personal Computer Revolution</p>
<p>Hi, I'm Carrie Anne, and welcome to CrashCourse Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>As we discussed last week, the idea of having a computer all to yourself a personal</p>
<p>上周说过"个人计算机"的概念，</p>
<p>computer was elusive for the first three decades of electronic computing.</p>
<p>在计算机发展的头 30 年难以想象</p>
<p>It was just way too expensive for a computer to be owned and used by one single person.</p>
<p>如果只让一个人用，成本实在太高</p>
<p>But, by the early 1970s, all the required components had fallen into place to build</p>
<p>但到 70 年代初，各种组件的成本都下降了，</p>
<p>a low cost, but still usefully powerful computer.</p>
<p>可以做出低成本同时性能足够强大的计算机</p>
<p>Not a toy, but a tool.</p>
<p>不是玩具级计算机，是真正能用的计算机</p>
<p>Most influential in this transition was the advent of single-chip CPUs,</p>
<p>这个转变中，最有影响力的是单芯片 CPU 的出现</p>
<p>which were surprisingly powerful, yet small and inexpensive.</p>
<p>强大 + 体积小 + 便宜</p>
<p>Advances in integrated circuits also offered low-cost solid-state memory,</p>
<p>集成电路的进步，也提供了低成本固态存储器</p>
<p>both for computer RAM and ROM.</p>
<p>可以用于计算机的 RAM 和 ROM</p>
<p>Suddenly it was possible to have an entire computer on one circuit board,</p>
<p>忽然间，把整台计算机做到一张电路板上成为可能</p>
<p>dramatically reducing manufacturing costs.</p>
<p>大大地降低了制造成本</p>
<p>Additionally, there was cheap and reliable computer storage,</p>
<p>而且，那时有便宜可靠的储存介质，</p>
<p>like magnetic tape cassettes and floppy disks.</p>
<p>比如磁带和软盘</p>
<p>And finally, the last ingredient was low cost displays, often just repurposed televisions.</p>
<p>最后是低成本的显示器，通常是电视机稍作改装而成</p>
<p>If you blended these four ingredients together in the 1970s, you got,</p>
<p>如果在 1970 年代，将这四种原料混在一起</p>
<p>what was called a microcomputer,</p>
<p>就得到了"微型计算机"</p>
<p>because these things were so tiny compared to "normal" computers of that era, the</p>
<p>因为和那个时代的"普通"计算机相比，这些计算机很小</p>
<p>types you'd see in business or universities.</p>
<p>"普通"计算机就是公司或大学里的那种</p>
<p>But more important than their size was their cost.</p>
<p>但比大小更重要的是成本</p>
<p>These were, for the first time, sufficiently cheap.</p>
<p>这是有史以来第一次，计算机的价格足够低</p>
<p>It was practical to buy one and only have one person ever use it.</p>
<p>"一个人专用"的想法变得可行</p>
<p>No time sharing,</p>
<p>不用划分时间和别人公用计算机</p>
<p>no multi-user logins,  just a single owner and user.</p>
<p>没有多用户登录，计算机只属于一个人，只有一个用户</p>
<p>The personal computer era had arrived.</p>
<p>个人计算机时代到来</p>
<p>Computer cost and performance eventually reached the point</p>
<p>计算机成本下降+性能提升, </p>
<p>where personal computing became viable.</p>
<p>让个人计算机成为可能</p>
<p>But, it's hard to define exactly when that happened.</p>
<p>但这个时间点很难准确定义, </p>
<p>There's no one point in time.</p>
<p>并没有一个具体时间点</p>
<p>And as such, there are many contenders for the title of "first" personal computer,</p>
<p>因此"第一台个人计算机"这个名号，有很多竞争者</p>
<p>like the Kenback-1 and MCM/70.</p>
<p>比如 Kenback-1 和 MCM/70</p>
<p>Less disputed, however, is the first commercially successful personal computer: The Altair 8800.</p>
<p>不过第一台取得商业成功的个人计算机，争议较小：Altair 8800</p>
<p>This machine debuted on the cover of Popular Electronics in 1975,</p>
<p>首次亮相在 1975 年《Popular Electronics》封面</p>
<p>and was sold as a $439 kit that you built yourself.</p>
<p>售价 $439 美元，需要自己组装</p>
<p>Inflation adjusted, that's about $2,000 today,</p>
<p>计算通货膨胀后，相当如今的 2000 美元左右</p>
<p>which isn't chump change, but extremely cheap for a computer in 1975.</p>
<p>不算小钱，但比起 1975 年的其它计算机，算是非常便宜了</p>
<p>Tens of thousands of kits were sold to computer hobbyists,</p>
<p>各种需要自己组装的组件包，卖给了计算机爱好者</p>
<p>and because of its popularity, there were soon all sorts of nifty add-ons available...</p>
<p>因为买的人多，很快相关产品出现了</p>
<p>things like extra memory, a paper tape reader and even a teletype interface.</p>
<p>比如内存，纸带读取器，甚至电传接口</p>
<p>This allowed you, for example, to load a longer, more complicated program from punch tape,</p>
<p>让你可以从纸带上读取更长更复杂的程序</p>
<p>and then interact with it using a teletype terminal.</p>
<p>然后用电传终端交互</p>
<p>However, these programs still had to be written in machine code,</p>
<p>但程序还是要用机器码写</p>
<p>which was really low level and nasty, even for hardcore computer enthusiasts.</p>
<p>写起来很麻烦，即使计算机爱好者也讨厌写</p>
<p>This problem didn't escape a young Bill Gates and Paul Allen,</p>
<p>这没有吓跑年轻的比尔·盖茨和保罗·艾伦</p>
<p>who were 19 and 22 respectively.</p>
<p>他们当时是19岁和22岁</p>
<p>They contacted MITS, the company making the Altair 8800,</p>
<p>他们联系了制造 Altair 8800 的 MITS 公司</p>
<p>suggesting the computer would be more attractive to hobbyists</p>
<p>建议说，如果能运行 BASIC 程序，</p>
<p>if it could run programs written in BASIC,</p>
<p>会对爱好者更有吸引力</p>
<p>a popular and simple programming language.</p>
<p>BASIC 是一门更受欢迎更简单的编程语言</p>
<p>To do this, they needed to write a program that converted BASIC instructions</p>
<p>为此，他们需要一个程序，把 BASIC 代码转成可执行机器码</p>
<p>into native machine code, what's called an interpreter.</p>
<p>这叫解释器 (interpreter)</p>
<p>This is very similar to a compiler,</p>
<p>"解释器"和"编译器"类似</p>
<p>but happens as the programs runs instead of beforehand.</p>
<p>区别是"解释器"运行时转换，而"编译器"提前转换</p>
<p>Let's go to the thought bubble!</p>
<p>让我们进入思想泡泡！</p>
<p>MITS was interested,</p>
<p>MITS 表示感兴趣</p>
<p>and agreed to meet Bill and Paul for a demonstration.</p>
<p>同意与 Bill 和 Paul 见个面，让他们演示一下</p>
<p>Problem is, they hadn't written the interpreter yet.</p>
<p>问题是，他们还没写好解释器</p>
<p>So, they hacked it together in just a few weeks</p>
<p>所以他们花了几个星期赶工，</p>
<p>without even an Altair 8800 to develop on,</p>
<p>而且还不是在 Altair 8800 上写的</p>
<p>finishing the final piece of code on the plane.</p>
<p>最后在飞机上完成了代码</p>
<p>The first time they knew their code worked was at MITS headquarters</p>
<p>他们在墨西哥阿尔伯克基（城市），的 MITS 总部做演示时，</p>
<p>in Albuquerque, New Mexico, for the demo.</p>
<p>才知道代码可以成功运行</p>
<p>Fortunately, it went well and MITS agreed to distribute their software.</p>
<p>幸运的是进展顺利，MITS 同意在计算机上搭载他们的软件</p>
<p>Altair BASIC became the newly formed Microsoft's first product.</p>
<p>Altair BASIC 成了微软的第一个产品</p>
<p>Although computer hobbyists existed prior to 1975,</p>
<p>虽然1975年之前就有计算机爱好者</p>
<p>the Altair 8800 really jump-started the movement.</p>
<p>但 Altair 8800 大量催生了更多计算机爱好者</p>
<p>Enthusiast groups formed, sharing knowledge and software and passion about computing.</p>
<p>爱好者们组成各种小组，分享知识，软件，以及对计算机的热爱</p>
<p>Most legendary among these is the Homebrew Computer Club,</p>
<p>最具传奇色彩的小组是"家酿计算机俱乐部"</p>
<p>which met for the first time in March 1975</p>
<p>第一次小组聚会在1975年3月</p>
<p>to see a review unit of the Altair 8800, one of the first to ship to California.</p>
<p>看一台第一批运来加州的 Altair 8800</p>
<p>At that first meeting was 24-year-old Steve Wozniak, who was so inspired by</p>
<p>第一次聚会上，24岁的 Steve Wozniak ，被 Altair 8800 大大激励</p>
<p>the Altair 8800 that he set out to design his own computer.</p>
<p>开始想设计自己的计算机</p>
<p>In May 1976, he demonstrated his prototype to the Club</p>
<p>1976年5月，他向小组展示了原型机</p>
<p>and shared the schematics with interested members.</p>
<p>并且把电路图分享给感兴趣的其他会员</p>
<p>Unusual for the time, it was designed to connect to a TV and offered a text interface</p>
<p>他的设计不同寻常，要连到电视显示，并提供文本界面</p>
<p>a first for a low-cost computer.</p>
<p>在低成本计算机上还是第一次见</p>
<p>Interest was high, and shortly after fellow club member and college friend Steve Jobs</p>
<p>同是俱乐部成员和大学朋友的史蒂夫·乔布斯</p>
<p>suggested that instead of just sharing the designs for free,</p>
<p>建议说与其免费分享设计，不如直接出售装好的主板</p>
<p>they should just sell an assembled motherboard.</p>
<p>建议说与其免费分享设计，不如直接出售装好的主板</p>
<p>However, you still had to add your own keyboard, power supply, and enclosure.</p>
<p>但用户依然需要自己加键盘，电源和机箱</p>
<p>It went on sale in July 1976 with a price tag of $666.66.</p>
<p>1976年7月开始发售，价格$666.66美元</p>
<p>It was called the Apple-I, and it was Apple Computer's first product.</p>
<p>它叫 Apple-I ，苹果计算机公司的第一个产品</p>
<p>Thanks thought bubble!</p>
<p>谢了思想泡泡</p>
<p>Like the Altair 8800, the Apple-I was sold as a kit.</p>
<p>就像 Altair 8800 一样，Apple-I 也是作为套件出售</p>
<p>It appealed to hobbyists,</p>
<p>Apple-I 吸引了业余爱好者，不</p>
<p>who didn't mind tinkering and soldering,</p>
<p>不介意机器买回来自己组装</p>
<p>but consumers and businesses weren't interested.</p>
<p>但个人消费者和公司对 Apple-I 不感兴趣</p>
<p>This changed in 1977,</p>
<p>这在 1977 年发生变化，</p>
<p>with the release of three game-changing computers,  that could be used right out of the box.</p>
<p>市场上有了三款开箱即用的计算机</p>
<p>First was the Apple II,</p>
<p>第一款是 Apple-II</p>
<p>Apple's earliest product that sold as a complete system</p>
<p>苹果公司第一个提供全套设备的产品</p>
<p>that was professionally designed and manufactured.</p>
<p>设计和制造工艺都是专业的</p>
<p>It also offered rudimentary color graphics and sound output,</p>
<p>它还提供了简单彩色图形和声音输出</p>
<p>amazing features for a low cost machine.</p>
<p>这些功能对低成本机器非常了不起</p>
<p>The Apple II series of computers sold by the millions and quickly</p>
<p>Apple-II 卖了上百万套</p>
<p>propelled Apple to the forefront of the personal computing industry.</p>
<p>把苹果公司推到了个人计算机行业的前沿</p>
<p>The second computer was the TRS-80 Model I,</p>
<p>第二款是"TRS-80 1型"</p>
<p>made by the Tandy Corporation</p>
<p>由 Tandy 公司生产</p>
<p>and sold by RadioShack hence the "TRS"</p>
<p>由 Radioshack 销售，所以叫 TRS</p>
<p>Although less advanced than the Apple II,</p>
<p>虽然不如 Apple-II 先进，</p>
<p>it was half the cost and sold like hot cakes.</p>
<p>但因为价格只有一半，所以卖得很火爆</p>
<p>Finally, there was the Commodore PET 2001,</p>
<p>最后一款是 Commodore PET 2001</p>
<p>with a unique all-in-one design</p>
<p>有一体化设计</p>
<p>that combined computer, monitor, keyboard and tape drive into one device,</p>
<p>集成了计算机，显示器，键盘和磁带驱动器</p>
<p>aimed to appeal to consumers.</p>
<p>目标是吸引普通消费者</p>
<p>It started to blur the line between computer and appliance.</p>
<p>计算机和家用电器之间的界限开始变得模糊</p>
<p>These three computers became known as the 1977 Trinity.</p>
<p>这3台计算机被称为1977年的"三位一体"</p>
<p>They all came bundled with BASIC interpreters,</p>
<p>它们都自带了 BASIC 解释器</p>
<p>allowing non-computer-wizards to create programs.</p>
<p>让不那么精通计算机的人也能用 BASIC 写程序</p>
<p>The consumer software industry also took off,</p>
<p>针对消费者的软件行业开始腾飞</p>
<p>offering games and productivity tools for personal computers,</p>
<p>市场上出现了各种，针对个人计算机的游戏和生产力工具</p>
<p>like calculators and word processors.</p>
<p>比如计算器和文字处理器</p>
<p>The killer app of the era was 1979's VisiCalc,</p>
<p>最火的是 1979 年的 VisiCalc</p>
<p>the first spreadsheet program</p>
<p>第一个电子表格程序</p>
<p>which was infinitely better than paper</p>
<p>比纸好无数倍</p>
<p>and the forbearer of programs like Microsoft Excel and Google Sheets.</p>
<p>是微软 Excel 和 Google Sheets 的老祖先</p>
<p>But perhaps the biggest legacy of these computers was their marketing,</p>
<p>但这些计算机带来的最大影响，也许是他们的营销策略</p>
<p>they were the first to be targeted at households, and not just businesses and hobbyists.</p>
<p>它们针对普通消费者，而不是企业和爱好者</p>
<p>And for the first time in a substantial way,</p>
<p>这是第一次大规模地</p>
<p>computers started to appear in homes, and also small businesses and schools.</p>
<p>计算机出现在家庭，小公司，以及学校中</p>
<p>This caught the attention of the biggest computer company on the planet, IBM, who had seen its</p>
<p>这引起了全球最大计算机公司 IBM 的注意</p>
<p>share of the overall computer market shrink from 60% in 1970 to around 30% by 1980.</p>
<p>其市场份额从1970年的60％，在1980年降到了30％左右</p>
<p>This was mainly because IBM had ignored the microcomputer market,</p>
<p>因为IBM忽略了增长的"微型计算机"市场</p>
<p>which was growing at about 40% annually.</p>
<p>这个市场每年增长约40％</p>
<p>As microcomputers evolved into personal computers, IBM knew it needed to get in on the action.</p>
<p>随着微型计算机演变成个人计算机，IBM 知道他们需要采取行动</p>
<p>But to do this, it would have to radically rethink its computer strategy and design.</p>
<p>但要做到这一点，公司要从根本上重新思考战略和设计</p>
<p>In 1980, IBM's least-expensive computer, the 5120, cost roughly ten thousand dollars,</p>
<p>1980年 IBM 最便宜的计算机，"5120"的价格大概是一万美元</p>
<p>which was never going to compete with the likes of the Apple II.</p>
<p>永远也没法和 Apple-II 这样的计算机竞争</p>
<p>This meant starting from scratch.</p>
<p>意味着要从头开始</p>
<p>A crack team of twelve engineers, later nicknamed the dirty dozen,</p>
<p>一个由十二名工程师组成的精干团队（后来叫"肮脏十二人"）</p>
<p>were sent off to offices in Boca Raton, Florida,</p>
<p>被派往佛罗里达州的，博卡拉顿（Boca Raton）办公室</p>
<p>to be left alone and put their talents to work.</p>
<p>让他们独立工作</p>
<p>Shielded from IBM internal politics, they were able to design a machine as they desired.</p>
<p>不受 IBM 内部的政治斗争干扰，他们想怎么设计怎么设计</p>
<p>Instead of using IBM proprietary CPUs, they chose Intel chips.</p>
<p>没用 IBM 的 CPU，选了 Intel 的芯片</p>
<p>Instead of using IBM's prefered operating system, CP/M,</p>
<p>也没用 IBM 的首选操作系统 CP/M</p>
<p>they licenced Microsoft's Disk Operating System: DOS</p>
<p>而是用了微软的 DOS</p>
<p>and so on, from the screen to the printer.</p>
<p>依此类推，从屏幕到打印机都这样自由选择</p>
<p>For the first time, IBM divisions had to compete with outside firms</p>
<p>IBM 第一次不得不与外部公司竞争</p>
<p>to build hardware and software for the new computer.</p>
<p>来给新计算机做硬件和软件</p>
<p>This radical break from the company tradition of in-house development kept costs low</p>
<p>这和 IBM 的传统做法不同：自己做硬件来节省成本</p>
<p>and brought partner firms into the fold.</p>
<p>然后和其它公司合作</p>
<p>After just a year of development,</p>
<p>经过短短一年</p>
<p>the IBM Personal Computer, or IBM PC was released.</p>
<p>IBM 个人计算机发布了，简称 IBM PC</p>
<p>It was an immediate success,</p>
<p>产品立马取得了成功</p>
<p>especially with businesses that had long trusted the IBM brand.</p>
<p>长期信任 IBM 品牌的企业买了很多</p>
<p>But, most influential to its ultimate success was that the computer featured an open architecture,</p>
<p>但最有影响力的是，它使用 "开放式架构"</p>
<p>with good documentation and expansion slots,</p>
<p>有良好的文档和扩展槽</p>
<p>allowing third parties to create new hardware and peripherals for the platform.</p>
<p>使得第三方可以做硬件/外设</p>
<p>That included things like graphics cards, sounds cards, external hard drives, joysticks,</p>
<p>包括显卡，声卡，外置硬盘，游戏控制杆，</p>
<p>and countless other add-ons.</p>
<p>以及无数其它组件</p>
<p>This spurred innovation, and also competition, resulting in a huge ecosystem of products.</p>
<p>这刺激了创新，激发了竞争，产生了巨大的生态系统</p>
<p>This open architecture became known as "IBM Compatible".</p>
<p>这个开放架构叫 IBM Compatible"（IBM 兼容）</p>
<p>If you bought an "IBM Compatible" computer, it meant you</p>
<p>意味着如果买了"IBM兼容"的计算机</p>
<p>could use that huge ecosystem of software and hardware.</p>
<p>你可以用庞大生态系统中的其它软硬件</p>
<p>Being an open architecture also meant that competitor companies could follow the standard</p>
<p>开放架构也意味着竞争对手公司可以遵循这个标准</p>
<p>and create their own IBM Compatible computers.</p>
<p>做出自己的"IBM 兼容"计算机</p>
<p>Soon, Compaq and Dell were selling their own PC clones...</p>
<p>很快，康柏和戴尔也开始卖 PC</p>
<p>And Microsoft was happy to license MS-DOS to them,</p>
<p>微软很乐意把 MS-DOS 授权给他们</p>
<p>quickly making it the most popular PC operating system.</p>
<p>使 DOS 迅速成为最受欢迎的 PC 操作系统</p>
<p>IBM alone sold two million PCs in the first three years, overtaking Apple.</p>
<p>仅在前三年，IBM就卖出了200万台 PC ，超过了苹果</p>
<p>With a large user base, software and hardware developers concentrated</p>
<p>有了庞大用户群，软件和硬件开发人员，</p>
<p>their efforts on IBM Compatible platforms, there were just more users to sell to.</p>
<p>把精力放在"IBM 兼容"平台，因为潜在用户更多</p>
<p>Then, people wishing to buy a computer bought the one with the</p>
<p>同时，想买计算机的人，也会看哪种计算机的软硬件选择更多</p>
<p>most software and hardware available, and this effect snowballed.</p>
<p>就像雪球效应一样</p>
<p>Companies producing non-IBM-compatible computers, often with superior specs,</p>
<p>而那些生产非"IBM兼容"计算机的公司 （一般性能更好）</p>
<p>failed.</p>
<p>都失败了</p>
<p>Only Apple kept significant market share without IBM compatibility.</p>
<p>只有苹果公司在没有"IBM兼容"的情况下，保持了足够市场份额</p>
<p>Apple ultimately chose to take the opposite approach a "closed architecture" proprietary</p>
<p>苹果公司最终选了相反的方式："封闭架构"</p>
<p>designs that typically prevent people from adding new hardware to their computers.</p>
<p>即自己设计一切，用户一般无法加新硬件到计算机中</p>
<p>This meant that Apple made its own computers, with its own operating system, and often its</p>
<p>意味着苹果公司要做自己的计算机，自己的操作系统</p>
<p>own peripherals, like displays, keyboards, and printers.</p>
<p>还有自己的外围设备，如显示器，键盘和打印机</p>
<p>By controlling the full stack, from hardware to software,</p>
<p>通过控制整个范围，从硬件到软件</p>
<p>Apple was able to control the user experience and improve reliability.</p>
<p>苹果能控制用户体验并提高可靠性</p>
<p>These competing business strategies were the genesis of the "Mac" versus "PC" division</p>
<p>不同的商业策略是"Mac vs PC 谁更好"这种争论的起源</p>
<p>that still exists today... which is a misnomer, because they're both personal computers!</p>
<p>这些争论如今还存在，不过"Mac vs PC"用词不对，因为它们都是个人计算机！</p>
<p>But whatever.</p>
<p>但是随便啦</p>
<p>To survive the onslaught of low-cost PCs,</p>
<p>为了在低成本个人计算机的竞争冲击下生存下来</p>
<p>Apple needed to up its game,</p>
<p>苹果需要提高自身水平，</p>
<p>and offer a user experience that PCs and DOS couldn't.</p>
<p>提供比 PC 和 DOS 更好的用户体验</p>
<p>Their answer was the Macintosh, released in 1984.</p>
<p>他们的答案是 Macintosh，于 1984 年发布</p>
<p>This ground breaking, reasonably-low-cost, all-in-one computer</p>
<p>一台突破性价格适中的一体式计算机，</p>
<p>booted not a command-line text-interface, but rather a graphical user interface,</p>
<p>用的不是命令行界面，而是图形界面</p>
<p>our topic for next week. See you then.</p>
<p>我们下周讨论图形界面. 到时见</p>
<p>26 图形用户界面</p>
<p>Graphical User Interfaces</p>
<p>Hi, I'm Carrie Anne, and welcome to CrashCourse Computer Science!</p>
<p>嗨我是 Carrie Anne 欢迎收看计算机科学速成课</p>
<p>We ended last episode with the 1984 release of Apple's Macintosh personal computer.</p>
<p>我们上集最后，谈了苹果在1984年发布的 Macintosh</p>
<p>It was the first computer a regular person could buy with a graphical user interface</p>
<p>这是普通人可以买到的，第一台带图形用户界面的计算机</p>
<p>and a mouse to interact with it.</p>
<p>还带一个鼠标</p>
<p>This was a radical evolution from the command line interfaces</p>
<p>那时的计算机全是命令行，</p>
<p>found on all other personal computers of the era.</p>
<p>图形界面是个革命性进展</p>
<p>Instead of having to remember...</p>
<p>不必记住</p>
<p>or guess...  the right commands to type in,</p>
<p>或猜测正确的命令</p>
<p>a graphical user interface shows you what functions are possible.</p>
<p>图形界面直接显示了，你可以做什么</p>
<p>You just have to look around the screen for what you want to do.</p>
<p>只要在屏幕上找选项就行了</p>
<p>It's a "point and click" interface.</p>
<p>这是一个"选择并点击"的界面</p>
<p>All of a sudden, computers were much more intuitive.</p>
<p>突然间计算机更直观了</p>
<p>Anybody, not just hobbyists or computer scientists,</p>
<p>不只是爱好者或科学家能用计算机，</p>
<p>could figure things out all by themselves.</p>
<p>任何人都可以用计算机解决问题</p>
<p>The Macintosh is credited with taking Graphical User Interfaces, or GUIs, mainstream,</p>
<p>人们认为是 Macintosh，把图形用户界面（GUI）变成主流</p>
<p>but in reality they were the result of many decades of research.</p>
<p>但实际上图形界面是数十年研究的成果</p>
<p>In previous episodes, we discussed some early interactive graphical applications,</p>
<p>前几集，我们讨论了早期的交互式图形程序</p>
<p>like Sketchpad and Spacewar!, both made in 1962.</p>
<p>比如 Sketchpad 和太空战争，都是1962年制作的</p>
<p>But these were one-off programs,</p>
<p>但都是一次性项目，</p>
<p>and not whole integrated computing experiences.</p>
<p>不是整合良好的体验</p>
<p>Arguably, the true forefather of modern GUIs was Douglas Engelbart.</p>
<p>现代图形界面的先驱，可以说是道格拉斯·恩格尔巴特</p>
<p>Let's go to the thought bubble!</p>
<p>让我们进入思想泡泡！</p>
<p>During World War 2, while Engelbart was stationed in the Philippines as a radar operator,</p>
<p>二战期间，恩格尔巴特驻扎在菲律宾做雷达操作员</p>
<p>he read Vannevar Bush's article on the Memex.</p>
<p>他读了万尼瓦尔·布什的 Memex 文章</p>
<p>These ideas inspired him,</p>
<p>这些文章启发了他</p>
<p>and when his Navy service ended,</p>
<p>当他海军服役结束时</p>
<p>he returned to school, completing a Ph.D. in 1955 at U.C. Berkeley.</p>
<p>他回到学校，1955年在 UCB 取得博士学位</p>
<p>Heavily involved in the emerging computing scene,</p>
<p>他沉溺于新兴的计算机领域</p>
<p>he collected his thoughts in a seminal 1962 report,</p>
<p>他在1962年一份开创性报告中，汇集了各种想法</p>
<p>titled: "Augmenting Human Intellect".</p>
<p>报告名为："增强人类智力"</p>
<p>Engelbart believed that the complexity of the problems facing mankind</p>
<p>恩格尔巴特认为，人类面临的问题，</p>
<p>was growing faster than our ability to solve them.</p>
<p>比解决问题的能力增长得更快</p>
<p>Therefore, finding ways to augment our intellect</p>
<p>因此，找到增强智力的方法，</p>
<p>would seem to be both a necessary and a desirable goal.</p>
<p>似乎是必要且值得一做的目标</p>
<p>He saw that computers could be useful beyond just automation,</p>
<p>他构想计算机不仅做自动化工作</p>
<p>and be essential interactive tools for future knowledge workers to tackle complex problems.</p>
<p>也可以成为未来知识型员工，应对复杂问题的工具</p>
<p>Further inspired by Ivan Sutherland's recently demonstrated Sketchpad,</p>
<p>伊凡·苏泽兰的"几何画板"，进一步启发了恩格尔巴特</p>
<p>Engelbart set out to make his vision a reality, recruiting a team to build the oN-Line System.</p>
<p>他决定动手把愿景变为现实，开始招募团队来做 oN-Line System</p>
<p>He recognized that a keyboard alone was insufficient</p>
<p>他意识到如果只有键盘，</p>
<p>for the type of applications he was hoping to enable.</p>
<p>对他想搭建的程序来说是不够的</p>
<p>In his words:</p>
<p>用他的话说：</p>
<p>"We envisioned problem-solvers using computer-aided working stations to augment their efforts.</p>
<p>"我们设想人们用计算机辅助工作站来增强工作</p>
<p>They required the ability to interact with information displays</p>
<p>用户需要和屏幕上的信息互动</p>
<p>using some sort of device to move [a cursor] around the screen."</p>
<p>用某种设备在屏幕上移动[光标]"</p>
<p>And in 1964, working with colleague Bill English,</p>
<p>1964年，和同事比尔·英格利希的共同努力下</p>
<p>he created the very first computer mouse.</p>
<p>他创造了第一个计算机鼠标，</p>
<p>The wire came from the bottom of the device</p>
<p>尾部有一根线</p>
<p>and looked very much like a rodent and the nickname stuck.</p>
<p>看起来很像老鼠，因此"鼠标"这个名字沿用了下来</p>
<p>Thanks thought bubble!</p>
<p>谢了思想泡泡！</p>
<p>In 1968, Engelbart demonstrated his whole system at the Fall Joint Computer Conference,</p>
<p>1968年恩格尔巴特，在"秋季计算机联合会议"展示了他的系统</p>
<p>in what's often referred to as "the mother of all demos".</p>
<p>这次演示被视为如今所有演示的祖先</p>
<p>The demo was 90 minutes long and demonstrated many features of modern computing:</p>
<p>演示有90分钟，展现了现代计算机的许多功能：</p>
<p>bitmapped graphics,</p>
<p>包括位图图像</p>
<p>video conferencing,</p>
<p>视频会议</p>
<p>word processing,</p>
<p>文字处理</p>
<p>and collaborative real-time editing of documents.</p>
<p>和实时协作编辑文件</p>
<p>There were also precursors to modern GUIs,</p>
<p>还有现代图形界面的原型</p>
<p>like the mouse and multiple windows</p>
<p>比如鼠标和多窗口</p>
<p>although they couldn't overlap.</p>
<p>不过窗口不能重叠</p>
<p>It was way ahead of its time,</p>
<p>远远先于那个时代</p>
<p>and like many products with that label, it ultimately failed,</p>
<p>就像其它"跨时代"的产品一样，它最终失败了</p>
<p>at least commercially.</p>
<p>至少商业上是这样</p>
<p>But its influence on computer researchers of the day was huge.</p>
<p>但它对当时的计算机研究者影响巨大</p>
<p>Engelbart was recognized for this watershed moment in computing with a Turing Award in 1997.</p>
<p>恩格尔巴特因此获得1997年图灵奖</p>
<p>Federal funding started to reduce in the early 1970s,</p>
<p>政府资金在 1970 年代初开始减少</p>
<p>which we discussed two episodes ago.</p>
<p>我们在两集前说过，（第24集：冷战和消费主义）</p>
<p>At that point, many of Engelbart's team, including Bill English,</p>
<p>那时，恩格尔巴特团队里的许多人，包括比尔·英格利希</p>
<p>left and went to Xerox's newly formed Palo Alto Research Center,</p>
<p>去了施乐公司新成立的"帕洛阿尔托研究中心"</p>
<p>more commonly known as Xerox PARC.</p>
<p>更为人熟知的名字是 Xerox PARC</p>
<p>It was here that the first true GUI computer was developed:</p>
<p>他们在这里开发了第一台带真正 GUI 的计算机：</p>
<p>the Xerox Alto, finished in 1973.</p>
<p>施乐奥托于1973年完成</p>
<p>For the computer to be easy to use,</p>
<p>为了让计算机易于使用，</p>
<p>it needed more than just fancy graphics.</p>
<p>需要的不只是花哨的图形</p>
<p>It needed to be built around a concept that people were already familiar with,</p>
<p>还要借助一些人们已经熟悉的概念</p>
<p>so they could immediately recognize how to use the interface with little or no training.</p>
<p>让人们不用培训就能很快明白如何使用</p>
<p>Xerox's answer was to treat the 2D screen like the top of a desk or desktop.</p>
<p>施乐的答案是将2D屏幕当作"桌面"</p>
<p>Just like how you can have many papers laid out on a desk,</p>
<p>就像桌面上放很多文件一样</p>
<p>a user could have several computer programs open at once.</p>
<p>用户可以打开多个程序，</p>
<p>Each was contained in their own frame,</p>
<p>每个程序都在一个框里，</p>
<p>which offered a view onto the application called a window.</p>
<p>叫"窗口"</p>
<p>Also like papers on a desk,</p>
<p>就像桌上的文件一样</p>
<p>these windows could overlap, blocking the items behind them.</p>
<p>窗口可以重叠，挡住后面的东西</p>
<p>And there were desk accessories, like a calculator and clock,</p>
<p>还有桌面配件，比如计算器和时钟</p>
<p>that the user could place on the screen and move around.</p>
<p>用户可以把配件在屏幕上四处移动</p>
<p>It wasn't an exact copy of a desktop though.</p>
<p>它不是现实桌面的完美复制，</p>
<p>Instead, it was a metaphor of a desktop.</p>
<p>而是用桌面这种隐喻</p>
<p>For this reason, surprisingly, it's called the Desktop Metaphor.</p>
<p>因此叫"桌面隐喻"</p>
<p>There are many ways to design an interface like this,</p>
<p>有很多方法来设计界面，</p>
<p>but the Alto team did it with windows, icons, menus, and a pointer</p>
<p>但 Alto 团队用窗口，图标，菜单和指针来做</p>
<p>what's called a WIMP interface.</p>
<p>因此叫 WIMP 界面</p>
<p>It's what most desktop GUIs use today.</p>
<p>如今大部分图形界面都用这个</p>
<p>It also offered a basic set of widgets,</p>
<p>它还提供了一套基本部件</p>
<p>reusable graphical building blocks, things like buttons, checkboxes, sliders, and tabs</p>
<p>可复用的基本元素，比如按钮，打勾框，滑动条和标签页</p>
<p>which were also drawn from real world objects to make them familiar.</p>
<p>这些也来自现实世界，让人们有熟悉感</p>
<p>GUI applications are constructed from these widgets,</p>
<p>GUI 程序就是这些小组件组成的</p>
<p>so let's try coding a simple example using this new programming paradigm.</p>
<p>让我们试着写一个简单例子</p>
<p>First, we have to tell the operating system that we need a new window to be created for our app.</p>
<p>首先，我们必须告诉操作系统，为程序创建一个窗口</p>
<p>We do this through a GUI API.</p>
<p>我们通过 GUI API 实现，需要指定窗口的名字和大小</p>
<p>We need to specify the name of the window and also its size.</p>
<p>我们通过 GUI API 实现，需要指定窗口的名字和大小</p>
<p>Let's say 500 by 500 pixels.</p>
<p>假设是 500×500 像素</p>
<p>Now, let's add some widgets a text box and a button.</p>
<p>现在再加一些小组件，一个文本框和一个按钮</p>
<p>These require a few parameters to create.</p>
<p>创建它们需要一些参数</p>
<p>First, we need to specify what window they should appear in,</p>
<p>首先要指定出现在哪个窗口，</p>
<p>because apps can have multiple windows.</p>
<p>因为程序可以有多个窗口</p>
<p>We also need to specify the default text, the X and Y location in the window, and a width and height.</p>
<p>还要指定默认文字，窗口中的 X,Y 位置以及宽度和高度</p>
<p>Ok, so now we've got something that looks like a GUI app,</p>
<p>好，现在我们有个，看起来像 GUI 程序的东西</p>
<p>but has no functionality.</p>
<p>但它还没有功能</p>
<p>If you click the "roll" button, nothing happens.</p>
<p>如果点 Roll 按钮，什么也不会发生</p>
<p>In previous examples we've discussed,</p>
<p>在之前的例子中，</p>
<p>the code pretty much executes from top to bottom.</p>
<p>代码是从上到下执行的</p>
<p>GUIs, on the other hand, use what's called event-driven programming;</p>
<p>但 GUI 是 "事件驱动编程"</p>
<p>code can fire at any time, and in different orders, in response to events.</p>
<p>代码可以在任意时间执行以响应事件</p>
<p>In this case, it's user driven events,</p>
<p>这里是用户触发事件，</p>
<p>like clicking on a button, selecting a menu item, or scrolling a window.</p>
<p>比如点击按钮，选一个菜单项，或滚动窗口</p>
<p>Or if a cat runs across your keyboard,</p>
<p>或一只猫踩过键盘</p>
<p>it's a bunch of events all at once!</p>
<p>就会一次触发好多事件！</p>
<p>Let's say that when the user clicks the "roll" button,</p>
<p>假设当用户点 Roll 按钮</p>
<p>we want to randomly generate a number between 1 and 20,</p>
<p>我们产生1到20之间的随机数</p>
<p>and then show that value in our text box.</p>
<p>然后在文本框中，显示这个数字</p>
<p>We can write a function that does just that.</p>
<p>我们可以写一个函数来做</p>
<p>We can even get a little fancy and say if we get the number 20,</p>
<p>我们还可以让它变有趣些，假设随机数是 20，</p>
<p>set the background color of the window to blood red!</p>
<p>就把背景颜色变成血红色！</p>
<p>The last thing we need to do is hook this code up</p>
<p>最后，把代码与"事件"相连，</p>
<p>so that it's triggered each time our button is clicked.</p>
<p>每次点按钮时都触发代码</p>
<p>To do this, we need to specify that our function "handles" this event for our button,</p>
<p>那么，要设置事件触发时，由哪个函数来处理</p>
<p>by adding a line to our initialize function.</p>
<p>我们可以在初始化函数中，加一行代码来实现</p>
<p>The type of event, in this case, is a click event,</p>
<p>我们要处理的，是"点击"事件，</p>
<p>and our function is the event handler for that event.</p>
<p>然后函数会处理这个事件</p>
<p>Now we're done.</p>
<p>现在完成了</p>
<p>We can click that button all day long,</p>
<p>可以点按钮点上一整天，</p>
<p>and each time, our "roll D20" function gets dispatched and executed.</p>
<p>每次都会执行 rollD20 函数</p>
<p>This is exactly what's happening behind the scenes</p>
<p>这就是程序背后的原理</p>
<p>when you press the little bold button in a text editor, or select shutdown from a dropdown menu</p>
<p>在编辑器里点粗体或菜单里选关机，</p>
<p>a function linked to that event is firing.</p>
<p>一个处理该事件的函数会触发</p>
<p>Hope I don't roll a 20.</p>
<p>希望不会随机到 20</p>
<p>Ahhhh!</p>
<p>啊！！！</p>
<p>Ok, back to the Xerox Alto!</p>
<p>好，现在回到施乐奥托！</p>
<p>Roughly 2000 Altos were made, and used at Xerox and given to University labs.</p>
<p>大约制作了2000台奥托，有的在施乐公司内部用，有的送给大学实验室</p>
<p>They were never sold commercially.</p>
<p>从来没有商业出售过</p>
<p>Instead, the PARC team kept refining the hardware and software,</p>
<p>然而，PARC 团队不断完善硬件和软件</p>
<p>culminating in the Xerox Star system, released in 1981.</p>
<p>最终于1981年发布了施乐之星系统</p>
<p>The Xerox Star extended the desktop metaphor.</p>
<p>施乐之星扩展了"桌面隐喻"</p>
<p>Now, files looked like pieces of paper,</p>
<p>现在文件看起来就像一张纸，</p>
<p>and they could be stored in little folders,</p>
<p>还可以存在文件夹里</p>
<p>all of which could sit on your desktop, or be put away into digital filing cabinets.</p>
<p>这些都可以放桌面上，或数字文件柜里</p>
<p>It's a metaphor that sits ontop of the underlying file system.</p>
<p>这样来隐喻底层的文件系统</p>
<p>From a user's perspective, this is a new level of abstraction!</p>
<p>从用户角度来看，是一层新抽象！</p>
<p>Xerox, being in the printing machine business, also advanced text and graphics creation tools.</p>
<p>施乐卖的是印刷机，但在文本和图形制作工具领域也有领先</p>
<p>For example, they introduced the terms: cut, copy and paste.</p>
<p>例如，他们首先使用了， "剪切""复制""粘贴"这样的术语</p>
<p>This metaphor was drawn</p>
<p>这个比喻来自</p>
<p>from how people dealt with making edits in documents written on typewriters.</p>
<p>编辑打字机文件</p>
<p>You'd literally cut text out with scissors, and then paste it, with glue,</p>
<p>真的是剪刀"剪切"，</p>
<p>into the spot you wanted in another document.</p>
<p>然后胶水"粘贴" 到另一个文件</p>
<p>Then you'd photocopy the page to flatten it back down into a single layer,</p>
<p>然后再复印一次，新文件就是一层了</p>
<p>making the change invisible.</p>
<p>看不出编辑的痕迹</p>
<p>Thank goodness for computers!</p>
<p>感谢计算机的出现！</p>
<p>This manual process was moot with the advent of word processing software,</p>
<p>文字处理软件出现后，这种手工做法就消失了</p>
<p>which existed on platforms like the Apple II and Commodore PET.</p>
<p>Apple II 和 Commodore PET 上有文字处理软件</p>
<p>But Xerox went way beyond the competition</p>
<p>但施乐在这点上走的更远</p>
<p>with the idea that whatever you made on the computer</p>
<p>无论你在计算机上做什么，</p>
<p>should look exactly like the real world version, if you printed it out.</p>
<p>文件打印出来应该长得一样</p>
<p>They dubbed this What-You-See-Is-What-You-Get or WYSIWYG.</p>
<p>他们叫这个"所见即所得"</p>
<p>Unfortunately, like Engelbart's oN-Line System,</p>
<p>不幸的是，就像恩格尔巴特的 oN-Line System</p>
<p>the Xerox Star was ahead of its time.</p>
<p>施乐之星也领先于那个时代，</p>
<p>Sales were sluggish</p>
<p>销售量不高</p>
<p>because it had a price tag equivalent to nearly $200,000 today for an office setup.</p>
<p>因为在办公室里配一个，相当如今20万美元</p>
<p>It also didn't help that the IBM PC launched that same year,</p>
<p>IBM 同年推出了 IBM PC</p>
<p>followed by a tsunami of cheap "IBM Compatible" PC Clones.</p>
<p>之后便宜的"IBM兼容"计算机席卷市场</p>
<p>But the great ideas that PARC researchers had been cultivating</p>
<p>但 PARC 研究人员花了十几年做的这些，</p>
<p>and building for almost a decade didn't go to waste.</p>
<p>没有被浪费</p>
<p>In December of 1979, a year and a half before the Xerox Star shipped,</p>
<p>1979年12月，施乐之星出货前一年半</p>
<p>a guy you may have heard of visited: Steve Jobs.</p>
<p>有个人去施乐公司参观，你可能听说过这个人：史蒂夫·乔布斯</p>
<p>There's a lot of lore surrounding this visit,</p>
<p>这次参观有很多传闻</p>
<p>with many suggesting that Steve Jobs and Apple stole Xerox's ideas.</p>
<p>许多人认为，乔布斯和苹果偷走了施乐的创意</p>
<p>But that simply isn't true.</p>
<p>但那不是事实</p>
<p>In fact, Xerox approached Apple, hoping to partner with them.</p>
<p>事实上是施乐公司主动找苹果，希望合作</p>
<p>Ultimately, Xerox was able to buy a million dollar stake in Apple</p>
<p>最终施乐还买了苹果的一百万美元股份</p>
<p>before its highly anticipated I.P.O.</p>
<p>在苹果备受瞩目的首次公开募股(IPO) 前买的</p>
<p>but it came with an extra provision:</p>
<p>但一个额外条款是：</p>
<p>"disclose everything cool going on at Xerox PARC".</p>
<p>"公布一切施乐研究中心正在进行的酷工作"</p>
<p>Steve knew they had some of the greatest minds in computing,</p>
<p>史蒂夫知道他们很厉害</p>
<p>but he wasn't prepared for what he saw.</p>
<p>但他完全没预想到这些</p>
<p>There was a demonstration of Xerox's graphical user interface,</p>
<p>其中有个演示是</p>
<p>running on a crisp, bitmapped display,</p>
<p>一个清晰的位图显示器上，运行着施乐公司的图形界面，</p>
<p>all driven with intuitive mouse input.</p>
<p>操作全靠鼠标直观进行</p>
<p>Steve later said, "It was like a veil being lifted from my eyes.</p>
<p>史蒂夫后来说："就像拨开了眼前的一层迷纱</p>
<p>I could see the future of what computing was destined to be."</p>
<p>我可以看到计算机产业的未来"</p>
<p>Steve returned to Apple with his engineering entourage,</p>
<p>史蒂夫和随行的工程师回到苹果公司，</p>
<p>and they got to work inventing new features,</p>
<p>开始开发新功能</p>
<p>like the menu bar and a trash can to store files to be deleted;</p>
<p>比如菜单栏和垃圾桶，垃圾桶存删除文件</p>
<p>it would even bulge when full again with the metaphors.</p>
<p>满了甚至会膨胀再次使用了隐喻</p>
<p>Apple's first product with a graphical user interface, and mouse,</p>
<p>苹果第一款有图形界面和鼠标的产品</p>
<p>was the Apple Lisa, released in 1983.</p>
<p>是 1983 年发行的 Apple Lisa</p>
<p>It was a super advanced machine, with a super advanced price</p>
<p>一台超级先进的机器，标了"超级先进"的价格</p>
<p>almost 25 thousand dollars today.</p>
<p>差不多是如今的 25000 美元</p>
<p>That was significantly cheaper than the Xerox Star,</p>
<p>虽然比施乐之星便宜不少</p>
<p>but it turned out to be an equal flop in the market.</p>
<p>但在市场上同样失败</p>
<p>Luckily, Apple had another project up its sleeve:</p>
<p>幸运的是，苹果还有另一个项目：</p>
<p>The Macintosh, released a year later, in 1984.</p>
<p>Macintosh，于 1984 年发布</p>
<p>It had a price of around 6,000 dollars today a quarter of the Lisa's cost.</p>
<p>价格大约是如今的6000美元 Lisa 的四分之一</p>
<p>And it hit the mark, selling 70,000 units in the first 100 days.</p>
<p>它成功了，开售100天就卖了7万台</p>
<p>But after the initial craze, sales started to falter,</p>
<p>但在最初的狂潮后，销售额开始波动</p>
<p>and Apple was selling more of its Apple II computers than Macs.</p>
<p>苹果公司卖的 Apple II 比 Mac 多</p>
<p>A big problem was that no one was making software for this new machine</p>
<p>一个大问题是：</p>
<p>with it's new radical interface.</p>
<p>没人给这台新机器做软件</p>
<p>And it got worse. The competition caught up fast.</p>
<p>之后情况变得更糟，竞争对手赶上来了</p>
<p>Soon, other personal computers had primitive,</p>
<p>不久，其它价格只有 Mac 几分之一的个人计算机，</p>
<p>but usable graphical user interfaces on computers a fraction of the cost.</p>
<p>有了原始但可用的图形界面</p>
<p>Consumers ate it up, and so did PC software developers.</p>
<p>消费者认可它们，PC 软件开发者也认可</p>
<p>With Apple's finances looking increasingly dire,</p>
<p>随着苹果的财务状况日益严峻，</p>
<p>and tensions growing with Apple's new CEO, John Sculley,</p>
<p>以及和苹果新 CEO 约翰·斯卡利的关系日益紧张</p>
<p>Steve Jobs was ousted.</p>
<p>史蒂夫乔布斯被赶出了苹果公司</p>
<p>A few months later, Microsoft released Windows 1.0.</p>
<p>几个月后，微软发布了 Windows 1.0</p>
<p>It may not have been as pretty as Mac OS,</p>
<p>它也许不如 Mac OS 漂亮</p>
<p>but it was the first salvo in what would become a bitter rivalry</p>
<p>但让微软在市场中站稳脚跟，</p>
<p>and near dominance of the industry by Microsoft.</p>
<p>奠定了统治地位</p>
<p>Within ten years, Microsoft Windows was running on almost 95% of personal computers.</p>
<p>十年内，95％的个人计算机上都有微软的 Windows</p>
<p>Initially, fans of Mac OS could rightly claim superior graphics and ease-of-use.</p>
<p>最初，Mac OS 的爱好者还可以说， Mac 有卓越的图形界面和易用性</p>
<p>Those early versions of Windows were all built on top of DOS,</p>
<p>Windows 早期版本都是基于 DOS，而 DOS 设计时 </p>
<p>which was never designed to run GUIs.</p>
<p>没想过运行图形界面</p>
<p>But, after Windows 3.1,</p>
<p>但 Windows 3.1 之后</p>
<p>Microsoft began to develop a new consumer-oriented OS</p>
<p>微软开始开发新的，面向消费者的 GUI 操作系统</p>
<p>with upgraded GUI called Windows 95.</p>
<p>叫 Windows 95</p>
<p>This was a significant rewrite that offered much more than just polished graphics.</p>
<p>这是一个意义非凡的版本，不仅提供精美的界面</p>
<p>It also had advanced features Mac OS didn't have,</p>
<p>还有 Mac OS 没有的高级功能</p>
<p>like program multitasking and protected memory.</p>
<p>比如"多任务"和"受保护内存"</p>
<p>Windows 95 introduced many GUI elements still seen in Windows versions today,</p>
<p>Windows 95 引入了许多，如今依然见得到的 GUI 元素</p>
<p>like the Start menu, taskbar, and Windows Explorer file manager.</p>
<p>比如开始菜单，任务栏和 Windows 文件管理器</p>
<p>Microsoft wasn't infallible though.</p>
<p>不过微软也失败过</p>
<p>Looking to make the desktop metaphor even easier and friendlier,</p>
<p>为了让桌面更简单友好，</p>
<p>it worked on a product called Microsoft Bob,</p>
<p>微软开发了一个产品叫 Microsoft Bob</p>
<p>and it took the idea of using metaphors to an extreme.</p>
<p>将比喻用到极致</p>
<p>Now you had a whole virtual room on your screen,</p>
<p>现在屏幕上有了一个虚拟房间</p>
<p>with applications embodied as objects that you could put on tables and shelves.</p>
<p>程序是物品，可以放在桌子和书架上</p>
<p>It even came with a crackling fireplace and a virtual dog to offer assistance.</p>
<p>甚至还有噼啪作响的壁炉，和提供帮助的虚拟狗狗</p>
<p>And you see those doors on the sides?</p>
<p>你看到那边的门没？</p>
<p>Yep, those went to different rooms in your computer</p>
<p>是的，那些门通往不同房间，</p>
<p>where different applications were available.</p>
<p>房间里有不同程序</p>
<p>As you might have guessed,</p>
<p>你可能猜到了，</p>
<p>it was not a success.</p>
<p>它没有获得成功</p>
<p>This is a great example of how the user interfaces we enjoy today</p>
<p>这是一个好例子，说明如今的用户界面</p>
<p>are the product of what's essentially natural selection.</p>
<p>是自然选择后的结果</p>
<p>Whether you're running Windows, Mac, Linux, or some other desktop GUI,</p>
<p>无论你用的是，Windows，Mac，Linux 或其他 GUI</p>
<p>it's almost certainly an evolved version of the WIMP paradigm first introduced on the Xerox Alto.</p>
<p>几乎都是施乐奥托 WIMP 的变化版</p>
<p>Along the way, a lot of bad ideas were tried, and failed.</p>
<p>一路上，人们试了各种做法并失败了</p>
<p>Everything had to be invented, tested, refined, adopted or dropped.</p>
<p>一切都必须发明，测试，改进，适应或抛弃</p>
<p>Today, GUIs are everywhere and while they're good,</p>
<p>如今，图形界面无处不在，使用体验一般只是可以接受，</p>
<p>they are not always great.</p>
<p>而不是非常好</p>
<p>No doubt you've experienced design-related frustrations</p>
<p>你肯定体验过差劲的设计</p>
<p>after downloading an application, used someone else's phone,</p>
<p>比如下载了很烂的 App，用过别人糟糕的手机</p>
<p>or visited a website. And for this reason,</p>
<p>或者看到过很差的网站，因此</p>
<p>computer scientists and interface designers continue to work hard</p>
<p>计算机科学家和界面设计师，会继续努力工作</p>
<p>to craft computing experiences that are both easier and more powerful.</p>
<p>做出更好更强大的界面</p>
<p>Ultimately, working towards Engelbart's vision of augmenting human intellect.</p>
<p>朝着恩格尔巴特"增强人类智能"的愿景努力</p>
<p>I'll see you next week.</p>
<p>我们下周见</p>
<p>27 3D 图形</p>
<p>3D Graphics</p>
<p>Hi, I'm Carrie Anne, and welcome to Crash Course Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>Over the past five episodes,</p>
<p>在过去五集</p>
<p>we've worked up from text-based teletype interfaces to pixelated bitmapped graphics.</p>
<p>我们从基于电传打字机的命令行界面，讲到图形怎么显示到屏幕上</p>
<p>Then, last episode,we covered Graphical User Interfaces and all</p>
<p>再到上集的图形用户界面（GUI）</p>
<p>their "Ooey Gooey" richness.</p>
<p>以及图形界面的美味</p>
<p>All of these examples have been 2D. But of course "we are living in a 3D world</p>
<p>之前的例子都是2D, 但我们生活的世界是3D的</p>
<p>and I'm a 3 dimensional girl!</p>
<p>我也是个三维 girl~</p>
<p>So today, we're going to talk about some fundamental methods in 3D computer graphics</p>
<p>所以今天，我们讲3D图形的基础知识</p>
<p>and how you render them onto a 2D screen.</p>
<p>以及如何渲染 3D 图形到 2D 屏幕上</p>
<p>As we discussed in episode 24 we can write functions that draw a line between any two points like A and B.</p>
<p>24集中说过，可以写一个函数，从A到B画一条线</p>
<p>By manipulating the X and Y coordinates of points A and B, we can manipulate the line.</p>
<p>通过控制 A 和 B 的(X,Y)坐标，可以控制一条线</p>
<p>In 3D graphics, points have not just two coordinates, but three -X, Y and Z.</p>
<p>在3D图像中, 点的坐标不再是两点, 而是三点, X,Y,Z</p>
<p>Or "zee" but I'm going to say "zed".</p>
<p>或读"Zee"，但我之后会读成"Zed"</p>
<p>Of course, we don't have X/Y/Z coordinates on a 2D computer screen</p>
<p>当然，2D的电脑屏幕上，不可能有 XYZ 立体坐标轴</p>
<p>so graphics algorithms are responsible for "flattening" 3D coordinates onto a 2D plane.</p>
<p>所以有图形算法，负责把3D坐标"拍平"显示到2D屏幕上</p>
<p>This process is known as 3D Projection.</p>
<p>这叫"3D投影"</p>
<p>Once all of the points have been converted from 3D to 2D</p>
<p>所有的点都从3D转成2D后</p>
<p>we can use the regular 2D line drawing function to connect the dots… literally.</p>
<p>就可以用画2D线段的函数来连接这些点</p>
<p>This is called Wireframe Rendering.</p>
<p>这叫 "线框渲染"</p>
<p>Imagine building a cube out of chopsticks, and shining a flashlight on it.</p>
<p>想象用筷子做一个立方体，然后用手电筒照它</p>
<p>The shadow it casts onto your wall its projection is flat.</p>
<p>墙上的影子就是投射，是平的</p>
<p>If you rotate the cube around</p>
<p>如果旋转立方体</p>
<p>you can see it's a 3D object, even though it's a flat projection.</p>
<p>投影看起来会像 3D 物体，尽管是投影面是平的</p>
<p>This transformation from 3D to 2D is exactly what your computer is doing</p>
<p>电脑也是这样3D转2D</p>
<p>just with a lot more math… and less chopsticks.</p>
<p>只不过用大量数学，而不是筷子</p>
<p>There are several types of 3D Projection.</p>
<p>3D投影有好几种</p>
<p>What you're seeing right now is an Orthographic Projection</p>
<p>你现在看到的，叫正交投影</p>
<p>where, for example, the parallel sides in the cube appear as parallel in the projection.</p>
<p>立方体的各个边，在投影中互相平行</p>
<p>In the real 3D world through, parallel lines converge as they get further from the viewer</p>
<p>在真实3D世界中,平行线段会在远处收敛于一点</p>
<p>like a road going to the horizon.</p>
<p>就像远处的马路汇聚到一点</p>
<p>This type of 3D projection is called Perspective Projection .</p>
<p>这叫透视投射</p>
<p>It's the same process, just with different math.</p>
<p>过程是类似的，只是数学稍有不同</p>
<p>Sometimes you want perspective and sometimes you don't --</p>
<p>有时你想要透视投影，有时不想</p>
<p>the choice is up to the developer.</p>
<p>具体取决于开发人员</p>
<p>Simple shapes, like cubes, are easily defined by straight lines.</p>
<p>如果想画立方体这种简单图形，直线就够了</p>
<p>But for more complex shapes, triangles are better</p>
<p>但更复杂的图形，三角形更好</p>
<p>what are called polygons in 3D graphics.</p>
<p>在3D图形学中，我们叫三角形"多边形"(Polygons)</p>
<p>Look at this beautiful teapot made out of polygons.</p>
<p>看看这个多边形组成的漂亮茶壶</p>
<p>A collection of polygons like this is a mesh</p>
<p>一堆多边形的集合叫网格</p>
<p>The denser the mesh, the smoother the curves and the finer the details.</p>
<p>网格越密，表面越光滑，细节越多</p>
<p>But, that also increases the polygon count, which means more work for the computer</p>
<p>但意味着更多计算量</p>
<p>Game designers have to carefully balance model fidelity vs. polygon count,</p>
<p>游戏设计者要平衡角色的真实度，和多边形数量</p>
<p>because if the count goes too high</p>
<p>如果数量太多，</p>
<p>the framerate of an animation drops below what users perceive as smooth.</p>
<p>帧率会下降到肉眼可感知，用户会觉得卡</p>
<p>For this reason, there are algorithms for simplifying meshes.</p>
<p>因此有算法用来简化网格</p>
<p>The reason triangles are used,</p>
<p>之所以三角形更常用，</p>
<p>and not squares, or polygons, or some other more complex shape</p>
<p>而不是用正方形，或其它更复杂的图形</p>
<p>is simplicity:</p>
<p>是因为三角形的简单性</p>
<p>three points in space unambiguously define a plane.</p>
<p>空间中三点定义一个平面</p>
<p>If you give me three points in a 3D space, I can draw a plane through it</p>
<p>如果给3个3D点，我能画出一个平面</p>
<p>there is only one.. single.. answer.</p>
<p>而且只有这一个答案</p>
<p>This isn't guaranteed to be true for shapes with four or more points.</p>
<p>4个或多于4个点就不一定了</p>
<p>Also two points aren't enough to define a plane, only a line,</p>
<p>而2个点不够定义平面，只能定义线段</p>
<p>so three is the perfect and minimal number. Triangles for the win!</p>
<p>所以3是最完美的数字，三角形万岁</p>
<p>Wireframe rendering is cool and all sorta retro but of course 3D graphics can also be filled.</p>
<p>线框渲染虽然很酷，但3D图像需要填充</p>
<p>The classic algorithm for doing this is called Scanline Rendering,</p>
<p>填充图形的经典算法叫扫描线渲染 (Scanline Rendering)，</p>
<p>first developed in 1967 at the University of Utah</p>
<p>于1967年诞生在犹他州大学</p>
<p>For a simple example, let's consider just one polygon.</p>
<p>为了例子简单，我们只看一个多边形</p>
<p>Our job here is to figure out how this polygon translates to filled pixels on a computer screen</p>
<p>我们要思考，这个多边形如何转成一块填满像素的区域</p>
<p>so let's first overlay a grid of pixels to fill</p>
<p>我们先铺一层像素网格</p>
<p>The scanline algorithm starts by reading the three points that make up the polygon</p>
<p>扫描线算法先读多边形的3个点</p>
<p>and finding the lowest and highest Y values.  It will only consider rows between these two points.</p>
<p>找最大和最小的Y值，只在这两点间工作</p>
<p>Then, the algorithm works down one row at a time.</p>
<p>然后算法从上往下，一次处理一行</p>
<p>In each row, it calculates where a line running through</p>
<p>计算每一行</p>
<p>the center of a row intersects with the side of the polygon.</p>
<p>和多边形相交的2个点</p>
<p>Because polygons are triangles, if you intersect one line, you have to intersect with another.</p>
<p>因为是三角形,如果相交一条边, </p>
<p>It's guaranteed!</p>
<p>必然相交另一条</p>
<p>The job of the scanline algorithm is to fill in the pixels between the two intersections.</p>
<p>扫描线算法会填满2个相交点之间的像素</p>
<p>Let's see how this works.</p>
<p>来看个具体例子</p>
<p>On the first row we look at we intersect here and here.</p>
<p>第一行相交于这里和这里</p>
<p>The algorithm then colors in all pixels between those two intersections.</p>
<p>算法把两点间填满颜色</p>
<p>And this just continues, row by row, which is why it's called Scan... Line... Rendering.</p>
<p>然后下一行，再下一行，所以叫扫描..线..渲染</p>
<p>When we hit the bottom of the polygon, we're done.</p>
<p>扫到底部就完成了</p>
<p>The rate at which a computer fills in polygons is called the fillrate.</p>
<p>填充的速度叫 fillrate（填充速率）</p>
<p>Admittedly, this is a pretty ugly filled polygon. It has what are known as "Jaggies" rough edges.</p>
<p>当然这样的三角形比较丑，边缘满是锯齿</p>
<p>This effect is less pronounced when using smaller pixels.</p>
<p>当像素较小时就不那么明显</p>
<p>But nonetheless, you see these in games all the time, especially on lower powered platforms.</p>
<p>但尽管如此，你肯定在游戏里见过这种效果，特别是低配电脑</p>
<p>One method to soften this effect is Antialiasing.</p>
<p>一种减轻锯齿的方法叫，抗锯齿(Antialiasing)</p>
<p>Instead of filling pixels in a polygon with the same color,</p>
<p>与其每个像素都涂成一样的颜色</p>
<p>we can adjust the color based on how much the polygon cuts through each pixel</p>
<p>可以判断多边形切过像素的程度，来调整颜色</p>
<p>If a pixel is entirely inside of a polygon,it gets fully colored.</p>
<p>如果像素在多边形内部，就直接涂颜色</p>
<p>But if the polygon only grazes a pixel, it'll get a lighter shade.</p>
<p>如果多边形划过像素，颜色就浅一些</p>
<p>This feathering of the edges is much more pleasant to the eyes.</p>
<p>这种边缘羽化的效果看着更舒服些</p>
<p>Antialiasing is used all over the place, including in 2D graphics, like fonts and icons.</p>
<p>抗锯齿被广泛使用，比如字体和图标</p>
<p>If you lean in real close to your monitor..</p>
<p>如果你把脸贴近屏幕</p>
<p>Closer, Closer.</p>
<p>近点..再近点</p>
<p>You'll see all the fonts in your browser are Antialiased. So smooth!</p>
<p>你能看到浏览器里字体是抗锯齿的，超平滑</p>
<p>In a 3D scene, there are polygons that are part objects in the back, near the front,and just about everywhere.</p>
<p>在3D场景中，多边形到处都是</p>
<p>Only some are visible,</p>
<p>但只有一部分能看见</p>
<p>because some objects are hidden behind other objects in the scene</p>
<p>因为其它的被挡住了</p>
<p>what's called occlusion .</p>
<p>这叫遮挡</p>
<p>The most straightforward way to handle this is to use a sort algorithm,</p>
<p>最直接的处理办法是用排序算法</p>
<p>and arrange all the polygons in the scene from farthest to nearest, then render them in that order.</p>
<p>从远到近排列，然后从远到近渲染</p>
<p>This is called the Painter's Algorithm , because painters also have to start with the background</p>
<p>这叫画家算法因为画家也是先画背景</p>
<p>and then increasingly work up to foreground elements.</p>
<p>然后再画更近的东西</p>
<p>Consider this example scene with three overlapping polygons.</p>
<p>看这个例子，有3个重叠的多边形</p>
<p>To make things easier to follow, we're going to color the polygons differently.</p>
<p>为了简单，我们画成不同颜色</p>
<p>Also for simplicity, we'll assume these polygons are all parallel to the screen</p>
<p>同时，假设3个多边形都和屏幕平行</p>
<p>but in a real program, like a game,</p>
<p>但在实际应用中, 比如游戏里，</p>
<p>the polygons can be tilted in 3D space.</p>
<p>多边形可能是倾斜的</p>
<p>Our three polygons, A B and C… are at distance 20, 12 and 14.</p>
<p>3个多边形A,B,C，距离20,12,14</p>
<p>The first thing the Painter's Algorithm does is sort all the polygons, from farthest to nearest.</p>
<p>画家算法的第一件事，是从远到近排序</p>
<p>Now that they're in order, we can use scanline rendering to fill each polygon, one at a time.</p>
<p>现在有序了，我们可以用扫描线算法填充多边形，一次填一个</p>
<p>We start with Polygon A, the farthest one away.</p>
<p>我们从最远的A开始</p>
<p>Then we repeat the process for the next farthest polygon, in this case, C.</p>
<p>然后重复这个过程，填充第二远的C</p>
<p>And then we repeat this again, for Polygon B.</p>
<p>然后是 B</p>
<p>Now we're all done, and you can see the ordering is correct. The polygons that are closer, are in front!</p>
<p>现在完成了，可以看到顺序是对的，近的多边形在前面！</p>
<p>An alternative method for handling occlusion is called Z-Buffering .</p>
<p>还有一种方法叫深度缓冲</p>
<p>It achieves the same output as before, but with a different algorithm.</p>
<p>它和之前的算法做的事情一样，但方法不同</p>
<p>Let's go back to our previous example, before it was sorted.</p>
<p>我们回到之前的例子，回到排序前的状态</p>
<p>That's because this algorithm doesn't need to sort any polygons, which makes it faster.</p>
<p>因为这个算法不用排序，所以速度更快</p>
<p>In short, Z-buffering keeps track of the closest distance</p>
<p>简而言之，Z-buffering 算法会记录</p>
<p>to a polygon for every pixel in the scene.</p>
<p>场景中每个像素和摄像机的距离</p>
<p>It does this by maintaining a Z-Buffer, which is just a matrix of values that sits in memory.</p>
<p>在内存里存一个数字矩阵</p>
<p>At first, every pixel is initialized to infinity.</p>
<p>首先，每个像素的距离被初始化为"无限大"</p>
<p>Then Z-buffering starts with the first polygon in its list. In this case, that's A.</p>
<p>然后 Z-buffering 从列表里第一个多边形开始处理，也就是A</p>
<p>It follows the same logic as the scanline algorithm, but instead of coloring in pixels,</p>
<p>它和扫描线算法逻辑相同，但不是给像素填充颜色</p>
<p>it checks the distance of the polygon versus what's recorded in its Z-Buffer.</p>
<p>而是把多边形的距离，和 Z-Buffer 里的距离进行对比</p>
<p>It records the lower of the two values.</p>
<p>它总是记录更低的值</p>
<p>For our Polygon A, with a distance of 20, it wins against infinity every time.</p>
<p>A距离20，20小于"无限大"，所以缓冲区记录20</p>
<p>When it's done with Polygon A, it moves on to the next polygon in its list, and the same thing happens.</p>
<p>算完A之后算下一个，以此类推</p>
<p>Now, because we didn't sort the polygons,</p>
<p>因为没对多边形排序</p>
<p>it's not always the case that later polygons overwrite high values.</p>
<p>所以后处理的多边形并不总会覆盖前面的</p>
<p>In the case of Polygon C,</p>
<p>对于多边形C</p>
<p>only some of the values in the Z-buffer get new minimum distances.</p>
<p>缓冲区里只有一部分值会被多边形C的距离值覆盖</p>
<p>This completed Z-buffer is used in conjunction with a fancier version of scanline rendering</p>
<p>Z缓冲区完成后，会和"扫描线"算法的改进高级版配合使用</p>
<p>that not only tests for line intersection,</p>
<p>不仅可以勘测到线的交叉点</p>
<p>but also does a look up to see if that pixel will even be visible in the final scene.</p>
<p>还可以知道某像素是否在最终场景中可见</p>
<p>If it's not, the algorithm skips it and moves on.</p>
<p>如果不可见，扫描线算法会跳过那个部分</p>
<p>An interesting problem arises when two polygons have the same distance,</p>
<p>当两个多边形距离相同时，会出现一个有趣问题</p>
<p>like if Polygon A and B are both at a distance of 20. Which one do you draw on top?</p>
<p>比如多边形 A 和 B 距离都是 20, 哪个画上面?</p>
<p>Polygons are constantly being shuffled around in memory and changing their access order.</p>
<p>多边形会在内存中移来移去，访问顺序会不断变化</p>
<p>Plus, rounding errors are inherent in floating point computations.</p>
<p>另外,计算浮点数有舍入误差</p>
<p>So, which one gets drawn on top is often unpredictable.</p>
<p>所以哪一个画在上面, 往往是不可预测的</p>
<p>The result is a flickering effect called Z-Fighting, which if you've played 3D games no doubt encountered.</p>
<p>导致出现 Z-fighting 效果，如果你玩过3D游戏，肯定见过</p>
<p>Speaking of glitches, another common optimization in 3D graphics is called Back-Face Culling.</p>
<p>说起故障，3D游戏中有个优化叫背面剔除</p>
<p>If you think about it, a triangle has two sides, a front and a back.</p>
<p>你想想,三角形有两面,正面和背面</p>
<p>With something like the head of an avatar, or the ground in a game,</p>
<p>游戏角色的头部或地面，</p>
<p>you should only ever see one side -the side facing outwards.</p>
<p>只能看到朝外的一面</p>
<p>So to save processing time, the back-side of polygons are often ignored in the rendering pipeline</p>
<p>所以为了节省处理时间，会忽略多边形背面</p>
<p>which cuts the number of polygon faces to consider in half.</p>
<p>减了一半多边形面数</p>
<p>This is great, except when there's a bug that lets you get inside of those objects,and look outwards.</p>
<p>这很好,但有个bug是如果进入模型内部往外看</p>
<p>Then the avatar head or ground becomes invisible.</p>
<p>头部和地面会消失</p>
<p>Moving on. We need to talk about lighting -also known as shading</p>
<p>继续，我们讲灯光，也叫明暗处理</p>
<p>because if it's a 3D scene, the lighting should vary over the surface of objects.</p>
<p>因为3D场景中, 物体表面应该有明暗变化</p>
<p>Let's go back to our teapot mesh.</p>
<p>我们回到之前的茶壶网格</p>
<p>With scanline rendering coloring in all the polygons, our teapot looks like this.</p>
<p>用"扫描线"算法渲染所有多边形后，茶壶看起来像这样</p>
<p>Not very 3D.</p>
<p>没什么 3D 感</p>
<p>So, let's add some lighting to enhance the realism!</p>
<p>我们来加点灯光，提高真实感</p>
<p>As an example, we'll pick 3 polygons from different parts of our teapot.</p>
<p>为了举例，我们从茶壶上挑3个不同位置的多边形</p>
<p>Unlike our previous examples, we're now going to consider how these polygons are oriented in 3D space</p>
<p>和之前的例子不同，这次要考虑这些多边形面对的方向</p>
<p>they're no longer parallel to the screen, but rather tilted in different 3D directions.</p>
<p>它们不平行于屏幕，而是面对不同方向</p>
<p>The direction they face is called the Surface Normal ,</p>
<p>他们面对的方向叫 " 表面法线 "</p>
<p>and we can visualize that direction with a little 3D arrow that's perpendicular to the polygon's surface.</p>
<p>我们可以用一个垂直于表面的小箭头，来显示这个方向</p>
<p>Now let's add a light source.</p>
<p>现在加个光源</p>
<p>Each polygon is going to be illuminated a different amount. Some will appear brighter</p>
<p>每个多边形被照亮的程度不同有的更亮</p>
<p>because their angle causes more light to be reflected towards the viewer.</p>
<p>因为面对的角度，导致更多光线反射到观察者</p>
<p>For example, the bottom-most polygon is tilted downwards,</p>
<p>举个例子，底部的多边形向下倾斜</p>
<p>away from the light source, which means it's going to be dark.</p>
<p>远离光源，所以更暗一些</p>
<p>In a similar way, the rightmost polygon is slightly facing away from the light,</p>
<p>类似的，最右的多边形更背对光源</p>
<p>so it will be partially illuminated.</p>
<p>所以只有部分照亮</p>
<p>And finally, there's the upper-left polygon.</p>
<p>最后是左上角的多边形</p>
<p>Its angle means that it will reflect light from the light source towards our view.</p>
<p>因为它面对的角度意味着会把光线反射到我们这里</p>
<p>So, it'll appear bright.</p>
<p>所以会显得更亮</p>
<p>If we do this for every polygon, our teapot looks like this which is much more realistic!</p>
<p>如果对每个多边形执行同样的步骤，看上去会更真实!</p>
<p>This approach is called Flat Shading, and it's the most basic lighting algorithm.</p>
<p>这叫平面着色，是最基本的照明算法</p>
<p>Unfortunately, it also makes all those polygon boundaries really noticeable</p>
<p>不幸的是，这使多边形的边界非常明显，</p>
<p>and the mesh doesn't look smooth.</p>
<p>看起来不光滑</p>
<p>For this reason, more advanced lighting algorithms were developed,</p>
<p>因此开发了更多算法</p>
<p>such as Gouraud Shading and Phong Shading .</p>
<p>比如高洛德着色和 冯氏着色</p>
<p>Instead of coloring in polygons using just one colour,</p>
<p>不只用一种颜色给整个多边形上色</p>
<p>they vary the colour across the surface in clever ways,</p>
<p>而是以巧妙的方式改变颜色</p>
<p>which results in much nicer output.</p>
<p>得到更好的效果</p>
<p>We also need to talk about textures ,</p>
<p>我们还要说下" 纹理 "</p>
<p>which in graphics refers to the look of a surface,rather than its feel.</p>
<p>纹理在图形学中指外观，而不是手感</p>
<p>Like with lighting, there are many algorithms with all sorts of fancy effects.</p>
<p>就像照明算法一样，纹理也有多种算法，来做各种花哨效果</p>
<p>The simplest is texture mapping .</p>
<p>最简单的是纹理映射</p>
<p>To visualize this process,let's go back to our single polygon.</p>
<p>为了理解纹理映射，回到单个多边形</p>
<p>When we're filling this in, using scanline rendering,</p>
<p>用"扫描线算法"填充时</p>
<p>we can look up what color to use at every pixel according to a texture image saved in memory.</p>
<p>可以看看内存内的纹理图像决定像素用什么颜色</p>
<p>To do this, we need a mapping between the polygon's coordinates and the texture's coordinates.</p>
<p>为了做到这点，需要把多边形坐标和纹理坐标对应起来</p>
<p>Let's jump to the first pixel that scanline rendering needs to fill in.</p>
<p>我们来看看"扫描线算法"要填充的第一个像素</p>
<p>The texturing algorithm will consult the texture in memory,</p>
<p>纹理算法会查询纹理</p>
<p>take the average color from the corresponding region, and fill the polygon accordingly.</p>
<p>从相应区域取平均颜色，并填充多边形</p>
<p>This process repeats for all pixels in the polygon, and that's how we get textures.</p>
<p>重复这个过程，就可以获得纹理</p>
<p>If you combine all the techniques we've talked about this episode, you get a wonderfully funky little teapot.</p>
<p>如果结合这集提到的所有技巧，会得到一个精美的小茶壶</p>
<p>And this teapot can sit in an even bigger scene, comprised of millions of polygons.</p>
<p>这个茶壶可以放进更大的场景里，场景由上百万个多边形组成</p>
<p>Rendering a scene like this takes a fair amount of computation.</p>
<p>渲染这样的场景需要大量计算</p>
<p>But importantly, it's the same type of calculations being performed</p>
<p>但重要的是，再大的场景，过程都是一样的，</p>
<p>over and over and over again for many millions of polygons –</p>
<p>一遍又一遍，处理所有多边形</p>
<p>scanline filling, antialiasing, lighting, and texturing.</p>
<p>扫描线填充, 抗锯齿, 光照, 纹理化</p>
<p>However there are a couple of ways to make this much faster!</p>
<p>然而，有几种方法可以加速渲染</p>
<p>First off, we can speed things up by having special hardware</p>
<p>首先，我们可以为这种特定运算，</p>
<p>with extra bells and whistles just for these specific types of computations, making them lightning fast.</p>
<p>做专门的硬件来加快速度，让运算快如闪电</p>
<p>And secondly,we can divide up a 3D scene into many smaller parts,</p>
<p>其次，我们可以把3D场景分解成多个小部分</p>
<p>and then render all the pieces in parallel,rather than sequentially.</p>
<p>然后并行渲染，而不是按顺序渲染</p>
<p>CPU's aren't designed for this, so they aren't particularly fast.</p>
<p>CPU不是为此设计的，因此图形运算不快</p>
<p>So, computer engineers created special processors just for graphics</p>
<p>所以，计算机工程师为图形做了专门的处理器</p>
<p>a GPU, or Graphics Processing Unit.</p>
<p>叫 GPU "图形处理单元"</p>
<p>These can be found on graphics cards inside of your computer, along with RAM reserved for graphics.</p>
<p>GPU 在显卡上，周围有专用的 RAM</p>
<p>This is where all the meshes and textures live,</p>
<p>所有网格和纹理都在里面</p>
<p>allowing them to be accessed super fast by many different cores of the GPU all at once.</p>
<p>让 GPU 的多个核心可以高速访问</p>
<p>A modern graphics card, like a GeForce GTX 1080 TI,</p>
<p>现代显卡，如 GeForce GTX 1080 TI</p>
<p>contains 3584 processing cores, offering massive parallelization.</p>
<p>有3584个处理核心，提供大规模并行处理</p>
<p>It can process hundreds of millions of polygons every second!</p>
<p>每秒处理上亿个多边形！</p>
<p>Ok, that concludes our whistle stop tour of 3D graphics.</p>
<p>好了，本集对3D图形的介绍到此结束</p>
<p>Next week, we switch topics entirely.</p>
<p>下周我们聊全新的主题</p>
<p>I'll ping you then.</p>
<p>我到时会 ping 你~</p>
<p>28 计算机网络</p>
<p>Computer Networks</p>
<p>Hi, I’m Carrie Anne, and welcome to Crash Course Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>The internet is amazings</p>
<p>互联网太棒啦</p>
<p>In just a few keystrokes, we can stream videos on Youtube -Hello!</p>
<p>键盘敲几下就能在 Youtube 直播--哈喽！</p>
<p>read articles on Wikipedia,</p>
<p>在维基百科上阅读文章</p>
<p>order supplies on amazon, video chat with friends, and tweet about the weather.</p>
<p>在亚马逊买东西和朋友视频发一条天气推特</p>
<p>Without a doubt, the ability for computers, and their users, to send and receive information</p>
<p>毫无疑问，用户在全球网络中发送和接收信息的能力</p>
<p>over a global telecommunications network forever changed the world.</p>
<p>永远改变了这个世界</p>
<p>150 years ago, sending a letter from London to California would have taken two to three</p>
<p>150年前发一封信件从伦敦到加州要花2~3周</p>
<p>weeks, and that’s if you paid for express mail.</p>
<p>而且还是特快邮件</p>
<p>Today, that email takes a fraction of a second.</p>
<p>如今电子邮件只要几分之一秒.</p>
<p>This million fold improvement in latency, that’s the time it takes for a message to</p>
<p>"时延"改善了上百万倍，(时延指传播一条信息所需的时间)</p>
<p>transfer, juiced up the global economy helping the modern world to</p>
<p>振兴了全球经济，</p>
<p>move at the speed of light on fiber optic cables spanning the globe.</p>
<p>帮助现代世界在遍布全球的光纤中快速发展</p>
<p>You might think that computers and networks always went hand in hand, but actually most</p>
<p>你可能觉得计算机和网络密切相关，但事实上，</p>
<p>computers pre-1970 were humming away all alone.</p>
<p>1970年以前大多数计算机是独立运行的</p>
<p>However, as big computers began popping up everywhere,</p>
<p>然而因为大型计算机开始随处可见</p>
<p>and low cost machines started to show up on people’s desks,</p>
<p>廉价机器开始出现在书桌上</p>
<p>it became increasingly useful to share data and resources,</p>
<p>分享数据和资源渐渐变得有用起来</p>
<p>and the first networks of computers appeared.</p>
<p>首个计算机网络出现了</p>
<p>Today, we’re going to start a three-episode arc on how computer networks came into being</p>
<p>今天起，我们花3集视频讲网络是如何发展成现在的样子</p>
<p>and the fundamental principles and techniques that power them.</p>
<p>以及支撑它们的基础原理和技术</p>
<p>The first computer networks appeared in the 1950s and 60s.</p>
<p>第一个计算机网络出现在1950~1960年代</p>
<p>They were generally used within an organization – like a company or research lab</p>
<p>通常在公司或研究室内部使用，</p>
<p>to facilitate the exchange of information between different people and computers.</p>
<p>为了方便信息交换</p>
<p>This was faster and more reliable than the previous method of having someone walk a pile</p>
<p>比把纸卡或磁带送到另一栋楼里</p>
<p>of punch cards, or a reel of magnetic tape, to a computer on the other side of a building</p>
<p>更快速可靠</p>
<p>which was later dubbed a sneakernet.</p>
<p>这叫"球鞋网络"</p>
<p>A second benefit of networks was the ability to share physical resources.</p>
<p>第二个好处是能共享物理资源</p>
<p>For example, instead of each computer having its own printer,</p>
<p>举个例子，与其每台电脑配一台打印机</p>
<p>everyone could share one attached to the network.</p>
<p>大家可以共享一台联网的打印机</p>
<p>It was also common on early networks to have large, shared, storage drives,</p>
<p>早期网络也会共享存储空间</p>
<p>ones too expensive to have attached to every machine.</p>
<p>因为每台电脑都配存储器太贵了</p>
<p>These relatively small networks of close-by computers</p>
<p>计算机近距离构成的小型网络，</p>
<p>are called Local Area Networks, or LANs.</p>
<p>叫局域网，简称LAN</p>
<p>A LAN could be as small as two machines in the same room,</p>
<p>局域网能小到是同一个房间里的两台机器</p>
<p>or as large as a university campus with thousands of computers.</p>
<p>或大到校园里的上千台机器</p>
<p>Although many LAN technologies were developed and deployed,</p>
<p>尽管开发和部署了很多不同 LAN 技术</p>
<p>the most famous and successful was Ethernet, developed in the</p>
<p>其中最著名和成功的是"以太网" , </p>
<p>early 1970s at Xerox PARC, and still widely used today.</p>
<p>开发于1970年代，在施乐的"帕洛阿尔托研究中心"诞生, 今日仍被广泛使用</p>
<p>In its simplest form, a series of computers are connected to a single, common ethernet cable.</p>
<p>以太网的最简单形式是：一条以太网电线连接数台计算机</p>
<p>When a computer wants to transmit data to another computer,</p>
<p>当一台计算机要传数据给另一台计算机时</p>
<p>it writes the data, as an electrical signal, onto the cable.</p>
<p>它以电信号形式，将数据传入电缆</p>
<p>Of course, because the cable is shared, every computer plugged into the network sees the</p>
<p>当然因为电缆是共享的，连在同一个网络里的其他计算机也看得到数据</p>
<p>transmission, but doesn’t know if data is intended for them or another computer.</p>
<p>但不知道数据是给它们的，还是给其他计算机的</p>
<p>To solve this problem, Ethernet requires that each computer has a unique</p>
<p>为了解决这个问题以太网需要每台计算机有唯一的，</p>
<p>Media Access Control address, or MAC address.</p>
<p>媒体访问控制地址简称 MAC地址</p>
<p>This unique address is put into a header that prefixes any data sent over the network.</p>
<p>这个唯一的地址放在头部，作为数据的前缀发送到网络中</p>
<p>So, computers simply listen to the ethernet cable,</p>
<p>所以，计算机只需要监听以太网电缆，</p>
<p>and only process data when they see their address in the header.</p>
<p>只有看到自己的 MAC 地址，才处理数据</p>
<p>This works really well; every computer made today comes with its own unique MAC address</p>
<p>这运作得很好现在制造的每台计算机都自带唯一的MAC地址</p>
<p>for both Ethernet and WiFi.</p>
<p>用于以太网和无线网络</p>
<p>The general term for this approach is Carrier Sense Multiple Access, or CSMA for short.</p>
<p>多台电脑共享一个传输媒介，这种方法叫 "载波侦听多路访问" 简称"CSMA"</p>
<p>The "carrier", in this case, is any shared transmission medium that carries data</p>
<p>载体(carrier)指运输数据的共享媒介</p>
<p>copper wire in the case of ethernet, and the air carrying radio waves for WiFi.</p>
<p>以太网的"载体"是铜线，WiFi 的"载体"是传播无线电波的空气</p>
<p>Many computers can simultaneously sense the carrier,</p>
<p>很多计算机同时侦听载体</p>
<p>hence the "Sense" and "Multiple Access",</p>
<p>所以叫"侦听"和"多路访问"</p>
<p>and the rate at which a carrier can transmit data is called its Bandwidth.</p>
<p>而载体传输数据的速度叫"带宽"</p>
<p>Unfortunately, using a shared carrier has one big drawback.</p>
<p>不幸的是使用共享载体有个很大的弊端</p>
<p>When network traffic is light, computers can simply wait for silence on the carrier,</p>
<p>当网络流量较小时计算机可以等待载体清空</p>
<p>and then transmit their data.</p>
<p>然后传送数据</p>
<p>But, as network traffic increases, the probability that</p>
<p>但随着网络流量上升 </p>
<p>two computers will attempt to write data at the same time also increases.</p>
<p>两台计算机想同时写入数据的概率也会上升</p>
<p>This is called a collision, and the data gets all garbled up,</p>
<p>这叫冲突数据全都乱套了</p>
<p>like two people trying to talk on the phone at the same time.</p>
<p>就像两个人同时在电话里讲话</p>
<p>Fortunately, computers can detect these collisions by listening to the signal on the wire.</p>
<p>幸运的是计算机能够通过监听电线中的信号检测这些冲突</p>
<p>The most obvious solution is for computers to stop transmitting,</p>
<p>最明显的解决办法是停止传输</p>
<p>wait for silence, then try again.</p>
<p>等待网络空闲, 然后再试一遍</p>
<p>Problem is, the other computer is going to try that too,</p>
<p>问题是其他计算机也打算这样做</p>
<p>and other computers on the network that have been waiting for the</p>
<p>其他等着的计算机</p>
<p>carrier to go silent will try to jump in during any pause.</p>
<p>可能在任何停顿间隙闯入</p>
<p>This just leads to more and more collisions.</p>
<p>导致越来越多冲突</p>
<p>Soon, everyone is talking over one another and has a backlog of things they need to say,</p>
<p>很快，每个人都一个接一个地讲话而且有一堆事要说</p>
<p>like breaking up with a boyfriend over a family holiday dinner.</p>
<p>就像在家庭聚餐中和男朋友分手一样</p>
<p>Terrible idea!</p>
<p>馊主意！</p>
<p>Ethernet had a surprisingly simple and effective fix.</p>
<p>以太网有个超简单有效的解决方法</p>
<p>When transmitting computers detect a collision,</p>
<p>当计算机检测到冲突 </p>
<p>they wait for a brief period before attempting to re-transmit.</p>
<p>就会在重传之前等待一小段时间</p>
<p>As an example, let’s say 1 second.</p>
<p>因为要举例，假设是 1 秒好了</p>
<p>Of course, this doesn’t work if all the computers use the same wait duration</p>
<p>当然如果所有计算机用同样的等待时间是不行的</p>
<p>they’ll just collide again one second later.</p>
<p>它们会在一秒后再次冲突</p>
<p>So, a random period is added: one computer might wait 1.3 seconds,</p>
<p>所以加入一个随机时间一台计算机可能等1.3秒</p>
<p>while another waits 1.5 seconds.</p>
<p>另一台计算机等待1.5秒</p>
<p>With any luck, the computer that waited 1.3 seconds will wake up,</p>
<p>要是运气好等1.3秒的计算机会醒来</p>
<p>find the carrier to be silent, and start transmitting.</p>
<p>发现载体是空闲的然后开始传输</p>
<p>When the 1.5 second computer wakes up a moment later, it’ll see the carrier is in use,</p>
<p>当1.5秒的计算机醒来后会发现载体被占用，</p>
<p>and will wait for the other computer to finish.</p>
<p>会等待其他计算机完成</p>
<p>This definitely helps, but doesn’t totally solve the problem, so an extra trick is used.</p>
<p>这有用但不能完全解决问题所以要用另一个小技巧</p>
<p>As I just explained, if a computer detects a collision while transmitting,</p>
<p>正如我刚才说的，如果一台计算机在传输数据期间检测到冲突</p>
<p>it will wait 1 second, plus some random extra time.</p>
<p>会等一秒+随机时间</p>
<p>However, if it collides again, which suggests network congestion,</p>
<p>然而如果再次发生冲突表明有网络拥塞</p>
<p>instead of waiting another 1 second, this time it will wait 2 seconds.</p>
<p>这次不等1秒，而是等2秒</p>
<p>If it collides again, it’ll wait 4 seconds, and then 8, and then 16,</p>
<p>如果再次发生冲突等4秒然后8秒 16秒等等</p>
<p>and so on, until it’s successful.</p>
<p>直到成功传输</p>
<p>With computers backing off, the rate of collisions goes down,</p>
<p>因为计算机的退避冲突次数降低了，</p>
<p>and data starts moving again, freeing up the network.</p>
<p>数据再次开始流动起来网络变得顺畅</p>
<p>Family dinner saved!</p>
<p>家庭晚餐有救啦！</p>
<p>This "backing off" behavior using an exponentially growing wait time is called</p>
<p>这种指数级增长等待时间的方法叫：</p>
<p>Exponential Backoff.</p>
<p>指数退避</p>
<p>Both Ethernet and WiFi use it, and so do many transmission protocols.</p>
<p>以太网和WiFi都用这种方法很多其他传输协议也用</p>
<p>But even with clever tricks like Exponential Backoff,</p>
<p>但即便有了"指数退避"这种技巧</p>
<p>you could never have an entire university’s</p>
<p>想用一根网线链接整个大学的计算机</p>
<p>worth of computers on one shared ethernet cable.</p>
<p>还是不可能的</p>
<p>To reduce collisions and improve efficiency,</p>
<p>为了减少冲突+提升效率</p>
<p>we need to shrink the number of devices on any given shared carrier</p>
<p>我们需要减少同一载体中设备的数量，</p>
<p>what’s called the Collision Domain.</p>
<p>载体和其中的设备总称 "冲突域"</p>
<p>Let go back to our earlier Ethernet example, where we had six computers on one shared cable,</p>
<p>让我们回到之前以太网的例子一根电缆连6台计算机</p>
<p>a.k.a. one collision domain.</p>
<p>也叫一个冲突域</p>
<p>To reduce the likelihood of collisions, we can break this network</p>
<p>为了减少冲突</p>
<p>into two collision domains by using a Network Switch.</p>
<p>我们可以用交换机把它拆成两个冲突域</p>
<p>It sits between our two smaller networks, and only passes data between them if necessary.</p>
<p>交换机位于两个更小的网络之间，必要时才在两个网络间传数据</p>
<p>It does this by keeping a list of what MAC addresses are on what side of the network.</p>
<p>交换机会记录一个列表，写着哪个 MAC 地址在哪边网络</p>
<p>So if A wants to transmit to C, the switch doesn’t forward the data to the other network</p>
<p>如果A想传数据给C，交换机不会把数据转发给另一边的网络</p>
<p>there’s no need.</p>
<p>没必要</p>
<p>This means if E wants to transmit to F at the same time, the network is wide open, and</p>
<p>如果E想同一时间传数据给F，网络仍然是空的</p>
<p>two transmissions can happen at once.</p>
<p>两个传输可以同时发生</p>
<p>But, if F wants to send data to A, then the switch passes it through,</p>
<p>但如果F想发数据给A  数据会通过交换机</p>
<p>and the two networks are both briefly occupied.</p>
<p>两个网络都会被短暂占用</p>
<p>This is essentially how big computer networks are constructed,</p>
<p>大的计算机网络也是这样构建的</p>
<p>including the biggest one of all – The Internet –</p>
<p>包括最大的网络互联网</p>
<p>which literally inter-connects a bunch of smaller networks,</p>
<p>也是多个连在一起的稍小一点网络</p>
<p>allowing inter-network communication.</p>
<p>使不同网络间可以传递信息</p>
<p>What’s interesting about these big networks,</p>
<p>这些大型网络有趣之处是</p>
<p>is that there’s often multiple paths to</p>
<p>从一个地点到另一个地点</p>
<p>get data from one location to another.</p>
<p>通常有多条路线</p>
<p>And this brings us to another fundamental networking topic, routing.</p>
<p>这就带出了另一个话题路由</p>
<p>The simplest way to connect two distant computers, or networks,</p>
<p>连接两台相隔遥远的计算机或网路，</p>
<p>is by allocating a communication line for their exclusive use.</p>
<p>最简单的办法，是分配一条专用的通信线路</p>
<p>This is how early telephone systems worked.</p>
<p>早期电话系统就是这样运作的</p>
<p>For example, there might be 5 telephone lines running between Indianapolis and Missoula.</p>
<p>假设"印第安纳波利斯"和"米苏拉"之间，有五条电话线</p>
<p>If John picked up the phone wanting to call Hank, in the 1910s,</p>
<p>如果在1910年代，John 想打电话给 Hank</p>
<p>John would tell a human operator where he wanted to call,</p>
<p>John要告诉操作员他想打到什么地方</p>
<p>and they’d physically connect John’s phone line into</p>
<p>然后工作人员手动将 John 的电话连到，</p>
<p>an unused line running to Missoula.</p>
<p>通往米苏拉的未使用线路</p>
<p>For the length of the call, that line was occupied, and if all 5 lines were already</p>
<p>通话期间这条线就被占用了如果五条线都被占用了，</p>
<p>in use, John would have to wait for one to become free.</p>
<p>John 要等待某条线空出来</p>
<p>This approach is called Circuit Switching,</p>
<p>这叫 "电路交换"，</p>
<p>because you’re literally switching whole</p>
<p>因为是把电路</p>
<p>circuits to route traffic to the correct destination.</p>
<p>连接到正确目的地</p>
<p>It works fine, but it’s relatively inflexible and expensive,</p>
<p>能用倒是能用，但不灵活而且价格昂贵 </p>
<p>because there’s often unused capacity.</p>
<p>因为总有闲置的线路</p>
<p>On the upside, once you have a line to yourself – or if you have the money to buy one for</p>
<p>好处是如果有一条专属于自己的线路，</p>
<p>your private use – you can use it to its full capacity, without having to share.</p>
<p>你可以最大限度地随意使用，无需共享</p>
<p>For this reason, the military, banks and other high importance operations</p>
<p>因此军队, 银行和其他一些机构</p>
<p>still buy dedicated circuits to connect their data centers.</p>
<p>依然会购买专用线路来连接数据中心</p>
<p>Another approach for getting data from one place to another is Message Switching,</p>
<p>传输数据的另一个方法是 "报文交换"</p>
<p>which is sort of like how the postal system works.</p>
<p>"报文交换" 就像邮政系统一样</p>
<p>Instead of dedicated route from A to B, messages are passed through several stops.</p>
<p>不像之前A和B有一条专有线路，消息会经过好几个站点</p>
<p>So if John writes a letter to Hank,</p>
<p>如果 John 写一封信给 Hank</p>
<p>it might go from Indianapolis to Chicago, and then</p>
<p>信件可能从"印第安纳波利斯"到"芝加哥"</p>
<p>hop to Minneapolis, then Billings, and then finally make it to Missoula.</p>
<p>然后"明尼阿波利斯" 然后"比林斯" 最后到"米苏拉"</p>
<p>Each stop knows where to send it next</p>
<p>每个站点都知道下一站发哪里，</p>
<p>because they keep a table of where to pass letters given a destination address.</p>
<p>因为站点有表格，记录到各个目的地，信件该怎么传</p>
<p>What’s neat about Message Switching is that it can use different routes,</p>
<p>报文交换的好处是可以用不同路由，</p>
<p>making communication more reliable and fault-tolerant.</p>
<p>使通信更可靠更能容错</p>
<p>Sticking with our mail example,</p>
<p>回到邮件的例子</p>
<p>if there’s a blizzard in Minneapolis grinding things to a halt,</p>
<p>如果"明尼阿波利斯"有暴风雪中断了通信，</p>
<p>the Chicago mail hub can decide to route the letter through Omaha instead.</p>
<p>"芝加哥"可以传给"奥马哈"</p>
<p>In our example, cities are acting like network routers.</p>
<p>在这个例子里，城市就像路由器一样</p>
<p>The number of hops a message takes along a route is called the hop count.</p>
<p>消息沿着路由跳转的次数，叫"跳数"(hop count)</p>
<p>Keeping track of the hop count is useful because it can help identify routing problems.</p>
<p>记录跳数很有用，因为可以分辨出路由问题</p>
<p>For example, let’s say Chicago thinks the fastest route to Missoula is through Omaha,</p>
<p>举例，假设芝加哥认为，去米苏拉的最快路线是奥马哈</p>
<p>but Omaha thinks the fastest route is through Chicago.</p>
<p>但奥马哈认为，去米苏拉的最快路线是芝加哥</p>
<p>That's bad, because both cities are going to look at the destination address, Missoula,</p>
<p>这就糟糕了，因为2个城市看到目的地是米苏拉</p>
<p>and end up passing the message back and forth between them, endlessly.</p>
<p>结果报文会在2个城市之间，不停传来传去</p>
<p>Not only is this wasting bandwidth, but it’s a routing error that needs to get fixed!</p>
<p>不仅浪费带宽而且这个路由错误需要修复!</p>
<p>This kind of error can be detected because the hop count is</p>
<p>这种错误会被检测到，因为跳数记录在消息中，</p>
<p>stored with the message and updated along its journey.</p>
<p>而且传输时会更新跳数</p>
<p>If you start seeing messages with high hop counts,</p>
<p>如果看到某条消息的跳数很高，</p>
<p>you can bet something has gone awry in the routing!</p>
<p>就知道路由肯定哪里错了</p>
<p>This threshold is the Hop Limit.</p>
<p>这叫"跳数限制"</p>
<p>A downside to Message Switching is that messages are sometimes big.</p>
<p>报文交换的缺点之一是有时候报文比较大</p>
<p>So, they can clog up the network, because the whole message has to be transmitted from</p>
<p>会堵塞网络因为要把整个报文从一站传到下一站后，</p>
<p>one stop to the next before continuing on its way.</p>
<p>才能继续传递其他报文</p>
<p>While a big file is transferring, that whole link is tied up.</p>
<p>传输一个大文件时整条路都阻塞了</p>
<p>Even if you have a tiny, one kilobyte email trying to get through,</p>
<p>即便你只有一个1KB的电子邮件要传输，也只能等大文件传完，</p>
<p>it either has to wait for the big file transfer to finish or take a less efficient route.</p>
<p>或是选另一条效率稍低的路线</p>
<p>That’s bad.</p>
<p>这就糟了</p>
<p>The solution is to chop up big transmissions into many small pieces, called packets.</p>
<p>解决方法是将大报文分成很多小块，叫"数据包"</p>
<p>Just like with Message Switching, each packet contains a destination address on the network,</p>
<p>就像报文交换每个数据包都有目标地址，</p>
<p>so routers know where to forward them.</p>
<p>因此路由器知道发到哪里</p>
<p>This format is defined by the "Internet Protocol", or IP for short,</p>
<p>报文具体格式由"互联网协议"定义，简称 IP，</p>
<p>a standard created in the 1970s.</p>
<p>这个标准创建于 1970 年代</p>
<p>Every computer connected to a network gets an IP Address.</p>
<p>每台联网的计算机都需要一个IP地址</p>
<p>You’ve probably seen these as four, 8-bit numbers written with dots in between.</p>
<p>你可能见过，以点分隔的4组数字</p>
<p>For example,172.217.7.238 is an IP Address for one of Google’s servers.</p>
<p>例如 172.217.7.238 是 Google 其中一个服务器的IP地址</p>
<p>With millions of computers online, all exchanging data,</p>
<p>数百万台计算机在网络上不断交换数据，</p>
<p>bottlenecks can appear and disappear in milliseconds.</p>
<p>瓶颈的出现和消失是毫秒级的</p>
<p>Network routers are constantly trying to balance the load across whatever routes they know</p>
<p>路由器会平衡与其他路由器之间的负载，</p>
<p>to ensure speedy and reliable delivery, which is called congestion control.</p>
<p>以确保传输可以快速可靠，这叫"阻塞控制"</p>
<p>Sometimes different packets from the same message take different routes through a network.</p>
<p>有时，同一个报文的多个数据包，会经过不同线路</p>
<p>This opens the possibility of packets arriving at their destination out of order,</p>
<p>到达顺序可能会不一样，</p>
<p>which is a problem for some applications.</p>
<p>这对一些软件是个问题</p>
<p>Fortunately, there are protocols that run on top of IP,</p>
<p>幸运的是，在 IP 之上还有其他协议</p>
<p>like TCP/IP, that handle this issue.</p>
<p>比如 TCP/IP, 可以解决乱序问题</p>
<p>We’ll talk more about that next week.</p>
<p>我们下周会讲</p>
<p>Chopping up data into small packets,</p>
<p>将数据拆分成多个小数据包，</p>
<p>and passing these along flexible routes with spare capacity,</p>
<p>然后通过灵活的路由传递</p>
<p>is so efficient and fault-tolerant, it’s what the whole internet runs on today.</p>
<p>非常高效且可容错，如今互联网就是这么运行的</p>
<p>This routing approach is called Packet Switching.</p>
<p>这叫"分组交换"</p>
<p>It also has the nice property of being decentralized,</p>
<p>有个好处是它是去中心化的</p>
<p>with no central authority or single point of failure.</p>
<p>没有中心权威机构没有单点失败问题</p>
<p>In fact, the threat of nuclear attack is why</p>
<p>事实上因为冷战期间有核攻击的威胁，</p>
<p>packet switching was developed during the cold war!</p>
<p>所以创造了分组交换</p>
<p>Today, routers all over the globe work cooperatively to find efficient routings,</p>
<p>如今，全球的路由器协同工作，找出最高效的线路</p>
<p>exchanging information with each other using special protocols,</p>
<p>用各种标准协议运输数据</p>
<p>like the Internet Control Message Protocol (ICMP)</p>
<p>比如 "因特网控制消息协议"(ICMP)</p>
<p>and the Border Gateway Protocol (BGP).</p>
<p>和 "边界网关协议"(BGP)</p>
<p>The world's first packet-switched network,</p>
<p>世界上第一个分组交换网络</p>
<p>and the ancestor to the modern internet, was the ARPANET,</p>
<p>以及现代互联网的祖先是 ARPANET</p>
<p>named after the US agency that funded it,</p>
<p>名字来源于赞助这个项目的机构，</p>
<p>the Advanced Research Projects Agency.</p>
<p>美国高级研究计划局</p>
<p>Here’s what the entire ARPANET looked like in 1974.</p>
<p>这是 1974 年整个 ARPANET 的样子</p>
<p>Each smaller circle is a location,</p>
<p>每个小圆表示一个地点，</p>
<p>like a university or research lab, that operated a router.</p>
<p>比如大学或实验室，那里运行着一个路由器</p>
<p>They also plugged in one or more computers</p>
<p>并且有一台或多台计算机</p>
<p>you can see PDP-1’s, IBM System 360s,</p>
<p>能看到 "PDP-1" 和"IBM 360系统"</p>
<p>and even an ATLAS in London connected over a satellite link.</p>
<p>甚至还有一个伦敦的 ATLAS，是通过卫星连到网络里的</p>
<p>Obviously the internet has grown by leaps and bounds in the decades since.</p>
<p>显然互联网在这几十年间发展迅速</p>
<p>Today, instead of a few dozen computers online, it’s estimated to be nearing 10 billion.</p>
<p>如今不再只有几十台计算机联网，据估计有接近100亿台联网设备</p>
<p>And it continues to grow rapidly,</p>
<p>而且互联网会继续快速发展</p>
<p>especially with the advent of wifi-connected refrigerators, thermostat</p>
<p>特别是如今各种智能设备层出不穷，比如联网冰箱，恒温器</p>
<p>and other smart appliances, forming an "internet of things".</p>
<p>以及其他智能家电，它们组成了"物联网"</p>
<p>So that’s part one – an overview of computer networks.</p>
<p>第一部分到此结束，我们对计算机网络进行了概览</p>
<p>Is it a series of tubes?</p>
<p>网络是一堆管子组成的吗？</p>
<p>Well, sort of.</p>
<p>额算是吧</p>
<p>Next week we’ll tackle some higher-level transmission protocols,</p>
<p>下周我们会讨论一些高级传输协议</p>
<p>slowly working our way up to the World Wide Web.</p>
<p>然后讲万维网</p>
<p>I’ll see you then!</p>
<p>到时见啦</p>
<p>29 互联网</p>
<p>The Internet</p>
<p>Hi, I’m Carrie Anne, and welcome to CrashCourse Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>As we talked about last episode, your computer is connected to a large, distributed network,</p>
<p>上集讲到，你的计算机和一个巨大的分布式网络连在一起</p>
<p>called The Internet.</p>
<p>这个网络叫互联网</p>
<p>I know this because you’re watching a YouTube video,</p>
<p>你现在就在网上看视频呀</p>
<p>which is being streamed over that very internet.</p>
<p>就在互联网上。</p>
<p>It’s arranged as an ever-enlarging web of interconnected devices.</p>
<p>互联网由无数互联设备组成，而且日益增多</p>
<p>For your computer to get this video,</p>
<p>计算机为了获取这个视频，</p>
<p>the first connection is to your local area network, or LAN,</p>
<p>首先要连到局域网，也叫 LAN</p>
<p>which might be every device in your house that’s connected to your wifi router.</p>
<p>你家 WIFI 路由器连着的所有设备，组成了局域网.</p>
<p>This then connects to a Wide Area Network, or WAN,</p>
<p>局域网再连到广域网，广域网也叫 WAN</p>
<p>which is likely to be a router run by your Internet Service Provider, or ISP，</p>
<p>WAN 的路由器一般属于你的"互联网服务提供商"，简称 ISP</p>
<p>companies like Comcast, AT&T or Verizon.</p>
<p>比如 Comcast，AT&T 和 Verizon 这样的公司</p>
<p>At first, this will be a regional router, like one for your neighborhood,</p>
<p>广域网里，先连到一个区域性路由器，这路由器可能覆盖一个街区。</p>
<p>and then that router connects to an even bigger WAN,</p>
<p>然后连到一个更大的 WAN，</p>
<p>maybe one for your whole city or town.</p>
<p>可能覆盖整个城市</p>
<p>There might be a couple more hops, but ultimately you’ll connect to the backbone of the internet</p>
<p>可能再跳几次，但最终会到达互联网主干</p>
<p>made up of gigantic routers with super high-bandwidth connections running between them.</p>
<p>互联网主干由一群超大型、带宽超高路由器组成</p>
<p>To request this video file from YouTube,</p>
<p>为了从 YouTube 获得这个视频，</p>
<p>a packet had to work its way up to the backbone,</p>
<p>数据包（packet）要先到互联网主干</p>
<p>travel along that for a bit, and then work its way back down to a YouTube server that had the file.</p>
<p>沿着主干到达有对应视频文件的 YouTube 服务器</p>
<p>That might be four hops up, two hops across the backbone,</p>
<p>数据包从你的计算机跳到 Youtube 服务器，可能要跳个10次，</p>
<p>and four hops down, for a total of ten hops.</p>
<p>先跳4次到互联网主干，2次穿过主干，主干出来可能再跳4次，然后到 Youtube 服务器</p>
<p>If you’re running Windows, Mac OS or Linux, you can see the route data takes to different</p>
<p>如果你在用 Windows, Mac OS 或 Linux系统，可以用 traceroute 来看跳了几次</p>
<p>places on the internet by using the traceroute program on your computer.</p>
<p>如果你在用 Windows, Mac OS 或 Linux系统，可以用 traceroute 来看跳了几次</p>
<p>Instructions in the Doobly Doo.</p>
<p>更多详情看视频描述（YouTube原视频下）</p>
<p>For us here at the Chad & Stacey Emigholz Studio in Indianapolis,</p>
<p>我们在"印第安纳波利斯"的 Chad&Stacy Emigholz 工作室，访问加州的 DFTBA 服务器，</p>
<p>the route to the DFTBA server in California goes through 11 stops.</p>
<p>经历了11次中转</p>
<p>We start at 192.168.0.1 -that's the IP address for my computer on our LAN.</p>
<p>从 192.168.0.1 出发，这是我的电脑在局域网（LAN）里的 IP 地址</p>
<p>Then there’s the wifi router here at the studio,</p>
<p>然后到工作室的 WIFI 路由器</p>
<p>then a series of regional routers, then we get onto the backbone,</p>
<p>然后穿过一个个地区路由器，到达主干.</p>
<p>and then we start working back down to the computer hosting "DFTBA.com”,</p>
<p>然后从主干出来，又跳了几次，到达"DFTBA.com”的服务器</p>
<p>which has the IP address 104.24.109.186.</p>
<p>IP 地址是 104.24.109.186.</p>
<p>But how does a packet actually get there?</p>
<p>但数据包*到底*是怎么过去的？</p>
<p>What happens if a packet gets lost along the way?</p>
<p>如果传输时数据包被弄丢了，会发生什么？</p>
<p>If I type "DFTBA.com” into my web browser, how does it know the server’s address?</p>
<p>如果在浏览器里输 "DFTBA.com"，浏览器怎么知道服务器的地址多少？</p>
<p>These are our topics for today!</p>
<p>我们今天会讨论这些话题.</p>
<p>As we discussed last episode, the internet is a huge distributed network</p>
<p>上集说过，互联网是一个巨型分布式网络，</p>
<p>that sends data around as little packets.</p>
<p>会把数据拆成一个个数据包来传输</p>
<p>If your data is big enough, like an email attachment,</p>
<p>如果要发的数据很大，比如邮件附件，</p>
<p>it might get broken up into many packets.</p>
<p>数据会被拆成多个小数据包</p>
<p>For example, this video stream is arriving to your computer right now</p>
<p>举例，你现在看的这个视频，就是一个个到达你电脑的数据包</p>
<p>as a series of packets, and not one gigantic file.</p>
<p>而不是一整个大文件发过来</p>
<p>Internet packets have to conform to a standard called the Internet Protocol, or IP.</p>
<p>数据包（packet）想在互联网上传输，要符合"互联网协议"的标准，简称 IP</p>
<p>It’s a lot like sending physical mail through the postal system</p>
<p>就像邮寄手写信一样，邮寄是有标准的，</p>
<p>every letter needs a unique and legible address written on it,</p>
<p>每封信需要一个地址，而且地址必须是独特的</p>
<p>and there are limits to the size and weight of packages.</p>
<p>并且大小和重量是有限制的</p>
<p>Violate this, and your letter won’t get through.</p>
<p>违反这些规定，信件就无法送达.</p>
<p>IP packets are very similar.</p>
<p>IP 数据包也是如此</p>
<p>However, IP is a very low level protocol</p>
<p>因为 IP 是一个非常底层的协议</p>
<p>there isn’t much more than a destination address in a packet’s header</p>
<p>数据包的头部（或者说前面）只有目标地址</p>
<p>which is the metadata that’s stored in front of the data payload.</p>
<p>头部存 "关于数据的数据"，也叫元数据(metadata)</p>
<p>This means that a packet can show up at a computer, but the computer may not know</p>
<p>这意味着当数据包到达对方电脑，对方不知道把包交给哪个程序，</p>
<p>which application to give the data to; Skype or Call of Duty.</p>
<p>是交给 Skype 还是使命召唤？</p>
<p>For this reason, more advanced protocols were developed that sit on top of IP.</p>
<p>因此需要在 IP 之上，开发更高级的协议.</p>
<p>One of the simplest and most common is the User Datagram Protocol, or UDP.</p>
<p>这些协议里，最简单最常见的叫"用户数据报协议"，简称 UDP</p>
<p>UDP has its own header, which sits inside the data payload.</p>
<p>UDP 也有头部，这个头部位于数据前面</p>
<p>Inside of the UDP header is some useful, extra information.</p>
<p>头部里包含有用的信息</p>
<p>One of them is a port number.</p>
<p>信息之一是端口号</p>
<p>Every program wanting to access the internet will</p>
<p>每个想访问网络的程序，</p>
<p>ask its host computer’s Operating System to be given a unique port.</p>
<p>都要向操作系统申请一个端口号.</p>
<p>Like Skype might ask for port number 3478.</p>
<p>比如 Skype 会申请端口 3478</p>
<p>When a packet arrives to the computer, the Operating System</p>
<p>当一个数据包到达时，接收方的操作系统</p>
<p>will look inside the UDP header and read the port number.</p>
<p>会读 UDP 头部，读里面的端口号</p>
<p>Then, if it sees, for example, 3478, it will give the packet to Skype.</p>
<p>如果看到端口号是 3478，就把数据包交给 Skype</p>
<p>So to review, IP gets the packet to the right computer,</p>
<p>总结：IP 负责把数据包送到正确的计算机，</p>
<p>but UDP gets the packet to the right program running on that computer.</p>
<p>UDP 负责把数据包送到正确的程序</p>
<p>UDP headers also include something called a checksum,</p>
<p>UDP 头部里还有"校验和"，</p>
<p>which allows the data to be verified for correctness.</p>
<p>用于检查数据是否正确</p>
<p>As the name suggests, it does this by checking the sum of the data.</p>
<p>正如"校验和"这个名字所暗示的，检查方式是把数据求和来对比</p>
<p>Here’s a simplified version of how this works.</p>
<p>以下是个简单例子</p>
<p>Let's imagine the raw data in our UDP packet is</p>
<p>假设 UDP 数据包里，</p>
<p>89 111 33 32 58 and 41.</p>
<p>原始数据是 89 111 33 32 58 41</p>
<p>Before the packet is sent, the transmitting computer calculates the checksum</p>
<p>在发送数据包前，电脑会把所有数据加在一起，算出"校验和"</p>
<p>by adding all the data together: 89 plus 111 plus 33 and so on.</p>
<p>89+111+33+... 以此类推</p>
<p>In our example, this adds up to a checksum of 364.</p>
<p>得到 364，这就是"校验和".</p>
<p>In UDP, the checksum value is stored in 16 bits.</p>
<p>UDP 中，"校验和"以 16 位形式存储 (就是16个0或1)</p>
<p>If the sum exceeds the maximum possible value, the upper-most bits overflw,</p>
<p>如果算出来的和，超过了 16 位能表示的最大值，高位数会被扔掉，</p>
<p>and only the lower bits are used.</p>
<p>保留低位</p>
<p>Now, when the receiving computer gets this packet,</p>
<p>当接收方电脑收到这个数据包</p>
<p>it repeats the process, adding up all the data.</p>
<p>它会重复这个步骤，把所有数据加在一起，</p>
<p>89 plus 111 plus 33 and so on.</p>
<p>89+111+33... 以此类推</p>
<p>If that sum is the same as the checksum sent in the header, all is well.</p>
<p>如果结果和头部中的校验和一致，代表一切正常</p>
<p>But, if the numbers don’t match, you know that the data got corrupted</p>
<p>如果不一致，数据肯定坏掉了</p>
<p>at some point in transit, maybe because of a power fluctuation or faulty cable.</p>
<p>也许传输时碰到了功率波动，或电缆出故障了</p>
<p>Unfortunately, UDP doesn’t offer any mechanisms to fix the data, or request a new copy</p>
<p>不幸的是，UDP 不提供数据修复或数据重发的机制</p>
<p>receiving programs are alerted to the corruption, but typically just discard the packet.</p>
<p>接收方知道数据损坏后，一般只是扔掉.</p>
<p>Also, UDP provides no mechanisms to know if packets are getting through</p>
<p>而且，UDP 无法得知数据包是否到达.</p>
<p>a sending computer shoots the UDP packet off,</p>
<p>发送方发了之后，</p>
<p>but has no confirmation it ever gets to its destination successfully.</p>
<p>无法知道数据包是否到达目的地</p>
<p>Both of these properties sound pretty catastrophic, but some applications are ok with this,</p>
<p>这些特性听起来很糟糕，但是有些程序不在意这些问题</p>
<p>because UDP is also really simple and fast.</p>
<p>因为 UDP 又简单又快.</p>
<p>Skype, for example, which uses UDP for video chat, can handle corrupt or missing packets.</p>
<p>拿 Skype 举例，它用 UDP 来做视频通话，能处理坏数据或缺失数据</p>
<p>That’s why sometimes if you’re on a bad internet connection,</p>
<p>所以网速慢的时候 Skype 卡卡的，</p>
<p>Skype gets all glitchy – only some of the UDP packets are making it to your computer.</p>
<p>因为只有一部分数据包到了你的电脑</p>
<p>But this approach doesn’t work for many other types of data transmission.</p>
<p>但对于其他一些数据，这个方法不适用.</p>
<p>Like, it doesn’t really work if you send an email, and it shows up with the middle missing.</p>
<p>比如发邮件，邮件不能只有开头和结尾没有中间.</p>
<p>The whole message really needs to get there correctly!</p>
<p>邮件要完整到达收件方</p>
<p>When it "absolutely, positively needs to get there”,</p>
<p>如果"所有数据必须到达"，</p>
<p>programs use the Transmission Control Protocol, or TCP,</p>
<p>就用"传输控制协议"，简称 TCP</p>
<p>which like UDP, rides inside the data payload of IP packets.</p>
<p>TCP 和 UDP 一样，头部也在存数据前面</p>
<p>For this reason, people refer to this combination of protocols as TCP/IP.</p>
<p>因此，人们叫这个组合 TCP/IP</p>
<p>Like UDP, the TCP header contains a destination port and checksum.</p>
<p>就像 UDP ，TCP 头部也有"端口号"和"校验和"</p>
<p>But, it also contains fancier features, and we’ll focus on the key ones.</p>
<p>但 TCP 有更高级的功能，我们这里只介绍重要的几个</p>
<p>First off, TCP packets are given sequential numbers.</p>
<p>1 TCP 数据包有序号</p>
<p>So packet 15 is followed by packet 16, which is followed by 17, and so on...</p>
<p>15号之后是16号，16号之后是17号，以此类推，</p>
<p>for potentially millions of packets sent during that session.</p>
<p>发上百万个数据包也是有可能的.</p>
<p>These sequence numbers allow a receiving computer to put the packets into the correct order,</p>
<p>序号使接收方可以把数据包排成正确顺序，</p>
<p>even if they arrive at different times across the network.</p>
<p>即使到达时间不同.</p>
<p>So if an email comes in all scrambled, the TCP implementation in your computer’s operating</p>
<p>哪怕到达顺序是乱的，</p>
<p>system will piece it all together correctly.</p>
<p>TCP 协议也能把顺序排对</p>
<p>Second, TCP requires that once a computer has correctly received a packet</p>
<p>2 TCP 要求接收方的电脑收到数据包，</p>
<p>and the data passes the checksum – that it send back an acknowledgement,</p>
<p>并且"校验和"检查无误后（数据没有损坏），给发送方发一个确认码，代表收到了</p>
<p>or "ACK” as the cool kids say, to the sending computer.</p>
<p>"确认码" 简称 ACK，</p>
<p>Knowing the packet made it successfully, the sender can now transmit the next packet.</p>
<p>得知上一个数据包成功抵达后，发送方会发下一个数据包</p>
<p>But this time, let’s say, it waits, and doesn’t get an acknowledgement packet back.</p>
<p>假设这次发出去之后，没收到确认码，那么肯定哪里错了</p>
<p>Something must be wrong. If enough time elapses,</p>
<p>如果过了一定时间还没收到确认码，</p>
<p>the sender will go ahead and just retransmit the same packet.</p>
<p>发送方会再发一次</p>
<p>It’s worth noting here  that the original packet might have actually gotten there,</p>
<p>注意数据包可能的确到了</p>
<p>but the acknowledgment is just really delayed.</p>
<p>只是确认码延误了很久</p>
<p>Or perhaps it was the acknowledgment that was lost.</p>
<p>或传输中丢失了</p>
<p>Either way, it doesn’t matter, because the receiver has those sequence numbers,</p>
<p>但这不碍事因为收件方有序列号</p>
<p>and if a duplicate packet arrives, it can be discarded.</p>
<p>如果收到重复的数据包就删掉</p>
<p>Also, TCP isn’t limited to a back and forth conversation – it can send many packets,</p>
<p>还有，TCP 不是只能一个包一个包发</p>
<p>and have many outstanding ACKs, which increases bandwidth significantly, since you aren’t</p>
<p>可以同时发多个数据包，收多个确认码，这大大增加了效率，</p>
<p>wasting time waiting for acknowledgment packets to return.</p>
<p>不用浪费时间等确认码</p>
<p>Interestingly, the success rate of ACKs, and also the round trip time</p>
<p>有趣的是，确认码的成功率和来回时间，</p>
<p>between sending and acknowledging, can be used to infer network congestion.</p>
<p>可以推测网络的拥堵程度</p>
<p>TCP uses this information to adjust how aggressively it sends packets –</p>
<p>TCP 用这个信息，调整同时发包数量，</p>
<p>a mechanism for congestion control.</p>
<p>解决拥堵问题</p>
<p>So, basically, TCP can handle out-of-order packet delivery, dropped packets</p>
<p>简单说，TCP 可以处理乱序和丢失数据包，丢了就重发.</p>
<p>including retransmission – and even throttle its transmission rate according to available bandwidth.</p>
<p>还可以根据拥挤情况自动调整传输率</p>
<p>Pretty awesome!</p>
<p>相当厉害！</p>
<p>You might wonder why anyone would use UDP when TCP has all those nifty features.</p>
<p>你可能会奇怪，既然 TCP 那么厉害，还有人用 UDP 吗？</p>
<p>The single biggest downside are all those acknowledgment packets</p>
<p>TCP 最大的缺点是，</p>
<p>it doubles the number of messages on the network,</p>
<p>那些"确认码"数据包把数量翻了一倍</p>
<p>and yet, you're not transmitting any more data.</p>
<p>但并没有传输更多信息</p>
<p>That overhead, including associated delays, is sometimes not worth the improved robustness,</p>
<p>有时候这种代价是不值得的，特别是对时间要求很高的程序，</p>
<p>especially for time-critical applications, like Multiplayer First Person Shooters.</p>
<p>比如在线射击游戏</p>
<p>And if it’s you getting lag-fragged you’ll definitely agree!</p>
<p>如果你玩游戏很卡，你也会觉得这样不值!</p>
<p>When your computer wants to make a connection to a website, you need two things</p>
<p>当计算机访问一个网站时，需要两个东西：</p>
<p>an IP address and a port.</p>
<p>1 IP地址 2 端口号</p>
<p>Like port 80, at 172.217.7.238.</p>
<p>例如 172.217.7.238 的 80 端口，</p>
<p>This example is the IP address and port for the Google web server.</p>
<p>这是谷歌的 IP 地址和端口号</p>
<p>In fact, you can enter this into your browser’s address bar, like so,</p>
<p>事实上，你可以输到浏览器里，</p>
<p>and you’ll end up on the google homepage.</p>
<p>然后你会进入谷歌首页</p>
<p>This gets you to the right destination,</p>
<p>有了这两个东西就能访问正确的网站，</p>
<p>but remembering that long string of digits would be really annoying.</p>
<p>但记一长串数字很讨厌</p>
<p>It’s much easier to remember: google.com.</p>
<p>google.com 比一长串数字好记</p>
<p>So the internet has a special service that maps these domain names to addresses.</p>
<p>所以互联网有个特殊服务，负责把域名和 IP 地址一一对应</p>
<p>It’s like the phone book for the internet.</p>
<p>就像专为互联网的电话簿，</p>
<p>And it’s called the Domain Name System, or DNS for short.</p>
<p>它叫"域名系统"，简称 DNS</p>
<p>You can probably guess how it works.</p>
<p>它的运作原理你可能猜到了</p>
<p>When you type something like "youtube.com” into your web browser,</p>
<p>在浏览器里输 youtube.com，浏览器会去问 DNS 服务器，它的 IP 地址是多少</p>
<p>it goes and asks a DNS server – usually one provided by your ISP – to lookup the address.</p>
<p>一般 DNS 服务器，是互联网供应商提供的</p>
<p>DNS consults its huge registry, and replies with the address... if one exists.</p>
<p>DNS 会查表，如果域名存在，就返回对应 IP 地址.</p>
<p>In fact, if you try mashing your keyboard, adding ".com”, and then hit enter in your</p>
<p>如果你乱敲键盘加个.com 然后按回车</p>
<p>browser, you’ll likely be presented with an error that says DNS failed.</p>
<p>你很可能会看到 DNS 错误</p>
<p>That’s because that site doesn’t exist, so DNS couldn’t give your browser an address.</p>
<p>因为那个网站不存在，所以 DNS 无法返回给你一个地址</p>
<p>But, if DNS returns a valid address, which it should for "YouTube.com”, then your</p>
<p>如果你输的是有效地址，比如 youtube.com，DNS 按理会返回一个地址</p>
<p>browser shoots off a request over TCP for the website’s data.</p>
<p>然后浏览器会给这个 IP 地址，发 TCP 请求</p>
<p>There’s over 300 million registered domain names, so to make out DNS Lookup a little</p>
<p>如今有三千万个注册域名，所以为了更好管理</p>
<p>more manageable, it’s not stored as one gigantically long list,</p>
<p>DNS 不是存成一个超长超长的列表，</p>
<p>but rather in a tree data structure.</p>
<p>而是存成树状结构</p>
<p>What are called Top Level Domains, or TLDs, are at the very top.</p>
<p>顶级域名（简称 TLD）在最顶部，</p>
<p>These are huge categories like .com and .gov.</p>
<p>比如 .com 和 .gov</p>
<p>Then, there are lower level domains that sit below that, called second level domains; Examples</p>
<p>下一层是二级域名，比如 .com </p>
<p>under .com include google.com and dftba.com.</p>
<p>下面有，google.com 和 dftba.com</p>
<p>Then, there are even lower level domains, called subdomains,</p>
<p>再下一层叫子域名，</p>
<p>like images.google.com, store.dftba.com.</p>
<p>比如 images.google.com, store.dftba.com</p>
<p>And this tree is absolutely HUGE!</p>
<p>这个树超！级！大！</p>
<p>Like I said, more than 300 million domain names, and that's just second level domain</p>
<p>我前面说的"三千万个域名"只是二级域名，</p>
<p>names, not all the sub domains.</p>
<p>不是所有子域名</p>
<p>For this reason, this data is distributed across many DNS servers,</p>
<p>因此，这些数据散布在很多 DNS 服务器上</p>
<p>which are authorities for different parts of the tree.</p>
<p>不同服务器负责树的不同部分</p>
<p>Okay, I know you’ve been waiting for it...</p>
<p>好了我知道你肯定在等这个梗：</p>
<p>We’ve reached a new level of abstraction!</p>
<p>我们到了一层新抽象！</p>
<p>Over the past two episodes, we’ve worked up from electrical signals on wires,</p>
<p>过去两集里，我们讲了线路里的电信号，</p>
<p>or radio signals transmitted through the air in the case of wireless networks.</p>
<p>以及无线网络里的无线信号</p>
<p>This is called the Physical Layer.</p>
<p>这些叫"物理层"</p>
<p>MAC addresses, collision detection,</p>
<p>而"数据链路层"负责操控"物理层"，数据链路层有：</p>
<p>exponential backoff and similar low level protocols that</p>
<p>媒体访问控制地址（MAC），碰撞检测，</p>
<p>mediate access to the physical layer are part of the Data Link Layer.</p>
<p>指数退避，以及其他一些底层协议</p>
<p>Above this is the Network Layer,</p>
<p>再上一层是"网络层"</p>
<p>which is where all the switching and routing technologies that we discussed operate.</p>
<p>负责各种报文交换和路由</p>
<p>And today, we mostly covered the Transport layer, protocols like UDP and TCP,</p>
<p>而今天，我们讲了"传输层"里一大部分，比如 UDP 和 TCP 这些协议,</p>
<p>which are responsible for point to point data transfer between computers,</p>
<p>负责在计算机之间进行点到点的传输</p>
<p>and also things like error detection and recovery when possible.</p>
<p>而且还会检测和修复错误</p>
<p>We’ve also grazed the Session Layer –</p>
<p>我们还讲了一点点"会话层"</p>
<p>where protocols like TCP and UDP are used to open a connection,</p>
<p>"会话层"会使用 TCP 和 UDP 来创建连接，</p>
<p>pass information back and forth, and then close the connection when finished</p>
<p>传递信息，然后关掉连接</p>
<p>what’s called a session.</p>
<p>这一整套叫"会话"</p>
<p>This is exactly what happens when you, for example, do a DNS Lookup, or request a webpage.</p>
<p>查询 DNS 或看网页时，就会发生这一套流程</p>
<p>These are the bottom five layers of the Open System Interconnection (OSI) model,</p>
<p>这是开放式系统互联通信参考模型(OSI) 的底下5层</p>
<p>a conceptual framework for compartmentalizing all these different network processes.</p>
<p>这个概念性框架把网络通信划分成多层</p>
<p>Each level has different things to worry about and solve,</p>
<p>每一层处理各自的问题</p>
<p>and it would be impossible to build one huge networking implementation.</p>
<p>如果不分层，直接从上到下捏在一起实现网络通信，是完全不可能的</p>
<p>As we’ve talked about all series, abstraction allows computer scientists and engineers to</p>
<p>抽象使得科学家和工程师</p>
<p>be improving all these different levels of the stack simultaneously,</p>
<p>能分工同时改进多个层，</p>
<p>without being overwhelmed by the full complexity.</p>
<p>不被整体复杂度难倒.</p>
<p>And amazingly, we’re not quite done yet</p>
<p>而且惊人的是！我们还没讲完呢！</p>
<p>The OSI model has two more layers, the Presentation Layer and the Application Layer,</p>
<p>OSI 模型还有两层，"表示层"和"应用程序层"</p>
<p>which include things like web browsers, Skype,</p>
<p>其中有浏览器，Skype，</p>
<p>HTML decoding, streaming movies and more.</p>
<p>HTML解码，在线看电影等</p>
<p>Which we’ll talk about next week.  See you then.</p>
<p>我们下周说，到时见</p>
<p>30 万维网</p>
<p>The World Wide Web</p>
<p>Hi, I’m Carrie Anne, and welcome to Crash Course Computer Science.</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>Over the past two episodes, we’ve delved into the wires, signals, switches, packets,</p>
<p>前两集我们深入讨论了电线信号交换机数据包，</p>
<p>routers and protocols that make up the internet.</p>
<p>路由器以及协议，它们共同组成了互联网.</p>
<p>Today we’re going to move up yet another level of abstraction</p>
<p>今天我们向上再抽象一层，</p>
<p>and talk about the World Wide Web.</p>
<p>来讨论万维网</p>
<p>This is not the same thing as the Internet,</p>
<p>万维网(World Wide Web)，和互联网(Internet)不是一回事</p>
<p>even though people often use the two terms interchangeably.</p>
<p>尽管人们经常混用这两个词</p>
<p>The World Wide Web runs on top of the internet,</p>
<p>万维网在互联网之上运行</p>
<p>in the same way that Skype, Minecraft or Instagram do.</p>
<p>互联网之上还有 Skype, Minecraft 和 Instagram</p>
<p>The Internet is the underlying plumbing that conveys the data for all these different applications.</p>
<p>互联网是传递数据的管道，各种程序都会用，</p>
<p>And The World Wide Web is the biggest of them all</p>
<p>其中传输最多数据的程序是万维网</p>
<p>a huge distributed application running on millions of servers worldwide,</p>
<p>分布在全球数百万个服务器上</p>
<p>accessed using a special program called a web browser.</p>
<p>可以用"浏览器"来访问万维网</p>
<p>We’re going to learn about that, and much more, in today’s episode.</p>
<p>这集我们会深入讲解万维网</p>
<p>The fundamental building block of the World Wide Web – or web for short</p>
<p>万维网的最基本单位，</p>
<p>is a single page.</p>
<p>是单个页面</p>
<p>This is a document, containing content, which can include links to other pages.</p>
<p>页面有内容，也有去往其他页面的链接，</p>
<p>These are called hyperlinks.</p>
<p>这些链接叫"超链接"</p>
<p>You all know what these look like: text or images that you can click,</p>
<p>你们都见过：可以点击的文字或图片</p>
<p>and they jump you to another page.</p>
<p>把你送往另一个页面</p>
<p>These hyperlinks form a huge web of interconnected information,</p>
<p>这些超链接形成巨大的互联网络</p>
<p>which is where the whole thing gets its name.</p>
<p>这就是"万维网"名字的由来</p>
<p>This seems like such an obvious idea.</p>
<p>现在说起来觉得很简单，</p>
<p>But before hyperlinks were implemented,</p>
<p>但在超链接做出来之前</p>
<p>every time you wanted to switch to another piece of information on a computer,</p>
<p>计算机上每次想看另一个信息时</p>
<p>you had to rummage through the file system to find it, or type it into a search box.</p>
<p>你需要在文件系统中找到它，或是把地址输入搜索框</p>
<p>With hyperlinks, you can easily flow from one related topic to another.</p>
<p>有了超链接，你可以在相关主题间轻松切换</p>
<p>The value of hyperlinked information was conceptualized by Vannevar Bush way back in 1945.</p>
<p>超链接的价值早在 1945 年，就被 Vannevar Bush 意识到了</p>
<p>He published an article describing a hypothetical machine called a Memex,</p>
<p>他发过一篇文章，描述一个假想的机器 Memex</p>
<p>which we discussed in Episode 24.</p>
<p>在第 24 集中我们说过</p>
<p>Bush described it as "associative indexing... whereby any item may be caused</p>
<p>Bush的形容是"关联式索引.. 选一个物品会引起</p>
<p>at will to select another immediately and automatically."</p>
<p>另一个物品被立即选中"</p>
<p>He elaborated: "The process of tying two things together is the important thing...</p>
<p>他解释道："将两样东西联系在一起的过程十分重要</p>
<p>thereafter, at any time, when one of those items is in view,</p>
<p>在任何时候，当其中一件东西进入视线</p>
<p>the other [item] can be instantly recalled merely by tapping a button."</p>
<p>只需点一下按钮，立马就能回忆起另一件"</p>
<p>In 1945, computers didn’t even have screens, so this idea was way ahead of its time!</p>
<p>1945年的时候计算机连显示屏都没有，所以这个想法非常超前！</p>
<p>Text containing hyperlinks is so powerful,</p>
<p>因为文字超链接是如此强大</p>
<p>it got an equally awesome name: hypertext!</p>
<p>它得到了一个同样厉害的名字："超文本"！</p>
<p>Web pages are the most common type of hypertext document today.</p>
<p>如今超文本最常指向的，是另一个网页</p>
<p>They’re retrieved and rendered by web browsers</p>
<p>然后网页由浏览器渲染，</p>
<p>which we'll get to in a few minutes.</p>
<p>我们待会会讲</p>
<p>In order for pages to link to one another, each hypertext page needs a unique address.</p>
<p>为了使网页能相互连接，每个网页需要一个唯一的地址</p>
<p>On the web, this is specified by a Uniform Resource Locator, or URL for short.</p>
<p>这个地址叫 "统一资源定位器"，简称 URL</p>
<p>An example web page URL is thecrashcourse.com/courses.</p>
<p>一个网页URL的例子是 "thecrashcourse.com/courses"</p>
<p>Like we discussed last episode, when you request a site,</p>
<p>就像上集讨论的，当你访问一个网站时</p>
<p>the first thing your computer does is a DNS lookup.</p>
<p>计算机首先会做"DNS查找"</p>
<p>This takes a domain name as input – like "thecrashcourse.com"</p>
<p>"DNS查找"的输入是一个域名，比如 thecrashcourse.com</p>
<p>and replies back with the corresponding computer’s IP address.</p>
<p>DNS 会输出对应的IP地址</p>
<p>Now, armed with the IP address of the computer you want,</p>
<p>现在有了IP地址，</p>
<p>your web browser opens a TCP connection to a computer</p>
<p>你的浏览器会打开一个 TCP 连接到这个 IP 地址</p>
<p>that’s running a special piece of software called a web server.</p>
<p>这个地址运行着"网络服务器"</p>
<p>The standard port number for web servers is port 80.</p>
<p>网络服务器的标准端口是 80 端口</p>
<p>At this point, all your computer has done is connect to</p>
<p>这时，你的计算机连到了，</p>
<p>the web server at the address thecrashcourse.com</p>
<p>thecrashcourse.com 的服务器</p>
<p>The next step is to ask that web server for the "courses" hypertext page.</p>
<p>下一步是向服务器请求"courses"这个页面</p>
<p>To do this, it uses the aptly named Hypertext Transfer Protocol, or HTTP.</p>
<p>这里会用"超文本传输协议"(HTTP)</p>
<p>The very first documented version of this spec, HTTP 0.9, created in 1991,</p>
<p>HTTP的第一个标准，HTTP 0.9，创建于1991年</p>
<p>only had one command – "GET".</p>
<p>只有一个指令，"GET" 指令</p>
<p>Fortunately, that’s pretty much all you need.</p>
<p>幸运的是，对当时来说也够用</p>
<p>Because we’re trying to get the "courses" page,</p>
<p>因为我们想要的是"courses"页面</p>
<p>we send the server the following command– GET /courses.</p>
<p>我们向服务器发送指令:"GET /courses"</p>
<p>This command is sent as raw ASCII text to the web server,</p>
<p>该指令以"ASCII编码"发送到服务器</p>
<p>which then replies back with the web page hypertext we requested.</p>
<p>服务器会返回该地址对应的网页，</p>
<p>This is interpreted by your computer's web browser and rendered to your screen.</p>
<p>然后浏览器会渲染到屏幕上</p>
<p>If the user follows a link to another page, the computer just issues another GET request.</p>
<p>如果用户点了另一个链接，计算机会重新发一个GET请求</p>
<p>And this goes on and on as you surf around the website.</p>
<p>你浏览网站时，这个步骤会不断重复</p>
<p>In later versions, HTTP added status codes,</p>
<p>在之后的版本，HTTP添加了状态码</p>
<p>which prefixed any hypertext that was sent following a GET request.</p>
<p>状态码放在请求前面</p>
<p>For example, status code 200 means OK – I’ve got the page and here it is!</p>
<p>举例，状态码 200 代表 "网页找到了,给你"</p>
<p>Status codes in the four hundreds are for client errors.</p>
<p>状态码400~499代表客户端出错</p>
<p>Like, if a user asks the web server for a page that doesn’t exist,</p>
<p>比如网页不存在，就是可怕的404错误</p>
<p>that’s the dreaded 404 error!</p>
<p>比如网页不存在，就是可怕的404错误</p>
<p>Web page hypertext is stored and sent as plain old text,</p>
<p>"超文本"的存储和发送都是以普通文本形式</p>
<p>for example, encoded in ASCII or UTF-16, which we talked about in Episodes 4 and 20.</p>
<p>举个例子，编码可能是 ASCII 或 UTF-16 ，我们在第4集和第20集讨论过</p>
<p>Because plain text files don’t have a way to specify what’s a link and what’s not,</p>
<p>因为如果只有纯文本，无法表明什么是链接，什么不是链接</p>
<p>it was necessary to develop a way to "mark up" a text file with hypertext elements.</p>
<p>所以有必要开发一种标记方法</p>
<p>For this, the Hypertext Markup Language was developed.</p>
<p>因此开发了超文本标记语言（HTML)</p>
<p>The very first version of HTML version 0.8, created in 1990,</p>
<p>HTML 第一版的版本号是 0.8，创建于 1990 年</p>
<p>provided 18 HTML commands to markup pages.</p>
<p>有18种HTML指令</p>
<p>That’s it!</p>
<p>仅此而已</p>
<p>Let’s build a webpage with these!</p>
<p>我们来做一个网页吧！</p>
<p>First, let’s give our web page a big heading.</p>
<p>首先，给网页一个大标题</p>
<p>To do this, we type in the letters "h1", which indicates the start of a first level</p>
<p>我们输 h1 代表一级标题，然后用&lt;>括起来</p>
<p>heading, and we surround that in angle brackets.</p>
<p>我们输 h1 代表一级标题，然后用&lt;>括起来</p>
<p>This is one example of an HTML tag.</p>
<p>这就是一个HTML标签</p>
<p>Then, we enter whatever heading text we want.</p>
<p>然后输入想要的标题</p>
<p>We don’t want the whole page to be a heading.</p>
<p>我们不想一整页都是标题，</p>
<p>So, we need to "close" the "h1" tag like so, with a little slash in the front.</p>
<p>所以加 &lt;/h1> 作为结束标签</p>
<p>Now lets add some content.</p>
<p>现在来加点内容</p>
<p>Visitors may not know what Klingons are, so let’s make that word a hyperlink to the</p>
<p>读者可能不知道"克林贡"是什么，所以我们给这个词</p>
<p>Klingon Language Institute for more information.</p>
<p>加一个超链接到"克林贡语言研究院"</p>
<p>We do this with an "A" tag, inside of which we include an attribute</p>
<p>我们用 &lt;a> 标签来做，它有一个 href 属性</p>
<p>that specifies a hyperlink reference.</p>
<p>说明链接指向哪里，当点击链接时就会进入那个网页</p>
<p>That’s the page to jump to if the link is clicked.</p>
<p>说明链接指向哪里，当点击链接时就会进入那个网页</p>
<p>And finally, we need to close the A tag.</p>
<p>最后用 &lt;/a> 关闭标签</p>
<p>Now lets add a second level heading, which uses an "h2" tag.</p>
<p>接下来用 &lt;h2> 标签做二级标题</p>
<p>HTML also provides tags to create lists.</p>
<p>HTML也有做列表的标签</p>
<p>We start this by adding the tag for an ordered list.</p>
<p>我们先写&lt;ol>，代表有序列表（ordered list）</p>
<p>Then we can add as many items as we want,</p>
<p>然后想加几个列表项目就加几个，</p>
<p>surrounded in "&lt;li>" tags, which stands for list item.</p>
<p>用 &lt;li> 包起来就行</p>
<p>People may not know what a bat'leth is, so let’s make that a hyperlink too.</p>
<p>读者可能不知道Bat'leth是什么，那么也加上超链接</p>
<p>Lastly, for good form, we need to close the ordered list tag.</p>
<p>最后，为了保持良好格式，用&lt;/ol>代表列表结束</p>
<p>And we’re done – that’s a very simple web page!</p>
<p>这就完成了一个很简单的网页！</p>
<p>If you save this text into notepad or textedit, and name it something like "test.html",</p>
<p>如果把这些文字存入记事本或文本编辑器，然后文件取名"test.html"</p>
<p>you should be able to open it by dragging it into your computer’s web browser.</p>
<p>就可以拖入浏览器打开</p>
<p>Of course, today’s web pages are a tad more sophisticated.</p>
<p>当然，如今的网页更复杂一些</p>
<p>The newest version of HTML, version 5, has over a hundred different tags –</p>
<p>最新版的 HTML，HTML5，有100多种标签</p>
<p>for things like images, tables, forms and buttons.</p>
<p>图片标签，表格标签，表单标签，按钮标签，等等</p>
<p>And there are other technologies we’re not going to discuss, like Cascading Style Sheets</p>
<p>还有其他相关技术就不说了，比如层叠样式表 (CSS)</p>
<p>or CSS and JavaScript, which can be embedded into HTML pages and do even fancier things.</p>
<p>和 JavaScript，这俩可以加进网页，做一些更厉害的事</p>
<p>That brings us back to web browsers.</p>
<p>让我们回到浏览器</p>
<p>This is the application on your computer that lets you talk with all these web servers.</p>
<p>网页浏览器可以和网页服务器沟通</p>
<p>Browsers not only request pages and media,</p>
<p>浏览器不仅获取网页和媒体，</p>
<p>but also render the content that’s being returned.</p>
<p>获取后还负责显示.</p>
<p>The first web browser, and web server,</p>
<p>第一个浏览器和服务器</p>
<p>was written by (now Sir) Tim Berners-Lee over the course of two months in 1990.</p>
<p>是 Tim Berners-Lee 在 1990 年写的，一共花了2个月</p>
<p>At the time, he was working at CERN in Switzerland.</p>
<p>那时候他在瑞士的"欧洲核子研究所"工作</p>
<p>To pull this feat off, he simultaneously created several of the fundamental web standards</p>
<p>为了做出来，他同时建立了几个最基本的网络标准</p>
<p>we discussed today: URL, HTML and HTTP.</p>
<p>URL, HTML 和 HTTP.</p>
<p>Not bad for two months work!</p>
<p>两个月能做这些很不错啊！</p>
<p>Although to be fair, he’d been researching hypertext systems for over a decade.</p>
<p>不过公平点说，他研究超文本系统已经有十几年了</p>
<p>After initially circulating his software amongst colleagues at CERN,</p>
<p>和同事在 CERN 内部使用一阵子后</p>
<p>it was released to the public in 1991.</p>
<p>在 1991 年发布了出去</p>
<p>The World Wide Web was born.</p>
<p>万维网就此诞生</p>
<p>Importantly, the web was an open standard,</p>
<p>重要的是，万维网有开放标准</p>
<p>making it possible for anyone to develop new web servers and browsers.</p>
<p>大家都可以开发新服务器和新浏览器</p>
<p>This allowed a team at the University of Illinois at Urbana-Champaign to</p>
<p>因此"伊利诺伊大学香槟分校"的一个小组</p>
<p>create the Mosaic web browser in 1993.</p>
<p>在 1993 年做了 Mosaic 浏览器</p>
<p>It was the first browser that allowed graphics to be embedded alongside text;</p>
<p>第一个可以在文字旁边显示图片的浏览器</p>
<p>previous browsers displayed graphics in separate windows.</p>
<p>之前浏览器要单开一个新窗口显示图片</p>
<p>It also introduced new features like bookmarks, and had a friendly GUI interface,</p>
<p>还引进了书签等新功能，界面友好，</p>
<p>which made it popular.</p>
<p>使它很受欢迎</p>
<p>Even though it looks pretty crusty, it’s recognizable as the web we know today!</p>
<p>尽管看上去硬邦邦的，但和如今的浏览器长的差不多</p>
<p>By the end of the 1990s, there were many web browsers in use,</p>
<p>1990年代末有许多浏览器面世</p>
<p>like Netscape Navigator, Internet Explorer, Opera, OmniWeb and Mozilla.</p>
<p>Netscape Navigator, Internet Explorer，Opera, OmniWeb, Mozilla</p>
<p>Many web servers were also developed,</p>
<p>也有很多服务器面世</p>
<p>like Apache and Microsoft’s Internet Information Services (IIS).</p>
<p>比如 Apache 和微软互联网信息服务(IIS)</p>
<p>New websites popped up daily, and web mainstays</p>
<p>每天都有新网站冒出来，如今的网络巨头</p>
<p>like Amazon and eBay were founded in the mid-1990s.</p>
<p>比如亚马逊和 eBay，创始于 1990 年代中期</p>
<p>It was a golden era!</p>
<p>那是个黄金时代！</p>
<p>The web was flourishing and people increasingly needed ways to find things.</p>
<p>随着万维网日益繁荣，人们越来越需要搜索</p>
<p>If you knew the web address of where you wanted to go –</p>
<p>如果你知道网站地址，比如 ebay.com，</p>
<p>like ebay.com – you could just type it into the browser.</p>
<p>直接输入浏览器就行</p>
<p>But what if you didn’t know where to go?</p>
<p>如果不知道地址呢？</p>
<p>Like, you only knew that you wanted pictures of cute cats.</p>
<p>比如想找可爱猫咪的图片</p>
<p>Right now!</p>
<p>现在就要！</p>
<p>Where do you go?</p>
<p>去哪里找呢？</p>
<p>At first, people maintained web pages</p>
<p>起初人们会维护一个目录，</p>
<p>which served as directories hyperlinking to other websites.</p>
<p>链接到其他网站</p>
<p>"Most famous among these was "Jerry and David's guide to the World Wide Web",</p>
<p>其中最有名的叫"Jerry和David的万维网指南"</p>
<p>renamed Yahoo in 1994.</p>
<p>1994年改名为Yahoo</p>
<p>As the web grew, these human-edited directories started to get unwieldy,</p>
<p>随着网络越来越大，人工编辑的目录变得不便利</p>
<p>and so search engines were developed.</p>
<p>所以开发了搜索引擎</p>
<p>Let’s go to the thought bubble!</p>
<p>让我们进入思想泡泡!</p>
<p>The earliest web search engine that operated like the ones we use today, was JumpStation,</p>
<p>长的最像现代搜索引擎的最早搜素引擎，叫JumpStation</p>
<p>created by Jonathon Fletcher in 1993 at the University of Stirling.</p>
<p>由Jonathon Fletcher于1993年在斯特林大学创建</p>
<p>This consisted of three pieces of software that worked together.</p>
<p>它有 3 个部分</p>
<p>The first was a web crawler, software that followed all the links it could find on the web;</p>
<p>第一个是爬虫，一个跟着链接到处跑的软件</p>
<p>anytime it followed a link to a page that had new links,</p>
<p>每当看到新链接，</p>
<p>it would add those to its list.</p>
<p>就加进自己的列表里</p>
<p>The second component was an ever enlarging index,</p>
<p>第二个部分是不断扩张的索引</p>
<p>recording what text terms appeared on what pages the crawler had visited.</p>
<p>记录访问过的网页上，出现过哪些词</p>
<p>The final piece was a search algorithm that consulted the index;</p>
<p>最后一个部分，是查询索引的搜索算法</p>
<p>for example, if I typed the word "cat" into JumpStation,</p>
<p>举个例子，如果我在 JumpStation 输入"猫"</p>
<p>every webpage where the word "cat" appeared would come up in a list.</p>
<p>每个有"猫"这个词的网页都会出现</p>
<p>Early search engines used very simple metrics to rank order their search results, most often</p>
<p>早期搜索引擎的排名方式非常简单</p>
<p>just the number of times a search term appeared on a page.</p>
<p>取决于搜索词在页面上的出现次数</p>
<p>This worked okay, until people started gaming the system,</p>
<p>刚开始还行，直到有人开始钻空子</p>
<p>like by writing "cat" hundreds of times on their web pages just to steer traffic their way.</p>
<p>比如在网页上写几百个"猫"，把人们吸引过来</p>
<p>Google’s rise to fame was in large part</p>
<p>谷歌成名的一个很大原因是，</p>
<p>due to a clever algorithm that sidestepped this issue.</p>
<p>创造了一个聪明的算法来规避这个问题</p>
<p>Instead of trusting the content on a web page,</p>
<p>与其信任网页上的内容，</p>
<p>they looked at how other websites linked to that page.</p>
<p>搜索引擎会看其他网站有没有链接到这个网站</p>
<p>If it was a spam page with the word cat over and over again, no site would link to it.</p>
<p>如果只是写满"猫"的垃圾网站，没有网站会指向它</p>
<p>But if the webpage was an authority on cats, then other sites would likely link to it.</p>
<p>如果有关于猫的有用内容，有网站会指向它</p>
<p>So the number of what are called "backlinks", especially from reputable sites,</p>
<p>所以这些"反向链接"的数量，特别是有信誉的网站</p>
<p>was often a good sign of quality.</p>
<p>代表了网站质量</p>
<p>This started as a research project called BackRub at Stanford University in 1996, before</p>
<p>Google 一开始时是 1996 年斯坦福大学，一个叫 BackRub 的研究项目</p>
<p>being spun out, two years later, into the Google we know today.</p>
<p>两年后分离出来，演变成如今的谷歌</p>
<p>Thanks thought bubble!</p>
<p>谢谢思想泡泡！</p>
<p>Finally, I want to take a second to talk about a term you’ve probably heard a lot recently,</p>
<p>最后我想讲一个词，你最近可能经常听到</p>
<p>"Net Neutrality".</p>
<p>网络中立性</p>
<p>Now that you’ve built an understanding of packets, internet routing, and the World Wide</p>
<p>现在你对数据包，路由和万维网，有了个大体概念</p>
<p>Web, you know enough to understand the essence, at least the technical essence, of this big debate.</p>
<p>足够你理解这个争论的核心点，至少从技术角度</p>
<p>In short, network neutrality is the principle that</p>
<p>简单说"网络中立性"是</p>
<p>all packets on the internet should be treated equally.</p>
<p>应该平等对待所有数据包</p>
<p>It doesn’t matter if the packets are my email or you streaming this video,</p>
<p>不论这个数据包是我的邮件，或者是你在看视频</p>
<p>they should all chug along at the same speed and priority.</p>
<p>速度和优先级应该是一样的</p>
<p>But many companies would prefer that their data arrive to you preferentially.</p>
<p>但很多公司会乐意让它们的数据优先到达</p>
<p>Take for example, Comcast, a large ISP that also owns many TV channels,</p>
<p>拿 Comcast 举例，它们不但是大型互联网服务提供商，而且拥有多家电视频道</p>
<p>like NBC and The Weather Channel, which are streamed online.</p>
<p>比如 NBC 和 The Weather Channel，可以在线看.</p>
<p>Not to pick on Comcast, but in the absence of Net Neutrality rules,</p>
<p>我不是特意找Comcast麻烦，但要是没有网络中立性</p>
<p>they could for example say that they want their content to be delivered silky smooth, with high priority…</p>
<p>Comcast 可以让自己的内容优先到达，</p>
<p>But other streaming videos are going to get throttled,</p>
<p>节流其他线上视频</p>
<p>that is, intentionally given less bandwidth and lower priority.</p>
<p>节流(Throttled) 意思是故意给更少带宽和更低优先级</p>
<p>Again I just want to reiterate here this is just conjecture.</p>
<p>再次重申，这只是举例，不是说 Comcast 很坏</p>
<p>At a high level, Net Neutrality advocates argue that giving internet providers this</p>
<p>支持网络中立性的人说，没有中立性后，</p>
<p>ability to essentially set up tolls on the internet – to provide premium packet delivery</p>
<p>服务商可以推出提速的"高级套餐"</p>
<p>plants the seeds for an exploitative business model.</p>
<p>给剥削性商业模式埋下种子</p>
<p>ISPs could be gatekeepers to content, with strong incentives to not play nice with competitors.</p>
<p>互联网服务供应商成为信息的"守门人"，它们有着强烈的动机去碾压对手</p>
<p>Also, if big companies like Netflix and Google can pay to get special treatment,</p>
<p>另外，Netflix和Google这样的大公司可以花钱买特权</p>
<p>small companies, like start-ups, will be at a disadvantage, stifling innovation.</p>
<p>而小公司，比如刚成立的创业公司，会处于劣势，阻止了创新</p>
<p>On the other hand, there are good technical reasons why you might</p>
<p>另一方面，从技术原因看</p>
<p>want different types of data to flow at different speeds.</p>
<p>也许你会希望不同数据传输速度不同</p>
<p>That skype call needs high priority,</p>
<p>你希望Skype的优先级更高，</p>
<p>but it’s not a big deal if an email comes in a few seconds late.</p>
<p>邮件晚几秒没关系</p>
<p>Net-neutrality opponents also argue that market forces and competition would discourage bad</p>
<p>而反对"网络中立性"的人认为，市场竞争会阻碍不良行为</p>
<p>behavior, because customers would leave ISPs that are throttling sites they like.</p>
<p>如果供应商把客户喜欢的网站降速，客户会离开供应商</p>
<p>This debate will rage on for a while yet, and as we always encourage on Crash Course,</p>
<p>这场争辩还会持续很久，就像我们在 Crash Course 其他系列中说过</p>
<p>you should go out and learn more</p>
<p>你应该自己主动了解更多信息</p>
<p>because the implications of Net Neutrality are complex and wide-reaching.</p>
<p>因为"网络中立性"的影响十分复杂而且广泛</p>
<p>I’ll see you next week.</p>
<p>我们下周再见</p>
<p>31 计算机安全</p>
<p>Cybersecurity</p>
<p>Hi, I’m Carrie Anne, and welcome to Crash Course Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>Over the last three episodes, we’ve talked about how computers have become interconnected,</p>
<p>过去3集我们讲了计算机如何互连</p>
<p>allowing us to communicate near-instantly across the globe.</p>
<p>让我们能瞬时跨全球沟通</p>
<p>But, not everyone who uses these networks is going to play by the rules,</p>
<p>但不是每个使用网络的人都会规规矩矩  </p>
<p>or have our best interests at heart.</p>
<p>不损害他人利益</p>
<p>Just as how we have physical security like locks, fences</p>
<p>就像现实世界中我们用锁和栅栏保证物理安全</p>
<p>and police officers to minimize crime in the real world,</p>
<p>有警察减少犯罪</p>
<p>we need cybersecurity to minimize crime and harm in the virtual world.</p>
<p>我们需要网络安全减少虚拟世界中的犯罪</p>
<p>Computers don’t have ethics.</p>
<p>计算机没有道德观念</p>
<p>Give them a formally specified problem and</p>
<p>只要给计算机写清具体问题</p>
<p>they’ll happily pump out an answer at lightning speed.</p>
<p>它们很乐意地闪电般算出答案</p>
<p>Running code that takes down a hospital’s computer systems</p>
<p>破坏医院计算机系统的代码和 保持病人心跳的代码，</p>
<p>is no different to a computer than code that keeps a patient's heart beating.</p>
<p>对计算机来说没有区别</p>
<p>Like the Force, computers can be pulled to the light side or the dark side.</p>
<p>就像"原力"一样，计算机可以被拉到"光明面"或"黑暗面"</p>
<p>Cybersecurity is like the Jedi Order, trying to bring peace and justice to the cyber-verse.</p>
<p>网络安全就像绝地武士团，给网络世界带来和平与正义</p>
<p>The scope of cybersecurity evolves as fast as the capabilities of computing,</p>
<p>计算机安全的范围，和计算能力的发展速度一样快</p>
<p>but we can think of it as a set of techniques to protect the secrecy,</p>
<p>我们可以把计算机安全，看成是保护系统和数据的：</p>
<p>integrity and availability of computer systems and data against threats.</p>
<p>保密性，完整性和可用性</p>
<p>Let’s unpack those three goals:</p>
<p>我们逐个细说：</p>
<p>Secrecy, or confidentiality, means that only authorized people</p>
<p>"保密性"是只有有权限的人，</p>
<p>should be able to access or read specific computer systems and data.</p>
<p>才能读取计算机系统和数据</p>
<p>Data breaches, where hackers reveal people’s credit card information,</p>
<p>黑客泄露别人的信用卡信息，</p>
<p>is an attack on secrecy.</p>
<p>就是攻击保密性.</p>
<p>Integrity means that only authorized people</p>
<p>"完整性"是只有有权限的人，</p>
<p>should have the ability to use or modify systems and data.</p>
<p>才能使用和修改系统和数据</p>
<p>Hackers who learn your password and send e-mails masquerading as you, is an integrity attack.</p>
<p>黑客知道你的邮箱密码，假冒你发邮件，就是攻击"完整性"</p>
<p>And availability means that authorized people should</p>
<p>"可用性"是有权限的人，</p>
<p>always have access to their systems and data.</p>
<p>应该随时可以访问系统和数据</p>
<p>Think of Denial of Service Attacks, where hackers overload a website</p>
<p>拒绝服务攻击(DDOS) 就是黑客</p>
<p>with fake requests to make it slow or unreachable for others.</p>
<p>发大量的假请求到服务器，让网站很慢或者挂掉</p>
<p>That’s attacking the service’s availability.</p>
<p>这就是攻击"可用性"</p>
<p>To achieve these three general goals, security experts start with</p>
<p>为了实现这三个目标，安全专家会从，</p>
<p>a specification of who your "enemy" is, at an abstract level, called a threat model.</p>
<p>抽象层面想象"敌人"可能是谁，这叫"威胁模型分析"</p>
<p>This profiles attackers: their capabilities, goals, and probable means of attack</p>
<p>模型会对攻击者有个大致描述：，能力如何，目标可能是什么，可能用什么手段</p>
<p>what’s called, awesomely enough, an attack vector.</p>
<p>攻击手段又叫"攻击矢量"</p>
<p>Threat models let you prepare against specific threats, rather than</p>
<p>"威胁模型分析"让你能为特定情境做准备</p>
<p>being overwhelmed by all the ways hackers could get to your systems and data.</p>
<p>不被可能的攻击手段数量所淹没，</p>
<p>And there are many, many ways.</p>
<p>因为手段实在有太多种了</p>
<p>Let’s say you want to "secure" physical access to your laptop.</p>
<p>假设你想确保笔记本计算机的"物理安全"，</p>
<p>Your threat model is a nosy roommate.</p>
<p>你的威胁模型是"好管闲事的室友"</p>
<p>To preserve the secrecy, integrity and availability of your laptop,</p>
<p>为了保证保密性，完整性和可用性，</p>
<p>you could keep it hidden in your dirty laundry hamper.</p>
<p>你可以藏在脏兮兮的洗衣篮里</p>
<p>But, if your threat model is a mischievous younger sibling</p>
<p>但如果威胁模型是调皮的兄弟姐妹，</p>
<p>who knows your hiding spots,</p>
<p>知道你喜欢藏哪里</p>
<p>then you’ll need to do more: maybe lock it in a safe.</p>
<p>那么你需要更多保护：比如锁在保险箱里</p>
<p>In other words, how a system is secured depends heavily on who it’s being secured against.</p>
<p>换句话说，要怎么保护，具体看对抗谁</p>
<p>Of course, threat models are typically a bit more formally defined than just "nosy roommate".</p>
<p>当然，威胁模型通常比"好管闲事的室友"更正式一些</p>
<p>Often you’ll see threat models specified in terms of technical capabilities.</p>
<p>通常威胁模型分析里会以能力水平区分</p>
<p>For example, "someone who has physical access to your laptop along with unlimited time".</p>
<p>比如"某人可以物理接触到笔记本计算机，而且时间无限"</p>
<p>With a given threat model, security architects need to come up</p>
<p>在给定的威胁模型下，安全架构师要</p>
<p>with a solution that keeps a system secure –</p>
<p>提供解决方案，保持系统安全</p>
<p>as long as certain assumptions are met,</p>
<p>只要某些假设不被推翻</p>
<p>like no one reveals their password to the attacker.</p>
<p>比如没人会告诉攻击者密码</p>
<p>There are many methods for protecting computer systems, networks and data.</p>
<p>保护计算机系统，网络和数据的方法有很多</p>
<p>A lot of security boils down to two questions:</p>
<p>很多安全问题可以总结成2个问题：</p>
<p>who are you, and what should you have access to?</p>
<p>你是谁？你能访问什么？</p>
<p>Clearly, access should be given to the right people, but refused to the wrong people.</p>
<p>权限应该给合适的人，拒绝错误的人</p>
<p>Like, bank employees should be able to open ATMs to restock them, but not me…</p>
<p>比如银行员工可以打开取款机来补充现金。，但我不应该有权限打开</p>
<p>because I’d take it all... all of it!</p>
<p>因为我会把钱拿走全拿走！</p>
<p>That ceramic cat collection doesn’t buy itself!</p>
<p>陶瓷猫收藏品可不会从天上掉下来哟！</p>
<p>So, to differentiate between right and wrong people, we use authentication</p>
<p>所以，为了区分谁是谁，我们用 "身份认证"(authentication)</p>
<p>the process by which a computer understands who it’s interacting with.</p>
<p>让计算机得知使用者是谁</p>
<p>Generally, there are three types, each with their own pros and cons:</p>
<p>身份认证有三种，各有利弊：</p>
<p>What you know.</p>
<p>你知道什么</p>
<p>What you have.</p>
<p>你有什么</p>
<p>And what you are.</p>
<p>你是什么</p>
<p>What you know authentication is based on knowledge of a secret that</p>
<p>"你知道什么" 是基于某个秘密</p>
<p>should be known only by the real user and the computer,</p>
<p>只有用户和计算机知道</p>
<p>for example, a username and password.</p>
<p>比如用户名和密码</p>
<p>This is the most widely used today because it’s the easiest to implement.</p>
<p>这是如今使用最广泛的，因为最容易实现</p>
<p>But, it can be compromised if hackers guess or otherwise come to know your secret.</p>
<p>但如果黑客通过猜测或其他方式，知道你的密码，就惨了</p>
<p>Some passwords are easy for humans to figure out, like 12356 or qwerty.</p>
<p>有些密码很容易猜中，比如12356或qwerty</p>
<p>But, there are also ones that are easy for computers.</p>
<p>但有些密码对计算机很容易</p>
<p>Consider the PIN: 2580.</p>
<p>比如PIN码：2580</p>
<p>This seems pretty difficult to guess – and it is – for a human.</p>
<p>看起来很难猜中起码对人类来说是这样</p>
<p>But there are only ten thousand possible combinations of 4-digit PINs.</p>
<p>但4位数字，只有一万种可能</p>
<p>A computer can try entering 0000, then try 0001, and then 0002,</p>
<p>一台计算机可以尝试0000，然后0001，然后0002，</p>
<p>all the way up to 9999... in a fraction of a second.</p>
<p>然后到9999，不到一秒内试完</p>
<p>This is called a brute force attack, because it just tries everything.</p>
<p>这叫"暴力攻击"，因为只是试遍一切可能</p>
<p>There’s nothing clever to the algorithm.</p>
<p>这种算法没什么聪明的地方</p>
<p>Some computer systems lock you out, or have you wait a little, after say three wrong attempts.</p>
<p>如果你错误尝试3次，有些系统会阻止你继续尝试，或让你等一会儿</p>
<p>That’s a common and reasonable strategy,</p>
<p>这个策略普遍而且合理</p>
<p>and it does make it harder for less sophisticated attackers.</p>
<p>对于一般的攻击者确实很难</p>
<p>But think about what happens if hackers have already taken over</p>
<p>但假设黑客控制了</p>
<p>tens of thousands of computers, forming a botnet.</p>
<p>数以万计的计算机，形成一个僵尸网络</p>
<p>Using all these computers, the same pin – 2580 –</p>
<p>用这么多计算机尝试密码 2580</p>
<p>can be tried on many tens of thousands of bank accounts simultaneously.</p>
<p>同时尝试很多银行账户</p>
<p>Even with just a single attempt per account, they’ll very likely</p>
<p>即使每个账户只试一次，也很可能</p>
<p>get into one or more that just happen to use that PIN.</p>
<p>碰到某个账户刚好用这个 PIN</p>
<p>In fact, we’ve probably guessed the pin of someone watching this video!</p>
<p>事实上，看视频的某人可能刚好用这个 PIN</p>
<p>Increasing the length of PINs and passwords can help,</p>
<p>增加密码长度有帮助</p>
<p>but even 8 digit PINs are pretty easily cracked.</p>
<p>但即使8位数字的PIN码也很容易破解</p>
<p>This is why so many websites now require you to use a mix of upper and lowercase letters,</p>
<p>这就是为什么现在很多网站要求大写+小写字母</p>
<p>special symbols, and so on – it explodes the number of possible password combinations.</p>
<p>还有特殊符号等，大大增加可能的密码</p>
<p>An 8-digit numerical PIN only has a hundred million combinations</p>
<p>8位数字的PIN只有一亿种组合</p>
<p>computers eat that for breakfast!</p>
<p>对计算机轻而易举</p>
<p>But an 8-character password with all those funky things mixed in</p>
<p>但包含各种字符的8位长度密码</p>
<p>has more than 600 trillion combinations.</p>
<p>有超过600万亿种组合</p>
<p>Of course, these passwords are hard for us mere humans to remember,</p>
<p>当然，这些密码会难以记住，</p>
<p>so a better approach is for websites to let us pick something more memorable,</p>
<p>所以更好的方法是选一些更好记的东西</p>
<p>like three words joined together:</p>
<p>比如三个单词连在一起：</p>
<p>"green brothers rock" or "pizza tasty yum".</p>
<p>"格林兄弟好厉害"或"披萨尝起来好好吃"</p>
<p>English has around 100,000 words in use,</p>
<p>英文大约有10万个单词</p>
<p>so putting three together would give you roughly</p>
<p>所以三个单词连一起大概有</p>
<p>1 quadrillion possible passwords. Good luck trying to guess that!</p>
<p>1亿亿种可能，想猜中的话，祝你好运！</p>
<p>I should also note here that using non-dictionary words</p>
<p>另外使用不在字典内的单词</p>
<p>is even better against more sophisticated kinds of attacks,</p>
<p>被猜中的可能性更低</p>
<p>but we don’t have time to get into that here.</p>
<p>但我们没时间细说这个</p>
<p>Computerphile has a great video on choosing a password link in the dooblydoo.</p>
<p>Computerphile 频道有个视频讲怎么选择好密码，链接请看 Youtube 描述</p>
<p>What you have authentication, on the other hand,</p>
<p>"你有什么"这种验证方式</p>
<p>is based on possession of a secret token that only the real user has.</p>
<p>是基于用户有特定物体</p>
<p>An example is a physical key and lock.</p>
<p>比如钥匙和锁</p>
<p>You can only unlock the door if you have the key.</p>
<p>如果你有钥匙，就能开门</p>
<p>This escapes this problem of being "guessable".</p>
<p>这避免了被人"猜中"的问题</p>
<p>And they typically require physical presence,</p>
<p>而且通常需要人在现场</p>
<p>so it’s much harder for remote attackers to gain access.</p>
<p>所以远程攻击就更难了</p>
<p>Someone in another country can’t gain access to your front door in Florida</p>
<p>另一个国家的人，得先来佛罗里达州</p>
<p>without getting to Florida first.</p>
<p>才能到你家前门</p>
<p>But, what you have authentication can be compromised if an attacker is physically close.</p>
<p>但如果攻击者离你比较近，那么也不安全</p>
<p>Keys can be copied, smartphones stolen, and locks picked.</p>
<p>钥匙可以被复制，手机可能被偷，锁可以撬开</p>
<p>Finally, what you are authentication is based on... you!</p>
<p>最后，"你是什么"这种验证，是基于你</p>
<p>You authenticate by presenting yourself to the computer.</p>
<p>把特征展示给计算机进行验证</p>
<p>Biometric authenticators, like fingerprint readers and iris scanners are classic examples.</p>
<p>生物识别验证器，比如指纹识别器和虹膜扫描仪就是典型例子</p>
<p>These can be very secure, but the best technologies are still quite expensive.</p>
<p>这些非常安全，但最好的识别技术仍然很贵</p>
<p>Furthermore, data from sensors varies over time.</p>
<p>而且，来自传感器的数据每次会不同</p>
<p>What you know and what you have authentication have the nice property of being deterministic</p>
<p>"你知道什么"和"你有什么"。这两种验证是"确定性"的</p>
<p>either correct or incorrect.</p>
<p>要么正确，要么错误</p>
<p>If you know the secret, or have the key, you’re granted access 100% of the time.</p>
<p>如果你知道密码，或有钥匙，那么100％能获得访问权限</p>
<p>If you don’t, you get access zero percent of the time.</p>
<p>如果没有，就绝对进不去</p>
<p>Biometric authentication, however, is probabilistic.There’s some chance the system won’t recognize you…</p>
<p>但"生物识别"是概率性的，系统有可能认不出你</p>
<p>maybe you’re wearing a hat or the lighting is bad.</p>
<p>可能你戴了帽子，或者光线不好</p>
<p>Worse, there’s some chance the system will recognize the wrong person as you</p>
<p>更糟的是，系统可能把别人错认成你</p>
<p>like your evil twin!</p>
<p>比如你的邪恶双胞胎</p>
<p>Of course, in production systems, these chances are low, but not zero.</p>
<p>当然，在现实世界中几率很低，但不是零</p>
<p>Another issue with biometric authentication is it can’t be reset.</p>
<p>生物认证的另一个问题是无法重设</p>
<p>You only have so many fingers, so what happens if an attacker compromises your fingerprint data?</p>
<p>你只有这么多手指，如果攻击者拿到你的指纹数据怎么办</p>
<p>This could be a big problem for life.</p>
<p>你一辈子都麻烦了</p>
<p>And, recently, researchers showed it’s possible to forge your iris</p>
<p>最近还有研究人员表示，拍个照都有可能伪造虹膜</p>
<p>just by capturing a photo of you, so that’s not promising either.</p>
<p>所以也不靠谱</p>
<p>Basically, all forms of authentication have strengths and weaknesses,</p>
<p>所有认证方法都有优缺点，</p>
<p>and all can be compromised in one way or another.</p>
<p>它们都可以被攻破</p>
<p>So, security experts suggest using two or more forms of authentication</p>
<p>所以，对于重要账户，</p>
<p>for important accounts.</p>
<p>安全专家建议用两种或两种以上的认证方式</p>
<p>This is known as two-factor or multi-factor authentication.</p>
<p>这叫"双因素"或"多因素"认证</p>
<p>An attacker may be able to guess your password or steal your phone:</p>
<p>攻击者可能猜出你密码，或偷走你的手机：</p>
<p>but it’s much harder to do both.</p>
<p>但两个都做到，会比较难</p>
<p>After authentication comes Access Control.</p>
<p>"身份验证"后，就来到了"访问控制"</p>
<p>Once a system knows who you are, it needs to know what you should be able to access,</p>
<p>一旦系统知道你是谁，它需要知道你能访问什么，</p>
<p>and for that there’s a specification of who should be able to see, modify and use what.</p>
<p>因此应该有个规范，说明谁能访问什么，修改什么，使用什么。</p>
<p>This is done through Permissions or Access Control Lists (ACL),</p>
<p>这可以通过"权限"或"访问控制列表"（ACL）来实现</p>
<p>which describe what access each user has for every file, folder and program on a computer.</p>
<p>其中描述了用户对每个文件，文件夹和程序的访问权限</p>
<p>"Read" permission allows a user to see the contents of a file,</p>
<p>"读"权限允许用户查看文件内容，</p>
<p>"write" permission allows a user to modify the contents,</p>
<p>"写"权限允许用户修改内容，</p>
<p>and "execute" permission allows a user to run a file, like a program.</p>
<p>"执行"权限允许用户运行文件，比如程序</p>
<p>For organizations with users at different levels of access privilege</p>
<p>有些组织需要不同层级的权限</p>
<p>like a spy agency – it’s especially important for Access Control Lists</p>
<p>比如间谍机构，"访问控制列表"的正确配置非常重要</p>
<p>to be configured correctly to ensure secrecy, integrity and availability.</p>
<p>以确保保密性，完整性和可用性</p>
<p>Let’s say we have three levels of access: public, secret and top secret.</p>
<p>假设我们有三个访问级别：公开，机密，绝密</p>
<p>The first general rule of thumb is that people shouldn’t be able to "read up".</p>
<p>第一个普遍的好做法是，用户不能"读上", 不能读等级更高的信息</p>
<p>If a user is only cleared to read secret files, they shouldn’t be able to read top secret</p>
<p>如果用户能读"机密"文件，那么不应该有权限读"绝密"文件</p>
<p>files, but should be able to access secret and public ones.</p>
<p>但能访问"机密"和"公开"文件</p>
<p>The second general rule of thumb is that people shouldn’t be able to "write down".</p>
<p>第二个法则是用户不能"写下"</p>
<p>If a member has top secret clearance, then they should be able to</p>
<p>如果用户等级是"绝密"</p>
<p>write or modify top secret files, but not secret or public files.</p>
<p>那么能写入或修改"绝密"文件，但不能修改"机密"或"公共"文件</p>
<p>It may seem weird that even with the highest clearance,</p>
<p>听起来好像很奇怪，</p>
<p>you can’t modify less secret files.</p>
<p>有最高等级也不能改等级更低的文件</p>
<p>But, it guarantees that there’s no accidental leakage of</p>
<p>但这样确保了"绝密"，</p>
<p>top secret information into secret or public files.</p>
<p>不会意外泄露到"机密"文件或"公共"文件里</p>
<p>This "no read up, no write down" approach is called the Bell-LaPadula model.</p>
<p>这个"不能向上读，不能向下写"的方法，叫 Bell-LaPadula 模型</p>
<p>It was formulated for the U.S. Department of Defense’s Multi-Level Security policy.</p>
<p>它是为美国国防部"多层安全政策"制定的</p>
<p>There are many other models for access control – like the Chinese Wall model and Biba model.</p>
<p>还有许多其他的访问控制模型比如"中国墙"模型和"比伯"模型</p>
<p>Which model is best depends on your use-case.</p>
<p>哪个模型最好，取决于具体情况</p>
<p>Authentication and access control help a computer determine who you are</p>
<p>"身份验证"和"访问控制"帮助计算机知道"你是谁"</p>
<p>and what you should access,</p>
<p>以及"你可以访问什么"，</p>
<p>but depend on being able to trust the hardware and software</p>
<p>但做这些事情的软硬件</p>
<p>that run the authentication and access control programs.</p>
<p>必须是可信的</p>
<p>That’s a big dependence.</p>
<p>这个依赖很重要</p>
<p>If an attacker installs malicious software – called malware</p>
<p>如果攻击者给计算机装了恶意软件</p>
<p>compromising the host computer’s operating system,</p>
<p>控制了计算机的操作系统</p>
<p>how can we be sure security programs don’t have a backdoor that let attackers in?</p>
<p>我们怎么确定安全程序没有给攻击者留后门？</p>
<p>The short answer is… we can’t.</p>
<p>短回答是...无法确定</p>
<p>We still have no way to guarantee the security of a program or computing system.</p>
<p>我们仍然无法保证程序或计算机系统的安全</p>
<p>That’s because even while security software might be "secure" in theory,</p>
<p>因为安全软件在理论上可能是"安全的"</p>
<p>implementation bugs can still result in vulnerabilities.</p>
<p>实现时可能会不小心留下漏洞</p>
<p>But, we do have techniques to reduce the likelihood of bugs,</p>
<p>但我们有办法减少漏洞出现的可能性</p>
<p>like quickly find and patch bugs when they do occur,</p>
<p>比如一找到就马上修复</p>
<p>and mitigate damage when a program is compromised.</p>
<p>以及当程序被攻破时尽可能减少损害</p>
<p>Most security errors come from implementation error.</p>
<p>大部分漏洞都是具体实现的时候出错了</p>
<p>To reduce implementation error, reduce implementation.</p>
<p>为了减少执行错误，减少执行</p>
<p>One of the holy grails of system level security is a "security kernel"</p>
<p>系统级安全的圣杯之一是"安全内核"</p>
<p>or a "trusted computing base": a minimal set of operating system software</p>
<p>或"可信计算基础"：一组尽可能少的操作系统软件</p>
<p>that’s close to provably secure.</p>
<p>安全性都是接近可验证的</p>
<p>A challenge in constructing these security kernels is deciding what should go into it.</p>
<p>构建安全内核的挑战在于决定内核应该有什么</p>
<p>Remember, the less code, the better!</p>
<p>记住，代码越少越好！</p>
<p>Even after minimizing code bloat, it would be great to "guarantee"</p>
<p>在最小化代码数量之后，</p>
<p>that’s code is written in secure.</p>
<p>要是能"保证"代码是安全的，会非常棒</p>
<p>Formally verifying the security of code is an active area of research.</p>
<p>正式验证代码的安全性是一个活跃的研究领域</p>
<p>The best we have right now is a process called Independent Verification and Validation.</p>
<p>我们现在最好的手段，叫"独立安全检查和质量验证"</p>
<p>This works by having code audited by a crowd of security-minded developers.</p>
<p>让一群安全行业内的软件开发者来审计代码</p>
<p>This is why security code is almost always open-sourced.</p>
<p>这就是为什么安全型代码几乎都是开源的</p>
<p>It’s often difficult for people who wrote the original code to find bugs,</p>
<p>写原始代码的人通常很难找到错误</p>
<p>but external developers, with fresh eyes and different expertise, can spot problems.</p>
<p>但外部开发人员有新鲜的眼光，和不同领域的专业知识，可以发现问题.</p>
<p>There are also conferences where like-minded hackers and security experts</p>
<p>另外还有一些安全大会，</p>
<p>can mingle and share ideas,</p>
<p>安全专家可以相互认识，分享想法.</p>
<p>the biggest of which is DEF CON, held annually in Las Vegas.</p>
<p>一年一次在拉斯维加斯举办的 DEF CON，是全球最大的安全大会</p>
<p>Finally, even after reducing code and auditing it,</p>
<p>最后，即便尽可能减少代码并进行了安全审计</p>
<p>clever attackers are bound to find tricks that let them in.</p>
<p>聪明的攻击者还是会找到方法入侵</p>
<p>With this in mind, good developers should take the approach that,</p>
<p>因为如此，优秀的开发人员</p>
<p>not if, but when their programs are compromised,</p>
<p>应该计划当程序被攻破后，如何限制损害，</p>
<p>the damage should be limited and contained,</p>
<p>控制损害的最大程度</p>
<p>and not let it compromise other things running on the computer.</p>
<p>并且不让它危害到计算机上其他东西</p>
<p>This principle is called isolation.</p>
<p>这叫"隔离"</p>
<p>To achieve isolation, we can "sandbox" applications.</p>
<p>要实现隔离，我们可以"沙盒"程序</p>
<p>This is like placing an angry kid in a sandbox; when the kid goes ballistic,</p>
<p>这好比把生气的小孩放在沙箱里，</p>
<p>they only destroy the sandcastle in their own box,</p>
<p>他们只能摧毁自己的沙堡，</p>
<p>but other kids in the playground continue having fun.</p>
<p>不会影响到其他孩子</p>
<p>Operating Systems attempt to sandbox applications</p>
<p>操作系统会把程序放到沙盒里</p>
<p>by giving each their own block of memory that others programs can’t touch.</p>
<p>方法是给每个程序独有的内存块，其他程序不能动</p>
<p>It’s also possible for a single computer to run multiple Virtual Machines, essentially</p>
<p>一台计算机可以运行多个虚拟机</p>
<p>simulated computers, that each live in their own sandbox.</p>
<p>虚拟机模拟计算机，每个虚拟机都在自己的沙箱里</p>
<p>If a program goes awry, worst case is that it crashes or</p>
<p>如果一个程序出错，最糟糕的情况是它自己崩溃</p>
<p>compromises only the virtual machine on which it’s running.</p>
<p>或者搞坏它处于的虚拟机</p>
<p>All other Virtual Machines running on the computer are isolated and unaffected.</p>
<p>计算机上其他虚拟机是隔离的，不受影响</p>
<p>Ok, that’s a broad overview of some key computer security topics.</p>
<p>好，一些重要安全概念的概览，我们到此就介绍完了</p>
<p>And I didn’t even get to network security, like firewalls.</p>
<p>我都还没讲网络安全，比如防火墙</p>
<p>Next episode, we’ll discuss some methods</p>
<p>下集我们会讨论</p>
<p>hackers use to get into computer systems.</p>
<p>黑客侵入系统的一些方法</p>
<p>After that, we’ll touch on encryption.</p>
<p>然后我们学加密</p>
<p>Until then, make your passwords stronger, turn on 2-factor authentication,</p>
<p>在此之前，别忘了加强你的密码，打开两步验证</p>
<p>and NEVER click links in unsolicited emails!</p>
<p>永远不要点可疑邮件</p>
<p>I’ll see you next week.</p>
<p>我们下周见</p>
<p>32 黑客&攻击</p>
<p>Hackers & Cyber Attacks</p>
<p>Hi, I’m Carrie Anne, and welcome to CrashCourse Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>Last episode, we talked about the basics of computer security,</p>
<p>上集我们讲了计算机安全的基础知识，</p>
<p>principles and techniques used to keep computer systems safe and sound.</p>
<p>包括各种原则和技术</p>
<p>But, despite our best efforts, the news is full of stories of individuals, companies</p>
<p>但尽管尽了最大努力，新闻上还是各种，个人，公司，</p>
<p>and governments getting cyberattacked by hackers, people who,</p>
<p>政府被黑客攻击的故事</p>
<p>with their technical knowledge, break into computer systems.</p>
<p>那些黑客凭技术知识闯入计算机系统</p>
<p>Not all hackers are bad though.</p>
<p>不是所有黑客都是坏人</p>
<p>There are hackers who hunt for bugs and try to close security holes</p>
<p>有些黑客会寻找并修复软件漏洞，</p>
<p>in software to make systems safer and more resilient.</p>
<p>让系统更安全</p>
<p>They’re often hired by companies and governments to perform security evaluations.</p>
<p>他们经常被公司和政府雇来做安全评估</p>
<p>These hackers are called White Hats, they’re the good guys.</p>
<p>这些黑客叫"白帽子"，他们是好人</p>
<p>On the flip side, there are Black Hats, malicious hackers with</p>
<p>另一方面，也有"黑帽"黑客，他们窃取，</p>
<p>intentions to steal, exploit and sell computer vulnerabilities and data.</p>
<p>利用和销售计算机漏洞和数据</p>
<p>Hackers’ motivations also differ wildly.</p>
<p>黑客的动机有很多种</p>
<p>Some hack for amusement and curiosity,</p>
<p>有些是好玩和好奇</p>
<p>while cybercriminals hack most often for monetary gain.</p>
<p>而网络罪犯一般是为了钱</p>
<p>And then there are hacktivists, who use their skills to promote a social or political goal.</p>
<p>还有的叫"黑客行动主义者"，通过黑客手段影响社会或达到政治目的</p>
<p>And that’s just the tip of the iceberg.</p>
<p>这只是冰山一角</p>
<p>Basically, the stereotypical view of a hacker as some unpopular kid sitting in a dark room</p>
<p>一般对黑客的刻板印象是，某个不受欢迎的小孩在黑暗的房间里</p>
<p>full of discarded pizza boxes probably better describes John Green in college than it does hackers.</p>
<p>到处都是吃完的比萨盒，这个印象是错的，形容约翰·格林的宿舍还更贴切些</p>
<p>Today, we’re not going to teach you how to be a hacker.</p>
<p>今天，我们不会教你如何成为黑客</p>
<p>Instead, we’ll discuss some classic examples of how hackers</p>
<p>而是讨论一些入侵原理，</p>
<p>break into computer systems to give you an idea of how it’s done.</p>
<p>给你一个大概概念</p>
<p>The most common way hackers get into computer systems isn’t</p>
<p>黑客入侵最常见的方式</p>
<p>by hacking at all; it’s by tricking users into letting them in.</p>
<p>不是通过技术，而是欺骗别人</p>
<p>This is called social engineering, where a person is manipulated into divulging confidential</p>
<p>这叫"社会工程学"，欺骗别人让人泄密信息</p>
<p>information, or configuring a computer system so that it permits entry by attackers.</p>
<p>或让别人配置电脑系统，变得易于攻击</p>
<p>The most common type of attack is phishing, which you most often encounter as an email</p>
<p>最常见的攻击是网络钓鱼，你可能见过</p>
<p>asking you to login to an account on a website, say your bank.</p>
<p>银行发邮件叫你点邮件里的链接，登陆账号</p>
<p>You’ll be asked to click a link in the email, which takes you to a site that looks legit</p>
<p>然后你会进入一个像官网的网站</p>
<p>to the casual observer, but is really an evil clone.</p>
<p>但实际上是个假网站</p>
<p>When you enter your username and password, that information goes straight to the hackers,</p>
<p>当你输入用户名和密码时，信息会发给黑客，</p>
<p>who then can login to the real website as you.</p>
<p>然后黑客就可以假扮你登陆网站</p>
<p>Bad news!</p>
<p>坏消息！</p>
<p>Even with a 1/10th of one percent success rate, a million phishing emails might yield</p>
<p>即使成功率只有1/1000，发一百万封钓鱼邮件</p>
<p>a thousand compromised accounts.</p>
<p>也有一千个帐户中招</p>
<p>Another social engineering attack is pretexting, where attackers call up, let's say a company,</p>
<p>另一种方法叫假托(Pretexting)，攻击者给某个公司打电话</p>
<p>and then confidently pretend to be from their IT department.</p>
<p>假装是IT部门的人</p>
<p>Often attackers will call a first number, and then ask to be transferred to a second,</p>
<p>攻击者的第一通电话一般会叫人转接</p>
<p>so that the phone number appears to be internal to the company.</p>
<p>这样另一个人接的时候，电话看起来像内部的</p>
<p>Then, the attacker can instruct an unwitting user to configure their computer in a compromising</p>
<p>然后让别人把电脑配置得容易入侵</p>
<p>way, or get them to reveal confidential details, like passwords or network configurations.</p>
<p>或让他们泄露机密信息，比如密码或网络配置</p>
<p>Sorry, one sec…</p>
<p>不好意思，等一下</p>
<p>Oh. Hey, it's Susan from It.</p>
<p>嘿，我是 IT 部门的苏珊</p>
<p>We’re having some network issues down here, can you go ahead and check a setting for me?"</p>
<p>我们遇到一些网络问题，你能帮我检查一个配置吗？</p>
<p>... and it begins.</p>
<p>然后就开始了</p>
<p>Attackers can be very convincing, especially with a little bit</p>
<p>只要预先做一点研究，攻击者可以装得很像真的</p>
<p>of research beforehand to find things like key employees’ names.</p>
<p>比如关键员工的名字</p>
<p>It might take ten phone calls to find an victim, but you only need one to get in.</p>
<p>也许要10通电话才能找到一个受害者，但只要一个人上当就够了</p>
<p>Emails are also a common delivery mechanism for trojan horses,</p>
<p>邮件里带"木马"也是常见手段</p>
<p>programs that masquerade as harmless attachments, like a photo or invoice,</p>
<p>木马会伪装成无害的东西，比如照片或发票</p>
<p>but actually contain malicious software, called malware.</p>
<p>但实际上是恶意软件</p>
<p>Malware can take many forms.</p>
<p>恶意软件有很多种</p>
<p>Some might steal your data, like your banking credentials.</p>
<p>有的会偷数据，比如银行凭证</p>
<p>Others might encrypt your files and demand a ransom, what's known as ransomware.</p>
<p>有的会加密文件，交赎金才解密，也就是"勒索软件"</p>
<p>If they can’t run malware or get a user to let them in,</p>
<p>如果攻击者无法用木马或电话欺骗</p>
<p>attackers have to force their way in through other means.</p>
<p>攻击者只能被迫用其他手段</p>
<p>One method, which we briefly discussed last episode, is to brute force a password</p>
<p>方法之一是暴力尝试，我们上集讨论过</p>
<p>try every combination of password until you gain entry.</p>
<p>尝试所有可能的密码，直到进入系统</p>
<p>Most modern systems defend against this type of attack by having you wait incrementally</p>
<p>大多数现代系统会加长等待时间，来抵御这种攻击</p>
<p>longer periods of time following each failed attempt,</p>
<p>每次失败就加长等待时间</p>
<p>or even lock you out entirely after a certain number of tries.</p>
<p>甚至失败超过一定次数后，完全锁住</p>
<p>One recent hack to get around this is called NAND Mirroring,</p>
<p>最近出现一种攻破方法叫 "NAND镜像"</p>
<p>where if you have physical access to the computer,</p>
<p>如果能物理接触到电脑</p>
<p>you can attach wires to the device's memory chip</p>
<p>可以往内存上接几根线</p>
<p>and make a perfect copy of its contents.</p>
<p>复制整个内存</p>
<p>With this setup, you can try a series of passwords, until the device starts making you wait.</p>
<p>复制之后，暴力尝试密码，直到设备让你等待</p>
<p>When this happens, you just reflash the memory with the original copy you made,</p>
<p>这时只要把复制的内容覆盖掉内存</p>
<p>essentially resetting it, allowing you to try more passwords immediately, with no waiting.</p>
<p>本质上重置了内存，就不用等待，可以继续尝试密码了</p>
<p>This technique was shown to be successful on an iPhone 5C,</p>
<p>这项方法在 iPhone 5C 上管用</p>
<p>but many newer devices include mechanisms to thwart this type of attack.</p>
<p>更新的设备有机制阻止这种攻击</p>
<p>If you don’t have physical access to a device,</p>
<p>如果你无法物理接触到设备</p>
<p>you have to find a way to hack it remotely, like over the internet.</p>
<p>就必须远程攻击，比如通过互联网.</p>
<p>In general, this requires an attacker to find and take advantage of a bug in a system, and</p>
<p>远程攻击一般需要攻击者利用系统漏洞</p>
<p>successfully utilizing a bug to gain capabilities or access is called an exploit.</p>
<p>来获得某些能力或访问权限，这叫"漏洞利用"(Exploit)</p>
<p>One common type of exploit is a buffer overflow.</p>
<p>一种常见的漏洞利用叫"缓冲区溢出"</p>
<p>Buffers are a general term for a block of memory reserved for storing data.</p>
<p>"缓冲区"是一种概称，指预留的一块内存空间</p>
<p>We talked about video buffers for storing pixel data in Episode 23.</p>
<p>我们在第23集，讨论过存像素数据的视频缓冲区</p>
<p>As a simple example, we can imagine an operating system’s login prompt,</p>
<p>举个简单例子，假设我们在系统登陆界面</p>
<p>which has fields for a username and password.</p>
<p>要输入用户名和密码</p>
<p>Behind the scenes, this operating system uses buffers for storing the text values that are entered.</p>
<p>在幕后，系统用缓冲区存输入的值</p>
<p>For illustration, let's say these buffers were specified to be of size ten.</p>
<p>假设缓冲区大小是10</p>
<p>In memory, the two text buffers would look something like this:</p>
<p>两个文本缓冲区看起来会像这样：</p>
<p>Of course, the operating system is keeping track of a lot more than just a username and</p>
<p>当然，操作系统记录的远不止用户名和密码</p>
<p>password, so there’s going to be data stored both before and after in memory.</p>
<p>所以缓冲区前后肯定有其他数据</p>
<p>When a user enters a username and password, the values are copied into the buffers,</p>
<p>当用户输入用户名和密码时，这些值会复制到缓冲区</p>
<p>where they can be verified.</p>
<p>然后验证是否正确</p>
<p>A buffer overflow attack does exactly what the name suggests: overflows the buffer.</p>
<p>"缓冲区溢出"正如名字所暗示的：它会溢出缓冲区</p>
<p>In this case, any password longer than ten characters</p>
<p>在这个例子中，超过十个字符的密码</p>
<p>will overwrite adjacent data in memory.</p>
<p>会覆盖掉相邻的数据</p>
<p>Sometimes this will just cause a program or operating system to crash,</p>
<p>有时只会让程序或系统崩溃，</p>
<p>because important values are overwritten with gobbledygook.</p>
<p>因为重要值被垃圾数据覆盖了</p>
<p>Crashing a system is bad, and maybe that’s all that</p>
<p>系统崩溃是坏事</p>
<p>a mischievous hacker wants to do, be a nuisance.</p>
<p>但也许恶作剧黑客就只是想系统崩溃，当个讨厌鬼</p>
<p>But attackers can also exploit this bug more cleverly by injecting purposeful new values</p>
<p>但攻击者可以更巧妙地利用这个漏洞(bug)，注入有意义的新值</p>
<p>into a program’s memory, for example, setting an "is admin" variable to true.</p>
<p>到程序的内存中，比如把"is_admin"的值改成true</p>
<p>With the ability to arbitrarily manipulate a program’s memory,</p>
<p>有了任意修改内存的能力，</p>
<p>hackers can bypass things like login prompts,</p>
<p>黑客可以绕过"登录"之类的东西，</p>
<p>and sometimes even use that program to hijack the whole system.</p>
<p>甚至使用那个程序劫持整个系统</p>
<p>There are many methods to combat buffer overflow attacks.</p>
<p>有很多方法阻止缓冲区溢出</p>
<p>The easiest is to always test the length of input before copying it into a buffer,</p>
<p>最简单的方法是，复制之前先检查长度，</p>
<p>called bounds checking.</p>
<p>这叫 "边界检查"</p>
<p>Many modern programming languages implement bounds checking automatically.</p>
<p>许多现代编程语言自带了边界检查</p>
<p>Programs can also randomize the memory location of variables,</p>
<p>程序也会随机存放变量在内存中的位置，</p>
<p>like our hypothetical "is admin" flag,</p>
<p>比如我们之前假设的"is_admin"</p>
<p>so that hackers don’t know what memory location to overwrite,</p>
<p>这样黑客就不知道应该覆盖内存的哪里</p>
<p>and are more likely to crash the program than gain access.</p>
<p>导致更容易让程序崩溃，而不是获得访问权限</p>
<p>Programs can also leave unused space after buffers,</p>
<p>程序也可以在缓冲区后，留一些不用的空间</p>
<p>and keep an eye on those values to see if they change;</p>
<p>然后跟踪里面的值，看是否发生变化</p>
<p>if they do, they know an attacker is monkeying around with memory.</p>
<p>如果发生了变化，说明有攻击者在乱来</p>
<p>These regions are called canaries, named after the small birds miners</p>
<p>这些不用的内存空间叫"金丝雀"，因为以前矿工会带</p>
<p>used to take underground to warn them of dangerous conditions.</p>
<p>金丝雀下矿，金丝雀会警告危险</p>
<p>Another classic hack is code injection.</p>
<p>另一种经典手段叫"代码注入"</p>
<p>It’s most commonly used to attack websites that use databases,</p>
<p>最常用于攻击用数据库的网站，</p>
<p>which pretty much all big websites do.</p>
<p>几乎所有大网站都用数据库</p>
<p>We won’t be covering databases in this series,</p>
<p>我们这个系列中不会讲解数据库，</p>
<p>so here’s a simple example to illustrate this type of attack.</p>
<p>所以以下是个简单例子</p>
<p>We’ll use Structured Query Language, S-Q-L, also called sequel, a popular database API.</p>
<p>我们会用"结构化查询语言"，也叫SQL，一种流行的数据库API</p>
<p>Let’s imagine our login prompt is now running on a webpage.</p>
<p>假设网页上有登录提示</p>
<p>When a user clicks "login", the text values are sent to a server, which executes code</p>
<p>当用户点击"登录"时，值会发到服务器</p>
<p>that checks if that username exists, and if it does, verifies the password matches.</p>
<p>服务器会运行代码，检查用户名是否存在，如果存在，看密码是否匹配</p>
<p>To do this, the server will execute code, known as a SQL query,</p>
<p>为了做检查，服务器会执行一段叫 "SQL查询" 的代码</p>
<p>that looks something like this.</p>
<p>看起来像这样</p>
<p>First, it needs to specify what data we’re retrieving from the database.</p>
<p>首先，语句要指定从数据库里查什么数据</p>
<p>In this case, we want to fetch the password.</p>
<p>在这个例子中，我们想查的是密码 (password) ，(SELECT password)</p>
<p>The server also needs to specify from what place in the database</p>
<p>还要指定从哪张表查数据，(FROM users)</p>
<p>to retrieve the value from.</p>
<p>还要指定从哪张表查数据，(FROM users)</p>
<p>In this case, let’s imagine all the users’ data is stored</p>
<p>在这个例子里，我们假设所有用户数据</p>
<p>in a data structure called a table labeled "users".</p>
<p>都存在 "users" 表里</p>
<p>Finally, the server doesn’t want to get back a giant list of passwords for every user</p>
<p>最后，服务器不想每次取出一个巨大密码列表，包含所有用户密码</p>
<p>in the database, so it specifies that it only wants data for the account</p>
<p>所以用 username = '用户名'，</p>
<p>whose username equals a certain value.</p>
<p>代表只要这个用户</p>
<p>That value is copied into the SQL query by the server, based on what the user typed in,</p>
<p>用户输的值会复制到"SQL查询"</p>
<p>so the actual command that’s sent to the SQL database would look something like this,</p>
<p>所以实际发到 SQL 数据库的命令，是这样的.</p>
<p>where username='philbin'</p>
<p>Where username='philbin'</p>
<p>Note also that SQL commands end with a semicolon.</p>
<p>还要注意，SQL命令以分号结尾</p>
<p>So how does someone hack this?</p>
<p>那怎么破解这个？</p>
<p>By sending in a malicious username, with embedded SQL commands!</p>
<p>做法是把"SQL命令"输入到用户名里！</p>
<p>Like, we could send the server this funky username:</p>
<p>比如我们可以发这个奇怪的用户名：</p>
<p>When the server copies this text into the SQL Query, it ends up looking like this:</p>
<p>当服务器把值复制到SQL查询中，会变成这样：</p>
<p>As I mentioned before, semicolons are used to separate commands,</p>
<p>正如之前提的，分号用于分隔命令，</p>
<p>so the first command that gets executed is this:</p>
<p>所以第一条被执行的命令是：</p>
<p>If there is a user named ‘whatever’, the database will return the password.</p>
<p>如果有个用户叫"whateer"，数据库将返回密码</p>
<p>Of course, we have no idea what ‘whatever’s’ password is,</p>
<p>当然，我们不知道密码是什么</p>
<p>so we’ll get it wrong and the server will reject us.</p>
<p>所以会出错，服务器会拒绝我们</p>
<p>If there’s no user named ‘whatever’, the database will return</p>
<p>如果没有一个用户叫"whatever"，数据库会返回，</p>
<p>no password or provide an error, and the server will again reject us.</p>
<p>空密码或直接错误，服务器也会拒绝我们</p>
<p>Either way, we don’t care, because it’s the next SQL command we’re interested in:</p>
<p>总之我们不在乎，我们感兴趣的是下一个SQL命令：</p>
<p>"drop table users" – a command that we injected by manipulating the username field.</p>
<p>"drop table users" 我们注入的命令</p>
<p>This command instructs the SQL database to delete the table containing all user data.</p>
<p>这条命令的意思是删掉 users 这张表</p>
<p>Wiped clean!</p>
<p>全删干净！</p>
<p>Which would cause a lot of headaches at a place like a bank... or really anywhere.</p>
<p>这会造成很多麻烦，不管是银行或什么其他地方</p>
<p>And notice that we didn’t even break into the system –</p>
<p>注意，我们甚至不需要侵入系统</p>
<p>it’s not like we correctly guessed a username and password.</p>
<p>我们没有猜到正确的用户名和密码</p>
<p>Even with no formal access, we were able to create mayhem by exploiting a bug.</p>
<p>即使没有正式访问权限，还是可以利用 bug 来制造混乱</p>
<p>This is a very simple example of code injection,</p>
<p>这是代码注入的一个简单例子，</p>
<p>which almost all servers today have defenses against.</p>
<p>如今几乎所有服务器都会防御这种手段</p>
<p>With more sophisticated attacks, it’s possible to add records to the database</p>
<p>如果指令更复杂一些，也许可以添加新记录到数据库</p>
<p>like a new administrator account –</p>
<p>比如一个新管理员帐户 -</p>
<p>or even get the database to reveal data, allowing hackers</p>
<p>甚至可以让数据库泄露数据，使得黑客</p>
<p>to steal things like credit card numbers, social security numbers</p>
<p>窃取信用卡号码，社会安全号码</p>
<p>and all sorts of nefarious goodies.</p>
<p>以及各种其他信息</p>
<p>But we’re not going to teach you how to do that.</p>
<p>但我们不会教你具体怎么做</p>
<p>As with buffer overflows, programmers should always assume input coming from the outside</p>
<p>就像缓冲区溢出攻击一样，应该总是假设外部数据</p>
<p>to be potentially dangerous, and examine it carefully.</p>
<p>是危险的，应该好好检查</p>
<p>Most username and password forms on the web don’t let you</p>
<p>很多用户名和密码表单，不让你输入</p>
<p>include special symbols like semicolons or quotes as a first level of defense.</p>
<p>特殊字符，比如分号或者括号，作为第一道防御</p>
<p>Good servers also sanitize input by removing or</p>
<p>好的服务器也会清理输入</p>
<p>modifying special characters before running database queries.</p>
<p>比如修改或删除特殊字符，然后才放到数据库查询语句里</p>
<p>Working exploits are often sold or shared online.</p>
<p>管用的漏洞利用(Exploits)一般会在网上贩卖或分享</p>
<p>The more prevalent the bug, or the more damaging the exploit,</p>
<p>如果漏洞很流行，或造成的危害很大</p>
<p>the higher the price or prestige it commands.</p>
<p>价格会越高，或者名气越大</p>
<p>Even governments sometimes buy exploits,</p>
<p>有时甚至政府也会买漏洞利用</p>
<p>which allow them to compromise computers for purposes like spying.</p>
<p>让他们侵入系统做间谍工作</p>
<p>When a new exploitable bug is discovered that the software creators weren’t aware of,</p>
<p>当软件制造者不知道软件有新漏洞被发现了</p>
<p>it’s called a zero day vulnerability.</p>
<p>那么这个漏洞叫 "零日漏洞"</p>
<p>Black Hat Hackers rush to use the exploit for maximum benefit</p>
<p>黑帽黑客经常赶时间，抢在白帽程序员做出补丁之前</p>
<p>before white hat programmers release a patch for the bug.</p>
<p>尽可能利用漏洞</p>
<p>This is why it’s so important to keep your computer’s software up to date;</p>
<p>所以保持系统更新非常重要</p>
<p>a lot of those downloads are security patches.</p>
<p>很多更新都是安全性补丁</p>
<p>If bugs are left open on enough systems, it allows hackers to</p>
<p>如果有足够多的电脑有漏洞</p>
<p>write a program that jump from computer to computer automatically</p>
<p>让恶意程序可以在电脑间互相传播</p>
<p>which are called worms.</p>
<p>那么叫"蠕虫"</p>
<p>If a hacker can take over a large number of computers, they can be used together,</p>
<p>如果黑客拿下大量电脑，这些电脑可以组成</p>
<p>to form what’s called a botnet.</p>
<p>"僵尸网络"</p>
<p>This can have many purposes, like sending huge volumes of spam,</p>
<p>可以用于很多目的，比如发大量垃圾邮件，</p>
<p>mining bitcoins using other people's computing power and electricity,</p>
<p>用别人电脑的计算能力和电费挖 Bitcoin，</p>
<p>and launching Distributed Denial of Service or DDoS attacks against servers.</p>
<p>或发起"拒绝服务攻击"简称DDoS，攻击服务器</p>
<p>DDoS is where all the computers in the botnet send a flood of dummy messages.</p>
<p>DDoS 就是僵尸网络里的所有电脑发一大堆垃圾信息</p>
<p>This can knock services offline, either to force owners</p>
<p>堵塞服务器，要么迫使别人交钱消灾</p>
<p>to pay a ransom or just to be evil.</p>
<p>或纯粹为了作恶</p>
<p>Despite all of the hard working white hats, exploits documented online,</p>
<p>尽管白帽黑客非常努力工作，漏洞利用的文档都在网上，</p>
<p>and software engineering best practices, cyberattacks happen on a daily basis.</p>
<p>编写软件有很多"最佳实践"，网络攻击每天都在发生</p>
<p>They cost the global economy roughly half a trillion dollars annually,</p>
<p>每年损害全球经济差不多5000亿</p>
<p>and that figure will only increase as we become more reliant on computing systems.</p>
<p>并且随着我们越来越依赖计算机系统，这个数字只会增加.</p>
<p>This is especially worrying to governments, as infrastructure is increasingly computer-driven,</p>
<p>这使得政府非常担心，因为基础设施越来越电脑化</p>
<p>like powerplants, the electrical grid, traffic lights, water treatment plants, oil refineries,</p>
<p>比如电力厂，电网，交通灯，水处理厂，炼油厂</p>
<p>air traffic control, and lots of other key systems.</p>
<p>空管，还有很多其他关键系统</p>
<p>Many experts predict that the next major war will be fought in cyberspace,</p>
<p>很多专家预测下一次大战会主要是网络战争</p>
<p>where nations are brought to their knees not by physical attack,</p>
<p>国家不是被物理攻击打败</p>
<p>but rather crippled economically and infrastructurally through cyberwarfare.</p>
<p>而是因为网络战争导致经济和基础设施崩溃</p>
<p>There may not be any bullets fired, but the potential for lives lost is still very high...</p>
<p>也许不会发射一颗子弹，但是人员伤亡的可能性依然很高</p>
<p>maybe even higher than conventional warfare.</p>
<p>甚至可能高于传统战争</p>
<p>So, we should all adopt good cybersecurity practices.</p>
<p>所以大家都应该知道一些方法保证网络安全</p>
<p>And, as a community interconnected over the internet,</p>
<p>全球社区因为互联网而互相连接，</p>
<p>we should ensure our computers are secured against those</p>
<p>我们应该确保自己的电脑安全</p>
<p>who wish to use their great potential for harm.</p>
<p>抵御其他想做坏事的人</p>
<p>So maybe stop ignoring that update notification?</p>
<p>也许不要再忽略更新提示？</p>
<p>I’ll see you next week.</p>
<p>我们下周见</p>
<p>33 加密</p>
<p>Cryptography</p>
<p>Hi, I'm Carrie Anne, and welcome to CrashCourse Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>Over the past two episodes, we’ve talked a lot about computer security.</p>
<p>在过去两集，我们聊了很多计算机安全话题</p>
<p>But the fact is, there’s no such thing as a perfectly, 100% secure, computer system.</p>
<p>但事实是世上不存在100%安全的系统</p>
<p>There will always be bugs and security experts know that.</p>
<p>总会有漏洞存在，而且安全专家知道这一点</p>
<p>So system architects employ a strategy called defence in depth</p>
<p>所以系统架构师会部署"多层防御"</p>
<p>which uses many layers of varying security mechanisms to frustrate attackers.</p>
<p>用多层不同的安全机制来阻碍攻击者</p>
<p>It’s a bit like how castles are designed</p>
<p>有点像城堡的设计一样</p>
<p>first you’ve got to dodge the archers</p>
<p>首先要避开弓箭手</p>
<p>then cross the moat, scale the walls, avoid the hot oil, get over the ramparts, and defeat the guards</p>
<p>穿过护城河,翻过城墙,避开热油,打败守卫</p>
<p>before you get to the throne room</p>
<p>才能达到王座</p>
<p>but in this case we’re talking about one of the most common forms of computer security</p>
<p>不过我们这里要说的是，计算机安全中最常见的防御形式</p>
<p>Cryptography</p>
<p>密码学</p>
<p>The word cryptography comes from the roots ‘crypto’ and ‘graphy’, roughly translating to "secret writing".</p>
<p>密码学(cryptography) 一词，来自 crypto 和 graphy，大致翻译成"秘密写作"</p>
<p>In order to make information secret, you use a cipher – an algorithm that converts plain text into ciphertext</p>
<p>为了加密信息，要用加密算法(Cipher) 把明文转为密文</p>
<p>which is gibberish unless you have a key that lets you undo the cipher.</p>
<p>除非你知道如何解密，不然密文看起来只是一堆乱码</p>
<p>The process of making text secret is called encryption</p>
<p>把明文转成密文叫"加密"(encryption)</p>
<p>and the reverse process is called decryption</p>
<p>把密文恢复回明文叫"解密"(decryption)</p>
<p>Ciphers have been used long before computers showed up.</p>
<p>加密算法早在计算机出现前就有了</p>
<p>Julius Caesar used what’s now called a Caesar cipher, to encrypt private correspondence.</p>
<p>朱利叶斯·凯撒用如今我们叫"凯撒加密"的方法来加密私人信件</p>
<p>He would shift the letters in a message forward by three places.</p>
<p>他会把信件中的字母向前移动三个位置</p>
<p>So, A became D, and the word "brutus" became this: "euxwxv".</p>
<p>所以A会变成D，brutus变成euxwxv</p>
<p>To decipher the message, recipients had to know both the algorithm and the number to shift by, which acted as the key.</p>
<p>为了解密，接收者要知道，1 用了什么算法 2 要偏移的字母位数</p>
<p>The Caesar cipher is one example of a larger class of techniques called substitution ciphers.</p>
<p>有一大类算法叫"替换加密"，凯撒密码是其中一种</p>
<p>These replace every letter in a message with，something else according to a translation.</p>
<p>算法把每个字母替换成其他字母</p>
<p>A big drawback of basic substitution ciphers is that letter frequencies are preserved.</p>
<p>但有个巨大的缺点是，字母的出现频率是一样的</p>
<p>For example, E is the most common letter in English</p>
<p>举个例子，E在英语中是最常见的字母</p>
<p>so if your cipher translates E to an X</p>
<p>如果把E加密成X</p>
<p>then X will show up the most frequently in the ciphertext.</p>
<p>那么密文中 X 的出现频率会很高</p>
<p>A skilled cryptanalyst can work backwards from these kinds of statistics to figure out the message.</p>
<p>熟练的密码破译师可以从统计数据中发现规律，进而破译密码</p>
<p>Indeed, it was the breaking of a substitution cipher that led to the execution of Mary Queen of Scots,in 1587 for plotting to kill Queen Elizabeth.</p>
<p>1587年，正因为一个"替换加密"的密文被破译，导致杀伊丽莎白女王的阴谋暴露，使得玛丽女王被处决</p>
<p>Another fundamental class of techniques are permutation ciphers.</p>
<p>另一类加密算法叫 "移位加密"</p>
<p>Let’s look at a simple example, called a columnar transposition cipher.</p>
<p>我们来看一个简单例子叫 "列移位加密"</p>
<p>Here, we take a message, and fill the letters into a grid.</p>
<p>我们把明文填入网格</p>
<p>In this case, we’ve chosen 5 by 5</p>
<p>网格大小我们这里选择 5x5</p>
<p>To encrypt our message, we read out the characters in a different order</p>
<p>为了加密信息，我们换个顺序来读</p>
<p>let’s say from the bottom left, working upwards, one column at a time.</p>
<p>比如从左边开始，从下往上，一次一列。</p>
<p>The new letter ordering, what’s called a permutation, is the encrypted message.</p>
<p>加密后字母的排列不同了</p>
<p>The ordering direction, as well as the 5 by 5 grid size, serves as the key.</p>
<p>解密的关键是，知道读取方向和网格大小是5x5</p>
<p>Like before, if the cipher and key are known, a recipient can reverse the process to reveal the original message.</p>
<p>就像之前，如果接收者知道密文和加密方法，才能解密得到原始消息</p>
<p>By the 1900s, cryptography was mechanized in the form of encryption machines.</p>
<p>到了1900年代，人们用密码学做了加密机器</p>
<p>The most famous was the German Enigma, used by the Nazis to encrypt their wartime communications.</p>
<p>其中最有名的是德国的英格玛（Enigma），纳粹在战时用英格玛加密通讯信息</p>
<p>As we discussed back in Episode 15, the Enigma was a typewriter-like machine, with a keyboard and lampboard, both showing the full alphabet.</p>
<p>正如第15集中说过，Enigma 是一台像打字机的机器，有键盘和灯板，两者都有完整的字母表</p>
<p>Above that, there was a series of configurable rotors that were the key to the Enigma’s encryption capability.</p>
<p>而且它有一系列"转子"(rotros) ，是加密的关键</p>
<p>First, let’s look at just one rotor.</p>
<p>首先，我们只看一个转子</p>
<p>One side had electrical contacts for all 26 letters.</p>
<p>它一面有26个接触点，代表26个字母</p>
<p>These connected to the other side of the rotor using cross-crossing wires that swapped one letter for another.</p>
<p>然后线会连到另一面，替换字母</p>
<p>If ‘H’ went in, ‘K’ might come out the other side.</p>
<p>如果输入'H'，'K'会从另一边出来</p>
<p>If "K’ went in, ‘F’ might come out, and so on.</p>
<p>如果输入'K'，'F'会从另一边出来，以此类推</p>
<p>This letter swapping behavior should sound familiar: it’s a substitution cipher!</p>
<p>这个字母替换过程你应该听起来很熟悉：它是"替换加密"!</p>
<p>But, the Enigma was more sophisticated becauseit used three or more rotors in a row, each feeding into the next.</p>
<p>但英格玛(Enigma)更复杂一些，因为它有3个或更多转子，一个转子的输出作为下一个转子的输入。</p>
<p>Rotors could also be rotated to one of 26 possible starting positions</p>
<p>转子还有26个起始位置</p>
<p>and they could be inserted in different orders, providinga lot of different substitution mappings.</p>
<p>还可以按不同顺序放入转子，提供更多字母替换映射</p>
<p>Following the rotors was a special circuit called a reflector.</p>
<p>转子之后是一个叫"反射器"的特殊电路</p>
<p>Instead of passing the signal on to another rotor, it connected every pin to another,</p>
<p>它每个引脚会连到另一个引脚</p>
<p>and sent the electrical signal back through the rotors.</p>
<p>并把信号发回给转子</p>
<p>Finally, there was a plug board at the front of the machine</p>
<p>最后，机器前方有一个插板</p>
<p>that allowed letters coming from the keyboard to be optionally swapped,</p>
<p>可以把输入键盘的字母预先进行替换</p>
<p>adding another level of complexity.</p>
<p>又加了一层复杂度</p>
<p>With our simplified circuit, let’s encrypta letter on this example enigma configuration.</p>
<p>让我们用这里的简化版电路，加密一些字母</p>
<p>If we press the ‘H’ key, electricity flows through the plugboard, then the rotors</p>
<p>如果我们按下"H"键，电流会先通过插板，然后通过转子</p>
<p>hits the reflector, comes back through the rotorsand plugboard, and illuminates the letter ‘L’ on the lampboard.</p>
<p>到达反射器，然后回来转子，回来插板，并照亮键盘灯板的字母"L"。</p>
<p>So H is encrypted to L.</p>
<p>H 就加密成了 L</p>
<p>Note that the circuit can flow both ways –</p>
<p>注意, 电路是双向的</p>
<p>so if we typed the letter ‘L’, ‘H’ would light up.</p>
<p>所以如果我们按下 L，H 会亮起来</p>
<p>In other words, it’s the same process for encrypting and decrypting;</p>
<p>换句话说，加密和解密的步骤是一样的</p>
<p>you just have to make sure the sending and receiving machineshave the same initial configuration.</p>
<p>你只需要确保发送机和接收机的初始配置一样就行</p>
<p>If you look carefully at this circuit, you’ll notice it’s impossible for a letter to be encrypted as itself</p>
<p>如果你有仔细观察，会注意到字母加密后一定会变成另一个字母</p>
<p>which turned out to be a fatal cryptographic weakness.</p>
<p>之后这成为最大的弱点</p>
<p>Finally, to prevent the Enigma from being a simple substitution cipher</p>
<p>最后，为了让英格玛不只是简单的"替换加密"</p>
<p>every single time a letter was entered, the rotors advanced by one spot, sort of like an odometer in a car.</p>
<p>每输入一个字母，转子会转一格，有点像汽车里程表。</p>
<p>So if you entered the text A-A-A, it might come out as B-D-K, where the substitution mapping changed with every key press.</p>
<p>如果你输入A-A-A，可能会变成B-D-K，映射会随着每次按键而改变</p>
<p>The Enigma was a tough cookie to crack, for sure.</p>
<p>英格玛当然是一块难啃的骨头</p>
<p>But as we discussed in Episode 15, Alan Turingand and his colleagues</p>
<p>但正如我们第15集中说的，艾伦·图灵和同事</p>
<p>at Bletchley Park were able to break Enigma codes and largely automate the process.</p>
<p>破解了英格玛加密，并把大部分破解流程做成了自动化</p>
<p>But with the advent of computers, cryptography moved from hardware into software.</p>
<p>但随着计算机出现，加密从硬件转往软件</p>
<p>One of the earliest software ciphers to become widespread</p>
<p>早期加密算法中，应用最广泛的</p>
<p>was the Data Encryption Standard developed by IBM and the NSA in 1977</p>
<p>是 IBM 和 NSA 于1977年开发的"数据加密标准"</p>
<p>DES, as it was known, originally used binary keys that were 56 bits long,</p>
<p>DES最初用的是56 bit长度的二进制密钥，</p>
<p>which means that there are 2 to the 56, or about 72 quadrillion different keys.</p>
<p>意味着有2的56次方，或大约72千万亿个不同密钥</p>
<p>Back in 1977, that meant that nobody – except perhaps the NSA –</p>
<p>在1977年时，也许 NSA 有这能力，</p>
<p>had enough computing power to brute-force all possible keys.</p>
<p>但没有其他人有足够计算能力来暴力破解所有可能密钥。</p>
<p>But, by 1999, a quarter-million dollar computer could try every possible DES key in just two days, rendering the cipher insecure.</p>
<p>但到1999年，一台25万美元的计算机能在两天内，把 DES 的所有可能密钥都试一遍，让 DES 算法不再安全</p>
<p>So, in 2001, the Advanced Encryption Standard(AES) was finalized and published.</p>
<p>因此 2001 年出了：高级加密标准（AES）</p>
<p>AES is designed to use much bigger keys – 128,192 or 256 bits in size – making brute force attacks much, much harder.</p>
<p>AES 用更长的密钥 128位/192位/256位让暴力破解更加困难</p>
<p>For a 128-bit keys, you'd need trillions of years to try every combination, even if you used every single computer on the planet today.</p>
<p>128位的密钥，哪怕用现在地球上的所有计算机，也要上万亿年才能试遍所有组合</p>
<p>So you better get started!</p>
<p>你最好赶紧开始!</p>
<p>AES chops data up into 16-byte blocks, and then applies a series of substitutions and permutations,</p>
<p>AES将数据切成一块一块，每块16个字节，然后用密钥进行一系列替换加密和移位加密</p>
<p>based on the key value plus some other operations to obscure the message,</p>
<p>再加上一些其他操作，进一步加密信息</p>
<p>and this process is repeated ten or more times for each block.</p>
<p>每一块数据，会重复这个过程10次或以上</p>
<p>You might be wondering: why only ten rounds?</p>
<p>你可能想知道：为什么只重复10次？</p>
<p>Or why only 128 bit keys, and not ten thousand bit keys?</p>
<p>为什么用128位密钥，而不是10000位？</p>
<p>Well, it’s a performance tradeoff.</p>
<p>这其实是基于性能的权衡</p>
<p>If it took hours to encrypt and send an email,or minutes to connect to a secure website, people wouldn't use it</p>
<p>如果要花几小时加密和发邮件，或几分钟载入网站，没人愿意用</p>
<p>AES balances performance and security to provide practical cryptography.</p>
<p>AES 在性能和安全性间取得平衡</p>
<p>Today, AES is used everywhere, from encrypting files on iPhones</p>
<p>如今AES被广泛使用，比如iPhone上加密文件</p>
<p>and transmitting data over WiFi with WPA2 to accessing websites using HTTPS.</p>
<p>用 WPA2 协议在 WiFi 中访问 HTTPS 网站</p>
<p>So far, the cryptographic techniques we’ve discussed rely on keys that are known by both sender and recipient.</p>
<p>到目前为止我们讨论过的加密技术，依赖于发送者和接收者都知道密钥</p>
<p>The sender encrypts a message using a key, and the recipient decrypts it using the same key.</p>
<p>发件人用密钥加密，收件人用相同的密钥解密</p>
<p>In the old days, keys would be shared by voice, or physically;</p>
<p>以前，密钥可以口头约定，或依靠物品</p>
<p>for example, the Germans distributed codebooks with daily settings for their Enigma machines.</p>
<p>比如德国人给英格玛配了密码本，上面有每天的配置</p>
<p>But this strategy could never work in the internet era.</p>
<p>但互联网时代没法这样做</p>
<p>Imagine having to crack open a codebook to connect to youtube</p>
<p>你能想象要打开密码本才能访问 YouTube 吗？</p>
<p>What’s needed is a way for a server to send a secret key over the public internet to a user wishing to connect securely.</p>
<p>我们需要某种方法在公开的互联网上传递密钥给对方</p>
<p>It seems like that wouldn’t be secure, because if the key is sent in the open and intercepted by a hacker</p>
<p>这看起来好像不安全，如果密钥被黑客拦截了</p>
<p>couldn’t they use that to decrypt all communication between the two?</p>
<p>黑客不就能解密通信了吗？</p>
<p>The solution is key exchange!</p>
<p>解决方案是 "密钥交换"！</p>
<p>An algorithm that lets two computers agreeon a key without ever sending one.</p>
<p>密钥交换是一种不发送密钥，但依然让两台计算机在密钥上达成共识的算法</p>
<p>We can do this with one-way functions –</p>
<p>我们可以用"单向函数"来做</p>
<p>mathematical operations that are very easy to do in one direction, but hard to reverse.</p>
<p>单项函数是一种数学操作，很容易算出结果，但想从结果逆向推算出输入非常困难</p>
<p>To show you how one-way functions work, let’ s use paint colors as an analogy.</p>
<p>为了让你明白单项函数，我们拿颜色作比喻</p>
<p>It’s easy to mix paint colors together, but it’s not so easy to figure</p>
<p>将颜色混合在一起很容易，</p>
<p>out the constituent colors that were used to make a mixed paint color.</p>
<p>但想知道混了什么颜色很难</p>
<p>You’d have to test a lot of possibilities to figure it out.</p>
<p>要试很多种可能才知道</p>
<p>In this metaphor, our secret key is a unique shade of paint.</p>
<p>用这个比喻，那么我们的密钥是一种独特的颜色</p>
<p>First, there’s a public paint color that everyone can see.</p>
<p>首先，有一个公开的颜色，所有人都可以看到</p>
<p>Then, John and I each pick a secret paint color.</p>
<p>然后，约翰和我各自选一个秘密颜色，只有自己知道.</p>
<p>To exchange keys, I mix my secret paint color with the public paint color.</p>
<p>为了交换密钥，我把我的秘密颜色和 公开颜色混在一起</p>
<p>Then, I send that mixed color to John by anymeans – mail, carrier pigeon, whatever.</p>
<p>然后发给约翰，可以写信发，用信鸽发，什么方式都行.</p>
<p>John does the same – mixing his secret paint color with the public color, then sending that to me.</p>
<p>约翰也这样做，把他的秘密颜色和公开颜色混在一起，然后发我</p>
<p>When I receive John’s color, I simply add my private color to create a blend of all three paints.</p>
<p>我收到约翰的颜色之后，把我的秘密颜色加进去，现在3种颜色混合在一起</p>
<p>John does the same with my mixed color.</p>
<p>John 也一样做</p>
<p>And Voila!</p>
<p>瞧!</p>
<p>We both end up with the same paint color!</p>
<p>我们有了一样的颜色</p>
<p>We can use this as a shared secret, even though we never sent each other our individual secret colors.</p>
<p>我们可以把这个颜色当密钥，尽管我们从来没有给对方发过这颜色</p>
<p>A snooping outside observer would know partial information, but they’d find it very difficult to figure out our shared secret color.</p>
<p>外部窥探者可以知道部分信息，但无法知道最终颜色</p>
<p>Of course, sending and mixing paint colors isn’t going to work well for transmitting computer data.</p>
<p>当然，计算机要传输数据时，混合颜料和发颜料不太合适</p>
<p>But luckily, mathematical one-way functions are perfect,</p>
<p>但幸运的是，数学单向函数是完美的</p>
<p>and this is what Diffie-Hellman Key Exchange uses.</p>
<p>我们可以用 "迪菲-赫尔曼密钥交换"</p>
<p>In Diffie-Hellman, the one-way function is modular exponentiation.</p>
<p>在 Diffie-Hellman 中，单向函数是模幂运算</p>
<p>This means taking one number, the base, to the power of another number,</p>
<p>意思是先做幂运算，拿一个数字当底数，拿一个数字当指数，比如 A b</p>
<p>the exponent, and taking the remainder when dividing by a third number, the modulus.</p>
<p>然后除以第三个数字，最后拿到我们想要的余数</p>
<p>So, for example, if we wanted to calculate 3 to the 5th power, modulo 31,</p>
<p>举个例子，假设我们想算3的5次方，模31</p>
<p>we would calculate 3 to the 5th, which is 243,</p>
<p>我们先算3的5次方，得到243</p>
<p>then take the remainder when divided by 31, which is 26.</p>
<p>，然后除31，取余数，得到26</p>
<p>The hard part is figuring out the exponent given only the result and the base.</p>
<p>重点是如果只给余数和基数。很难得知指数是多少</p>
<p>If I tell you I raised 3 to some secret number, modulo 31, and got 7 as the remainder</p>
<p>如果我告诉你，3的某次方模31，余数是7</p>
<p>you'd have to test a lot of exponents to know which one I picked.</p>
<p>你要试很多次，才能知道次方是多少</p>
<p>If we make these numbers big, say hundreds of digits long,</p>
<p>如果把数字变长一些，比如几百位长</p>
<p>then finding the secret exponent is nearly impossible.</p>
<p>想找到秘密指数是多少，几乎是不可能的。</p>
<p>Now let’s talk about how Diffie-Hellman</p>
<p>现在我们来讨论 Diffie-Hellman 是怎么</p>
<p>uses modular exponentiation to calculate a shared key.</p>
<p>用模幂运算算出双方共享的密钥</p>
<p>First, there's a set of public values – the base and the modulus,</p>
<p>首先，我们有公开的值基数和模数</p>
<p>that, like our public paint color, everyone gets to know... even the bad guys!</p>
<p>就像公开的油漆颜色，所有人都看的到，甚至坏人!</p>
<p>To send a message securely to John, I would pick a secret exponent: X.</p>
<p>为了安全向 John 发信息，我选一个秘密指数：X</p>
<p>Then, I’d calculate B to the power of X, modulo M.</p>
<p>然后算  B^X mod M 的结果</p>
<p>I send this big number over to John.</p>
<p>然后把这个大数字发给 John.</p>
<p>John does the same, picking a secret exponent Y, and sending me B to the Y modulo M.</p>
<p>John 也一样做，选一个秘密指数Y，然后把 B^Y mod M 的结果发我</p>
<p>To create a shared secret key,</p>
<p>为了算出双方共用的密钥</p>
<p>I take what John sent me, and take it to the power of X, my secret exponent.</p>
<p>我把 John 给我的数，用我的秘密指数 X，进行模幂运算 (看上图)</p>
<p>This is mathematically equivalent to B to the XY modulus M.</p>
<p>数学上相等于  B的XY次方模M</p>
<p>John does the same, taking what I sent to him to the power of Y, and we both end up with the exact same number!</p>
<p>John也一样做，拿我给他的数进行模幂运算，最终得到一样的数</p>
<p>It’s a secret shared key, even though we never sent each other our secret number.</p>
<p>双方有一样的密钥，即使我们从来没给对方发过各自的秘密指数</p>
<p>We can use this big number as a shared key for encrypted communication, using something like AES for encryption.</p>
<p>我们可以用这个大数字当密钥，用 AES 之类的加密技术来加密通信</p>
<p>Diffie-Hellman key exchange is one method for establishing a shared key.</p>
<p>"Diffie-Hellman 密钥交换"是建立共享密钥的一种方法。</p>
<p>These keys that can be used by both sender and receiver, to encrypt and decrypt messages</p>
<p>双方用一样的密钥加密和解密消息，这叫"对称加密", 因为密钥一样</p>
<p>are called symmetric keys because the key is the same on both sides.</p>
<p>双方用一样的密钥加密和解密消息，这叫"对称加密", 因为密钥一样</p>
<p>The Caesar Cipher, Enigma and AES are all symmetric encryption.</p>
<p>凯撒加密，英格玛，AES 都是"对称加密"</p>
<p>There’s also asymmetric encryption, where there are two different keys</p>
<p>还有"非对称加密"，有两个不同的密钥</p>
<p>most often one that’s public and another that’s private.</p>
<p>一个是公开的，另一个是私有的</p>
<p>So, people can encrypt a message using a public key that</p>
<p>人们用公钥加密消息，</p>
<p>only the recipient, with their private key, can decrypt.</p>
<p>只有有私钥的人能解密</p>
<p>In other words, knowing the public key only lets you encrypt, but not decrypt – it’s asymmetric!</p>
<p>换句话说，知道公钥只能加密但不能解密，它是"不对称"的！</p>
<p>So, think about boxes with padlocks that you can open with a key.</p>
<p>想象一个可以锁上的盒子</p>
<p>To receive a secure message, I can give a sender a box and padlock.</p>
<p>为了收到安全的信息，我们可以给别人箱子和锁</p>
<p>They put their message in it and lock it shut.</p>
<p>别人把信息放箱子，然后锁起来</p>
<p>Now, they can send that box back to me and only I can open it, with my private key.</p>
<p>把盒子寄回给我，只有我的钥匙能打开</p>
<p>After locking the box, neither the sender,</p>
<p>上锁后，如果发件人或其他人想打开盒子，</p>
<p>nor anyone else who finds the box, can open it without brute force.</p>
<p>除了暴力尝试没有其他办法.</p>
<p>In the same way, a digital public key can encrypt something that can only be decrypted with a private key.</p>
<p>和盒子例子一样，公钥加密后只能私钥来解密.</p>
<p>The reverse is possible too: encrypting something with a</p>
<p>反过来也是可以的：私钥加密后 </p>
<p>private key that can be decrypted with a public key.</p>
<p>用公钥解密</p>
<p>This is used for signing, where a server encrypts data using their private key.</p>
<p>这种做法用于签名，服务器可以用私钥加密，</p>
<p>Anyone can decrypt it using the server's public key.</p>
<p>任何人都可以用服务器的公钥解密</p>
<p>This acts like an unforgeable signature,</p>
<p>就像一个不可伪造的签名</p>
<p>as only the owner, using their private key, can encrypt.</p>
<p>因为只有私钥的持有人能加密</p>
<p>It proves that you're getting data from the right server or person, and not an imposter.</p>
<p>这能证明数据来自正确的服务器或个人，而不是某个假冒者</p>
<p>The most popular asymmetric encryption technique used today is RSA,</p>
<p>目前最流行的"非对称加密"技术是 RSA</p>
<p>named after its inventors: Rivest, Shamir and Adleman.</p>
<p>名字来自发明者： Rivest, Shamir, Adleman.</p>
<p>So, now you know all the "key" parts of modern cryptography:</p>
<p>现在你学会了现代密码学的所有"关键"部分：</p>
<p>symmetric encryption, key exchange and public-key cryptography.</p>
<p>对称加密，密钥交换，公钥密码学</p>
<p>When you connect to a secure website, like your bank,</p>
<p>当你访问一个安全的网站，比如银行官网</p>
<p>that little padlock icon means that your computer has used public key cryptography</p>
<p>绿色锁图标代表用了公钥密码学</p>
<p>to verify the server key exchange to establish a secret temporary key,</p>
<p>验证服务器的密钥，然后建立临时密钥</p>
<p>and symmetric encryption to protect all the back-and-forth communication from prying eyes.</p>
<p>然后用对称加密保证通信安全</p>
<p>Whether you're buying something online, sending emails to BFFs,</p>
<p>不管你是网上购物，发邮件给朋友，</p>
<p>or just browsing cat videos</p>
<p>还是看猫咪视频</p>
<p>cryptography keeps all that safe, private and secure.</p>
<p>密码学都在保护你的隐私和安全</p>
<p>Thanks cryptography!</p>
<p>谢啦密码学！</p>
<p>34 机器学习&人工智能</p>
<p>Machine Learning & Artificial Intelligence</p>
<p>Hi, I'm Carrie Anne, and welcome to Crash Course Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>As we've touched on many times in this series,</p>
<p>我们之前说过，</p>
<p>computers are incredible at storing, organizing,</p>
<p>计算机很擅长存放，整理，</p>
<p>fetching and processing huge volumes of data.</p>
<p>获取和处理大量数据</p>
<p>That's perfect for things like e-commerce websites with millions of items for sale,</p>
<p>很适合有上百万商品的电商网站</p>
<p>and for storing billions of health records for quick access by doctors.</p>
<p>或是存几十亿条健康记录，方便医生看.</p>
<p>But what if we want to use computers not just to fetch and display data,</p>
<p>但是如果我们想用计算机不仅仅是为了获取和显示数据，</p>
<p>but to actually make decisions about data?</p>
<p>但如果想根据数据做决定呢？</p>
<p>This is the essence of machine learning</p>
<p>这是机器学习的本质</p>
<p>algorithms that give computers the ability to learn from data,</p>
<p>机器学习算法让计算机可以从数据中学习，</p>
<p>and then make predictions and decisions.</p>
<p>然后自行做出预测和决定</p>
<p>Computer prosgrams with this ability</p>
<p>能自我学习的程序很有用，</p>
<p>are extremely useful in answering questions like Is an email spam?</p>
<p>比如判断是不是垃圾邮件</p>
<p>Does a person's heart have arrhythmia?</p>
<p>这人有心律失常吗？</p>
<p>or what video should youtube recommend after this one?</p>
<p>YouTube 的下一个视频该推荐哪个？</p>
<p>While useful, we probably wouldn't describe these programs as "intelligent"</p>
<p>虽然有用，但我们不会说它</p>
<p>in the same way we think of human intelligence.</p>
<p>有人类一般的智能</p>
<p>So, even though the terms are often interchanged,</p>
<p>虽然 AI 和 ML 这两词经常混着用</p>
<p>most computer scientists would say that machine learning is a set of techniques</p>
<p>大多数计算机科学家会说，</p>
<p>that sits inside the even more ambitious goal of Artificial Intelligence,</p>
<p>机器学习是为了实现人工智能这个更宏大目标的技术之一</p>
<p>or AI for short.</p>
<p>人工智能简称 AI</p>
<p>Machine Learning and AI algorithms tend to be pretty sophisticated.</p>
<p>机器学习和人工智能算法一般都很复杂</p>
<p>So rather than wading into the mechanics of how they work,</p>
<p>所以我们不讲具体细节</p>
<p>we're going to focus on what the algorithms do conceptually.</p>
<p>重点讲概念</p>
<p>Let's start with a simple example:</p>
<p>我们从简单例子开始：</p>
<p>deciding if a moth is a Luna Moth or an Emperor Moth.</p>
<p>判断飞蛾是"月蛾"还是"帝蛾"</p>
<p>This decision process is called classification,</p>
<p>这叫"分类"</p>
<p>and an algorithm that does it is called a classifier.</p>
<p>做分类的算法叫 "分类器"</p>
<p>Although there are techniques that can use raw data for training</p>
<p>虽然我们可以用照片和声音 </p>
<p>like photos and sounds -</p>
<p>来训练算法</p>
<p>many algorithms reduce the complexity of real world objects</p>
<p>很多算法会减少复杂性</p>
<p>and phenomena into what are called features.</p>
<p>把数据简化成 "特征"</p>
<p>Features are values that usefully characterize the things we wish to classify.</p>
<p>"特征"是用来帮助"分类"的值</p>
<p>For our moth example, we're going to use two features: "wingspan" and "mass".</p>
<p>对于之前的飞蛾分类例子，我们用两个特征:"翼展"和"重量"</p>
<p>In order to train our machine learning classifier to make good predictions,</p>
<p>为了训练"分类器"做出好的预测，</p>
<p>we're going to need training data.</p>
<p>我们需要"训练数据"</p>
<p>To get that,</p>
<p>为了得到数据</p>
<p>we'd send an entomologist out into a forest to collect data for both luna and emperor moths.</p>
<p>我们派昆虫学家到森林里收集"月蛾"和"帝蛾"的数据</p>
<p>These experts can recognize different moths,</p>
<p>专家可以认出不同飞蛾，</p>
<p>so they not only record the feature values,</p>
<p>所以专家不只记录特征值，</p>
<p>but also label that data with the actual moth species.</p>
<p>还会把种类也写上</p>
<p>This is called labeled data.</p>
<p>这叫 "标记数据"</p>
<p>Because we only have two features,</p>
<p>因为只有两个特征</p>
<p>it's easy to visualize this data in a scatterplot.</p>
<p>很容易用散点图把数据视觉化</p>
<p>Here, I've plotted data for 100 Emperor Moths in red and 100 Luna Moths in blue.</p>
<p>红色标了100个帝蛾，蓝色标了100个月蛾</p>
<p>We can see that the species make two groupings, but.</p>
<p>可以看到大致分成了两组</p>
<p>there's some overlap in the middle</p>
<p>但中间有一定重叠</p>
<p>so it's not entirely obvious how to best separate the two.</p>
<p>所以想完全区分两个组比较困难</p>
<p>That's what machine learning algorithms do</p>
<p>所以机器学习算法登场</p>
<p>find optimal separations!</p>
<p>找出最佳区分</p>
<p>I'm just going to eyeball it</p>
<p>我用肉眼大致估算下</p>
<p>and say anything less than 45 millimeters in wingspan is likely to be an Emperor Moth.</p>
<p>然后判断翼展小于45毫米的很可能是帝蛾</p>
<p>We can add another division that says additionally mass must be less than .75</p>
<p>可以再加一个条件，重量必须小于.75</p>
<p>in order for our guess to be Emperor Moth.</p>
<p>才算是帝蛾。</p>
<p>These lines that chop up the decision space are called decision boundaries.</p>
<p>这些线叫 "决策边界"</p>
<p>If we look closely at our data,</p>
<p>如果仔细看数据</p>
<p>we can see that 86 emperor moths would correctly end up inside the emperor decision region,</p>
<p>86只帝蛾在正确的区域</p>
<p>but 14 would end up incorrectly in luna moth territory.</p>
<p>但剩下14只在错误的区域</p>
<p>On the other hand, 82 luna moths would be correct,</p>
<p>另一方面，82只月蛾在正确的区域</p>
<p>with 18 falling onto the wrong side.</p>
<p>18个在错误的区域</p>
<p>A table, like this, showing where a classifier gets things right and wrong</p>
<p>这里有个表记录正确数和错误数</p>
<p>is called a confusion matrix...</p>
<p>这表叫"混淆矩阵"</p>
<p>which probably should have also been the title of the last two movies in the Matrix Trilogy!</p>
<p>"黑客帝国三部曲"的后两部也许该用这个标题</p>
<p>Notice that there's no way for us to draw lines that give us 100% accuracy.</p>
<p>注意我们没法画出 100% 正确分类的线</p>
<p>If we lower our wingspan decision boundary,</p>
<p>降低翼展的决策边界，</p>
<p>we misclassify more Emperor moths as Lunas.</p>
<p>会把更多"帝蛾"误分类成"月蛾"</p>
<p>If we raise it, we misclassify more Luna moths.</p>
<p>如果提高，会把更多月蛾分错类.</p>
<p>The job of machine learning algorithms,</p>
<p>机器学习算法的目的</p>
<p>at a high level,</p>
<p>在一个高的水平</p>
<p>is to maximize correct classifications while minimizing errors</p>
<p>是最大化正确分类 + 最小化错误分类</p>
<p>On our training data, we get 168 moths correct, and 32 moths wrong,</p>
<p>在训练数据中，有168个正确，32个错误</p>
<p>for an average classification accuracy of 84%.</p>
<p>平均准确率84％</p>
<p>Now, using these decision boundaries,</p>
<p>用这些决策边界</p>
<p>if we go out into the forest and encounter an unknown moth,</p>
<p>如果我们进入森林，碰到一只不认识的飞蛾，</p>
<p>we can measure its features and plot it onto our decision space.</p>
<p>我们可以测量它的特征, 并绘制到决策空间上</p>
<p>This is unlabeled data.</p>
<p>这叫 "未标签数据"</p>
<p>Our decision boundaries offer a guess as to what species the moth is.</p>
<p>决策边界可以猜测飞蛾种类</p>
<p>In this case, we'd predict it's a Luna Moth.</p>
<p>这里我们预测是"月蛾"</p>
<p>This simple approach, of dividing the decision space up into boxes,</p>
<p>这个把决策空间切成几个盒子的简单方法</p>
<p>can be represented by what's called a decision tree,</p>
<p>可以用"决策树"来表示</p>
<p>which would look like this pictorially or could be written in code using If-Statements, like this.</p>
<p>画成图像，会像左侧，用 if 语句写代码，会像右侧</p>
<p>A machine learning algorithm that produces decision trees</p>
<p>生成决策树的机器学习算法</p>
<p>needs to choose what features to divide on</p>
<p>需要选择用什么特征来分类</p>
<p>and then for each of those features, what values to use for the division.</p>
<p>每个特征用什么值</p>
<p>Decision Trees are just one basic example of a machine learning technique.</p>
<p>"决策树"只是机器学习的一个简单例子</p>
<p>There are hundreds of algorithms in computer science literature today.</p>
<p>如今有数百种算法，</p>
<p>And more are being published all the time.</p>
<p>而且新算法不断出现</p>
<p>A few algorithms even use many decision trees working together to make a prediction.</p>
<p>一些算法甚至用多个"决策树"来预测</p>
<p>Computer scientists smugly call those Forests</p>
<p>计算机科学家叫这个"森林"，</p>
<p>because they contain lots of trees.</p>
<p>因为有多颗树嘛</p>
<p>There are also non-tree-based approaches,</p>
<p>也有不用树的方法，</p>
<p>like Support Vector Machines,</p>
<p>比如"支持向量机"</p>
<p>which essentially slice up the decision space using arbitrary lines.</p>
<p>本质上是用任意线段来切分"决策空间"</p>
<p>And these don't have to be straight lines;</p>
<p>不一定是直线</p>
<p>they can be polynomials or some other fancy mathematical function.</p>
<p>可以是多项式或其他数学函数</p>
<p>Like before, it's the machine learning algorithm's job</p>
<p>就像之前，机器学习算法负责</p>
<p>to figure out the best lines to provide the most accurate decision boundaries.</p>
<p>找出最好的线，最准的决策边界</p>
<p>So far, my examples have only had two features,</p>
<p>之前的例子只有两个特征，</p>
<p>which is easy enough for a human to figure out.</p>
<p>人类也可以轻松做到</p>
<p>If we add a third feature,</p>
<p>如果加第3个特征，</p>
<p>let's say, length of antennae,</p>
<p>比如"触角长度"</p>
<p>then our 2D lines become 3D planes,</p>
<p>那么2D线段，会变成3D平面</p>
<p>creating decision boundaries in three dimensions.</p>
<p>在三个维度上做决策边界</p>
<p>These planes don't have to be straight either.</p>
<p>这些平面不必是直的</p>
<p>Plus, a truly useful classifier would contend with many different moth species.</p>
<p>而且真正有用的分类器会有很多飞蛾种类</p>
<p>Now I think you'd agree this is getting too complicated to figure out by hand</p>
<p>你可能会同意现在变得太复杂了</p>
<p>But even this is a very basic example</p>
<p>但这也只是个简单例子</p>
<p>just three features and five moth species.</p>
<p>只有3个特征和5个品种</p>
<p>We can still show it in this 3D scatter plot.</p>
<p>我们依然可以用 3D散点图画出来</p>
<p>Unfortunately, there's no good way to visualize four features at once, or twenty features,</p>
<p>不幸的是，一次性看4个或20个特征，没有好的方法</p>
<p>let alone hundreds or even thousands of features.</p>
<p>更别说成百上千的特征了</p>
<p>But that's what many real-world machine learning problems face.</p>
<p>但这正是机器学习要面临的问题</p>
<p>Can YOU imagine trying to figure out the equation for a hyperplane</p>
<p>你能想象靠手工在一个上千维度的决策空间里</p>
<p>rippling through a thousand-dimensional decision space?</p>
<p>给超平面(Hyperplane)找出一个方程吗</p>
<p>Probably not,</p>
<p>大概不行</p>
<p>but computers, with clever machine learning algorithms can</p>
<p>但聪明的机器学习算法可以做到</p>
<p>and they do, all day long, on computers at places like Google, Facebook, Microsoft and Amazon.</p>
<p>Google，Facebook，微软和亚马逊的计算机里，整天都在跑这些算法</p>
<p>Techniques like Decision Trees and Support Vector Machines are strongly rooted in the field of statistics,</p>
<p>"决策树"和"支持向量机"这样的技术，发源自统计学</p>
<p>which has dealt with making confident decisions,</p>
<p>统计学早在计算机出现前，</p>
<p>using data, long before computers ever existed.</p>
<p>就在用数据做决定</p>
<p>There's a very large class of widely used statistical machine learning techniques,</p>
<p>有一大类机器学习算法用了统计学</p>
<p>but there are also some approaches with no origins in statistics.</p>
<p>但也有不用统计学的算法</p>
<p>Most notable are artificial neural networks,</p>
<p>其中最值得注意的是人工神经网络</p>
<p>which were inspired by neurons in our brains!</p>
<p>灵感来自大脑里的神经元</p>
<p>For a primer of biological neurons,</p>
<p>想学习神经元知识的人，</p>
<p>check out our three-part overview here,</p>
<p>可以看这3集</p>
<p>but basically neurons are cells</p>
<p>神经元是细胞</p>
<p>that process and transmit messages using electrical and chemical signals.</p>
<p>用电信号和化学信号来处理和传输消息</p>
<p>They take one or more inputs from other cells,</p>
<p>它从其他细胞得到一个或多个输入</p>
<p>process those signals,</p>
<p>然后处理信号</p>
<p>and then emit their own signal.</p>
<p>并发出信号</p>
<p>These form into huge interconnected networks that are able to process complex information.</p>
<p>形成巨大的互联网络，能处理复杂的信息</p>
<p>Just like your brain watching this youtube video.</p>
<p>就像你的大脑在看这个视频</p>
<p>Artificial Neurons are very similar.</p>
<p>人造神经元很类似</p>
<p>Each takes a series of inputs, combines them, and emits a signal.</p>
<p>可以接收多个输入，然后整合并发出一个信号</p>
<p>Rather than being electrical or chemical signals,</p>
<p>它不用电信号或化学信号</p>
<p>artificial neurons take numbers in, and spit numbers out.</p>
<p>而是吃数字进去，吐数字出来</p>
<p>They are organized into layers that are connected by links,</p>
<p>它们被放成一层层</p>
<p>forming a network of neurons, hence the name.</p>
<p>形成神经元网络，因此得名神经网络</p>
<p>Let's return to our moth example to see how neural nets can be used for classification.</p>
<p>回到飞蛾例子，看如何用神经网络分类</p>
<p>Our first layer the input layer -</p>
<p>我们的第一层输入层 -</p>
<p>provides data from a single moth needing classification.</p>
<p>提供需要被分类的单个飞蛾数据</p>
<p>Again, we'll use mass and wingspan.</p>
<p>同样，这次也用重量和翼展</p>
<p>At the other end, we have an output layer, with two neurons:</p>
<p>另一边是输出层，有两个神经元：</p>
<p>one for Emperor Moth and another for Luna Moth.</p>
<p>一个是帝蛾，一个是月蛾</p>
<p>The most excited neuron will be our classification decision.</p>
<p>2个神经元里最兴奋的就是分类结果</p>
<p>In between, we have a hidden layer,</p>
<p>中间有一个隐藏层</p>
<p>that transforms our inputs into outputs, and does the hard work of classification.</p>
<p>负责把输入变成输出，负责干分类这个重活</p>
<p>To see how this is done,</p>
<p>为了看看它是如何分类的</p>
<p>let's zoom into one neuron in the hidden layer.</p>
<p>我们放大"隐藏层"里的一个神经元</p>
<p>The first thing a neuron does is multiply each of its inputs by a specific weight,</p>
<p>神经元做的第一件事，是把每个输入乘以一个权重</p>
<p>let's say 2.8 for its first input, and .1 for it's second input.</p>
<p>假设2.8是第一个输入，0.1是第二个输入。</p>
<p>Then, it sums these weighted inputs together,</p>
<p>然后它会相加输入</p>
<p>which is in this case, is a grand total of 9.74.</p>
<p>总共是9.74</p>
<p>The neuron then applies a bias to this result</p>
<p>然后对这个结果，用一个偏差值处理</p>
<p>in other words, it adds or subtracts a fixed value,</p>
<p>意思是加或减一个固定值</p>
<p>for example, minus six, for a new value of 3.74.</p>
<p>比如-6，得到3.74</p>
<p>These bias and inputs weights are initially set to random values when a neural network is created.</p>
<p>做神经网络时，这些偏差和权重，一开始会设置成随机值</p>
<p>Then, an algorithm goes in, and starts tweaking all those values to train the neural network,</p>
<p>然后算法会调整这些值来训练神经网络</p>
<p>using labeled data for training and testing.</p>
<p>使用"标记数据"来训练和测试</p>
<p>This happens over many interactions, gradually improving accuracy</p>
<p>逐渐提高准确性</p>
<p>a process very much like human learning.</p>
<p>很像人类学习的过程</p>
<p>Finally, neurons have an activation function, also called a transfer function,</p>
<p>最后，神经元有激活函数，它也叫传递函数，</p>
<p>that gets applied to the output, performing a final mathematical modification to the result.</p>
<p>会应用于输出，对结果执行最后一次数学修改</p>
<p>For example, limiting the value to a range from negative one and positive one,</p>
<p>例如，把值限制在-1和+1之间</p>
<p>or setting any negative values to 0.</p>
<p>或把负数改成0</p>
<p>We'll use a linear transfer function that passes the value through unchanged,</p>
<p>我们用线性传递函数，它不会改变值</p>
<p>so 3.74 stays as 3.74.</p>
<p>所以3.74还是3.74</p>
<p>So for our example neuron,</p>
<p>所以这里的例子</p>
<p>given the inputs .55 and 82, the output would be 3.74.</p>
<p>输入0.55和82，输出3.74</p>
<p>This is just one neuron,</p>
<p>这只是一个神经元，</p>
<p>but this process of weighting, summing, biasing</p>
<p>但加权，求和，偏置，激活函数</p>
<p>and applying an activation function is computed for all neurons in a layer,</p>
<p>会应用于一层里的每个神经元</p>
<p>and the values propagate forward in the network, one layer at a time.</p>
<p>并向前传播，一次一层</p>
<p>In this example, the output neuron with the highest value is our decision:</p>
<p>数字最高的就是结果：</p>
<p>Luna Moth.</p>
<p>月蛾</p>
<p>Importantly, the hidden layer doesn't have to be just one layer</p>
<p>重要的是，隐藏层不是只能有一层，</p>
<p>it can be many layers deep.</p>
<p>可以有很多层</p>
<p>This is where the term deep learning comes from.</p>
<p>"深度学习"因此得名</p>
<p>Training these more complicated networks takes a lot more computation and data.</p>
<p>训练更复杂的网络需要更多的计算量和数据</p>
<p>Despite the fact that neural networks were invented over fifty years ago,</p>
<p>尽管神经网络50多年前就发明了</p>
<p>deep neural nets have only been practical very recently,</p>
<p>深层神经网络直到最近才成为可能</p>
<p>thanks to powerful processors,</p>
<p>感谢强大的处理器</p>
<p>but even more so, wicked fast GPUs.</p>
<p>和超快的GPU</p>
<p>So, thank you gamers for being so demanding about silky smooth framerates!</p>
<p>感谢游戏玩家对帧率的苛刻要求！</p>
<p>A couple of years ago, Google and Facebook</p>
<p>几年前，Google和Facebook</p>
<p>demonstrated deep neural nets that could find faces in photos as well as humans</p>
<p>展示了深度神经网络，在照片中识别人脸的准确率，和人一样高</p>
<p>and humans are really good at this!</p>
<p>人类可是很擅长这个的！</p>
<p>It was a huge milestone.</p>
<p>这是个巨大的里程碑</p>
<p>Now deep neural nets are driving cars,</p>
<p>现在有深层神经网络开车，</p>
<p>translating human speech,</p>
<p>翻译，</p>
<p>diagnosing medical conditions and much more.</p>
<p>诊断医疗状况等等</p>
<p>These algorithms are very sophisticated,</p>
<p>这些算法非常复杂，</p>
<p>but it's less clear if they should be described as "intelligent".</p>
<p>但还不够"聪明"</p>
<p>They can really only do one thing like classify moths, find faces, or translate languages.</p>
<p>它们只能做一件事，分类飞蛾，找人脸，翻译</p>
<p>This type of AI is called Weak AI or Narrow AI.</p>
<p>这种AI叫"弱AI"或"窄AI"，</p>
<p>It's only intelligent at specific tasks.</p>
<p>只能做特定任务</p>
<p>But that doesn't mean it's not useful;</p>
<p>但这不意味着它没用</p>
<p>I mean medical devices that can make diagnoses,</p>
<p>能自动做出诊断的医疗设备，</p>
<p>and cars that can drive themselves are amazing!</p>
<p>和自动驾驶的汽车真是太棒了！</p>
<p>But do we need those computers to compose music</p>
<p>但我们是否需要这些计算机来创作音乐</p>
<p>and look up delicious recipes in their free time?</p>
<p>在空闲时间找美味食谱呢？</p>
<p>Probably not.</p>
<p>也许不要</p>
<p>Although that would be kinda cool.</p>
<p>如果有的话还挺酷的</p>
<p>Truly general-purpose AI, one as smart and well-rounded as a human,</p>
<p>真正通用的，像人一样聪明的AI，</p>
<p>is called Strong AI.</p>
<p>叫 "强AI"</p>
<p>No one has demonstrated anything close to human-level artificial intelligence yet.</p>
<p>目前没人能做出来接近人类智能的 AI</p>
<p>Some argue it's impossible,</p>
<p>有人认为不可能做出来</p>
<p>but many people point to the explosion of digitized knowledge</p>
<p>但许多人说数字化知识的爆炸性增长</p>
<p>like Wikipedia articles, web pages, and Youtube videos -</p>
<p>比如维基百科，网页和Youtube视频 -</p>
<p>as the perfect kindling for Strong AI.</p>
<p>是"强 AI"的完美引燃物</p>
<p>Although you can only watch a maximum of 24 hours of youtube a day,</p>
<p>你一天最多只能看24小时的 YouTube，</p>
<p>a computer can watch millions of hours.</p>
<p>计算机可以看上百万小时</p>
<p>For example, IBM's Watson consults and synthesizes information from 200 million pages of content,</p>
<p>比如，IBM 的沃森吸收了 2 亿个网页的内容</p>
<p>including the full text of Wikipedia.</p>
<p>包括维基百科的全文</p>
<p>While not a Strong AI, Watson is pretty smart,</p>
<p>虽然不是"强AI" 但沃森也很聪明，</p>
<p>and it crushed its human competition in Jeopardy way back in 2011.</p>
<p>在2011年的知识竞答中碾压了人类</p>
<p>Not only can AIs gobble up huge volumes of information,</p>
<p>AI不仅可以吸收大量信息，也可以不断学习进步，</p>
<p>but they can also learn over time, often much faster than humans.</p>
<p>而且一般比人类快得多</p>
<p>In 2016, Google debuted AlphaGo,</p>
<p>2016 年 Google 推出 AlphaGo</p>
<p>a Narrow AI that plays the fiendishly complicated board game Go.</p>
<p>一个会玩围棋的窄AI</p>
<p>One of the ways it got so good and able to beat the very best human players,</p>
<p>它和自己的克隆版下无数次围棋，</p>
<p>was by playing clones of itself millions and millions of times.</p>
<p>从而打败最好的人类围棋选手</p>
<p>It learned what worked and what didn't,</p>
<p>学习什么管用，什么不管用，</p>
<p>and along the way, discovered successful strategies all by itself.</p>
<p>自己发现成功的策略</p>
<p>This is called Reinforcement Learning,</p>
<p>这叫 "强化学习" </p>
<p>and it's a super powerful approach.</p>
<p>是一种很强大的方法</p>
<p>In fact, it's very similar to how humans learn.</p>
<p>和人类的学习方式非常类似</p>
<p>People don't just magically acquire the ability to walk...</p>
<p>人类不是天生就会走路，</p>
<p>it takes thousands of hours of trial and error to figure it out.</p>
<p>是上千小时的试错学会的</p>
<p>Computers are now on the cusp of learning by trial and error,</p>
<p>计算机现在才刚学会反复试错来学习</p>
<p>and for many narrow problems,</p>
<p>对于很多狭窄的问题，</p>
<p>reinforcement learning is already widely used.</p>
<p>强化学习已被广??泛使用</p>
<p>What will be interesting to see, is if these types of learning techniques can be applied more broadly,</p>
<p>有趣的是，如果这类技术可以更广泛地应用</p>
<p>to create human-like, Strong AIs that learn much like how kids learn, but at super accelerated rates.</p>
<p>创造出类似人类的"强AI"，能像人类小孩一样学习，但学习速度超快</p>
<p>If that happens, there are some pretty big changes in store for humanity</p>
<p>如果这发生了，对人类可能有相当大的影响</p>
<p>a topic we'll revisit later.</p>
<p>我们以后会讨论</p>
<p>Thanks for watching. See you next week.</p>
<p>感谢收看.  我们下周见</p>
<p>35 计算机视觉</p>
<p>Computer Vision</p>
<p>Hi, I'm Carrie Anne, and welcome to Crash Course Computer Science!</p>
<p>嗨我是Carrie Anne，欢迎收看计算机科学速成课</p>
<p>Today, let's start by thinking about how important vision can be.</p>
<p>今天我们来思考视觉的重要性</p>
<p>Most people rely on it to prepare food,</p>
<p>大部分人靠视觉来做饭</p>
<p>walk around obstacles,</p>
<p>越过障碍</p>
<p>read street signs,</p>
<p>读路牌</p>
<p>watch videos like this,</p>
<p>看视频</p>
<p>and do hundreds of other tasks.</p>
<p>以及无数其它任务</p>
<p>Vision is the highest bandwidth sense,</p>
<p>视觉是信息最多的感官，</p>
<p>and it provides a firehose of information about the state of the world and how to act on it.</p>
<p>比如周围的世界是怎样的，如何和世界交互</p>
<p>For this reason, computer scientists have been trying to give computers vision for half a century,</p>
<p>因此半个世纪来，计算机科学家一直在想办法让计算机有视觉</p>
<p>birthing the sub-field of computer vision.</p>
<p>因此诞生了"计算机视觉"这个领域</p>
<p>Its goal is to give computers the ability</p>
<p>目标是让计算机</p>
<p>to extract high-level understanding from digital images and videos.</p>
<p>理解图像和视频</p>
<p>As everyone with a digital camera or smartphone knows,</p>
<p>用过相机或手机的都知道，</p>
<p>computers are already really good at capturing photos with incredible fidelity and detail</p>
<p>可以拍出有惊人保真度和细节的照片</p>
<p>much better than humans in fact.</p>
<p>比人类强得多</p>
<p>But as computer vision professor Fei-Fei Li recently said,</p>
<p>但正如计算机视觉教授李飞飞最近说的</p>
<p>"Just like to hear is the not the same as to listen.</p>
<p>"听到"不等于"听懂"</p>
<p>To take pictures is not the same as to see."</p>
<p>"看到"不等于"看懂"</p>
<p>As a refresher, images on computers are most often stored as big grids of pixels.</p>
<p>复习一下，图像是像素网格</p>
<p>Each pixel is defined by a color, stored as a combination of three additive primary colors:</p>
<p>每个像素的颜色通过三种基色定义：</p>
<p>red, green and blue.</p>
<p>红，绿，蓝</p>
<p>By combining different intensities of these three colors,</p>
<p>通过组合三种颜色的强度，</p>
<p>we can represent any color.  what's called a RGB value,</p>
<p>可以得到任何颜色, 也叫 RGB 值</p>
<p>Perhaps the simplest computer vision algorithm</p>
<p>最简单的计算机视觉算法</p>
<p>and a good place to start -</p>
<p>最合适拿来入门的</p>
<p>is to track a colored object, like a bright pink ball.</p>
<p>是跟踪一个颜色物体，比如一个粉色的球</p>
<p>The first thing we need to do is record the ball's color.</p>
<p>首先，我们记下球的颜色，</p>
<p>For that, we'll take the RGB value of the centermost pixel.</p>
<p>保存最中心像素的 RGB 值</p>
<p>With that value saved, we can give a computer program an image,</p>
<p>然后给程序喂入图像，</p>
<p>and ask it to find the pixel with the closest color match.</p>
<p>让它找最接近这个颜色的像素</p>
<p>An algorithm like this might start in the upper right corner,</p>
<p>算法可以从左上角开始，</p>
<p>and check each pixel, one at time,</p>
<p>逐个检查像素</p>
<p>calculating the difference from our target color.</p>
<p>计算和目标颜色的差异</p>
<p>Now, having looked at every pixel,</p>
<p>检查了每个像素后，最贴近的像素，</p>
<p>the best match is very likely a pixel from our ball.</p>
<p>很可能就是球</p>
<p>We're not limited to running this algorithm on a single photo;</p>
<p>不只是这张图片，</p>
<p>we can do it for every frame in a video,</p>
<p>我们可以在视频的每一帧图片跑这个算法</p>
<p>allowing us to track the ball over time.</p>
<p>跟踪球的位置</p>
<p>Of course, due to variations in lighting, shadows, and other effects,</p>
<p>当然，因为光线，阴影和其它影响</p>
<p>the ball on the field is almost certainly not going to be the exact same RGB value as our target color,</p>
<p>球的颜色会有变化，不会和存的 RGB 值完全一样</p>
<p>but merely the closest match.</p>
<p>但会很接近</p>
<p>In more extreme cases, like at a game at night,</p>
<p>如果情况更极端一些，比如比赛是在晚上，</p>
<p>the tracking might be poor.</p>
<p>追踪效果可能会很差</p>
<p>And if one of the team's jerseys used the same color as the ball,</p>
<p>如果球衣的颜色和球一样，</p>
<p>our algorithm would get totally confused.</p>
<p>算法就完全晕了</p>
<p>For these reasons, color marker tracking and similar algorithms are rarely used,</p>
<p>因此很少用这类颜色跟踪算法</p>
<p>unless the environment can be tightly controlled.</p>
<p>除非环境可以严格控制</p>
<p>This color tracking example was able to search pixel-by-pixel,</p>
<p>颜色跟踪算法是一个个像素搜索，</p>
<p>because colors are stored inside of single pixels.</p>
<p>因为颜色是在一个像素里</p>
<p>But this approach doesn't work for features larger than a single pixel,</p>
<p>但这种方法不适合占多个像素的特征</p>
<p>like edges of objects, which are inherently made up of many pixels.</p>
<p>比如物体的边缘，是多个像素组成的.</p>
<p>To identify these types of features in images,</p>
<p>为了识别这些特征，</p>
<p>computer vision algorithms have to consider small regions of pixels,</p>
<p>算法要一块块像素来处理</p>
<p>called patches.</p>
<p>每一块都叫"块"</p>
<p>As an example, let's talk about an algorithm that finds vertical edges in a scene,</p>
<p>举个例子，找垂直边缘的算法</p>
<p>let's say to help a drone navigate safely through a field of obstacles.</p>
<p>假设用来帮无人机躲避障碍</p>
<p>To keep things simple, we're going to convert our image into grayscale,</p>
<p>为了简单，我们把图片转成灰度，</p>
<p>although most algorithms can handle color.</p>
<p>不过大部分算法可以处理颜色</p>
<p>Now let's zoom into one of these poles to see what an edge looks like up close.</p>
<p>放大其中一个杆子，看看边缘是怎样的</p>
<p>We can easily see where the left edge of the pole starts,</p>
<p>可以很容易地看到杆子的左边缘从哪里开始</p>
<p>because there's a change in color that persists across many pixels vertically.</p>
<p>因为有垂直的颜色变化</p>
<p>We can define this behavior more formally by creating a rule</p>
<p>我们可以弄个规则说</p>
<p>that says the likelihood of a pixel being a vertical edge</p>
<p>某像素是垂直边缘的可能性，</p>
<p>is the magnitude of the difference in color</p>
<p>取决于左右两边像素的</p>
<p>between some pixels to its left and some pixels to its right.</p>
<p>颜色差异程度</p>
<p>The bigger the color difference between these two sets of pixels,</p>
<p>左右像素的区别越大，</p>
<p>the more likely the pixel is on an edge.</p>
<p>这个像素越可能是边缘</p>
<p>If the color difference is small, it's probably not an edge at all.</p>
<p>如果色差很小，就不是边缘</p>
<p>The mathematical notation for this operation looks like this</p>
<p>这个操作的数学符号看起来像这样</p>
<p>it's called a kernel or filter.</p>
<p>这叫"核"或"过滤器"</p>
<p>It contains the values for a pixel-wise multiplication,</p>
<p>里面的数字用来做像素乘法</p>
<p>the sum of which is saved into the center pixel.</p>
<p>总和存到中心像素里</p>
<p>Let's see how this works for our example pixel.</p>
<p>我们来看个实际例子</p>
<p>I've gone ahead and labeled all of the pixels with their grayscale values.</p>
<p>我已经把所有像素转成了灰度值</p>
<p>Now, we take our kernel, and center it over our pixel of interest.</p>
<p>现在把"核"的中心，对准感兴趣的像素</p>
<p>This specifies what each pixel value underneath should be multiplied by.</p>
<p>这指定了每个像素要乘的值</p>
<p>Then, we just add up all those numbers.</p>
<p>然后把所有数字加起来</p>
<p>In this example, that gives us 147.</p>
<p>在这里，最后结果是 147</p>
<p>That becomes our new pixel value.</p>
<p>成为新像素值</p>
<p>This operation, of applying a kernel to a patch of pixels,</p>
<p>把核 应用于像素块，</p>
<p>is call a convolution.</p>
<p>这种操作叫"卷积"</p>
<p>Now let's apply our kernel to another pixel.</p>
<p>现在我们把"核"应用到另一个像素</p>
<p>In this case, the result is 1. Just 1.</p>
<p>结果是 1</p>
<p>In other words, it's a very small color difference, and not an edge.</p>
<p>色差很小，不是边缘</p>
<p>If we apply our kernel to every pixel in the photo,</p>
<p>如果把"核"用于照片中每个像素</p>
<p>the result looks like this,</p>
<p>结果会像这样</p>
<p>where the highest pixel values are where there are strong vertical edges.</p>
<p>垂直边缘的像素值很高</p>
<p>Note that horizontal edges, like those platforms in the background,</p>
<p>注意，水平边缘（比如背景里的平台）</p>
<p>are almost invisible.</p>
<p>几乎看不见</p>
<p>If we wanted to highlight those features,</p>
<p>如果要突出那些特征</p>
<p>we'd have to use a different kernel</p>
<p>要用不同的"核"</p>
<p>one that's sensitive to horizontal edges.</p>
<p>用对水平边缘敏感的"核"</p>
<p>Both of these edge enhancing kernels are called Prewitt Operators,</p>
<p>这两个边缘增强的核叫"Prewitt 算子"</p>
<p>named after their inventor.</p>
<p>以发明者命名</p>
<p>These are just two examples of a huge variety of kernels,</p>
<p>这只是众多"核"的两个例子</p>
<p>able to perform many different image transformations.</p>
<p>"核"能做很多种图像转换</p>
<p>For example, here's a kernel that sharpens images.</p>
<p>比如这个"核"能锐化图像</p>
<p>And here's a kernel that blurs them.</p>
<p>这个"核"能模糊图像</p>
<p>Kernels can also be used like little image cookie cutters that match only certain shapes.</p>
<p>"核"也可以像饼干模具一样，匹配特定形状</p>
<p>So, our edge kernels looked for image patches</p>
<p>之前做边缘检测的"核"</p>
<p>with strong differences from right to left or up and down.</p>
<p>会检查左右或上下的差异</p>
<p>But we could also make kernels that are good at finding lines, with edges on both sides.</p>
<p>但我们也可以做出擅长找线段的"核"</p>
<p>And even islands of pixels surrounded by contrasting colors.</p>
<p>或者包了一圈对比色的区域</p>
<p>These types of kernels can begin to characterize simple shapes.</p>
<p>这类"核"可以描述简单的形状</p>
<p>For example, on faces, the bridge of the nose tends to be brighter than the sides of the nose,</p>
<p>比如鼻梁往往比鼻子两侧更亮</p>
<p>resulting in higher values for line-sensitive kernels.</p>
<p>所以线段敏感的"核"对这里的值更高</p>
<p>Eyes are also distinctive</p>
<p>眼睛也很独特</p>
<p>a dark circle sounded by lighter pixels -</p>
<p>一个黑色圆圈被外层更亮的一层像素包着</p>
<p>a pattern other kernels are sensitive to.</p>
<p>有其它"核"对这种模式敏感</p>
<p>When a computer scans through an image,</p>
<p>当计算机扫描图像时，</p>
<p>most often by sliding around a search window,</p>
<p>最常见的是用一个窗口来扫</p>
<p>it can look for combinations of features indicative of a human face.</p>
<p>可以找出人脸的特征组合</p>
<p>Although each kernel is a weak face detector by itself,</p>
<p>虽然每个"核"单独找出脸的能力很弱，</p>
<p>combined, they can be quite accurate.</p>
<p>但组合在一起会相当准确</p>
<p>It's unlikely that a bunch of face-like features will cluster together if they're not a face.</p>
<p>不是脸但又有一堆脸的特征在正确的位置，这种情况不太可能</p>
<p>This was the basis of an early and influential algorithm</p>
<p>这是一个早期很有影响力的算法的基础</p>
<p>called Viola-Jones Face Detection.</p>
<p>叫维奥拉·琼斯人脸检测算法</p>
<p>Today, the hot new algorithms on the block are Convolutional Neural Networks.</p>
<p>如今的热门算法是 "卷积神经网络"</p>
<p>We talked about neural nets last episode, if you need a primer.</p>
<p>我们上集谈了神经网络，如果需要可以去看看</p>
<p>In short, an artificial neuron</p>
<p>总之，神经网络的最基本单位，</p>
<p>which is the building block of a neural network -</p>
<p>是神经元</p>
<p>takes a series of inputs, and multiplies each by a specified weight,</p>
<p>它有多个输入，然后会把每个输入乘一个权重值</p>
<p>and then sums those values all together.</p>
<p>然后求总和</p>
<p>This should sound vaguely familiar, because it's a lot like a convolution.</p>
<p>听起来好像挺耳熟，因为它很像"卷积"</p>
<p>In fact, if we pass a neuron 2D pixel data, rather than a one-dimensional list of inputs,</p>
<p>实际上，如果我们给神经元输入二维像素</p>
<p>it's exactly like a convolution.</p>
<p>完全就像"卷积"</p>
<p>The input weights are equivalent to kernel values,</p>
<p>输入权重等于"核"的值</p>
<p>but unlike a predefined kernel,</p>
<p>但和预定义"核"不同</p>
<p>neural networks can learn their own useful kernels</p>
<p>神经网络可以学习对自己有用的"核"</p>
<p>that are able to recognize interesting features in images.</p>
<p>来识别图像中的特征</p>
<p>Convolutional Neural Networks use banks of these neurons to process image data,</p>
<p>"卷积神经网络"用一堆神经元处理图像数据</p>
<p>each outputting a new image, essentially digested by different learned kernels.</p>
<p>每个都会输出一个新图像，本质上是被不同的"核"处理了</p>
<p>These outputs are then processed by subsequent layers of neurons,</p>
<p>输出会被后面一层神经元处理</p>
<p>allowing for convolutions on convolutions on convolutions.</p>
<p>卷积卷积再卷积</p>
<p>The very first convolutional layer might find things like edges,</p>
<p>第一层可能会发现"边缘"这样的特征</p>
<p>as that's what a single convolution can recognize, as we've already discussed.</p>
<p>单次卷积可以识别出这样的东西，之前说过</p>
<p>The next layer might have neurons that convolve on those edge features</p>
<p>下一层可以在这些基础上识别</p>
<p>to recognize simple shapes, comprised of edges, like corners.</p>
<p>比如由"边缘"组成的角落</p>
<p>A layer beyond that might convolve on those corner features,</p>
<p>然后下一层可以在"角落"上继续卷积</p>
<p>and contain neurons that can recognize simple objects,</p>
<p>下一些可能有识别简单物体的神经元</p>
<p>like mouths and eyebrows.</p>
<p>比如嘴和眉毛</p>
<p>And this keeps going, building up in complexity,</p>
<p>然后不断重复，逐渐增加复杂度</p>
<p>until there's a layer that does a convolution that puts it together:</p>
<p>直到某一层把所有特征放到一起：</p>
<p>eyes, ears, mouth, nose, the whole nine yards,</p>
<p>眼睛，耳朵，嘴巴，鼻子</p>
<p>and says "ah ha, it's a face!"</p>
<p>然后说："啊哈，这是脸！"</p>
<p>Convolutional neural networks aren't required to be many layers deep,</p>
<p>"卷积神经网络"不是非要很多很多层</p>
<p>but they usually are, in order to recognize complex objects and scenes.</p>
<p>但一般会有很多层，来识别复杂物体和场景</p>
<p>That's why the technique is considered deep learning.</p>
<p>所以算是"深度学习"</p>
<p>Both Viola-Jones and Convolutional Neural Networks can be applied to many image recognition problems,</p>
<p>"维奥拉·琼斯"和"卷积神经网络"，</p>
<p>beyond faces, like recognizing handwritten text,</p>
<p>不只是认人脸，还可以识别手写文字</p>
<p>spotting tumors in CT scans and monitoring traffic flow on roads.</p>
<p>在 CT 扫描中发现肿瘤，监测马路是否拥堵</p>
<p>But we're going to stick with faces.</p>
<p>但我们这里接着用人脸举例</p>
<p>Regardless of what algorithm was used, once we've isolated a face in a photo,</p>
<p>不管用什么算法，识别出脸之后</p>
<p>we can apply more specialized computer vision algorithms to pinpoint facial landmarks,</p>
<p>可以用更专用的计算机视觉算法，来定位面部标志</p>
<p>like the tip of the nose and corners of the mouth.</p>
<p>比如鼻尖和嘴角</p>
<p>This data can be used for determining things like if the eyes are open,</p>
<p>有了标志点，</p>
<p>which is pretty easy once you have the landmarks</p>
<p>判断眼睛有没有张开就很容易了</p>
<p>it's just the distance between points.</p>
<p>只是点之间的距离罢了</p>
<p>We can also track the position of the eyebrows;</p>
<p>也可以跟踪眉毛的位置</p>
<p>their relative position to the eyes can be an indicator of surprise, or delight.</p>
<p>眉毛相对眼睛的位置可以代表惊喜或喜悦</p>
<p>Smiles are also pretty straightforward to detect based on the shape of mouth landmarks.</p>
<p>根据嘴巴的标志点，检测出微笑也很简单</p>
<p>All of this information can be interpreted by emotion recognition algorithms,</p>
<p>这些信息可以用"情感识别算法"来识别</p>
<p>giving computers the ability to infer when you're happy, sad, frustrated, confused and so on.</p>
<p>让电脑知道你是开心，忧伤，沮丧，困惑等等</p>
<p>In turn, that could allow computers to intelligently adapt their behavior...</p>
<p>然后计算机可以做出合适的行为.</p>
<p>maybe offer tips when you're confused,</p>
<p>比如当你不明白时给你提示</p>
<p>and not ask to install updates when you're frustrated.</p>
<p>你心情不好时，就不弹更新提示了</p>
<p>This is just one example of how vision can give computers the ability to be context sensitive,</p>
<p>这只是计算机通过视觉感知</p>
<p>that is, aware of their surroundings.</p>
<p>周围的一个例子</p>
<p>And not just the physical surroundings</p>
<p>不只是物理环境 </p>
<p>like if you're at work or on a train -</p>
<p>比如是不是在上班，或是在火车上</p>
<p>but also your social surroundings</p>
<p>还有社交环境 </p>
<p>like if you're in a formal business meeting versus a friend's birthday party.</p>
<p>比如是朋友的生日派对，还是正式商务会议</p>
<p>You behave differently in those surroundings, and so should computing devices,</p>
<p>你在不同环境会有不同行为，计算机也应如此</p>
<p>if they're smart.</p>
<p>如果它们够聪明的话...</p>
<p>Facial landmarks also capture the geometry of your face,</p>
<p>面部标记点也可以捕捉脸的形状</p>
<p>like the distance between your eyes and the height of your forehead.</p>
<p>比如两只眼睛之间的距离，以及前额有多高</p>
<p>This is one form of biometric data,</p>
<p>做生物识别</p>
<p>and it allows computers with cameras to recognize you.</p>
<p>让有摄像头的计算机能认出你</p>
<p>Whether it's your smartphone automatically unlocking itself when it sees you,</p>
<p>不管是手机解锁 </p>
<p>or governments tracking people using CCTV cameras,</p>
<p>还是政府用摄像头跟踪人</p>
<p>the applications of face recognition seem limitless.</p>
<p>人脸识别有无限应用场景</p>
<p>There have also been recent breakthroughs in landmark tracking for hands and whole bodies,</p>
<p>另外跟踪手臂和全身的标记点，最近也有一些突破</p>
<p>giving computers the ability to interpret a user's body language,</p>
<p>让计算机理解用户的身体语言</p>
<p>and what hand gestures they're frantically waving at their internet connected microwave.</p>
<p>比如用户给联网微波炉的手势</p>
<p>As we've talked about many times in this series,</p>
<p>正如系列中常说的，</p>
<p>abstraction is the key to building complex systems,</p>
<p>抽象是构建复杂系统的关键</p>
<p>and the same is true in computer vision.</p>
<p>计算机视觉也是一样</p>
<p>At the hardware level, you have engineers building better and better cameras,</p>
<p>硬件层面，有工程师在造更好的摄像头，</p>
<p>giving computers improved sight with each passing year,</p>
<p>让计算机有越来越好的视力</p>
<p>which I can't say for myself.</p>
<p>我自己的视力却不能这样</p>
<p>Using that camera data,</p>
<p>用来自摄像头的数据</p>
<p>you have computer vision algorithms crunching pixels to find things like faces and hands.</p>
<p>可以用视觉算法找出脸和手</p>
<p>And then, using output from those algorithms,</p>
<p>然后可以用其他算法接着处理，</p>
<p>you have even more specialized algorithms for interpreting things</p>
<p>解释图片中的东西</p>
<p>like user facial expression and hand gestures.</p>
<p>比如用户的表情和手势</p>
<p>On top of that, there are people building novel interactive experiences,</p>
<p>有了这些，人们可以做出新的交互体验</p>
<p>like smart TVs and intelligent tutoring systems,</p>
<p>比如智能电视和智能辅导系统，</p>
<p>that respond to hand gestures and emotion.</p>
<p>会根据用户的手势和表情来回应</p>
<p>Each of these levels are active areas of research,</p>
<p>这里的每一层都是活跃的研究领域</p>
<p>with breakthroughs happening every year.</p>
<p>每年都有突破，</p>
<p>And that's just the tip of the iceberg.</p>
<p>这只是冰山一角</p>
<p>Today, computer vision is everywhere</p>
<p>如今计算机视觉无处不在</p>
<p>whether it's barcodes being scanned at stores,</p>
<p>商店里扫条形码，</p>
<p>self-driving cars waiting at red lights,</p>
<p>等红灯的自动驾驶汽车</p>
<p>or snapchat filters superimposing mustaches.</p>
<p>或是 Snapchat 里添加胡子的滤镜</p>
<p>And, the most exciting thing is that computer scientists are really just getting started,</p>
<p>令人兴奋的是一切才刚刚开始</p>
<p>enabled by recent advances in computing, like super fast GPUs.</p>
<p>最近的技术发展，比如超快的GPU，会开启越来越多可能性</p>
<p>Computers with human-like ability to see is going to totally change how we interact with them.</p>
<p>视觉能力达到人类水平的计算机，会彻底改变交互方式</p>
<p>Of course, it'd also be nice if they could hear and speak,</p>
<p>当然，如果计算机能听懂我们然后回话，就更好了</p>
<p>which we'll discuss next week. I'll see you then.</p>
<p>我们下周讨论到时见</p>
<p>36 自然语言处理</p>
<p>Natural Language Processing</p>
<p>Hi, I'm Carrie Anne, and welcome to Crash Course Computer Science!</p>
<p>嗨我是Carrie Anne，欢迎收看计算机科学速成课</p>
<p>Last episode we talked about computer vision</p>
<p>上集我们讨论了计算机视觉 </p>
<p>giving computers the ability to see and understand visual information.</p>
<p>让电脑能看到并理解</p>
<p>Today we're going to talk about how to give computers the ability to understand language.</p>
<p>今天我们讨论怎么让计算机理解语言</p>
<p>You might argue they've always had this capability.</p>
<p>你可能会说：计算机已经有这个能力了</p>
<p>Back in Episodes 9 and 12,</p>
<p>在第9和第12集</p>
<p>we talked about machine language instructions,</p>
<p>我们聊了机器语言</p>
<p>as well as higher-level programming languages.</p>
<p>和更高层次的编程语言</p>
<p>While these certainly meet the definition of a language,</p>
<p>虽然从定义来说它们也算语言</p>
<p>they also tend to have small vocabularies and follow highly structured conventions.</p>
<p>但词汇量一般很少，而且非常结构化</p>
<p>Code will only compile and run if it's 100 percent free of spelling and syntactic errors.</p>
<p>代码只能在拼写和语法完全正确时，编译和运行</p>
<p>Of course, this is quite different from human languages</p>
<p>当然，这和人类语言完全不同，</p>
<p>what are called natural languages -</p>
<p>人类语言叫"自然语言"</p>
<p>containing large, diverse vocabularies,</p>
<p>自然语言有大量词汇</p>
<p>words with several different meanings,</p>
<p>有些词有多种含义</p>
<p>speakers with different accents,</p>
<p>不同口音</p>
<p>and all sorts of interesting word play.</p>
<p>以及各种有趣的文字游戏</p>
<p>People also make linguistic faux pas when writing and speaking,</p>
<p>人们在写作和说话时也会犯错</p>
<p>like slurring words together, leaving out key details so things are ambiguous,</p>
<p>比如单词拼在一起发音，关键细节没说导致意思模糊两可</p>
<p>and mispronouncing things.</p>
<p>以及发错音</p>
<p>But, for the most part, humans can roll right through these challenges.</p>
<p>但大部分情况下，另一方能理解</p>
<p>The skillful use of language is a major part of what makes us human.</p>
<p>人类有强大的语言能力</p>
<p>And for this reason,</p>
<p>因此，</p>
<p>the desire for computers to understand and speak our language</p>
<p>让计算机拥有语音对话的能力</p>
<p>has been around since they were first conceived.</p>
<p>这个想法从构思计算机时就有了</p>
<p>This led to the creation of Natural Language Processing, or NLP,</p>
<p>"自然语言处理"因此诞生，简称 NLP</p>
<p>an interdisciplinary field combining computer science and linguistics.</p>
<p>结合了计算机科学和语言学的一个跨学科领域</p>
<p>There's an essentially infinite number of ways to arrange words in a sentence.</p>
<p>单词组成句子的方式有无限种</p>
<p>We can't give computers a dictionary of all possible sentences</p>
<p>我们没法给计算机一个字典，包含所有可能句子</p>
<p>to help them understand what humans are blabbing on about.</p>
<p>让计算机理解人类在嘟囔什么</p>
<p>So an early and fundamental NLP problem was deconstructing sentences into bite-sized pieces,</p>
<p>所以 NLP 早期的一个基本问题是，怎么把句子切成一块块</p>
<p>which could be more easily processed.</p>
<p>这样更容易处理</p>
<p>In school, you learned about nine fundamental types of English words:</p>
<p>上学时，老师教你英语单词有九种基本类型：</p>
<p>nouns, pronouns, articles, verbs, adjectives,</p>
<p>名词，代词，冠词，动词，形容词</p>
<p>adverbs, prepositions, conjunctions, and interjections.</p>
<p>副词，介词，连词和感叹词</p>
<p>These are called parts of speech.</p>
<p>这叫"词性"</p>
<p>There are all sorts of subcategories too,</p>
<p>还有各种子类，比如</p>
<p>like singular vs. plural nouns and superlative vs. comparative adverbs,</p>
<p>单数名词 vs 复数名词，副词最高级 vs 副词比较级</p>
<p>but we're not going to get into that.</p>
<p>但我们不会深入那些.</p>
<p>Knowing a word's type is definitely useful,</p>
<p>了解单词类型有用</p>
<p>but unfortunately, there are a lot words that have multiple meanings like "rose" and "leaves",</p>
<p>但不幸的是，很多词有多重含义比如 rose 和 leaves</p>
<p>which can be used as nouns or verbs.</p>
<p>可以用作名词或动词</p>
<p>A digital dictionary alone isn't enough to resolve this ambiguity,</p>
<p>仅靠字典，不能解决这种模糊问题</p>
<p>so computers also need to know some grammar.</p>
<p>所以电脑也要知道语法</p>
<p>For this, phrase structure rules were developed, which encapsulate the grammar of a language.</p>
<p>因此开发了 "短语结构规则" 来代表语法规则</p>
<p>For example, in English there's a rule</p>
<p>例如，英语中有一条规则</p>
<p>that says a sentence can be comprised of a noun phrase followed by a verb phrase.</p>
<p>句子可以由一个名词短语和一个动词短语组成</p>
<p>Noun phrases can be an article, like "the",</p>
<p>名词短语可以是冠词，如 the</p>
<p>followed by a noun or they can be an adjective followed by a noun.</p>
<p>然后一个名词，或一个形容词后面跟一个名词</p>
<p>And you can make rules like this for an entire language.</p>
<p>你可以给一门语言制定出一堆规则</p>
<p>Then, using these rules, it's fairly easy to construct what's called a parse tree,</p>
<p>用这些规则，可以做出"分析树"</p>
<p>which not only tags every word with a likely part of speech,</p>
<p>它给每个单词标了可能是什么词性</p>
<p>but also reveals how the sentence is constructed.</p>
<p>也标明了句子的结构</p>
<p>These smaller chunks of data allow computers to more easily access,</p>
<p>数据块更小 </p>
<p>process and respond to information.</p>
<p>更容易处理</p>
<p>Equivalent processes are happening every time you do a voice search,</p>
<p>每次语音搜索，都有这样的流程</p>
<p>like: "where's the nearest pizza".</p>
<p>比如 "最近的披萨在哪里"</p>
<p>The computer can recognize that this is a "where" question,</p>
<p>计算机能明白这是"哪里"（where）的问题</p>
<p>knows you want the noun "pizza",</p>
<p>知道你想要名词"披萨"（pizza）</p>
<p>and the dimension you care about is "nearest".</p>
<p>而且你关心的维度是"最近的"（nearest）</p>
<p>The same process applies to "what is the biggest giraffe?" or "who sang thriller?"</p>
<p>"最大的长颈鹿是什么？"或"Thriller是谁唱的？"，也是这样处理</p>
<p>By treating language almost like lego,</p>
<p>把语言像乐高一样拆分，</p>
<p>computers can be quite adept at natural language tasks.</p>
<p>方便计算机处理</p>
<p>They can answer questions and also process commands,</p>
<p>计算机可以回答问题以及处理命令</p>
<p>like "set an alarm for 2:20"</p>
<p>比如"设 2:20 的闹钟"</p>
<p>or "play T-Swizzle on spotify".</p>
<p>或"用 Spotify 播放 T-Swizzle"</p>
<p>But, as you've probably experienced, they fail when you start getting too fancy,</p>
<p>但你可能体验过，如果句子复杂一点</p>
<p>and they can no longer parse the sentence correctly, or capture your intent.</p>
<p>计算机就没法理解了</p>
<p>Hey Siri... me thinks the mongols doth roam too much,</p>
<p>嘿Siri ...... 俺觉得蒙古人走得太远了</p>
<p>what think ye on this most gentle mid-summer's day?</p>
<p>在这个最温柔的夏日的日子里，你觉得怎么样？</p>
<p>Siri: I'm not sure I got that.</p>
<p>Siri：我没明白</p>
<p>I should also note that phrase structure rules, and similar methods that codify language,</p>
<p>还有，"短语结构规则"和其他把语言结构化的方法</p>
<p>can be used by computers to generate natural language text.</p>
<p>可以用来生成句子</p>
<p>This works particularly well when data is stored in a web of semantic information,</p>
<p>数据存在语义信息网络时，这种方法特别有效</p>
<p>where entities are linked to one another in meaningful relationships,</p>
<p>实体互相连在一起</p>
<p>providing all the ingredients you need to craft informational sentences.</p>
<p>提供构造句子的所有成分</p>
<p>Siri: Thriller was released in 1983 and sung by Michael Jackson</p>
<p>Siri：Thriller 于1983年发行，由迈克尔杰克逊演唱</p>
<p>Google's version of this is called Knowledge Graph.</p>
<p>Google 版的叫"知识图谱"</p>
<p>At the end of 2016,</p>
<p>在2016年底</p>
<p>it contained roughly seventy billion facts about, and relationships between, different entities.</p>
<p>包含大概七百亿个事实，以及不同实体间的关系</p>
<p>These two processes, parsing and generating text,</p>
<p>处理, 分析, 生成文字，</p>
<p>are fundamental components of natural language chatbots</p>
<p>是聊天机器人的最基本部件</p>
<p>computer programs that chat with you.</p>
<p>聊天机器人就是能和你聊天的程序</p>
<p>Early chatbots were primarily rule-based,</p>
<p>早期聊天机器人大多用的是规则.</p>
<p>where experts would encode hundreds of rules mapping what a user might say,</p>
<p>专家把用户可能会说的话，和机器人应该回复什么，</p>
<p>to how a program should reply.</p>
<p>写成上百个规则</p>
<p>Obviously this was unwieldy to maintain and limited the possible sophistication.</p>
<p>显然，这很难维护，而且对话不能太复杂.</p>
<p>A famous early example was ELIZA, created in the mid-1960s at MIT.</p>
<p>一个著名早期例子叫 Eliza，1960年代中期诞生于麻省理工学院</p>
<p>This was a chatbot that took on the role of a therapist,</p>
<p>一个治疗师聊天机器人</p>
<p>and used basic syntactic rules to identify content in written exchanges,</p>
<p>它用基本句法规则来理解用户打的文字</p>
<p>which it would turn around and ask the user about.</p>
<p>然后向用户提问</p>
<p>Sometimes, it felt very much like human-human communication,</p>
<p>有时候会感觉像和人类沟通一样</p>
<p>but other times it would make simple and even comical mistakes.</p>
<p>但有时会犯简单甚至很搞笑的错误</p>
<p>Chatbots, and more advanced dialog systems,</p>
<p>聊天机器人和对话系统</p>
<p>have come a long way in the last fifty years, and can be quite convincing today!</p>
<p>在过去五十年发展了很多，如今可以和真人很像!</p>
<p>Modern approaches are based on machine learning,</p>
<p>如今大多用机器学习</p>
<p>where gigabytes of real human-to-human chats are used to train chatbots.</p>
<p>用上GB的真人聊天数据来训练机器人</p>
<p>Today, the technology is finding use in customer service applications,</p>
<p>现在聊天机器人已经用于客服回答</p>
<p>where there's already heaps of example conversations to learn from.</p>
<p>客服有很多对话可以参考</p>
<p>People have also been getting chatbots to talk with one another,</p>
<p>人们也让聊天机器人互相聊天</p>
<p>and in a Facebook experiment, chatbots even started to evolve their own language.</p>
<p>在 Facebook 的一个实验里，聊天机器人甚至发展出自己的语言</p>
<p>This experiment got a bunch of scary-sounding press,</p>
<p>很多新闻把这个实验报导的很吓人</p>
<p>but it was just the computers crafting a simplified protocol to negotiate with one another.</p>
<p>但实际上只是计算机，在制定简单协议来帮助沟通</p>
<p>It wasn't evil, it's was efficient.</p>
<p>这些语言不是邪恶的，而是为了效率</p>
<p>But what about if something is spoken</p>
<p>但如果听到一个句子</p>
<p>how does a computer get words from the sound?</p>
<p>计算机怎么从声音中提取词汇？</p>
<p>That's the domain of speech recognition,</p>
<p>这个领域叫"语音识别"</p>
<p>which has been the focus of research for many decades.</p>
<p>这个领域已经重点研究了几十年</p>
<p>Bell Labs debuted the first speech recognition system in 1952,</p>
<p>贝尔实验室在1952年推出了第一个语音识别系统</p>
<p>nicknamed Audrey, the automatic digit recognizer.</p>
<p>绰号 Audrey，自动数字识别器</p>
<p>It could recognize all ten numerical digits,</p>
<p>如果你说得够慢，</p>
<p>if you said them slowly enough.</p>
<p>它可以识别全部十位数字</p>
<p>The project didn't go anywhere</p>
<p>这个项目没有实际应用，</p>
<p>because it was much faster to enter telephone numbers with a finger.</p>
<p>因为手输快得多</p>
<p>Ten years later, at the 1962 World's Fair,</p>
<p>十年后，1962年的世界博览会上</p>
<p>IBM demonstrated a shoebox-sized machine capable of recognizing sixteen words.</p>
<p>IBM展示了一个鞋盒大小的机器，能识别16个单词</p>
<p>To boost research in the area,</p>
<p>为了推进"语音识别"领域的研究</p>
<p>DARPA kicked off an ambitious five-year funding initiative in 1971,</p>
<p>DARPA 在1971年启动了一项雄心勃勃的五年筹资计划</p>
<p>which led to the development of Harpy at Carnegie Mellon University.</p>
<p>之后诞生了卡内基梅隆大学的 Harpy</p>
<p>Harpy was the first system to recognize over a thousand words.</p>
<p>Harpy 是第一个可以识别1000个单词以上的系统</p>
<p>But, on computers of the era,</p>
<p>但那时的电脑</p>
<p>transcription was often ten or more times slower than the rate of natural speech.</p>
<p>语音转文字，经常比实时说话要慢十倍或以上</p>
<p>Fortunately, thanks to huge advances in computing performance in the 1980s and 90s,</p>
<p>幸运的是，1980,1990年代计算机性能的大幅提升</p>
<p>continuous, real-time speech recognition became practical.</p>
<p>实时语音识别变得可行</p>
<p>There was simultaneous innovation in the algorithms for processing natural language,</p>
<p>同时也出现了处理自然语言的新算法</p>
<p>moving from hand-crafted rules,</p>
<p>不再是手工定规则</p>
<p>to machine learning techniques</p>
<p>而是用机器学习</p>
<p>that could learn automatically from existing datasets of human language.</p>
<p>从语言数据库中学习</p>
<p>Today, the speech recognition systems with the best accuracy are using deep neural networks,</p>
<p>如今准确度最高的语音识别系统用深度神经网络</p>
<p>which we touched on in Episode 34.</p>
<p>我们在第34集讲过</p>
<p>To get a sense of how these techniques work,</p>
<p>为了理解原理</p>
<p>let's look at some speech, specifically,</p>
<p>我们来看一些对话声音</p>
<p>the acoustic signal.</p>
<p>我们来看一些对话声音</p>
<p>Let's start by looking at vowel sounds,</p>
<p>先看元音</p>
<p>like aaaaa and eeeeee.</p>
<p>比如 a 和 e</p>
<p>These are the waveforms of those two sounds, as captured by a computer's microphone.</p>
<p>这是两个声音的波形</p>
<p>As we discussed in Episode 21 on Files and File Formats -</p>
<p>我们在第21集（文件格式）说过</p>
<p>this signal is the magnitude of displacement,</p>
<p>这个信号来自 </p>
<p>of a diaphragm inside of a microphone, as sound waves cause it to oscillate.</p>
<p>麦克风内部隔膜震动的频率</p>
<p>In this view of sound data, the horizontal axis is time,</p>
<p>在这个视图中，横轴是时间</p>
<p>and the vertical axis is the magnitude of displacement, or amplitude.</p>
<p>竖轴是隔膜移动的幅度，或者说振幅</p>
<p>Although we can see there are differences between the waveforms,</p>
<p>虽然可以看到2个波形有区别</p>
<p>it's not super obvious what you would point at to say,</p>
<p>但不能看出</p>
<p>"ah ha! this is definitely an eeee sound".</p>
<p>"啊！这个声音肯定是 e"</p>
<p>To really make this pop out, we need to view the data in a totally different way:</p>
<p>为了更容易识别，我们换个方式看：</p>
<p>a spectrogram.</p>
<p>谱图</p>
<p>In this view of the data, we still have time along the horizontal axis,</p>
<p>这里横轴还是时间</p>
<p>but now instead of amplitude on the vertical axis,</p>
<p>但竖轴不是振幅</p>
<p>we plot the magnitude of the different frequencies that make up each sound.</p>
<p>而是不同频率的振幅</p>
<p>The brighter the color, the louder that frequency component.</p>
<p>颜色越亮，那个频率的声音越大</p>
<p>This conversion from waveform to frequencies is done with a very cool algorithm called</p>
<p>这种波形到频率的转换是用一种很酷的算法做的</p>
<p>a Fast Fourier Transform.</p>
<p>快速傅立叶变换（FFT）</p>
<p>If you've ever stared at a stereo system's EQ visualizer,</p>
<p>如果你盯过立体声系统的 EQ 可视化器</p>
<p>it's pretty much the same thing.</p>
<p>它们差不多是一回事</p>
<p>A spectrogram is plotting that information over time.</p>
<p>谱图是随着时间变化的</p>
<p>You might have noticed that the signals have a sort of ribbed pattern to them</p>
<p>你可能注意到，信号有种螺纹图案</p>
<p>that's all the resonances of my vocal tract.</p>
<p>那是我声道的回声</p>
<p>To make different sounds,</p>
<p>为了发出不同声音</p>
<p>I squeeze my vocal chords, mouth and tongue into different shapes,</p>
<p>我要把声带，嘴巴和舌头变成不同形状</p>
<p>which amplifies or dampens different resonances.</p>
<p>放大或减少不同的共振</p>
<p>We can see this in the signal, with areas that are brighter, and areas that are darker.</p>
<p>可以看到有些区域更亮，有些更暗</p>
<p>If we work our way up from the bottom, labeling where we see peaks in the spectrum</p>
<p>如果从底向上看，标出高峰</p>
<p>what are called formants -</p>
<p>叫"共振峰"  -</p>
<p>we can see the two sounds have quite different arrangements.</p>
<p>可以看到有很大不同</p>
<p>And this is true for all vowel sounds.</p>
<p>所有元音都是如此</p>
<p>It's exactly this type of information that lets computers recognize spoken vowels,</p>
<p>这让计算机可以识别元音</p>
<p>and indeed, whole words.</p>
<p>然后识别出整个词</p>
<p>Let's see a more complicated example,</p>
<p>让我们看一个更复杂的例子</p>
<p>like when I say: "she.. was.. happy"</p>
<p>当我说"她..很开心"的时候</p>
<p>We can see our "eee" sound here, and "aaa" sound here.</p>
<p>可以看到 e 声，和 a 声</p>
<p>We can also see a bunch of other distinctive sounds,</p>
<p>以及其它不同声音</p>
<p>like the "shh" sound in "she",</p>
<p>比如 she 中的 shh 声</p>
<p>the "wah" and "sss" in "was", and so on.</p>
<p>was 中的 wah 和 sss，等等</p>
<p>These sound pieces, that make up words,</p>
<p>这些构成单词的声音片段</p>
<p>are called phonemes.</p>
<p>叫"音素"</p>
<p>Speech recognition software knows what all these phonemes look like.</p>
<p>语音识别软件知道这些音素</p>
<p>In English, there are roughly forty-four,</p>
<p>英语有大概44种音素</p>
<p>so it mostly boils down to fancy pattern matching.</p>
<p>所以本质上变成了音素识别</p>
<p>Then you have to separate words from one another,</p>
<p>还要把不同的词分开</p>
<p>figure out when sentences begin and end...</p>
<p>弄清句子的开始和结束点</p>
<p>and ultimately, you end up with speech converted into text,</p>
<p>最后把语音转成文字</p>
<p>allowing for techniques like we discussed at the beginning of the episode.</p>
<p>使这集视频开头里讨论的那些技术成为可能</p>
<p>Because people say words in slightly different ways,</p>
<p>因为口音和发音错误等原因</p>
<p>due to things like accents and mispronunciations,</p>
<p>人们说单词的方式略有不同</p>
<p>transcription accuracy is greatly improved when combined with a language model,</p>
<p>所以结合语言模型后，语音转文字的准确度会大大提高</p>
<p>which contains statistics about sequences of words.</p>
<p>里面有单词顺序的统计信息</p>
<p>For example "she was" is most likely to be followed by an adjective, like "happy".</p>
<p>比如："她"后面很可能跟一个形容词，比如"很开心"</p>
<p>It's uncommon for "she was" to be followed immediately by a noun.</p>
<p>"她"后面很少是名词</p>
<p>So if the speech recognizer was unsure between, "happy" and "harpy",</p>
<p>如果不确定是 happy 还是 harpy，会选 happy</p>
<p>it'd pick "happy",</p>
<p>如果不确定是 happy 还是 harpy，会选 happy</p>
<p>since the language model would report that as a more likely choice.</p>
<p>因为语言模型认为可能性更高</p>
<p>Finally, we need to talk about Speech Synthesis,</p>
<p>最后, 我们来谈谈 "语音合成"</p>
<p>that is, giving computers the ability to output speech.</p>
<p>让计算机输出语音</p>
<p>This is very much like speech recognition, but in reverse.</p>
<p>它很像语音识别，不过反过来</p>
<p>We can take a sentence of text, and break it down into its phonetic components,</p>
<p>把一段文字，分解成多个声音</p>
<p>and then play those sounds back to back, out of a computer speaker.</p>
<p>然后播放这些声音</p>
<p>You can hear this chaining of phonemes very clearly with older speech synthesis technologies,</p>
<p>早期语音合成技术，可以清楚听到音素是拼在一起的</p>
<p>like this 1937, hand-operated machine from Bell Labs.</p>
<p>比如这个1937年贝尔实验室的手动操作机器</p>
<p>Say, "she saw me" with no expression.</p>
<p>不带感情的说"她看见了我"</p>
<p>She saw me.</p>
<p>她看见了我</p>
<p>Now say it in answer to these questions.</p>
<p>现在回答问题</p>
<p>Who saw you?</p>
<p>谁看见你了？</p>
<p>She saw me.</p>
<p>她看见了我</p>
<p>Who did she see?</p>
<p>她看到了谁？</p>
<p>She saw me.</p>
<p>她看见了我</p>
<p>Did she see you or hear you?</p>
<p>她看到你还是听到你说话了？</p>
<p>She saw me.</p>
<p>她看见了我</p>
<p>By the 1980s, this had improved a lot,</p>
<p>到了1980年代，技术改进了很多</p>
<p>but that discontinuous and awkward blending of phonemes</p>
<p>但音素混合依然不够好，</p>
<p>still created that signature, robotic sound.</p>
<p>产生明显的机器人声</p>
<p>Thriller was released in 1983 and sung by Michael Jackson.</p>
<p>Thriller 于1983年发行，迈克尔·杰克逊演唱.</p>
<p>Today, synthesized computer voices, like Siri, Cortana and Alexa,</p>
<p>如今，电脑合成的声音，比如 Siri, Cortana, Alexa</p>
<p>have gotten much better, but they're still not quite human.</p>
<p>好了很多，但还不够像人</p>
<p>But we're soo soo close,</p>
<p>但我们非常非常接近了</p>
<p>and it's likely to be a solved problem pretty soon.</p>
<p>这个问题很快会被解决</p>
<p>Especially because we're now seeing an explosion of voice user interfaces on our phones,</p>
<p>现在语音界面到处都是，手机里</p>
<p>in our cars and homes, and maybe soon, plugged right into our ears.</p>
<p>汽车里，家里，也许不久之后耳机也会有.</p>
<p>This ubiquity is creating a positive feedback loop,</p>
<p>这创造一个正反馈循环</p>
<p>where people are using voice interaction more often,</p>
<p>人们用语音交互的频率会提高</p>
<p>which in turn, is giving companies like Google, Amazon and Microsoft</p>
<p>这又给了谷歌，亚马逊，微软等公司</p>
<p>more data to train their systems on.</p>
<p>更多数据来训练语音系统.</p>
<p>Which is enabling better accuracy,</p>
<p>提高准确性</p>
<p>which is leading to people using voice more,</p>
<p>准确度高了，人们更愿意用语音交互</p>
<p>which is enabling even better accuracy and the loop continues!</p>
<p>越用越好，越好越用</p>
<p>Many predict that speech technologies will become as common a form of interaction</p>
<p>很多人预测，语音交互会越来越常见</p>
<p>as screens, keyboards, trackpads and other physical input-output devices that we use today.</p>
<p>就像如今的屏幕，键盘，触控板等设备</p>
<p>That's particularly good news for robots,</p>
<p>这对机器人发展是个好消息</p>
<p>who don't want to have to walk around with keyboards in order to communicate with humans.</p>
<p>机器人就不用走来走去时带个键盘和人类沟通</p>
<p>But, we'll talk more about them next week. See you then.</p>
<p>下周我们讲机器人.  到时见</p>
<p>37 机器人</p>
<p>Robots</p>
<p>Hi, I’m Carrie Anne, and welcome to Crash Course Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机速成课</p>
<p>Today we’re going to talk about robots.</p>
<p>今天我们要讨论机器人</p>
<p>The first image that jumps to your mind is probably a humanoid robot,</p>
<p>你脑中冒出来的第一个印象估计是类人机器人</p>
<p>like we usually see in shows or movies.</p>
<p>经常在电视剧和电影里看到.</p>
<p>Sometimes they’re our friends and colleagues,</p>
<p>有时候它们是朋友和同事</p>
<p>but more often, they're sinister, apathetic and battle-hardened.</p>
<p>但更常见的是阴险无情，身经百战</p>
<p>We also tend to think of robots as a technology of the future.</p>
<p>我们经常把机器人看成未来科技</p>
<p>But the reality is: they’re already here – by the millions</p>
<p>但事实是：机器人时代已经来临了</p>
<p>and they're our workmates,</p>
<p>它们是同事</p>
<p>helping us to do things harder, better, faster, and stronger.</p>
<p>帮我们把困难的工作，做得更快更好</p>
<p>There are many definitions for robots, but in general,</p>
<p>机器人的定义有很多种，但总的来说，</p>
<p>these are machines capable of carrying out a series of actions automatically</p>
<p>机器人由计算机控制，可以自动执行一系列动作的机器</p>
<p>guided by computer control.</p>
<p>机器人由计算机控制，可以自动执行一系列动作的机器</p>
<p>How they look isn’t part of the equation –</p>
<p>外观并不重要</p>
<p>robots can be industrial arms that spray paint cars,</p>
<p>可以是给汽车喷漆的机械臂</p>
<p>drones that fly, snake-like medical robots that assist surgeons,</p>
<p>无人机，或辅助外科医生的蛇状机器人</p>
<p>as well as humanoid robotic assistants.</p>
<p>以及人形机器人</p>
<p>Although the term "robot" is sometimes</p>
<p>有时我们叫</p>
<p>applied to interactive virtual characters,</p>
<p>虚拟人物"机器人"</p>
<p>it’s more appropriate to call these "bots", or even better, "agents."</p>
<p>但叫 bot 甚至 agent 会更合适</p>
<p>That’s because the term "robot" carries a physical connotation</p>
<p>因为"机器人"的潜在含义是</p>
<p>a machine that lives in and acts on the real world.</p>
<p>存在于现实世界中的机器</p>
<p>The word "robot" was first used in a 1920 Czech play</p>
<p>robot (机器人) 一词，首次出现在1920年的一部捷克戏剧</p>
<p>to denote artificial, humanoid characters.</p>
<p>代表人造的类人角色</p>
<p>The word was derived from "robota", the slavic-language word for a forced laborer,</p>
<p>robot 源于斯拉夫语词汇 robota ，代表强迫劳动</p>
<p>indicating peasants in compulsory service in feudal, nineteenth century Europe.</p>
<p>The play didn’t go too much into technological details.</p>
<p>戏剧没讲太多技术细节</p>
<p>But, even a century later, it’s still a common portrayal:</p>
<p>但即使一个世纪后，这种描述依然很普遍：</p>
<p>mass-produced, efficient, tireless creatures that look human-esque,</p>
<p>机器人都是大规模生产，高效不知疲倦，看起来像人的东西</p>
<p>but are emotionless, indifferent to self-preservation and lack creativity.</p>
<p>但毫无情感，不会保护自己，没有创造力</p>
<p>The more general idea of self-operating machines</p>
<p>更广义的自动运行机器，</p>
<p>goes back even further than the 1920s.</p>
<p>早在1920年代前就有了</p>
<p>Many ancient inventors created mechanical devices that</p>
<p>很多古代发明家，发明了能自动运行的机械装置</p>
<p>performed functions automatically,</p>
<p>很多古代发明家，发明了能自动运行的机械装置</p>
<p>like keeping the time and striking bells on the hour.</p>
<p>比如计时和定时敲钟</p>
<p>There are plenty of examples of automated animal and humanoid figures,</p>
<p>有很多装置有动物和人类的形象，</p>
<p>that would perform dances, sing songs, strike drums and do other physical actions.</p>
<p>能跳舞，唱歌，打鼓等</p>
<p>These non-electrical and certainly non-electronic machines were called automatons.</p>
<p>这些不用电，而且肯定没有电子部件的机器，叫"自动机"</p>
<p>For instance, an early automaton created in 1739</p>
<p>举个例子，1739年法国人 Jacques de Vaucans </p>
<p>by the Frenchman Jacques de Vaucanson</p>
<p>做了个自动机</p>
<p>was the Canard Digerateur or Digesting Duck,</p>
<p>法语叫 Canard Digerateur，翻译过来是 "吃饭鸭"</p>
<p>a machine in the shape of a duck that appeared</p>
<p>一个像鸭子的机器，</p>
<p>to eat grain and then defecate.</p>
<p>能吃东西然后排便</p>
<p>In 1739 Voltaire wrote,</p>
<p>伏尔泰在1739年写</p>
<p>"Without the voice of le Maure and Vaucanson’s duck,</p>
<p>"如果没有吃饭鸭的声音</p>
<p>you would have nothing to remind you of the glory of France."</p>
<p>还有什么能提醒你法国的荣光呢？"</p>
<p>One of the most infamous examples was the "Mechanical Turk":</p>
<p>一个名声很臭的例子是"土耳其行棋傀儡"</p>
<p>a chess-playing, humanoid automaton.</p>
<p>一个能下国际象棋的人形机器人</p>
<p>After construction in 1770, it toured all over Europe,</p>
<p>在1770年建造完成后，就在欧洲各地展览</p>
<p>wowing audiences with its surprisingly good chess-playing.</p>
<p>好棋艺惊叹观众</p>
<p>It appeared to be a mechanical, artificial intelligence.</p>
<p>像某种机械人工智能</p>
<p>Unfortunately, it was a hoax – there was a dainty human stuffed inside the machine.</p>
<p>不幸的是，这是个骗局机器里有人控制</p>
<p>The first machines controlled by computers emerged in the late 1940s.</p>
<p>第一台计算机控制的机器，出现在1940年代晚期</p>
<p>These Computer Numerical Control, or CNC machines,</p>
<p>这些计算机数控的机器，简称 CNC 机器</p>
<p>could run programs that instructed a machine to perform a series of operations.</p>
<p>可以执行一连串程序指定的操作</p>
<p>This level of control also enabled the creation of new manufactured goods,</p>
<p>精细的控制让我们能生产之前很难做的物品</p>
<p>like milling a complex propellor design out of a block of aluminum</p>
<p>比如从一整块铝加工出复杂的螺旋桨</p>
<p>something that was difficult to do using standard machine tools,</p>
<p>这用普通机械工具很难做到</p>
<p>and with tolerances too small to be done by hand.</p>
<p>并且误差容忍度很小，无法手工加工</p>
<p>CNC machines were a huge boon to industry,</p>
<p>CNC 机器大大推进了制造业</p>
<p>not just due to increased capability and precision,</p>
<p>不仅提高了制造能力和精确度还</p>
<p>but also in terms of reducing labor costs by automating human jobs</p>
<p>还降低了生产成本</p>
<p>a topic we'll revisit in a later episode.</p>
<p>我们之后会深入讨论这个（第40集）</p>
<p>The first commercial deployment was a programmable industrial robot</p>
<p>第一个商业贩卖的可编程工业机器人</p>
<p>called the Unimate, sold to General Motors in 1960</p>
<p>叫 Unimate，于1960年卖给通用汽车公司</p>
<p>to lift hot pieces of metal from a die casting machine and stack them.</p>
<p>它可以把压铸机做出来的热金属成品提起来，然后堆起来</p>
<p>This was the start of the robotics industry.</p>
<p>机器人行业由此开始</p>
<p>Soon, robots were stacking pallets, welding parts, painting cars and much more.</p>
<p>很快，机器人开始堆叠货盘，焊接，给汽车喷漆等等</p>
<p>For simple motions – like a robotic gripper that moves back and forth on a track</p>
<p>对于简单运动比如机器爪子在轨道上来回移动</p>
<p>a robot can be instructed to move to a particular position,</p>
<p>可以指示它移动到特定位置</p>
<p>and it'll keep moving in that direction until the desired position is reached</p>
<p>它会一直朝那个方向移动，</p>
<p>at which point it’ll stop.</p>
<p>直到到达，然后停下来</p>
<p>This behavior can be achieved through a simple control loop.</p>
<p>这种行为可以用简单控制回路做</p>
<p>First, sense the robot position.</p>
<p>首先，判断机器人的位置</p>
<p>Are we there yet?</p>
<p>我们到了吗？</p>
<p>Nope.</p>
<p>没有</p>
<p>So keep moving.</p>
<p>那么继续前进</p>
<p>Now sense position again.</p>
<p>再次判断位置</p>
<p>Are we there yet?</p>
<p>我们到了吗？</p>
<p>Nope, so keep moving.</p>
<p>没有，所以继续前进</p>
<p>Are we there yet?</p>
<p>我们到了吗？</p>
<p>Yes!</p>
<p>是的!</p>
<p>So we can stop moving, and also please be quiet!</p>
<p>现在可以停下来了，别问了！</p>
<p>Because we’re trying to minimize the distance between</p>
<p>因为我们在不断缩小 </p>
<p>the sensed position and the desired position,</p>
<p>当前位置和目标位置的距离</p>
<p>this control loop is, more specifically, a negative feedback loop.</p>
<p>这个控制回路更准确的叫"负反馈回路"</p>
<p>A negative feedback control loop has three key pieces.</p>
<p>负反馈回路有三个重要部分</p>
<p>There’s a sensor, that measures things in the real world,</p>
<p>首先是一个传感器，可以测量现实中的东西</p>
<p>like water pressure, motor position, air temperature,</p>
<p>比如水压，马达位置，气温，</p>
<p>or whatever you’re trying to control.</p>
<p>或任何你想控制的东西</p>
<p>From this measurement, we calculate how far we are from</p>
<p>根据传感器，计算和目标值相差多大</p>
<p>where we want to be – the error.</p>
<p>得到一个"错误"</p>
<p>The error is then interpreted by a controller,</p>
<p>然后"控制器"会处理这个"错误"</p>
<p>which decides how to instruct the system to minimize that error.</p>
<p>决定怎么减小错误</p>
<p>Then, the system acts on the world though pumps, motors,</p>
<p>然后用泵，电机，加热元件，</p>
<p>heating elements, and other physical actuators.</p>
<p>或其他物理组件来做出动作</p>
<p>In tightly controlled environments, simple control loops, like this, work OK.</p>
<p>在严格控制的环境中，这种简单控制回路也够用了</p>
<p>But in many real world applications, things are a tad more complicated.</p>
<p>但在很多现实应用中，情况复杂得多</p>
<p>Imagine that our gripper is really heavy, and even when the control loop says to stop,</p>
<p>假设爪子很重，哪怕控制回路叫停了</p>
<p>momentum causes the gripper to overshoot the desired position.</p>
<p>惯性让爪子超过了预期位置</p>
<p>That would cause the control loop to take over again,</p>
<p>然后控制回路又开始运行</p>
<p>this time backing the gripper up.</p>
<p>叫爪子移动回去</p>
<p>A badly tuned control loop might overshoot and overshoot and overshoot,</p>
<p>一个糟糕的控制回路可能会让爪子不断来回移动</p>
<p>and maybe even wobble forever.</p>
<p>甚至永远循环</p>
<p>To make matters worse, in real world settings,</p>
<p>更糟糕的是，现实世界中</p>
<p>there are typically external and variable forces acting on a robot,</p>
<p>机器人会受到各种外力影响</p>
<p>like friction, wind and items of different weight.</p>
<p>比如摩擦力，风，等等</p>
<p>To handle this gracefully, more sophisticated control logic is needed.</p>
<p>为了处理这些外力，我们需要更复杂的控制逻辑</p>
<p>A widely used control-loop, feedback mechanism is a</p>
<p>一个使用广泛的机制，有控制回路和反馈机制。</p>
<p>proportional–integral–derivative controller.</p>
<p>叫 "比例-积分-微分控制器"</p>
<p>That’s a bit of a mouthful, so people call them PID controllers.</p>
<p>这个有点绕口，所以一般简称 "PID控制器"</p>
<p>These used to be mechanical devices, but now it’s all done in software.</p>
<p>它以前是机械设备，现在全是纯软件了</p>
<p>Let’s imagine a robot that delivers coffee.</p>
<p>想象有一个机器人，端咖啡给客人</p>
<p>Its goal is to travel between customers at two meters per second,</p>
<p>设计目标是每秒两米的速度在顾客间穿行</p>
<p>which has been determined to be the ideal speed</p>
<p>这个速度是理想速度</p>
<p>that’s both safe and expedient.</p>
<p>安全又合适</p>
<p>Of course, the environment doesn’t always cooperate.</p>
<p>当然，环境是会变化的</p>
<p>Sometimes there’s wind, and sometimes there's uphills and downhills</p>
<p>有时候有风，有时候有上坡下坡</p>
<p>and all sorts of things that affect the speed of the robot.</p>
<p>以及其他影响机器人速度的因素</p>
<p>So, it’s going to have to increase and decrease power</p>
<p>所以，给马达的动力要加大或减少，</p>
<p>to its motors to maintain the desired speed.</p>
<p>以保持目标速度</p>
<p>Using the robot's speed sensor, we can keep track of its</p>
<p>用机器人的速度传感器，我们可以</p>
<p>actual speed and plot that alongside its desired speed.</p>
<p>把当前速度和目标速度画张图</p>
<p>PID controllers calculate three values from this data.</p>
<p>PID 控制器根据这些数据，算出3个值</p>
<p>First is the proportional value, which is the difference between</p>
<p>首先是"比例值"，</p>
<p>the desired value and the actual value</p>
<p>就是"实际值"和"理想值"差多少</p>
<p>at the most recent instant in time or the present.</p>
<p>"实际值"可能有一定滞后，或者是实时的。</p>
<p>This is what our simpler control loop used before.</p>
<p>之前的简单控制回路，用的就是这个值</p>
<p>The bigger the gap between actual and desired,</p>
<p>"实际值"和"理想值"的差距越大，</p>
<p>the harder you'll push towards your target.</p>
<p>就越用力</p>
<p>In other words, it’s proportional control.</p>
<p>换句话说，它是"比例控制"的</p>
<p>Next, the integral value is computed,</p>
<p>接下来，算"积分值"</p>
<p>which is the sum of error over a window of time,</p>
<p>就是一段时间内误差的总和</p>
<p>like the last few seconds.</p>
<p>比如最近几秒</p>
<p>This look back helps compensate for steady state errors,</p>
<p>帮助弥补误差</p>
<p>resulting from things like motoring up a long hill.</p>
<p>比如上坡时可能就会产生误差</p>
<p>If this value is large, it means proportional control is not enough,</p>
<p>如果这个值很大，说明比例控制不够，</p>
<p>and we have to push harder still.</p>
<p>要继续用力前进</p>
<p>Finally, there’s the derivative value,</p>
<p>最后有"导数值"</p>
<p>which is the rate of change between the desired and actual values.</p>
<p>是期望值与实际值之间的变化率</p>
<p>This helps account for possible future error,</p>
<p>有助于解决未来可能出现的错误，</p>
<p>and is sometimes called "anticipatory control".</p>
<p>有时也叫"预期控制"</p>
<p>For example, if you are screaming in towards your goal too fast,</p>
<p>比如前进的太快</p>
<p>you'll need to ease up a little to prevent overshoot.</p>
<p>要稍微放松一点，避免冲过头</p>
<p>These three values are summed together, with different relative weights,</p>
<p>这三个值会一起使用，它们有不同权重</p>
<p>to produce a controller output that’s passed to the system.</p>
<p>然后用来控制系统</p>
<p>PID controllers are everywhere,</p>
<p>PID 控制器到处都是</p>
<p>from the cruise control in your car,</p>
<p>比如汽车里的巡航控制</p>
<p>to drones that automatically adjust their rotor speeds to maintain level flight,</p>
<p>无人机调整螺旋桨速度，以保持水平</p>
<p>as well as more exotic robots,</p>
<p>以及一些更奇怪的机器人，</p>
<p>like this one that balances on a ball to move around.</p>
<p>比如这个用球来平衡和移动的机器人</p>
<p>Advanced robots often require many control loops running in parallel,</p>
<p>更高级的机器人一般需要多个控制回路同时运行</p>
<p>working together, managing everything from robot balance to limb position.</p>
<p>来保持机器人平衡，调整肢体位置，等等</p>
<p>As we’ve discussed, control loops are responsible for</p>
<p>之前说过，控制回路负责</p>
<p>getting robot attributes  like location to desired values.</p>
<p>把机器人的属性（比如当前位置）变成期望值</p>
<p>So, you may be wondering where these values come from.</p>
<p>你可能好奇这些值是哪里来的</p>
<p>This is the responsibility of higher-level robot software,</p>
<p>这是更高层软件的责任</p>
<p>which plans and executes robot actions,</p>
<p>软件负责做出计划并让机器人执行动作，</p>
<p>like plotting a path around sensed obstacles, or breaking down physical tasks,</p>
<p>比如制定一条路线来绕过障碍物，或者把任务分成一步步</p>
<p>like picking up a ball, into simple, sequential motions.</p>
<p>比如把拿起一个球，分解成一个个简单连续动作</p>
<p>Using these techniques, robots have racked up some impressive achievements</p>
<p>用这些技术，机器人已经取得不少令人印象深刻的成就</p>
<p>they've been to the deepest depths of Earth's oceans</p>
<p>它们潜到了海洋最深处</p>
<p>and roved around on Mars for over a decade.</p>
<p>在火星上跑了十几年</p>
<p>But interestingly, lots of problems that are trivial for many humans</p>
<p>但有趣的是，许多对人类来说很简单的任务</p>
<p>have turned out to be devilishly difficult for robots:</p>
<p>对机器人很困难：</p>
<p>like walking on two legs, opening a door, picking up objects</p>
<p>比如两条腿走路，开门，拿东西时不要捏碎了</p>
<p>without crushing them, putting on a t-shirt, or petting a dog.</p>
<p>或是穿T恤，或是摸狗</p>
<p>These are tasks you may be able to do without thinking,</p>
<p>这些你可能想都不用想</p>
<p>but a supercomputer-powered robot fails at spectacularly.</p>
<p>但有超级计算机能力的机器人却做不到</p>
<p>These sorts of tasks are all active areas of robotics research.</p>
<p>机器人研究领域在全力解决这些问题</p>
<p>Artificial intelligence techniques,</p>
<p>人工智能</p>
<p>which we discussed a few episodes ago, are perhaps</p>
<p>我们前几集聊过的</p>
<p>the most promising avenue to overcome these challenges.</p>
<p>最有可能解决这些问题</p>
<p>For example, Google has been running an experiment</p>
<p>例如，谷歌在进行一项实验</p>
<p>with a series of robotic arms that spend their days</p>
<p>让一堆机器人手臂把各种东西</p>
<p>moving miscellaneous objects from one box to another, learning from trial and error.</p>
<p>从一个盒子拿到另一个盒子，不断试错学习</p>
<p>After thousands of hours of practice, the robots had cut their error rate in half.</p>
<p>经过数千小时的练习，机器人把错误率降低了一半</p>
<p>Of course, unlike humans, robots can run twenty-four hours a day</p>
<p>不像人类，机器人可以24小时全天运行</p>
<p>and practice with many arms at the same time.</p>
<p>而且多个手臂同时练习</p>
<p>So, it may just be a matter of time until they become adept at grasping things.</p>
<p>所以机器人擅长抓东西只是时间问题</p>
<p>But, for the time being, toddlers can out-grasp them.</p>
<p>但现在，小婴儿都比机器人更会抓东西</p>
<p>One of the biggest and most visible robotic breakthrough</p>
<p>近年最大的突破之一</p>
<p>in recent years has been self-driving, autonomous cars.</p>
<p>是无人驾驶汽车</p>
<p>If you think about it, cars don’t have too many system inputs</p>
<p>如果你仔细想想，汽车没几个输入</p>
<p>you can speed up or slow down, and you can steer left or right.</p>
<p>只是加速减速，左转右转</p>
<p>The tough part is sensing lanes, reading signs,</p>
<p>难的问题是判断车道，理解路标</p>
<p>and anticipating and navigating traffic, pedestrians,</p>
<p>预测车流，车流中穿行，留心行人和骑自行车的。</p>
<p>bicyclists, and a whole host of obstacles.</p>
<p>以及各种障碍</p>
<p>In addition to being studded with proximity sensors,</p>
<p>车上布满了传感器</p>
<p>these robotic vehicles heavily rely</p>
<p>无人驾驶汽车非常依赖</p>
<p>on Computer Vision algorithms, which we discussed in Episode 35.</p>
<p>计算机视觉算法，我们在第35集讨论过</p>
<p>We’re also seeing the emergence of very primitive androids</p>
<p>现在也开始出现类人机器人</p>
<p>robots that look and act like humans.</p>
<p>外貌和行为像人类的机器人</p>
<p>Arguably, we’re not close on either of those goals,</p>
<p>不过现在两个目标都没接近（外貌和行为）</p>
<p>as they tend to look pretty weird and act even weirder.</p>
<p>因为看起来一般怪怪的，行为也怪怪的.</p>
<p>At least we’ll always have Westworld.</p>
<p>但至少有《西部世界》可以看看</p>
<p>But anyway, these remain a tantalizing goal for roboticists</p>
<p>无论如何，对机器人研究者来说，</p>
<p>combine many computer science topics</p>
<p>把各种技术结合起来</p>
<p>we’ve touched on over the last few episodes, like artificial intelligence,</p>
<p>比如人工智能，计算机视觉和自然语言处理</p>
<p>computer vision and natural language processing.</p>
<p>来让机器人越来越像人，是个诱人的目标</p>
<p>As for why humans are so fascinated by</p>
<p>至于人类为什么如此着迷 </p>
<p>creating artificial embodiments of ourselves.</p>
<p>做出和我们一样的机器人</p>
<p>you'll have to go to Crash Course Philosophy for that.</p>
<p>你得去看《哲学速成课》</p>
<p>And for the foreseeable future,</p>
<p>在未来好一段时间里</p>
<p>realistic androids will continue to be the stuff of science fiction.</p>
<p>和人类一样的机器人依然只能存在科幻小说里。</p>
<p>Militaries also have a great interest in robots –</p>
<p>军队也对机器人很有兴趣 -</p>
<p>they're not only replaceable, but can surpass humans</p>
<p>因为机器人可以替换，</p>
<p>in attributes like strength, endurance, attention, and accuracy.</p>
<p>而且力量，耐力，注意力，准确性可以远超人类</p>
<p>Bomb disposal robots and reconnaissance drones are fairly common today.</p>
<p>拆弹机器人和无人侦察机如今很常见</p>
<p>But fully autonomous, armed-to-the-teeth robots are slowly appearing,</p>
<p>但完全自主决定，全副武装的机器人也在慢慢出现</p>
<p>like the Samsung SGR-A1 sentry gun deployed by South Korea.</p>
<p>比如韩国的三星 SGR-A1 哨兵炮</p>
<p>Robots with the intelligence and capability to take human lives</p>
<p>有智力并且可以杀人的机器人</p>
<p>are called lethal autonomous weapons.</p>
<p>叫 "致命自主武器"</p>
<p>And they’re widely considered a complex and thorny issue.</p>
<p>这种武器是复杂又棘手的问题</p>
<p>Without doubt, these systems could save soldiers lives</p>
<p>毫无疑问，它们可以把士兵从战场带离 </p>
<p>by taking them off the battlefield and out of harm’s way.</p>
<p>挽救生命</p>
<p>It might even discourage war all together.</p>
<p>甚至阻止战争的发生</p>
<p>Though it’s worth noting that people said the same thing</p>
<p>值得注意的是 </p>
<p>about dynamite and nuclear weapons.</p>
<p>人们对炸药和核弹也说过一样的话</p>
<p>On the flip side, we might be creating ruthlessly</p>
<p>另一方面，我们可能会不小心创造出，无情又高效的杀人机器</p>
<p>efficient killing machines that don't apply human judgment</p>
<p>没有人类般的判断力</p>
<p>or compassion to complex situations.</p>
<p>和同情心</p>
<p>And the fog of war is about as complex and murky as they come.</p>
<p>战争的硝烟会变得更加黑暗和复杂</p>
<p>These robots would be taking orders and executing them</p>
<p>机器人会接受命令</p>
<p>as efficiently as they can and sometimes</p>
<p>并高效执行</p>
<p>human orders turn out to be really bad.</p>
<p>但有时人类的命令是错的</p>
<p>This debate is going to continue for a long time,</p>
<p>这场辩论会持续很长时间，</p>
<p>and pundits on both sides will grow louder as robotic technology improves.</p>
<p>而且随着机器人技术的进步，两边的辩论会越来越激烈</p>
<p>It’s also an old debate –</p>
<p>这也是个老话题了</p>
<p>the danger was obvious to science fiction writer Isaac Asimov,</p>
<p>科幻作家艾萨克·阿西莫夫早预见了这种危险</p>
<p>who introduced a fictional "Three Laws of Robotics" in his 1942 short story "Runaround".</p>
<p>他在1942年短篇小说 Runaround 中写了"机器人三定律"</p>
<p>And then, later he added a zeroth rule.</p>
<p>之后又加了"定律0"</p>
<p>In short, it’s a code of conduct or moral compass for robots –</p>
<p>简单说这些定律指导机器人的行为准则或者说道德指南</p>
<p>guiding them to do no harm, especially to humans.</p>
<p>让机器人不要伤害，特别是不要伤害人类</p>
<p>It’s pretty inadequate for practical application and it leaves plenty of room for equivocation.</p>
<p>这些规则实践起来相当不足，并且有很多模糊的地方</p>
<p>But still, Asimov’s laws inspired a ton of science fiction and academic discussion,</p>
<p>但阿西莫夫三定律激发了大量科幻小说讨论和学术讨论，</p>
<p>and today there are whole conferences on robot ethics.</p>
<p>如今有专门讨论机器人伦理的会议</p>
<p>Importantly, Asimov crafted his fictional rules</p>
<p>重要的是，阿西莫夫写这些虚构规则</p>
<p>as a way to push back on "Robot as a Menace" memes</p>
<p>是为了反对 "机器人都很邪恶" 这种常见描述</p>
<p>common in fiction from his childhood.</p>
<p>他童年读的小说里，这样的场景很常见</p>
<p>These were stories where robots went off the rails,</p>
<p>机器人脱离控制，</p>
<p>harming or even destroying their creators in the process.</p>
<p>然后伤害甚至毁灭创造者</p>
<p>Asimov, on the other hand, envisioned robots as useful,</p>
<p>阿西莫夫认为机器人有用，</p>
<p>reliable, and even loveable machines.</p>
<p>可靠，甚至可以让人喜爱</p>
<p>And it’s this duality I want to leave you thinking about today.</p>
<p>我想让你思考这种两面性</p>
<p>Like many of the technologies we’ve discussed throughout this series,</p>
<p>我们讨论过的许多技术，</p>
<p>there are benevolent and malicious uses.</p>
<p>有好的一面也有坏的一面</p>
<p>Our job is to carefully reflect on computing's potential and peril,</p>
<p>我们要认真思考计算机的潜力和危害</p>
<p>and wield our inventive talents to improve the state of the world.</p>
<p>来改善这个世界</p>
<p>And robots are one of the most potent reminders of this responsibility.</p>
<p>而机器人最能提醒我们这一点了</p>
<p>I’ll see you next week.</p>
<p>我们 下周 见</p>
<p>38 计算机心理学</p>
<p>Psychology of Computing</p>
<p>Hi, I’m Carrie Anne, and welcome to Crash Course Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>So, over the course of this series,</p>
<p>在这个系列中，</p>
<p>we’ve focused almost exclusively on computers –</p>
<p>我们聊的话题几乎全是计算机</p>
<p>the circuits and algorithms that make them tick.</p>
<p>比如电路和算法</p>
<p>Because...this is Crash Course Computer Science.</p>
<p>毕竟这是*计算机*速成课</p>
<p>But ultimately, computers are tools employed by people.</p>
<p>但归根结底，计算机只是给人用的工具</p>
<p>And humans are… well… messy.</p>
<p>而人类有点... 乱</p>
<p>We haven’t been designed by human engineers from the ground up</p>
<p>人类不是被工程师设计的，</p>
<p>with known performance specifications.</p>
<p>没有具体性能规格</p>
<p>We can be logical one moment and irrational the next.</p>
<p>我们一会儿是理性的，一会儿是不理性的</p>
<p>Have you ever gotten angry at your navigation system? Surfed wikipedia aimlessly?</p>
<p>你有没有对导航生过气？或是漫无目的的刷维基百科？</p>
<p>Begged your internet browser to load faster?</p>
<p>求浏览器加载快点？</p>
<p>Nicknamed your roomba?</p>
<p>给扫地机器人取名？</p>
<p>These behaviors are quintessentially human!</p>
<p>这些是人类行为！</p>
<p>To build computer systems that are useful, usable and enjoyable,</p>
<p>为了做出使用愉快的计算机</p>
<p>we need to understand the strengths and weaknesses of both computers and humans.</p>
<p>我们需要了解计算机和人类的优缺点</p>
<p>And for this reason, when good system designers are creating software,</p>
<p>优秀的系统设计师在创造软件时</p>
<p>they employ social, cognitive, behavioral, and perceptual psychology principles.</p>
<p>会运用社会心理学，认知心理学，行为心理学，感知心理学的原理</p>
<p>No doubt you’ve encountered a physical or computer interface</p>
<p>你肯定见过难用的物理界面/计算机界面，</p>
<p>that was frustrating to use, impeding your progress.</p>
<p>阻碍你做事</p>
<p>Maybe it was so badly designed that you couldn’t figure it out and just gave up.</p>
<p>甚至糟糕到放弃使用</p>
<p>That interface had poor usability.</p>
<p>那个界面的"易用度"很差</p>
<p>Usability is the degree to which a human-made artifact – like software</p>
<p>"易用度"指的是人造物体，比如软件，</p>
<p>can be used to achieve an objective effectively and efficiently.</p>
<p>达到目的的效率有多高</p>
<p>To facilitate human work, we need to understand humans</p>
<p>为了帮助人类工作，我们需要了解人类，</p>
<p>from how they see and think, to how they react and interact.</p>
<p>怎么看，思考，反应和互动</p>
<p>For instance, the human visual system has been well studied by Psychologists.</p>
<p>举个例子，心理学家已经对，人类的视觉系统做了全面的研究</p>
<p>Like, we know that people are good at ordering intensities of colors.</p>
<p>我们知道人类擅长给颜色强度排序</p>
<p>Here are three.</p>
<p>这里有三个颜色</p>
<p>Can you arrange these from lightest to darkest?</p>
<p>你能从浅色到深色排序吗？</p>
<p>You probably don’t have to think too much about it.</p>
<p>你可以轻易做到</p>
<p>Because of this innate ability, color intensity is a great choice</p>
<p>所以颜色强度</p>
<p>for displaying data with continuous values.</p>
<p>很适合显示连续值</p>
<p>On the other hand, humans are terrible at ordering colors.</p>
<p>另一方面，人类很不擅长排序颜色</p>
<p>Here’s another example for you to put in order.</p>
<p>这是另一个例子</p>
<p>is orange before blue, or after blue?</p>
<p>把橙色放到蓝色前面还是后面？</p>
<p>Where does green go?</p>
<p>绿色放哪里？</p>
<p>You might be thinking we could order this by wavelength of light,</p>
<p>你可能想通过光的波长排序，</p>
<p>like a rainbow, but that’s a lot more to think about.</p>
<p>就像彩虹一样，但这样太累了</p>
<p>Most people are going to be much slower and error-prone at ordering.</p>
<p>大部分人会很慢而且容易出错</p>
<p>Because of this innate ineptitude of your visual system,</p>
<p>由于视觉系统天生是这样</p>
<p>displaying continuous data using colors can be a disastrous design choice.</p>
<p>所以用不同颜色显示连续性数据，是个糟糕的选择</p>
<p>You’ll find yourself constantly referring back to a color legend to compare items.</p>
<p>你得经常看表格来对比数据</p>
<p>However, colors are perfect for when the data is discrete with no ordering,</p>
<p>然而，如果数据没有顺序，用不同颜色就很合适</p>
<p>like categorical data.</p>
<p>比如分类数据</p>
<p>This might seem obvious, but you’d be amazed at</p>
<p>也许这些看起来很明显，</p>
<p>how many interfaces get basic things like this wrong.</p>
<p>但你会惊讶有多少设计把这些基本事情搞错</p>
<p>Beyond visual perception, understanding human cognition helps us</p>
<p>除了视觉，理解人类的认知系统能帮我们</p>
<p>design interfaces that align with how the mind works.</p>
<p>设计更好的界面</p>
<p>Like, humans can read, remember and process information more effectively</p>
<p>比如，如果信息分块了，会更容易读，更容易记</p>
<p>when it's chunked–that is, when items are put together into small, meaningful groups.</p>
<p>分块是指把信息分成更小，更有意义的块</p>
<p>Humans can generally juggle seven items, plus-or-minus two, in short-term memory.</p>
<p>人类的短期记忆能记住5到9个东西</p>
<p>To be conservative, we typically see groupings of five or less.</p>
<p>保守一点，分组一般是5个或更少</p>
<p>That’s why telephone numbers are broken into chunks, like 317, 555, 3897.</p>
<p>所以电话号码一般分块，比如 317-555-3897</p>
<p>Instead of being ten individual digits that we’d likely forget, it’s three chunks,</p>
<p>10个连续数可能会忘，</p>
<p>which we can handle better.</p>
<p>分成3块更好记</p>
<p>From a computer's standpoint, this needlessly takes more time and space,</p>
<p>从计算机的角度来看，分块更费时费空间</p>
<p>so it's less efficient.</p>
<p>效率更低</p>
<p>But, it’s way more efficient for us humans –</p>
<p>但这对人类更有效率</p>
<p>a tradeoff we almost always make in our favor,</p>
<p>碰到这种抉择时，我们总是以人类优先</p>
<p>since we’re the ones running the show...for now.</p>
<p>现在我们还是老大.. 暂时啦</p>
<p>Chunking has been applied to computer interfaces for things</p>
<p>界面设计用了分块，</p>
<p>like drop-down menu items and menu bars with buttons.</p>
<p>比如下拉菜单和带按钮的菜单栏</p>
<p>It’d be more efficient for computers to just pack all those together, edge to edge</p>
<p>对电脑来说，全部挤在一起更有效率</p>
<p>it’s wasted memory and screen real estate.</p>
<p>分块浪费内存浪费屏幕</p>
<p>But designing interfaces in this way makes them much easier</p>
<p>但这样设计更容易扫视，</p>
<p>to visually scan, remember and access.</p>
<p>记住和访问</p>
<p>Another central concept used in interface design is affordances.</p>
<p>界面设计中另一个重点概念是"直观功能"</p>
<p>According to Don Norman, who popularized the term in computing,</p>
<p>Don Norman 让这个词在计算机界流行起来，根据他的说法</p>
<p>"affordances provide strong clues to the operations of things.</p>
<p>"直观功能为如何操作物体提供线索</p>
<p>Plates are for pushing.</p>
<p>平板用来推</p>
<p>Knobs are for turning.</p>
<p>旋钮用来转</p>
<p>Slots are for inserting things into.</p>
<p>插槽用来插东西</p>
<p>[...] When affordances are taken advantage of, the user knows what to do just by looking:</p>
<p>[...]直观功能做的好，用户只需要看一眼就知道怎么做：</p>
<p>no picture, label, or instruction needed."</p>
<p>不需要图片，标签或指南来说明"</p>
<p>If you’ve ever tried to pull a door handle, only to realize that you have to push it open,</p>
<p>如果你拉过门把手打不开，然后意识到要推开才对</p>
<p>you’ve discovered a broken affordance.</p>
<p>那么你发现了一个坏掉的"直观功能"</p>
<p>On the other hand, a door plate is a better design</p>
<p>平板是更好的设计</p>
<p>because it only gives you the option to push.</p>
<p>因为只能推开</p>
<p>Doors are pretty straightforward – if you need to put written instructions on them,</p>
<p>门是简单的东西，如果你要贴指示让人们明白怎么用.</p>
<p>you should probably go back to the drawing board.</p>
<p>那么也许你应该重新设计</p>
<p>Affordances are used extensively in graphical user interfaces,</p>
<p>"直观功能"广泛用于图形界面</p>
<p>which we discussed in episode 26.</p>
<p>我们在第26集讨论过</p>
<p>It’s one of the reasons why computers became so much easier to use than with command lines.</p>
<p>这是图形界面比命令行更容易用的原因之一</p>
<p>You don’t have to guess what things on-screen are clickable, because they look like buttons.</p>
<p>你不用猜测屏幕上什么东西是可点的，可点的会看起来像按钮</p>
<p>They pop out, just waiting for you to press them!</p>
<p>他们弹出来，只是等着你压他们！</p>
<p>One of my favorite affordances, which suggests to users that an on-screen element is draggable,</p>
<p>我最喜欢的"直观功能"之一，是向用户表明元素是可拖动的</p>
<p>is knurling – that texture added to objects</p>
<p>"滚花" 一种视觉纹理</p>
<p>to improve grip and show you where to best grab them.</p>
<p>告诉用户哪里可以拖动</p>
<p>This idea and pattern was borrowed from real world physical tools.</p>
<p>这个点子来自现实世界中的工具</p>
<p>Related to the concept of affordances is the psychology of recognition vs recall.</p>
<p>和"直观功能"相关的一个心理学概念是 "认出与回想"</p>
<p>You know this effect well from tests –</p>
<p>如果你考过试，肯定感受过这个</p>
<p>it's why multiple choice questions are easier than fill-in-the-blank ones.</p>
<p>这就是为什么选择题比填空题容易</p>
<p>In general, human memory is much better when it’s triggered by a sensory cue,</p>
<p>一般来说，用感觉来触发记忆会容易得多</p>
<p>like a word, picture or sound.</p>
<p>比如文字，图片或声音</p>
<p>That’s why interfaces use icons – pictorial representations of functions</p>
<p>所以我们用图标代表功能</p>
<p>like a trash can for where files go to be deleted.</p>
<p>比如"垃圾桶"图标代表里面放着被删除的文件</p>
<p>We don’t have to recall what that icon does, we just have to recognise the icon.</p>
<p>我们不用去回想图标的功能是什么，只要能认出来就行了</p>
<p>This was also a huge improvement over command line interfaces,</p>
<p>比命令行好得多</p>
<p>where you had to rely on your memory for what commands to use.</p>
<p>命令行得依靠记忆来输命令</p>
<p>Do I have to type "delete", or "remove", or... "trash", or… shoot, it could be anything!</p>
<p>到底是输入"删除""移除""垃圾"还是"射出"？，可能是任何命令！</p>
<p>It’s actually "rm" in linux,</p>
<p>顺带一说，在 Linux 里删除文件的命令是 "rm"</p>
<p>but anyway, making everything easy to discover and learn sometimes means slow to access,</p>
<p>回到正题，让所有菜单选项好找好记，有时候意味着用的时候会慢一些</p>
<p>which conflicts with another psychology concept: expertise.</p>
<p>这与另一个心理学概念冲突："专业知识"</p>
<p>As you gain experience with interfaces, you get faster,</p>
<p>当你用界面熟悉之后，速度会更快一些</p>
<p>building mental models of how to do things efficiently.</p>
<p>建立如何高效完成事情的"心理模型"</p>
<p>So, good interfaces should offer multiple paths to accomplish goals.</p>
<p>所以好的界面应该提供多种方法来实现目标</p>
<p>A great example of this is copy and paste, which can be found in the edit dropdown menu</p>
<p>一个好例子是复制粘贴，可以在"编辑"的下拉菜单中找到</p>
<p>of word processors, and is also triggered with keyboard shortcuts.</p>
<p>也可以用快捷键</p>
<p>One approach caters to novices, while the other caters to experts, slowing down neither.</p>
<p>一种适合新手，一种适合专家，两者都不耽误</p>
<p>So, you can have your cake and eat it too!</p>
<p>鱼和熊掌兼得！</p>
<p>In addition to making humans more efficient,</p>
<p>除了让人类做事更高效，</p>
<p>we'd also like computers to be emotionally intelligent –</p>
<p>我们也希望电脑能有一点情商</p>
<p>adapting their behavior to respond appropriately</p>
<p>能根据用户的状态做出合适地反应</p>
<p>to their users' emotional state – also called affect.</p>
<p>能根据用户的状态做出合适地反应</p>
<p>That could make experiences more empathetic, enjoyable, or even delightful.</p>
<p>让使用电脑更加愉快</p>
<p>This vision was articulated by Rosalind Picard in her 1995 paper on Affective Computing,</p>
<p>Rosalind Picard 在 1995 年关于"情感计算"的论文中，阐述了这一愿景</p>
<p>which kickstarted an interdisciplinary field combining aspects</p>
<p>这篇论文开创了心理学，</p>
<p>of psychology, social and computer sciences.</p>
<p>社会科学和计算机科学的跨学科结合</p>
<p>It spurred work on computing systems that could recognize,</p>
<p>促进了让计算机理解</p>
<p>interpret, simulate and alter human affect.</p>
<p>人类情感的研究</p>
<p>This was a huge deal, because we know emotion influences cognition and perception</p>
<p>这很重要，因为情绪会影响日常活动</p>
<p>in everyday tasks like learning, communication, and decision making.</p>
<p>比如学习，沟通和决策</p>
<p>Affect-aware systems use sensors, sometimes worn, that capture things like speech and</p>
<p>情感系统会用传感器，录声音，</p>
<p>video of the face, as well as biometrics, like sweatiness and heart rate.</p>
<p>录像（你的脸）以及生物指标，比如出汗和心率</p>
<p>This multimodal sensor data is used in conjunction with computational models that represent how</p>
<p>得到的数据和计算模型结合使用</p>
<p>people develop and express affective states, like happiness and frustration,</p>
<p>模型会写明人类如何表达情感，怎么是快乐怎么是沮丧</p>
<p>and social states, like friendship and trust.</p>
<p>以及社交状态，比如友谊和信任</p>
<p>These models estimate the likelihood of a user being in a particular state,</p>
<p>模型会估算用户的情绪</p>
<p>and figure out how to best respond to that state,</p>
<p>以及怎样以最好的回应用户</p>
<p>in order to achieve the goals of the system.</p>
<p>以达到目标</p>
<p>This might be to calm the user down, build trust, or help them get their homework done.</p>
<p>比如让用户冷静下来，建立信任，或帮忙完成作业</p>
<p>A study, looking at user affect, was conducted by Facebook in 2012.</p>
<p>Facebook 在 2012 年进行了一项"影响用户"的研究</p>
<p>For one week, data scientists altered the content</p>
<p>数据科学家在一个星期内</p>
<p>on hundreds of thousands of users' feeds.</p>
<p>修改了很多用户时间线上显示的内容</p>
<p>Some people were shown more items with positive content,</p>
<p>有些人会看到</p>
<p>while others were presented with more negative content.</p>
<p>更多负面消极的内容</p>
<p>The researchers analyzed people's posts during that week,</p>
<p>研究人员分析了那一周内人们的发帖</p>
<p>and found that users who were shown more positive content,</p>
<p>发现看到积极向上内容的用户，</p>
<p>tended to also post more positive content.</p>
<p>发的帖子往往更正面</p>
<p>On the other hand, users who saw more negative content, tended to have more negative posts.</p>
<p>另一方面，看到负面内容的用户，发的内容也更负面</p>
<p>Clearly, what Facebook and other services show you</p>
<p>显然，Facebook和其他网站向你展示的内容</p>
<p>can absolutely have an affect on you.</p>
<p>绝对会对你有影响</p>
<p>As gatekeepers of content, that’s a huge opportunity and responsibility.</p>
<p>作为信息的守门人，这是巨大的机会同时也是责任</p>
<p>Which is why this study ended up being pretty controversial.</p>
<p>研究结果相当有争议性.</p>
<p>Also, it raises some interesting questions about</p>
<p>而且它还产生了一个有趣的问题：</p>
<p>how computer programs should respond to human communication.</p>
<p>计算机程序如何回应人类</p>
<p>If the user is being negative, maybe the computer shouldn’t be</p>
<p>如果用户的情绪比较负面，也许电脑不应该</p>
<p>annoying by responding in a cheery, upbeat manner.</p>
<p>以一种烦人的 "你要振作起来呀" 的态度回答问题.</p>
<p>Or, maybe the computer should attempt to evoke a positive response,</p>
<p>或者，也许电脑应该试着积极正面的回应用户</p>
<p>even if it's a bit awkward.</p>
<p>即使这有点尴尬.</p>
<p>The "correct" behavior is very much an open research question.</p>
<p>什么行为是"正确的"，是个开放性的研究问题</p>
<p>Speaking of Facebook, it’s a great example of computer-mediated communication, or CMC,</p>
<p>既然说到Facebook，这是一个"以计算机为媒介沟通"的好例子，简称 "CMC"</p>
<p>another large field of research.</p>
<p>也是一个很大的研究领域</p>
<p>This includes synchronous communication – like video calls, where all participants are online</p>
<p>这包括同步通信所有参与者同时在线进行视频通话</p>
<p>simultaneously – as well as asynchronous communication – like tweets, emails, and</p>
<p>以及异步通信比如推特，邮件，</p>
<p>text messages, where people respond whenever they can or want.</p>
<p>短信，人们可以随时随地回复信息</p>
<p>Researchers study things like the use of emoticons, rules such as turn-taking,</p>
<p>研究人员还研究用户怎么用表情包，怎么轮换发言，</p>
<p>and language used in different communication channels.</p>
<p>以及用不同沟通渠道时，用词有什么区别.</p>
<p>One interesting finding is that people exhibit higher levels of self-disclosure</p>
<p>一个有趣的发现是，比起面对面沟通，</p>
<p>that is, reveal personal information –in computer-mediated conversations,</p>
<p>人们更愿意在网上</p>
<p>as opposed to face-to-face interactions.</p>
<p>透露自己的信息</p>
<p>So if you want to build a system that knows how many hours a user truly spent</p>
<p>所以如果想知道用户，真正花了多少小时看"大英烘培大赛"(电视节目)</p>
<p>watching The Great British Bakeoff, it might be better to build a chatbot</p>
<p>做聊天机器人是个更好的选择</p>
<p>than a virtual agent with a face.</p>
<p>比起做个带脸的虚拟助理</p>
<p>Psychology research has also demonstrated that eye gaze is</p>
<p>心理学研究也表明，如果想说服，讲课，</p>
<p>extremely important in persuading, teaching and getting people's attention.</p>
<p>或引起注意，眼神注视非常重要</p>
<p>Looking at others while talking is called mutual gaze.</p>
<p>在谈话时看着别人叫相互凝视</p>
<p>This has been shown to boost engagement and help achieve the goals of a conversation,</p>
<p>这被证明可以促进参与感帮助实现谈话目标，</p>
<p>whether that’s learning, making a friend, or closing a business deal.</p>
<p>不管是学习，交朋友，还是谈生意</p>
<p>In settings like a videotaped lecture, the instructor rarely, if ever, looks into the</p>
<p>在录像讲座中，老师很少直视相机，</p>
<p>camera, and instead generally looks at the students who are physically present.</p>
<p>一般是看在场学生</p>
<p>That’s ok for them, but it means people who</p>
<p>对他们没问题，但这会让在线看视频的人</p>
<p>watch the lectures online have reduced engagement.</p>
<p>没什么参与感</p>
<p>In response, researchers have developed computer vision</p>
<p>为此，研究人员开发了计算机视觉和图形软件，</p>
<p>and graphics software that can warp the head and eyes,</p>
<p>来纠正头部和眼睛</p>
<p>making it appear as though the instructor is looking into the camera</p>
<p>视频时会觉得对方在直视摄像头，</p>
<p>right at the remote viewer.</p>
<p>看着他们</p>
<p>This technique is called augmented gaze.</p>
<p>这叫"增强凝视"</p>
<p>Similar techniques have also been applied to video conference calls, to correct for</p>
<p>类似技术也用于视频会议</p>
<p>the placement of webcams, which are almost always located above screens.</p>
<p>纠正摄像头位置，因为摄像头几乎总在屏幕上方</p>
<p>Since you’re typically looking at the video of your conversation partner,</p>
<p>因为你一般会盯着屏幕上的另一方，</p>
<p>rather than directly into the webcam,</p>
<p>而不是盯着摄像头</p>
<p>you'll always appear to them as though you're looking downwards –</p>
<p>所以视频里看起来像在向下看</p>
<p>breaking mutual gaze – which can create all kinds of</p>
<p>没有相互凝视这会导致各种不幸的副作用，</p>
<p>unfortunate social side effects, like a power imbalance.</p>
<p>，比如权力不平衡</p>
<p>Fortunately, this can be corrected digitally, and appear to participants</p>
<p>幸运的是可以用软件修正</p>
<p>as though you're lovingly gazing into their eyes.</p>
<p>看起来像在凝视着对方的眼睛</p>
<p>Humans also love anthropomorphizing objects, and computers are no exception,</p>
<p>人类也喜欢"拟人化"的物体，对计算机也不例外</p>
<p>especially if they move, like our Robots from last episode.</p>
<p>特别是会动的计算机，比如上集说的机器人</p>
<p>Beyond industrial uses that prevailed over the last century,</p>
<p>在过去一个世纪，除了工业用途机器人</p>
<p>robots are used increasingly in medical, education, and entertainment settings,</p>
<p>有越来越多机器人用于医疗，教育和娱乐，</p>
<p>where they frequently interact with humans.</p>
<p>它们经常和人类互动</p>
<p>Human-Robot Interaction – or HRI</p>
<p>人机交互，简称 HRI</p>
<p>is a field dedicated to studying these interactions,</p>
<p>是一个研究人类和机器人交互的领域，</p>
<p>like how people perceive different robots behaviors and forms,</p>
<p>比如人类如何感受机器人的不同形式和不同行为</p>
<p>or how robots can interpret human social cues to blend in and not be super awkward.</p>
<p>或是机器人如何明白人类暗示来社交，而不是尴尬的互动</p>
<p>As we discussed last episode, there’s an ongoing quest to make</p>
<p>正如上集说的，我们有追求</p>
<p>robots as human-like in their appearance and interactions as possible.</p>
<p>把机器人的外表和行为，做得尽可能像人一样</p>
<p>When engineers first made robots in the 1940s and 50s, they didn’t look very human at all.</p>
<p>工程师在1940 1950年代刚开始做机器人时，看起来完全不像人</p>
<p>They were almost exclusively industrial machines with no human-likeness.</p>
<p>是完完全全的工业机器</p>
<p>Over time, engineers got better and better at making human-like robots</p>
<p>随着时间的推移，工程师越来越擅长做类人机器人</p>
<p>they gained heads and walked around on two legs,</p>
<p>它们有头，而且用两条腿走路</p>
<p>but… they couldn't exactly go to restaurants and masquerade as humans.</p>
<p>但它们做不到伪装成人类去餐馆点餐</p>
<p>As people pushed closer and closer to human likeness,</p>
<p>随着机器人可以做得越来越像人类</p>
<p>replacing cameras with artificial eyeballs, and covering metal chassis with synthetic flesh,</p>
<p>用人造眼球代替摄像头，用人工肌肉盖住金属骨架</p>
<p>things started to get a bit... uncanny...</p>
<p>事情会开始变得有些.. 奇怪..，</p>
<p>eliciting an eerie and unsettling feeling.</p>
<p>引起一种怪异不安的感觉</p>
<p>This dip in realism between almost-human and actually-human became known as the uncanny valley.</p>
<p>这个"几乎像人类"和"真的人类"之间的小曲线，叫 "恐怖谷"</p>
<p>There’s debate over whether robots should act like humans too.</p>
<p>对于机器人是否应该有人类一样的行为，也存在争议</p>
<p>Lots of evidence already suggests that even if robots don’t act like us,</p>
<p>很多证据表明，即使机器人的行为不像人类</p>
<p>people will treat them as though they know our social conventions.</p>
<p>人类也会用社交习俗对待它们</p>
<p>And when they violate these rules – such as not apologizing if they cut in front of</p>
<p>而当机器人违反习俗时 </p>
<p>you or roll over your foot – people get really mad!</p>
<p>比如插队或踩了脚不道歉，人们会很生气！</p>
<p>Without a doubt, psychology and computer science are a potent combination,</p>
<p>毫无疑问，心理学+计算机科学是强大的组合</p>
<p>and have tremendous potential to affect our everyday lives.</p>
<p>可以影响日常生活的巨大潜力</p>
<p>Which leaves us with a lot of question, like you might lie to your laptop,</p>
<p>这也带来了很多开放式问题，比如你可能会对计算机撒谎</p>
<p>but should your laptop lie to you?</p>
<p>但计算机应不应该对你撒谎？</p>
<p>What if it makes you more efficient or happy?</p>
<p>如果撒谎能让你更高效更快乐呢？</p>
<p>Or should social media companies curate the content they show you to</p>
<p>或社交媒体公司，是否应该精心挑选展示给你的内容</p>
<p>make you stay on their site longer to make you buy more products?</p>
<p>让你在网站上多待一会儿，买更多东西？</p>
<p>They do by the way.</p>
<p>顺带一说，他们的确有这样做</p>
<p>These types of ethical considerations aren’t easy to answer, but psychology can at least</p>
<p>这类道德问题不容易回答，但心理学至少可以</p>
<p>help us understand the effects and implications of design choices in our computing systems.</p>
<p>帮助我们理解不同选择带来的影响和意义</p>
<p>But, on the positive side, understanding the psychology behind design</p>
<p>但从积极的方面来说，了解设计背后的心理学</p>
<p>might lead to increased accessibility.</p>
<p>能增加易用性</p>
<p>A greater number of people can understand and use computers</p>
<p>让更多人可以明白和使用电脑</p>
<p>now that they're more intuitive than ever.</p>
<p>如今计算机比以往更加直观</p>
<p>Conference calls and virtual classrooms are becoming more agreeable experiences.</p>
<p>线上会议和虚拟教室的体验越来越好</p>
<p>As robot technology continues to improve, the population</p>
<p>随着机器人技术不断提高，</p>
<p>will grow more comfortable in those interactions.</p>
<p>互动也会越来越舒适</p>
<p>Plus, thanks to psychology, we can all bond over our love of knurling.</p>
<p>另外，感谢心理学，让我们能分享对"滚花"的热爱</p>
<p>I’ll see you next week.</p>
<p>我们下周见</p>
<p>39 教育科技</p>
<p>Educational Technology</p>
<p>Hi, I’m Carrie Anne, and welcome to Crash Course Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！，</p>
<p>One of the most dramatic changes enabled by computing technology</p>
<p>计算机带来的最大改变之一，</p>
<p>has been the creation and widespread availability of information.</p>
<p>是信息的创造和传播能力</p>
<p>There are currently 1.3 billion websites on the internet.</p>
<p>目前有13亿个网站在互联网上</p>
<p>Wikipedia alone has five million English language articles,</p>
<p>仅维基百科就有500万篇英文文章</p>
<p>spanning everything from the Dancing Plague of 1518</p>
<p>涵盖从"1518年的舞蹈瘟疫"</p>
<p>to proper toilet paper roll orientation.</p>
<p>到"正确的纸卷方向"</p>
<p>Every day, Google serves up four billion searches to access this information.</p>
<p>每天，Google提供40亿次搜索来访问这些信息</p>
<p>And every minute, 3.5 million videos are viewed on Youtube,</p>
<p>Youtube上每分钟有350万个视频被观看.</p>
<p>and 400 hours of NEW video get uploaded by users.</p>
<p>每分钟用户上传400小时的新视频</p>
<p>Lots of these views are people watching Gangnam Style and Despacito.</p>
<p>很多观看量都是 Gangnam Style 和 Despacito</p>
<p>But another large percentage could be considered educational,</p>
<p>但剩下的大部分是教育型内容</p>
<p>like what you’re doing right now.</p>
<p>就像你现在看的这个.</p>
<p>This amazing treasure trove of information can be accessed</p>
<p>如今只要手机上点几下 </p>
<p>with just a few taps on your smartphone.</p>
<p>就能访问到这些宝藏</p>
<p>Anywhere, anytime.</p>
<p>任何时间，任何地点</p>
<p>But, having information available isn’t the same as learning from it.</p>
<p>但能获取到信息和学习不是一回事</p>
<p>To be clear, we here at Crash Course we are big fans of interactive in-class learning,</p>
<p>先说清楚，我们 Crash Course 喜欢互动式课堂学习</p>
<p>directed conversations, and hands-on experiences as powerful tools for learning.</p>
<p>课上提问，以及上手实践，它们是很棒的学习途径</p>
<p>But we also believe in the additive power of educational technology</p>
<p>但我们也相信教育型技术</p>
<p>both inside and outside the classroom.</p>
<p>在课内课外带来的帮助</p>
<p>So today we’re going to go a little meta,</p>
<p>今天我们要在这个教育型视频里，聊教育型科技</p>
<p>and talk specifically about how computer science</p>
<p>具体讲解计算机</p>
<p>can support learning with educational technology.</p>
<p>怎么帮助我们学习</p>
<p>Technology, from paper and pencil to recent machine-learning-based intelligent systems,</p>
<p>从纸和笔到用机器学习的智能系统，</p>
<p>has been supporting education for millennia -</p>
<p>科技几千年来一直在辅助教育</p>
<p>even as early as humans drawing cave paintings</p>
<p>甚至早期人类 </p>
<p>to record hunting scenes for posterity.</p>
<p>在洞穴里画狩猎场景也是为了后代</p>
<p>Teaching people at a distance has long been a driver of educational technology.</p>
<p>远距离教育一直推动着教育科技的发展</p>
<p>For example, around 50 CE, St. Paul was sending epistles</p>
<p>例如公元50年左右，</p>
<p>that offered lessons on religious teachings</p>
<p>圣保罗就发书信，</p>
<p>for new churches being set up in Asia.</p>
<p>给亚洲设立的新教堂提供宗教课程</p>
<p>Since then, several major waves of technological advances</p>
<p>从那以后，有几大技术浪潮，</p>
<p>have each promised to revolutionize education,</p>
<p>自称要改变教育</p>
<p>from radio and television, to DVDs and laserdiscs.</p>
<p>从广播和电视，到DVD和光碟</p>
<p>In fact, as far back as 1913, Thomas Edison predicted,</p>
<p>事实上，在1913年托马斯·爱迪生预测说</p>
<p>"Books will soon be obsolete in the schools…</p>
<p>"书籍很快会过时… </p>
<p>It is possible to teach every branch of human knowledge with the motion picture.</p>
<p>用影片来教授所有知识是可能的</p>
<p>Our school system will be completely changed in the next ten years."</p>
<p>学校体系将在未来十年彻底改变"</p>
<p>Of course, you know that didn’t happen.</p>
<p>当然，他的预测没有成真</p>
<p>But distributing educational materials in formats like video has become more and more popular.</p>
<p>但发布教育视频变得越来越流行</p>
<p>Before we discuss what educational technology research can do for you,</p>
<p>在讨论教育技术可以帮你做什么之前</p>
<p>there are some simple things research has shown you can do,</p>
<p>有研究表明 </p>
<p>while watching an educational video like this one,</p>
<p>有些简单事情，可</p>
<p>significantly increase what you learn and retain.</p>
<p>可以显著提高学习效率</p>
<p>First, video is naturally adjustable, so make sure the pacing is right for you,</p>
<p>1 把速度调整到</p>
<p>by using the video speed controls.</p>
<p>适合你，</p>
<p>On YouTube, you can do that in the right hand corner of the screen.</p>
<p>YouTube 的速度设置在右下角</p>
<p>You should be able to understand the video and have enough time to reflect on the content.</p>
<p>让你能理解视频有足够的时间思考</p>
<p>Second, pause!</p>
<p>2 暂停！</p>
<p>You learn more if you stop the video at the difficult parts.</p>
<p>在困难的部分暂停</p>
<p>When you do, ask yourself questions about what you’ve watched, and see if you can answer.</p>
<p>问自己一些问题，看能不能回答</p>
<p>Or ask yourself questions about what might be coming up next,</p>
<p>或想想视频接下来可能讲什么，</p>
<p>and then play the video to see if you’re right.</p>
<p>然后继续播放，看猜对没有</p>
<p>Third, try any examples or exercises that are presented in the video on your own.</p>
<p>3 做视频中的提供的练习</p>
<p>Even if you aren’t a programmer, write pseudocode on paper,</p>
<p>即使不是程序员，你也可以在纸上写伪代码，</p>
<p>and maybe even give coding a try.</p>
<p>或试试学编程</p>
<p>Active learning techniques like these</p>
<p>这些主动学习的技巧已被证明，</p>
<p>have been shown to increase learning by a factor of ten.</p>
<p>可以把学习效率提升10倍或以上</p>
<p>And if you want more information like this we’ve got a whole course on it here.</p>
<p>如果想学学习技巧，有整个系列专门讲这个</p>
<p>The idea of video as a way to spread quality education</p>
<p>把高质量教育内容做成视频传播，</p>
<p>has appealed to a lot of people over the last century.</p>
<p>在过去一个世纪吸引了很多人</p>
<p>What’s just the latest incarnation of this idea</p>
<p>这个老想法的新化身</p>
<p>came in the form of Massive Open Online Courses, or MOOCs.</p>
<p>以"大型开放式在线课程"（MOOC）的形式出现</p>
<p>In fact, the New York Times declared 2012 the Year of the MOOC!</p>
<p>纽约时报宣称 2012 年是 MOOC 年！</p>
<p>A lot of the early forms were just videos of lectures from famous professors.</p>
<p>很多早期视频直接录制著名教授上课</p>
<p>But for a while, some people thought this might mean the end of universities as we know them.</p>
<p>有段时间，有些人以为大学要终结了</p>
<p>Whether you were worried about this idea or excited by it,</p>
<p>不管你是担心还是开心，</p>
<p>that future also hasn’t really come to pass</p>
<p>这暂时还没成为现实</p>
<p>and most of the hype has dissipated.</p>
<p>现在热度也淡去了</p>
<p>This is probably mostly because when you try to scale up learning</p>
<p>这可能是因为加大规模时 </p>
<p>using technology to include millions of students simultaneously</p>
<p>同时教百万名学生</p>
<p>with small numbers of instructional staff or even none</p>
<p>但老师数量很少，甚至完全没有老师</p>
<p>you run into a lot of problems.</p>
<p>会遇到很多问题</p>
<p>Fortunately, these problems have intrigued computer scientists and more specifically,</p>
<p>幸运的是，这引起了计算机科学家，或具体一点 "教育科技家"的兴趣</p>
<p>educational technologists, who are finding ways to solve them.</p>
<p>他们在想办法解决这些问题</p>
<p>For example, effective learning involves getting timely and relevant feedback</p>
<p>比如，为了有效学习，学生要及时获得反馈</p>
<p>but how do you give good feedback</p>
<p>但如果有几百万学生，只有一名老师，</p>
<p>when you have millions of learners and only one teacher?</p>
<p>怎么提供好的反馈？</p>
<p>For that matter, how does a teacher grade a million assignments?</p>
<p>一个老师怎么给一百万份作业打成绩？</p>
<p>Solving many of these problems means creating hybrid, human-technology systems.</p>
<p>为了解决问题，很多时候需要把科技和人类都用上</p>
<p>A useful, but controversial insight,</p>
<p>一种有用但有些争议的做法是</p>
<p>was that students could be a great resource to give each other feedback.</p>
<p>学生互相之间提供反馈</p>
<p>Unfortunately, they’re often pretty bad at doing so –</p>
<p>不幸的是，学生一般做不好</p>
<p>they’re neither experts in the subject matter, nor teachers.</p>
<p>他们既不是专家也不是老师</p>
<p>However, we can support their efforts with technology.</p>
<p>但我们可以用技术来帮助他们</p>
<p>Like, by using algorithms, we can match perfect learning partners together,</p>
<p>比如通过算法，从数百万个选择里，</p>
<p>out of potentially millions of groupings.</p>
<p>匹配出最完美的学习伙伴</p>
<p>Also, parts of the grading can be done with automated systems while humans do the rest.</p>
<p>另外，有些部分可以机器打分，剩下的让人类打分</p>
<p>For instance, computer algorithms that grade the</p>
<p>例如，给 SAT 写作部分打分的电脑算法</p>
<p>writing portions of the SATs have been found to be</p>
<p>已被证实</p>
<p>just as accurate  as humans hired to grade them by hand.</p>
<p>和人工打分一样准确</p>
<p>Other algorithms are being developed that provide personalized learning experiences,</p>
<p>还有些算法提供个性化学习体验</p>
<p>much like Netflix’s personalized movie recommendations or Google’s personalized search results.</p>
<p>类似于 Netflix 的电影推荐，或 Google 的个性化搜索结果</p>
<p>To achieve this, the software needs to understand what a learner knows and doesn’t know.</p>
<p>为了个性化推荐，软件需要了解用户知道什么，不知道什么</p>
<p>With that understanding, the software can present the right material, at the right time,</p>
<p>在正确的时间提供正确的资料，</p>
<p>to give each particular learner practice on the things that are hardest for them,</p>
<p>让用户练习没理解的难的部分</p>
<p>rather than what they’re already good at.</p>
<p>而不是给出用户已经学会的内容</p>
<p>Such systems – most often powered by Artificial Intelligence –</p>
<p>这种系统一般用 AI 实现</p>
<p>are broadly called Intelligent Tutoring Systems.</p>
<p>泛称叫法是"智能辅导系统"</p>
<p>Let’s break down a hypothetical system that follows common conventions.</p>
<p>我们现在讲一个假想的辅导系统</p>
<p>So, imagine a student is working on this algebra problem in our hypothetical tutoring software.</p>
<p>假设学生在这个假想的辅导系统中，研究一个代数问题</p>
<p>The correct next step to solve it, is to subtract both sides by 7.</p>
<p>正确的下一步是两边-7</p>
<p>The knowledge required to do this step can be represented by something called a production rule.</p>
<p>我们可以用 "判断规则" 来表示这一步</p>
<p>These describe procedures as IF-THEN statements.</p>
<p>用 IF-THEN 语句来描述</p>
<p>The pseudo code of a production rule for this step would say</p>
<p>伪代码是</p>
<p>IF there is a constant on the same side as the variable,</p>
<p>IF变量和常数在同一边</p>
<p>THEN subtract that constant from both sides.</p>
<p>THEN两侧都减去这个常数</p>
<p>The cool thing about production rules is that they can also be used</p>
<p>"判断规则" 酷的地方是也可以用来</p>
<p>to represent common mistakes a student might make.</p>
<p>代表学生的常犯错误</p>
<p>These production rules are called "buggy rules".</p>
<p>这些"判断规则"叫"错误规则"</p>
<p>For example, instead of subtracting the constant,</p>
<p>例如，学生可能不去减常数</p>
<p>the student might mistakenly try to subtract the coefficient.</p>
<p>而是去减系数</p>
<p>No can do!</p>
<p>这不行！</p>
<p>It’s totally possible that multiple competing production rules</p>
<p>学生做完一个步骤后</p>
<p>are triggered after a student completes a step –</p>
<p>可能触发多个"判断规则"</p>
<p>it may not be entirely clear what misconception has led to a student’s answer.</p>
<p>系统不能完全弄清是什么原因让学生选了那个答案</p>
<p>So, production rules are combined with an algorithm that selects the most likely one.</p>
<p>所以"判断规则"会和算法结合使用，判断可能原因</p>
<p>That way, the student can be given a helpful piece of feedback.</p>
<p>让学生得到有用反馈</p>
<p>These production rules, and the selection algorithm,</p>
<p>"判断规则"+选择算法，</p>
<p>combine to form what’s called a Domain Model,</p>
<p>组合在一起成为 "域模型"</p>
<p>which is a formal representation of the knowledge,</p>
<p>它给知识，解决步骤和一门学科比如代数，</p>
<p>procedures and skills of a particular discipline like algebra.</p>
<p>用一种"正式写法"来表示</p>
<p>Domain models can be used to assist learners on any individual problem,</p>
<p>域模型可以用来帮助学习者解决特定问题</p>
<p>but they’re insufficient for helping learners move through a whole curriculum</p>
<p>但它无法带着学习者，以正确顺序搞定整个学科该上的所有课程</p>
<p>because they don’t track any progress over time.</p>
<p>因为域模型不记录进度</p>
<p>For that, intelligent tutoring systems build and maintain a student model</p>
<p>因此智能辅导系统负责创建和维护学生模型</p>
<p>one that tracks, among other things, what production rules a student has mastered,</p>
<p>记录学生已经掌握的判断规则</p>
<p>and where they still need practice.</p>
<p>以及还需练习的生疏部分</p>
<p>This is exactly what we need to properly personalize the tutor.</p>
<p>这正是个性化辅导系统需要的。</p>
<p>That doesn’t sound so hard,</p>
<p>听起来好像不难，</p>
<p>but it’s actually a big challenge to figure out what a student knows and doesn’t know</p>
<p>但只靠学生对一些问题的回答，来弄清学生知道什么，</p>
<p>based only on their answers to problems.</p>
<p>不知道什么，是很大的挑战</p>
<p>A common technique for figuring this out is Bayesian knowledge tracing.</p>
<p>"贝叶斯知识追踪" 常用来解决这个问题</p>
<p>The algorithm treats student knowledge as a set of latent variables,</p>
<p>这个算法把学生的知识当成一组隐藏变量</p>
<p>which are variables whose true value is hidden from</p>
<p>这些变量的值，对外部是不可见的</p>
<p>an outside observer, like our software.</p>
<p>比如我们的软件</p>
<p>This is also true in the physical world,</p>
<p>这在现实中也是一样的</p>
<p>where a teacher would not know for certain whether</p>
<p>老师无法知道 </p>
<p>a student knows something completely.</p>
<p>学生是否完全掌握了某个知识点</p>
<p>Instead, they might probe that knowledge using a test</p>
<p>老师会出考题，</p>
<p>to see if the student gets the right answer.</p>
<p>测试学生能否答对</p>
<p>Similarly, Bayesian knowledge tracing updates its estimate of the students’ knowledge</p>
<p>同样，"贝叶斯知识追踪"，会看学生答题的正确度，</p>
<p>by observing the correctness of each interaction using that skill.</p>
<p>更新学生掌握程度的估算值</p>
<p>To do this, the software maintains four probabilities..</p>
<p>它会记录四个概率</p>
<p>First is the probability that a student has learned how to do a particular skill.</p>
<p>首先是 "学生已经学会的概率"</p>
<p>For example, the skill of subtracting constants from both sides of an algebraic equation.</p>
<p>比如从代数方程的两边减去常数</p>
<p>Let’s say our student correctly subtracts both sides by 7.</p>
<p>假设学生正确将两边-7</p>
<p>Because she got the problem correct,</p>
<p>做对了</p>
<p>we might assume she knows how to do this step.</p>
<p>我们可以假设她知道怎么做</p>
<p>But there’s also the possibility that the student got it correct by accident,</p>
<p>但也有可能她是瞎蒙的</p>
<p>and doesn’t actually understand how to solve the problem.</p>
<p>没有真的学会怎么解决问题</p>
<p>This is the probability of guess.</p>
<p>这叫 "瞎猜的概率"</p>
<p>Similarly, if the student gets it wrong,</p>
<p>类似的，如果学生答错了，</p>
<p>you might assume that she doesn’t know how to do the step.</p>
<p>你可能会假设她不会做</p>
<p>But, there’s also the possibility that she knows it,</p>
<p>但她可能知道答案，</p>
<p>but made a careless error or other slip-up.</p>
<p>只是不小心犯了个错</p>
<p>This is called the probability of slip.</p>
<p>这叫 "失误的概率"</p>
<p>The last probability that Bayesian knowledge tracing calculates</p>
<p>最后一个概率</p>
<p>is the probability that the student started off the problem</p>
<p>是学生一开始不会做，</p>
<p>not knowing how to do the step, but learned how to do</p>
<p>但是在解决问题的过程中，</p>
<p>it as a result of working through the problem.</p>
<p>学会了怎么做</p>
<p>This is called the probability of transit.</p>
<p>这叫 "做题过程中学会的概率"</p>
<p>These four probabilities are used in a set of equations that update the student model,</p>
<p>有一组方程，会用这四个概率，更新学生模型</p>
<p>keeping a running assessment for each skill the student is supposed to know.</p>
<p>对学生应该学会的每项技能进行持续评估</p>
<p>The first equation asks:</p>
<p>第一个等式问：</p>
<p>what’s the probability that the student has learned a particular skill</p>
<p>学生已经知道某技能的概率是多少？</p>
<p>which takes into account the probability that it was</p>
<p>等式里有</p>
<p>already learned previously and the probability of transit.</p>
<p>"之前已经学会的概率"和"做题过程中学会的概率"</p>
<p>Like a teacher, our estimate of this probability that it was already learned previously</p>
<p>就像老师一样，"之前已经学会的概率"</p>
<p>depends on whether we observe a student getting a question correct or incorrect,</p>
<p>取决于学生回答问题正确与否，</p>
<p>and so we have these two equations to pick from.</p>
<p>回答正确和错误分别有2个公式</p>
<p>After we compute the right value, we plug it into our first equation,</p>
<p>算出结果之后，我们把结果放到第一个方程</p>
<p>updating the probability that a student has learned a particular skill,</p>
<p>更新"之前已经学会的概率"</p>
<p>which then gets stored in their student model.</p>
<p>然后存到学生模型里.</p>
<p>Although there are other approaches,</p>
<p>虽然存在其他方法，</p>
<p>intelligent tutoring systems often use Bayesian knowledge tracing</p>
<p>但"智能辅导系统"通常用贝叶斯知识追踪</p>
<p>to support what’s called mastery learning, where students practice skills,</p>
<p>让学生练习技能，</p>
<p>until they’re deeply understood.</p>
<p>直到掌握</p>
<p>To do this most efficiently, the software selects the</p>
<p>为了高效做到这点，软件要选择合适的问题</p>
<p>best problems to present to the student to achieve mastery,</p>
<p>呈现给学生，让学生学</p>
<p>what’s called adaptive sequencing,</p>
<p>这叫：自适应式程序</p>
<p>which is one form of personalization.</p>
<p>个性化算法的形式之一</p>
<p>But, our example is still just dealing with data from one student.</p>
<p>但我们的例子只是一个学生的数据</p>
<p>Internet-connected educational apps or sites</p>
<p>现在有 App 或网站</p>
<p>now allow teachers and researchers the ability</p>
<p>让教师和研究人员 </p>
<p>to collect data from millions of learners.</p>
<p>收集上百万学习者的数据</p>
<p>From that data, we can discover things like common pitfalls and where students get frustrated.</p>
<p>从数据中可以发现常见错误，一般哪里难倒学生</p>
<p>Beyond student responses to questions,</p>
<p>除了学生的回答，</p>
<p>this can be done by looking at how long they pause</p>
<p>还可以看回答前暂停了多久</p>
<p>before entering an answer, where they speed up a video,</p>
<p>哪个部分加速视频，</p>
<p>and how they interact with other students on discussion forums.</p>
<p>以及学生如何在论坛和其他人互动</p>
<p>This field is called Educational Data Mining,</p>
<p>这个领域叫 "教育数据挖掘"</p>
<p>and it has the ability to use all those face palms and "ah ha" moments</p>
<p>它能用上学生所有的"捂脸"和"啊哈"时刻</p>
<p>to help improve personalized learning in the future.</p>
<p>帮助改善未来的个性化学习</p>
<p>Speaking of the future, educational technologists have often</p>
<p>谈到未来，教育技术人员</p>
<p>drawn inspiration for their innovations from science fiction.</p>
<p>经常从科幻小说中获得灵感</p>
<p>In particular, many researchers were inspired by the future envisioned in the book</p>
<p>具体来说，Neal Stephenson 的"钻石时代"这本书，</p>
<p>"The Diamond Age" by Neal Stephenson.</p>
<p>激励了很多研究人员</p>
<p>It describes a young girl who learns from a book</p>
<p>里面说一个年轻女孩从书中学习</p>
<p>that has a set of virtual agents who interact with her</p>
<p>书中有一些虚拟助手会和她互动，</p>
<p>in natural language acting as coaches, teachers,</p>
<p>教她知识</p>
<p>and mentors who grow and change with her as she grows up.</p>
<p>这些助手和她一起成长</p>
<p>They can detect what she knows and how’s she’s feeling,</p>
<p>直到她学会了什么，以及感觉如何，</p>
<p>and give just the right feedback and support to help her learn.</p>
<p>给她正确的反馈和支持，帮助她学习</p>
<p>Today, there are non-science-fiction researchers, such as Justine Cassell,</p>
<p>如今有非科幻小说研究者，比如贾斯汀卡塞尔，</p>
<p>crafting pedagogical virtual agents</p>
<p>在制作虚拟教学助手</p>
<p>that can "exhibit the verbal and bodily behaviors found in</p>
<p>助手可以"像人类一样沟通有人类一样的行为</p>
<p>conversation among humans, and in doing so, build trust,</p>
<p>在陪伴过程中和学习者建立信任，</p>
<p>rapport and even friendship with their human students."</p>
<p>相处融洽，甚至和人类学生成为朋友"</p>
<p>Maybe Crash Course in 2040 will have a little John Green A.I. that lives on your iPhone 30.</p>
<p>2040年的"速成课"，可能会有一个 John Green AI，活在你的 iPhone 30 上</p>
<p>Educational technology and devices are now moving off of laptop and desktop computers,</p>
<p>教育科技和设备，如今在逐渐扩展到笔记本和台式电脑之外</p>
<p>onto huge tabletop surfaces, where students can collaborate in groups,</p>
<p>比如巨大桌面设备，让学生可以团队合作</p>
<p>and also tiny mobile devices, where students can learn on the go.</p>
<p>以及小型移动设备，让学生路上也能学习</p>
<p>Virtual reality and augmented reality are also getting people excited</p>
<p>"虚拟现实"和"增强现实"也让人们兴奋不已</p>
<p>and enabling new educational experiences for learners –</p>
<p>它们可以为学习者提供全新的体验 -</p>
<p>diving deep under the oceans, exploring outer space,</p>
<p>深潜海洋，探索太空，</p>
<p>traveling through the human body, or interacting with cultures</p>
<p>漫游人体，</p>
<p>they might never encounter in their real lives.</p>
<p>或是和现实中难以遇见的生物互动</p>
<p>If we look far into the future, educational interfaces might disappear entirely,</p>
<p>如果猜想遥远的未来，教育可能会完全消失，</p>
<p>and instead happen through direct brain learning,</p>
<p>直接在大脑层面进行</p>
<p>where people can be uploaded with new skills, directly into their brains.</p>
<p>把新技能直接下载到大脑</p>
<p>This might seem really far fetched,</p>
<p>这看起来可能很遥远，</p>
<p>but scientists are making inroads already such as detecting</p>
<p>但科学家们已经在摸索比如</p>
<p>whether someone knows something just from their brain signals.</p>
<p>仅仅通过检测大脑信号，得知某人是否知道什么</p>
<p>That leads to an interesting question:</p>
<p>这带来了一个有趣的问题：</p>
<p>if we can download things INTO our brains,</p>
<p>如果我们可以把东西下载到大脑里</p>
<p>could we also upload the contents of our brains?</p>
<p>我们能不能上传大脑里的东西？</p>
<p>We’ll explore that in our series finale next week about the far future of computing.</p>
<p>下周的最后一集，我们会讨论计算的未来</p>
<p>I'll see you then.</p>
<p>到时见</p>
<p>40 奇点,天网,计算机的未来</p>
<p>The Singularity, Skynet, and the Future of Computing	</p>
<p>Hi, I’m Carrie Anne, and welcome to Crash Course Computer Science!</p>
<p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p>
<p>We’re here: the final episode!</p>
<p>我们到了最后一集！</p>
<p>If you’ve watched the whole series,</p>
<p>如果你看了整个系列，</p>
<p>hopefully you’ve developed a newfound appreciation</p>
<p>希望你对计算机影响的深度和广度，</p>
<p>for the incredible breadth of computing applications and topics.</p>
<p>有全新的认知和欣赏</p>
<p>It’s hard to believe we’ve worked up from mere transistors and logic gates,</p>
<p>难以相信我们从简单的晶体管和逻辑门开始</p>
<p>all the way to computer vision, machine learning, robotics and beyond.</p>
<p>一直到计算机视觉，机器学习，机器人以及更多</p>
<p>We’ve stood on the shoulders of giants</p>
<p>我们站在巨人的肩膀上</p>
<p>like Babbage and Lovelace, Hollerith and Turing,</p>
<p>Charles Babbage，Ada Lovelac，Herman Hollerith，Alan Turing</p>
<p>Eckert and Hopper, Sutherland and Engelbart,</p>
<p>J. Presper Eckert，Grace Hopper，Ivan Sutherland，Douglas Engelbart</p>
<p>Bush and Berners Lee, Gates and the Woz,</p>
<p>Vannevar Bush (Memex)，Berners-Lee  (万维网)，Bill Gates (微软)，Steve Wozniak (苹果)</p>
<p>and many other computing pioneers.</p>
<p>和许多其他先驱</p>
<p>My biggest hope is that these episodes have inspired you to</p>
<p>我最大的希望是这些视频能激励你，</p>
<p>learn more about how these subjects affect your life.</p>
<p>去了解这些东西如何影响你的人生</p>
<p>Maybe you’ll even pick up programming or choose a career in computing.</p>
<p>甚至开始学编程，或找一份计算机职业</p>
<p>It’s awesome!</p>
<p>这很棒！</p>
<p>It’s also a skill of the future.</p>
<p>这是未来的技能</p>
<p>I said in the very first episode that computer science isn’t magic, but it sort of is!</p>
<p>我在第一集说过，计算机科学不是魔法，但它有点像魔法</p>
<p>Knowing how to use and program computers is sorcery of the 21st century.</p>
<p>学习使用电脑和编程，是21世纪的巫术</p>
<p>Instead of incantations and spells, it’s scripts and code.</p>
<p>只不过用的不是咒语而是代码</p>
<p>Those who know how to wield that tremendous power will be able to craft great things,</p>
<p>懂得运用的人，能创造出伟大的东西</p>
<p>not just to improve their own lives, but also their communities and humanity at large.</p>
<p>不仅改善自己的生活，还有当地社区乃至整体人类</p>
<p>Computing is also going to be literally everywhere –</p>
<p>计算机会随处可见 -</p>
<p>not just the computers we see today, sitting on desks and countertops,</p>
<p>不仅是放在桌上带在包里</p>
<p>and carried in pockets and bags – but inside every object imaginable.</p>
<p>而是在所有可想象的东西里</p>
<p>Inside all your kitchen appliances, embedded in your walls, nanotagged in your food,</p>
<p>厨房用具里，墙里，食物里</p>
<p>woven into your clothes, and floating around inside your body.</p>
<p>编织进衣服里，在你的血液里</p>
<p>This is the vision of the field of Ubiquitous Computing.</p>
<p>这是"普适计算"的愿景</p>
<p>In some ways, it’s already here, and in other ways, we’ve got many decades to go.</p>
<p>从某种角度来讲它已经来临了，而换一个角度还要几十年</p>
<p>Some might view this eventuality as dystopian,</p>
<p>有些人把这种未来看成反乌托邦</p>
<p>with computers everywhere surveilling us and competing for our attention.</p>
<p>到处都有监视器，有无数东西想吸引我们的注意力</p>
<p>But the late Mark Weiser, who articulated this idea in the 1990s,</p>
<p>但 1990 年代提出这个想法的马克·维泽尔</p>
<p>saw the potential very differently:</p>
<p>看到了非常不同的潜力：</p>
<p>"For [fifty] years, most interface design, and most computer design,</p>
<p>"[五十]年来，大多数界面和计算机设计，</p>
<p>has been headed down the path of the "dramatic" machine.</p>
<p>都是朝"戏剧性"方向前进</p>
<p>Its highest idea is to make a computer so exciting, so wonderful,</p>
<p>想把计算机做得超好，</p>
<p>so interesting, that we never want to be without it.</p>
<p>让人一刻也不想离开</p>
<p>A less-traveled path I call the "invisible";</p>
<p>另一条少有人走的路是"无形"的</p>
<p>its highest idea is to make a computer so imbedded, so fitting,</p>
<p>把计算机整合到所有东西里，</p>
<p>so natural, that we use it without even thinking about it …</p>
<p>用的时候很自然完全注意不到</p>
<p>The most profound technologies are those that disappear.</p>
<p>最厉害的科技是看不见的科技</p>
<p>They weave themselves into the fabric of everyday life</p>
<p>它们融入到日常生活的每一部分 </p>
<p>until they are indistinguishable from it."</p>
<p>直到无法区分"</p>
<p>That doesn’t describe computing of today</p>
<p>如今我们还没达到这样</p>
<p>where people sit for hours upon end in front of computer monitors,</p>
<p>人们在电脑前连续坐好几小时</p>
<p>and social media notifications interrupt us at dinner.</p>
<p>吃晚餐被手机推送通知打扰</p>
<p>But, it could describe computing of the future, our final topic.</p>
<p>但它可以描述计算的未来，本系列最后一个主题</p>
<p>When people think of computing in the future,</p>
<p>人们思考计算机的未来时 </p>
<p>they often jump right to Artificial Intelligence.</p>
<p>经常会直接想到人工智能</p>
<p>No doubt there will be tremendous strides made in AI in the coming years,</p>
<p>毫无疑问，接下来几十年人工智能会有巨大进步</p>
<p>but not everything will be, or need to be, AI-powered.</p>
<p>但不是所有东西都要做成 AI ，或需要 AI</p>
<p>Your car might have an AI to self-drive, but the door locks</p>
<p>车有自动驾驶AI，</p>
<p>might continue to be powered by what are essentially if-statements.</p>
<p>但门锁依然会很简单</p>
<p>AI technology is just as likely to enhance existing devices,</p>
<p>人工智能可能只是增强现有设备</p>
<p>like cars, as it is to open up entirely new product categories.</p>
<p>比如汽车，AI 带来了一个全新的产品种类</p>
<p>The exact same thing happened with the advent of electrical power – lightbulbs replaced candles.</p>
<p>刚出现电力时也是这样，灯泡取代了蜡烛.</p>
<p>But electrification also led to the creation of hundreds of new electrically-powered gadgets.</p>
<p>但电气化也导致上百种新的电动小工具诞生</p>
<p>And of course, we still have candles today.</p>
<p>当然我们如今仍然有蜡烛</p>
<p>It’s most likely that AI will be yet another tool</p>
<p>最可能的情况是 AI 变成，</p>
<p>that computer scientists can draw upon to tackle problems.</p>
<p>计算机科学家手中的另一门新工具</p>
<p>What really gets people thinking, and sometimes sweating,</p>
<p>但真正让人深思和担忧的是</p>
<p>is whether Artificial Intelligence will surpass human intelligence.</p>
<p>人工智能是否会超越人类智能？</p>
<p>This is a really tricky question for a multitude of reasons,</p>
<p>这个问题很难有多方面原因</p>
<p>including most immediately: "what is intelligence?"</p>
<p>比如 "智能的准确定义是什么？"</p>
<p>On one hand, we have computers that can drive cars,</p>
<p>一方面，有会开车的计算机</p>
<p>recognize songs with only a few seconds of audio,</p>
<p>几秒就能识别歌的 App</p>
<p>translate dozens of languages, and totally dominate at games like chess, Jeopardy, and Go.</p>
<p>翻译几十种语言，还称霸了一些游戏，比如象棋，知识竞答和围棋</p>
<p>That sounds pretty smart!</p>
<p>听起来很聪明！</p>
<p>But on the other hand, computers fail at some basic tasks,</p>
<p>但另一方面，计算机连一些简单事情都做不了</p>
<p>like walking up steps, folding laundry,</p>
<p>比如走楼梯，叠衣服，</p>
<p>understanding speech at a cocktail party, and feeding themselves.</p>
<p>在鸡尾酒派对和人聊天，喂饱自己</p>
<p>We’re a long way from Artificial Intelligence that’s as general purpose and capable as a human.</p>
<p>人工智能成长到和人类一样通用，还有很长的路</p>
<p>With intelligence being somewhat hard to quantify,</p>
<p>因为"智能"是难以量化的指标</p>
<p>people prefer to characterize computers and creatures</p>
<p>人们更喜欢用</p>
<p>by their processing power instead,</p>
<p>处理能力来区分</p>
<p>but that’s a pretty computing-centric view of intelligence.</p>
<p>但这种衡量智能的方法比较"以计算为中心"</p>
<p>Nonetheless, if we do this exercise,</p>
<p>但如果把视频中出现过的电脑和处理器 </p>
<p>plotting computers and processors we’ve talked about in this series,</p>
<p>画张图</p>
<p>we find that computing today has very roughly equivalence in calculating</p>
<p>可以看到如今的计算能力</p>
<p>power to that of a mouse...</p>
<p>粗略等同于一只老鼠</p>
<p>which, to be fair, also can’t fold laundry, although that would be super cute!</p>
<p>公平点说，老鼠也不会叠衣服，但如果真的会叠就太可爱了</p>
<p>Human calculating power is up here, another 10 to the 5,</p>
<p>人类的计算能力在这儿，多10的5次方</p>
<p>or 100,000 times more powerful than computers today.</p>
<p>也就是比如今电脑强10万倍</p>
<p>That sounds like a big gap, but with the rate of change in computing technologies,</p>
<p>听起来差距很大，但按如今的发展速度，</p>
<p>we might meet that point in as early as a decade,</p>
<p>也许十几年就可以赶上了</p>
<p>even though processor speeds are no longer following Moore’s Law,</p>
<p>虽然现在处理器的速度不再按摩尔定律增长了</p>
<p>like we discussed in Episode 17.</p>
<p>我们在第17集讨论过</p>
<p>If this trend continues, computers would have more processing power/intelligence,</p>
<p>假设趋势继续保持下去，在本世纪结束前</p>
<p>than the sum total of all human brains combined before the end of this century.</p>
<p>计算机的处理能力/智能会比全人类加起来还多</p>
<p>And this could snowball as such systems need less human input,</p>
<p>然后人的参与会越来越少，</p>
<p>with an artificial superintelligence designing and training new versions of itself.</p>
<p>人工超级智能会开始改造自己</p>
<p>This runaway technological growth, especially with respect to an intelligence explosion,</p>
<p>智能科技的失控性发展</p>
<p>is called the singularity.</p>
<p>叫 "奇点"</p>
<p>The term was first used by our old friend from Episode 10,</p>
<p>第10集约翰·冯·诺伊曼最早用这个词</p>
<p>John von Neumann, who said:</p>
<p>他说：</p>
<p>"The accelerating progress of technology and changes in the mode of human life,</p>
<p>"越来越快的技术发展速度和人类生活方式的改变，</p>
<p>give the appearance of approaching some essential singularity</p>
<p>看起来会接近人类历史中</p>
<p>in the history of the race beyond which human affairs,</p>
<p>某些重要的奇点</p>
<p>as we know them, could not continue."</p>
<p>这个势头不会永远继续下去"</p>
<p>And Von Neumann suggested this back in the 1950s,</p>
<p>冯诺依曼在 1950 年代说的这话.</p>
<p>when computers were trillions of times slower than they are today.</p>
<p>那时计算机比现在慢得多</p>
<p>Sixty years later, though, the singularity is</p>
<p>六十年后的今天，</p>
<p>still just a possibility on the horizon.</p>
<p>奇点仍然在遥远的地平线上</p>
<p>Some experts believe this progress is going to level off,</p>
<p>一些专家认为发展趋势会更平缓一些</p>
<p>and be more of an S curve than an exponential one,</p>
<p>更像是S型，而不是指数型</p>
<p>where as complexity increases, it becomes more difficult to make additional progress.</p>
<p>而随着复杂度增加，进步会越来越难</p>
<p>Microsoft co-founder Paul Allen calls it a "complexity brake".</p>
<p>微软联合创始人保罗·艾伦叫这个"复杂度刹车"</p>
<p>But, as a thought experiment,</p>
<p>但当作思维练习</p>
<p>let’s just say that superintelligent computers will emerge.</p>
<p>我们假设超智能计算机会出现。</p>
<p>What that would mean for humanity is a hotly debated topic.</p>
<p>这对人类意味着什么，是个讨论激烈的话题</p>
<p>There are people who eagerly await it,</p>
<p>有些人迫不及待</p>
<p>and those who are already working to stop it from happening.</p>
<p>有些人则努力阻止它</p>
<p>Probably the most immediate effect would be technological unemployment,</p>
<p>最直接的影响可能是"技术性失业"</p>
<p>where workers in many job sectors are rendered obsolete</p>
<p>很多工作被计算机，</p>
<p>by computers – like AIs and Robots –</p>
<p>比如AI和机器人，给代替掉了</p>
<p>that can do their work better and for less pay.</p>
<p>它们的效率更高，成本更低</p>
<p>Although computers are new, this effect is not.</p>
<p>虽然计算机出现没多久，但"技术性失业"不是新事</p>
<p>Remember Jacquard's Loom from Episode 10?</p>
<p>还记得第10集里雅卡尔的织布机吗？</p>
<p>That automated the task of skilled textile workers back in the 1800s, which led to riots.</p>
<p>它让1800年代的纺织工人失业，导致了骚乱</p>
<p>Also, back then, most of the population of the US and Europe were farmers.</p>
<p>当时美国和欧洲大部分人都是农民</p>
<p>That’s dropped to under 5% today,</p>
<p>如今农民占人口比例&lt;5％</p>
<p>due to advances like synthetic fertilizers and tractors.</p>
<p>因为有合成肥料和拖拉机等等技术</p>
<p>More modern examples include telephone switchboard operators</p>
<p>时间更近一些的例子是"电话接线员"</p>
<p>being replaced with automatic switchboards in 1960,</p>
<p>在1960年被自动接线板代替了</p>
<p>and robotic arms replacing human painters in car factories in the 1980s.</p>
<p>还有1980年代的"机器喷漆臂"替代了人工喷漆</p>
<p>And the list goes on and on.</p>
<p>这样的例子还有很多.</p>
<p>On one hand, these were jobs lost to automation.</p>
<p>一方面，因为自动化失去了工作</p>
<p>And on the other hand, clothes, food, bicycles, toys,</p>
<p>另一方面，我们有衣服，食物，自行车，玩具</p>
<p>and a myriad of other products are all plentiful today</p>
<p>和其它大量产品</p>
<p>because they can be cheaply produced thanks to computing.</p>
<p>因为可以廉价生产</p>
<p>But, experts argue that AI, robots and computing technologies in general,</p>
<p>但专家认为人工智能，机器人以及更广义的计算</p>
<p>are going to be even more disruptive than these historical examples.</p>
<p>比之前更有破坏性</p>
<p>Jobs, at a very high level, can be summarized along two dimensions.</p>
<p>工作可以用两个维度概括</p>
<p>First, jobs can be either more manual – like assembling toys</p>
<p>首先，手工型工作，比如组装玩具</p>
<p>or more cognitive – like picking stocks.</p>
<p>或思维型工作比如选股票</p>
<p>These jobs can also be routine – the same tasks over and over again</p>
<p>还有重复性工作，一遍遍做相同的事</p>
<p>or non-routine, where tasks vary and workers need to problem solve and be creative.</p>
<p>或非重复性，需要创造性的解决问题</p>
<p>We already know that routine-manual jobs can be automated by machines.</p>
<p>我们知道重复性手工工作，可以让机器自动化</p>
<p>It has already happened for some jobs and is happening right now for others.</p>
<p>现在有些已经替代了，剩下的在逐渐替代</p>
<p>What’s getting people worried is that non-routine manual jobs,</p>
<p>让人担心的是"非重复性手工型工作"</p>
<p>like cooks, waiters and security guards, may get automated too.</p>
<p>比如厨师，服务员，保安。</p>
<p>And the same goes for routine cognitive work,</p>
<p>思维型工作也一样</p>
<p>like customer service agents, cashiers, bank tellers, and office assistants.</p>
<p>比如客服，收银员，银行柜员和办公室助理</p>
<p>That leaves us with just one quadrant that might be safe,</p>
<p>剩下一个比较安全的象限</p>
<p>at least for a little while:</p>
<p>至少是暂时的</p>
<p>non-routine cognitive work,</p>
<p>非重复性思维型工作</p>
<p>which includes professions like teachers and artists,</p>
<p>包括教师和艺术家，</p>
<p>novelists and lawyers, and doctors and scientists.</p>
<p>小说家和律师，医生和科学家</p>
<p>These types of jobs encompass roughly 40% of the US workforce.</p>
<p>这类工作占美国劳动力大概40％</p>
<p>That leaves 60% of jobs vulnerable to automation.</p>
<p>意味着剩下60％工作容易受自动化影响</p>
<p>People argue that technological unemployment at this scale</p>
<p>有人认为这种规模的技术失业</p>
<p>would be unprecedented and catastrophic,</p>
<p>是前所未有的，会导致灾难性的后果，</p>
<p>with most people losing their jobs.</p>
<p>大部分人会失业</p>
<p>Others argue that this will be great,</p>
<p>其他人则认为很好，</p>
<p>freeing people from less interesting jobs to pursue better ones,</p>
<p>让人们从无聊工作解脱，去做更好的工作，</p>
<p>all while enjoying a higher standard of living with the bounty of food and products</p>
<p>同时享受更高生活水平，有更多食物和物品</p>
<p>that will result from computers and robots doing most of the hard work.</p>
<p>都是计算机和机器人生产的.</p>
<p>No one really knows how this is going to shake out,</p>
<p>没人知道未来到底会怎样</p>
<p>but if history is any guide, it’ll probably be ok in the long run.</p>
<p>但如果历史有指导意义，长远看一切会归于平静</p>
<p>Afterall, no one is advocating that 90% of people</p>
<p>毕竟，现在没人嚷嚷着让90％的人 </p>
<p>go back to farming and weaving textiles by hand.</p>
<p>回归耕田和纺织</p>
<p>The tough question, which politicians are now discussing,</p>
<p>政界在讨论的棘手问题是</p>
<p>is how to handle hopefully-short-term economic disruption,</p>
<p>怎么处理数百万人突然失业，</p>
<p>for millions of people that might be suddenly out of a job.</p>
<p>造成的短期经济混乱</p>
<p>Beyond the workplace, computers are also very likely to change our bodies.</p>
<p>除了工作，计算机很可能会改变我们的身体</p>
<p>For example, futurist Ray Kurzweil believes that</p>
<p>举个例子, 未来学家 Ray Kurzweil 认为</p>
<p>"The Singularity will allow us to transcend</p>
<p>"奇点会让我们超越 </p>
<p>[the] limitations of our biological bodies and brains.</p>
<p>肉体和大脑的局限性</p>
<p>We will gain power over our fates.</p>
<p>我们能掌控自己的命运</p>
<p>We will be able to live as long as we want.</p>
<p>可以想活多久活多久</p>
<p>We will fully understand human thinking and will vastly extend and expand its reach."</p>
<p>我们能完全理解并扩展大脑思维</p>
<p>Transhumanists see this happening in the form of cyborgs,</p>
<p>超人类主义者认为会出现"改造人"</p>
<p>where humans and technology merge, enhancing our intellect and physiology.</p>
<p>人类和科技融合在一起，增强智力和身体</p>
<p>There are already brain computer interfaces in use today.</p>
<p>如今已经有脑电接口了</p>
<p>And wearable computers, like Google Glass and Microsoft Hololens,</p>
<p>而 Google Glass 和微软 Hololens，这样的穿戴式计算机 </p>
<p>are starting to blur the line too.</p>
<p>也在模糊这条界线</p>
<p>There are also people who foresee "Digital Ascension",</p>
<p>也有人预见到"数字永生"</p>
<p>which, in the words of Jaron Lanier,</p>
<p>Jaron Lanier 的说法是</p>
<p>"would involve people dying in the flesh and being uploaded into a computer and remaining conscious".</p>
<p>"人类的肉体死去，意识上传到计算机"</p>
<p>This transition from biological to digital beings</p>
<p>从生物体变成数字体 </p>
<p>might end up being our next evolutionary step...</p>
<p>可能是下一次进化跨越</p>
<p>and a new level of abstraction.</p>
<p>一层新的抽象</p>
<p>Others predict humans staying largely human,</p>
<p>其他人则预测人类大体会保持原样</p>
<p>but with superintelligent computers as a benevolent force,</p>
<p>但超智能电脑会照顾我们，</p>
<p>emerging as a caretaker for humanity – running all the farms,</p>
<p>帮我们管农场</p>
<p>curing diseases, directing robots to pick-up trash,</p>
<p>治病，指挥机器人收垃圾，</p>
<p>building new homes and many other functions.</p>
<p>建房子以及很多其他事情</p>
<p>This would allow us to simply enjoy our time on this lovely pale blue dot.</p>
<p>让我们在这个可爱蓝点上(地球) 好好享受</p>
<p>Still others view AI with more suspicion –</p>
<p>另一些人对 AI 持怀疑态度 -</p>
<p>why would a superintelligent AI waste its time taking care of us?</p>
<p>为什么超级人工智能会费时间照顾我们？</p>
<p>It’s not like we’ve taken on the role of being the benevolent caretaker of ants.</p>
<p>人类不也没照顾蚂蚁吗？</p>
<p>So maybe this play out like so many Sci-Fi movies</p>
<p>也许会像许多科幻电影一样，</p>
<p>where we’re at war with computers, our own creation having turned on us.</p>
<p>和计算机开战</p>
<p>It’s impossible to know what the future holds,</p>
<p>我们无法知道未来到底会怎样</p>
<p>but it’s great that this discussion and debate is already happening,</p>
<p>但现在已经有相关讨论了，这非常好</p>
<p>so as these technologies emerge, we can plan and react intelligently.</p>
<p>所以等这些技术出现后，我们可以更好地计划</p>
<p>What’s much more likely, regardless of whether you see computers as future friend or foe,</p>
<p>不论你把计算机视为未来的朋友或敌人</p>
<p>is that they will outlive humanity.</p>
<p>更有可能的是，它们的存在时间会超过人类</p>
<p>Many futurists and science fiction writers have speculated</p>
<p>许多未来学家和科幻作家猜测</p>
<p>that computers will head out into space and colonize the galaxy,</p>
<p>机器人会去太空殖民</p>
<p>ambivalent to time scales, radiation,</p>
<p>无视时间，辐射，以及一些其他让人类难以长时间太空旅行的因素.</p>
<p>and all that other stuff that makes</p>
<p>无视时间，辐射，以及一些其他让人类难以长时间太空旅行的因素.</p>
<p>long-distance space travel difficult for us humans.</p>
<p>无视时间，辐射，以及一些其他让人类难以长时间太空旅行的因素.</p>
<p>And when the sun is burned up and the Earth is space dust,</p>
<p>亿万年后太阳燃尽地球成为星尘，</p>
<p>maybe our technological children will be hard at work</p>
<p>也许我们的机器人孩子 </p>
<p>exploring every nook and cranny of the universe,</p>
<p>会继续努力探索宇宙每一个角落</p>
<p>hopefully in honor of their parents’ tradition to build knowledge,</p>
<p>以纪念它们的父母，</p>
<p>improve the state of the universe,</p>
<p>同时让宇宙变得更好，</p>
<p>and to boldly go where no one has gone before!</p>
<p>大胆探索无人深空</p>
<p>In the meantime, computers have a long way to go,</p>
<p>与此同时，计算机还有很长的路要走</p>
<p>and computer scientists are hard at work advancing</p>
<p>计算机科学家们在努力推进</p>
<p>all of the topics we talked about over the past forty episodes.</p>
<p>过去40集谈到的话题</p>
<p>In the next decade or so,</p>
<p>在接下来的十几年</p>
<p>we’ll likely see technologies like virtual and augmented reality,</p>
<p>VR 和 AR，</p>
<p>self-driving vehicles, drones, wearable computers,</p>
<p>无人驾驶车，无人机，可穿戴计算机，</p>
<p>and service robots go mainstream.</p>
<p>和服务型机器人会变得主流</p>
<p>The internet will continue to evolve new services,</p>
<p>互联网会继续诞生新服务</p>
<p>stream new media, and connect people in different ways.</p>
<p>在线看新媒体. 用新方式连接人们</p>
<p>New programming languages and paradigms will be developed</p>
<p>会出现新的编程语言和范例，</p>
<p>to facilitate the creation of new and amazing software.</p>
<p>帮助创造令人惊叹的新软件</p>
<p>And new hardware will make complex operations blazingly fast,</p>
<p>而新硬件能让复杂运算快如闪电，</p>
<p>like neural networks and 3D graphics.</p>
<p>比如神经网络和3D图形</p>
<p>Personal computers are also ripe for innovation,</p>
<p>个人电脑也会创新</p>
<p>perhaps shedding their forty-year old desktop metaphor</p>
<p>不像过去40年着重宣传 "桌面" 电脑</p>
<p>and being reborn as omnipresent and lifelong virtual assistants.</p>
<p>而是变成无处不在的虚拟助手</p>
<p>And there’s so much we didn’t get to talk about in this series,</p>
<p>这个系列我们还有很多话题没谈</p>
<p>like cryptocurrencies, wireless communication,</p>
<p>比如加密货币，无线通讯，</p>
<p>3D printing, bioinformatics, and quantum computing.</p>
<p>3D打印，生物信息学和量子计算</p>
<p>We’re in a golden age of computing</p>
<p>我们正处于计算机的黄金时代</p>
<p>and there’s so much going on, it’s impossible to summarize.</p>
<p>有很多事情在发生，全部总结是不可能的</p>
<p>But most importantly, you can be a part of this amazing transformation and challenge,</p>
<p>但最重要的是你可以成为这个惊人转型的一部分</p>
<p>by learning about computing, and taking what’s arguably humanity’s greatest invention,</p>
<p>通过学习计算机，并采取可以说是人类最伟大的发明</p>
<p>to make the world a better place.</p>
<p>把世界变得更好</p>
<p>Thanks for watching.</p>
<p>感谢收看</p>


<p style='float:right;'>本页共16970段，768945个字符，1012695 Byte(字节)</p>﻿




</div>


<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>

<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
</script>
</div>

</body>
</html>
