<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//谷歌浏览器  
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox等浏览器
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//谷歌浏览器  
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox等浏览器  
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
</script>
<script>
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:link，#container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:85.29%;
	line-height:1.6em;
	overflow:hidden;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}
#goTopBtn, #goBottom, #shangy, #xiay, #menuPage, #lPage, #fPage, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #menuPage, #lPage, #fPage, #ftsize1, #ftsize3{
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #lPage, #fPage, #ftsize, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#fPage{
	bottom: 236px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
	//writing-mode:tb-rl;
}
#menuPage{
	bottom: 198px;
	height:27px;
	white-space:nowrap;
	overflow:hidden;
}
#lPage{
	bottom: 145px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
}
#ftsize1{
	bottom:360px;
}
#ftsize2{
	bottom:334px;
}
#ftsize3{
	bottom:308px;
}
#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #menuPage:hover, #lPage:hover, #fPage:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #menuPage a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link, #menuPage a:visited, #lPage a:link, #fPage a:link, #lPage a:visited, #fPage a:visited {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
.code0, .code2, .code4{
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
.layout, .layout2{
    clear:both;
	width:95%;
	border:1px dotted #eee;
	margin:auto;
	margin-bottom:5px;
	overflow:hidden;
}
.layout2 .right, .layout2 .left, .layout p{
margin-bottom:-55px;
padding-bottom:55px;
text-align: justify;
margin:0;
padding:0;
margin-left:1%;
margin-right:1%;
}
.layout2 .left, .layout p{
float:left;
width:60%;
font-size:1.0em;
}
.layout2 .right,  .layout p+p {
	float: left;
	width:34%;
	border-left:1px dotted #cccccc;
	font-size:0.9em;
	padding-left:1%;
	
}
.layout2 .right p, .layout2 .left p, .layout p{
padding-bottom:5px;
}
h3{
text-indent:3%;
font-size:1em;
height:2.0em;
padding:0;
margin:0;
}
</style>
</head>
<body>
<div id="container">
﻿<div class='layout'><p>28 Computer Networks</p><p>28 计算机网络</p></div>	
<div class='layout'><p>Hi, I'm Carrie Anne, and welcome to Crash Course Computer Science!</p><p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p></div>	
<div class='layout'><p>The internet is amazings</p><p>互联网太棒啦</p></div>	
<div class='layout'><p>In just a few keystrokes, we can stream videos on Youtube -Hello!</p><p>键盘敲几下就能在 Youtube 直播--哈喽！</p></div>	
<div class='layout'><p>read articles on Wikipedia,</p><p>在维基百科上阅读文章</p></div>	
<div class='layout'><p>order supplies on amazon, video chat with friends, and tweet about the weather.</p><p>在亚马逊买东西  和朋友视频  发一条天气推特</p></div>	
<div class='layout'><p>Without a doubt, the ability for computers, and their users, to send and receive information</p><p>毫无疑问，用户在全球网络中发送和接收信息的能力</p></div>	
<div class='layout'><p>over a global telecommunications network forever changed the world.</p><p>永远改变了这个世界</p></div>	
<div class='layout'><p>150 years ago, sending a letter from London to California would have taken two to three</p><p>150年前 发一封信件从伦敦到加州 要花2~3周</p></div>	
<div class='layout'><p>weeks, and that's if you paid for express mail.</p><p>而且还是特快邮件</p></div>	
<div class='layout'><p>Today, that email takes a fraction of a second.</p><p>如今 电子邮件只要几分之一秒.</p></div>	
<div class='layout'><p>This million fold improvement in latency, that's the time it takes for a message to</p><p>时延改善了上百万倍，(时延指传播一条信息所需的时间)</p></div>	
<div class='layout'><p>transfer, juiced up the global economy helping the modern world to</p><p>振兴了全球经济，</p></div>	
<div class='layout'><p>move at the speed of light on fiber optic cables spanning the globe.</p><p>帮助现代世界在遍布全球的光纤中快速发展</p></div>	
<div class='layout'><p>You might think that computers and networks always went hand in hand, but actually most</p><p>你可能觉得计算机和网络密切相关，但事实上，</p></div>	
<div class='layout'><p>computers pre-1970 were humming away all alone.</p><p>1970年以前 大多数计算机是独立运行的</p></div>	
<div class='layout'><p>However, as big computers began popping up everywhere,</p><p>然而 因为大型计算机开始随处可见</p></div>	
<div class='layout'><p>and low cost machines started to show up on people's desks,</p><p>廉价机器开始出现在书桌上</p></div>	
<div class='layout'><p>it became increasingly useful to share data and resources,</p><p>分享数据和资源渐渐变得有用起来</p></div>	
<div class='layout'><p>and the first networks of computers appeared.</p><p>首个计算机网络出现了</p></div>	
<div class='layout'><p>Today, we're going to start a three-episode arc on how computer networks came into being</p><p>今天起，我们花3集视频讲网络是如何发展成现在的样子</p></div>	
<div class='layout'><p>and the fundamental principles and techniques that power them.</p><p>以及支撑它们的基础原理和技术</p></div>	
<div class='layout'><p>The first computer networks appeared in the 1950s and 60s.</p><p>第一个计算机网络出现在1950~1960年代</p></div>	
<div class='layout'><p>They were generally used within an organization – like a company or research lab</p><p>通常在公司或研究室内部使用，</p></div>	
<div class='layout'><p>to facilitate the exchange of information between different people and computers.</p><p>为了方便信息交换</p></div>	
<div class='layout'><p>This was faster and more reliable than the previous method of having someone walk a pile</p><p>比把纸卡或磁带送到另一栋楼里</p></div>	
<div class='layout'><p>of punch cards, or a reel of magnetic tape, to a computer on the other side of a building</p><p>更快速可靠</p></div>	
<div class='layout'><p>which was later dubbed a sneakernet.</p><p>这叫"球鞋网络"</p></div>	
<div class='layout'><p>A second benefit of networks was the ability to share physical resources.</p><p>第二个好处是能共享物理资源</p></div>	
<div class='layout'><p>For example, instead of each computer having its own printer,</p><p>举个例子，与其每台电脑配一台打印机</p></div>	
<div class='layout'><p>everyone could share one attached to the network.</p><p>大家可以共享一台联网的打印机</p></div>	
<div class='layout'><p>It was also common on early networks to have large, shared, storage drives,</p><p>早期网络也会共享存储空间</p></div>	
<div class='layout'><p>ones too expensive to have attached to every machine.</p><p>因为每台电脑都配存储器太贵了</p></div>	
<div class='layout'><p>These relatively small networks of close-by computers</p><p>计算机近距离构成的小型网络，</p></div>	
<div class='layout'><p>are called Local Area Networks, or LANs.</p><p>叫局域网，简称LAN</p></div>	
<div class='layout'><p>A LAN could be as small as two machines in the same room,</p><p>局域网能小到是同一个房间里的两台机器</p></div>	
<div class='layout'><p>or as large as a university campus with thousands of computers.</p><p>或大到校园里的上千台机器</p></div>	
<div class='layout'><p>Although many LAN technologies were developed and deployed,</p><p>尽管开发和部署了很多不同 LAN 技术</p></div>	
<div class='layout'><p>the most famous and successful was Ethernet, developed in the</p><p>其中最著名和成功的是"以太网" ， </p></div>	
<div class='layout'><p>early 1970s at Xerox PARC, and still widely used today.</p><p>开发于1970年代，在施乐的"帕洛阿尔托研究中心"诞生， 今日仍被广泛使用</p></div>	
<div class='layout'><p>In its simplest form, a series of computers are connected to a single, common ethernet cable.</p><p>以太网的最简单形式是：一条以太网电线连接数台计算机</p></div>	
<div class='layout'><p>When a computer wants to transmit data to another computer,</p><p>当一台计算机要传数据给另一台计算机时</p></div>	
<div class='layout'><p>it writes the data, as an electrical signal, onto the cable.</p><p>它以电信号形式，将数据传入电缆</p></div>	
<div class='layout'><p>Of course, because the cable is shared, every computer plugged into the network sees the</p><p>当然 因为电缆是共享的 ，连在同一个网络里的其他计算机也看得到数据</p></div>	
<div class='layout'><p>transmission, but doesn't know if data is intended for them or another computer.</p><p>但不知道数据是给它们的，还是给其他计算机的</p></div>	
<div class='layout'><p>To solve this problem, Ethernet requires that each computer has a unique</p><p>为了解决这个问题 以太网需要每台计算机有唯一的，</p></div>	
<div class='layout'><p>Media Access Control address, or MAC address.</p><p>媒体访问控制地址 简称 MAC地址</p></div>	
<div class='layout'><p>This unique address is put into a header that prefixes any data sent over the network.</p><p>这个唯一的地址放在头部，作为数据的前缀发送到网络中</p></div>	
<div class='layout'><p>So, computers simply listen to the ethernet cable,</p><p>所以，计算机只需要监听以太网电缆，</p></div>	
<div class='layout'><p>and only process data when they see their address in the header.</p><p>只有看到自己的 MAC 地址，才处理数据</p></div>	
<div class='layout'><p>This works really well; every computer made today comes with its own unique MAC address</p><p>这运作得很好 现在制造的每台计算机都自带唯一的MAC地址</p></div>	
<div class='layout'><p>for both Ethernet and WiFi.</p><p>用于以太网和无线网络</p></div>	
<div class='layout'><p>The general term for this approach is Carrier Sense Multiple Access, or CSMA for short.</p><p>多台电脑共享一个传输媒介，这种方法叫 "载波侦听多路访问" 简称"CSMA"</p></div>	
<div class='layout'><p>The "carrier", in this case, is any shared transmission medium that carries data</p><p>载体(carrier)指运输数据的共享媒介</p></div>	
<div class='layout'><p>copper wire in the case of ethernet, and the air carrying radio waves for WiFi.</p><p>以太网的"载体"是铜线，WiFi 的"载体"是传播无线电波的空气</p></div>	
<div class='layout'><p>Many computers can simultaneously sense the carrier,</p><p>很多计算机同时侦听载体</p></div>	
<div class='layout'><p>hence the "Sense" and "Multiple Access",</p><p>所以叫"侦听"和"多路访问"</p></div>	
<div class='layout'><p>and the rate at which a carrier can transmit data is called its Bandwidth.</p><p>而载体传输数据的速度 叫"带宽"</p></div>	
<div class='layout'><p>Unfortunately, using a shared carrier has one big drawback.</p><p>不幸的是 使用共享载体有个很大的弊端</p></div>	
<div class='layout'><p>When network traffic is light, computers can simply wait for silence on the carrier,</p><p>当网络流量较小时 计算机可以等待载体清空</p></div>	
<div class='layout'><p>and then transmit their data.</p><p>然后传送数据</p></div>	
<div class='layout'><p>But, as network traffic increases, the probability that</p><p>但随着网络流量上升 </p></div>	
<div class='layout'><p>two computers will attempt to write data at the same time also increases.</p><p>两台计算机想同时写入数据的概率也会上升</p></div>	
<div class='layout'><p>This is called a collision, and the data gets all garbled up,</p><p>这叫冲突 数据全都乱套了</p></div>	
<div class='layout'><p>like two people trying to talk on the phone at the same time.</p><p>就像两个人同时在电话里讲话</p></div>	
<div class='layout'><p>Fortunately, computers can detect these collisions by listening to the signal on the wire.</p><p>幸运的是 计算机能够通过监听电线中的信号检测这些冲突</p></div>	
<div class='layout'><p>The most obvious solution is for computers to stop transmitting,</p><p>最明显的解决办法是停止传输</p></div>	
<div class='layout'><p>wait for silence, then try again.</p><p>等待网络空闲， 然后再试一遍</p></div>	
<div class='layout'><p>Problem is, the other computer is going to try that too,</p><p>问题是 其他计算机也打算这样做</p></div>	
<div class='layout'><p>and other computers on the network that have been waiting for the</p><p>其他等着的计算机</p></div>	
<div class='layout'><p>carrier to go silent will try to jump in during any pause.</p><p>可能在任何停顿间隙闯入</p></div>	
<div class='layout'><p>This just leads to more and more collisions.</p><p>导致越来越多冲突</p></div>	
<div class='layout'><p>Soon, everyone is talking over one another and has a backlog of things they need to say,</p><p>很快，每个人都一个接一个地讲话 而且有一堆事要说</p></div>	
<div class='layout'><p>like breaking up with a boyfriend over a family holiday dinner.</p><p>就像在家庭聚餐中和男朋友分手一样</p></div>	
<div class='layout'><p>Terrible idea!</p><p>馊主意！</p></div>	
<div class='layout'><p>Ethernet had a surprisingly simple and effective fix.</p><p>以太网有个超简单有效的解决方法</p></div>	
<div class='layout'><p>When transmitting computers detect a collision,</p><p>当计算机检测到冲突 </p></div>	
<div class='layout'><p>they wait for a brief period before attempting to re-transmit.</p><p>就会在重传之前等待一小段时间</p></div>	
<div class='layout'><p>As an example, let's say 1 second.</p><p>因为要举例，假设是 1 秒好了</p></div>	
<div class='layout'><p>Of course, this doesn't work if all the computers use the same wait duration</p><p>当然 如果所有计算机用同样的等待时间 是不行的</p></div>	
<div class='layout'><p>they'll just collide again one second later.</p><p>它们会在一秒后再次冲突</p></div>	
<div class='layout'><p>So, a random period is added: one computer might wait 1.3 seconds,</p><p>所以加入一个随机时间 一台计算机可能等1.3秒</p></div>	
<div class='layout'><p>while another waits 1.5 seconds.</p><p>另一台计算机等待1.5秒</p></div>	
<div class='layout'><p>With any luck, the computer that waited 1.3 seconds will wake up,</p><p>要是运气好 等1.3秒的计算机会醒来</p></div>	
<div class='layout'><p>find the carrier to be silent, and start transmitting.</p><p>发现载体是空闲的 然后开始传输</p></div>	
<div class='layout'><p>When the 1.5 second computer wakes up a moment later, it'll see the carrier is in use,</p><p>当1.5秒的计算机醒来后 会发现载体被占用，</p></div>	
<div class='layout'><p>and will wait for the other computer to finish.</p><p>会等待其他计算机完成</p></div>	
<div class='layout'><p>This definitely helps, but doesn't totally solve the problem, so an extra trick is used.</p><p>这有用 但不能完全解决问题 所以要用另一个小技巧</p></div>	
<div class='layout'><p>As I just explained, if a computer detects a collision while transmitting,</p><p>正如我刚才说的 ，如果一台计算机在传输数据期间检测到冲突</p></div>	
<div class='layout'><p>it will wait 1 second, plus some random extra time.</p><p>会等一秒+随机时间</p></div>	
<div class='layout'><p>However, if it collides again, which suggests network congestion,</p><p>然而 如果再次发生冲突 表明有网络拥塞</p></div>	
<div class='layout'><p>instead of waiting another 1 second, this time it will wait 2 seconds.</p><p>这次不等1秒，而是等2秒</p></div>	
<div class='layout'><p>If it collides again, it'll wait 4 seconds, and then 8, and then 16,</p><p>如果再次发生冲突 等4秒 然后8秒 16秒等等</p></div>	
<div class='layout'><p>and so on, until it's successful.</p><p>直到成功传输</p></div>	
<div class='layout'><p>With computers backing off, the rate of collisions goes down,</p><p>因为计算机的退避 冲突次数降低了，</p></div>	
<div class='layout'><p>and data starts moving again, freeing up the network.</p><p>数据再次开始流动起来 网络变得顺畅</p></div>	
<div class='layout'><p>Family dinner saved!</p><p>家庭晚餐有救啦！</p></div>	
<div class='layout'><p>This "backing off" behavior using an exponentially growing wait time is called</p><p>这种指数级增长等待时间的方法叫：</p></div>	
<div class='layout'><p>Exponential Backoff.</p><p>指数退避</p></div>	
<div class='layout'><p>Both Ethernet and WiFi use it, and so do many transmission protocols.</p><p>以太网和WiFi都用这种方法 很多其他传输协议也用</p></div>	
<div class='layout'><p>But even with clever tricks like Exponential Backoff,</p><p>但即便有了"指数退避"这种技巧</p></div>	
<div class='layout'><p>you could never have an entire university's</p><p>想用一根网线链接整个大学的计算机</p></div>	
<div class='layout'><p>worth of computers on one shared ethernet cable.</p><p>还是不可能的</p></div>	
<div class='layout'><p>To reduce collisions and improve efficiency,</p><p>为了减少冲突+提升效率</p></div>	
<div class='layout'><p>we need to shrink the number of devices on any given shared carrier</p><p>我们需要减少同一载体中设备的数量，</p></div>	
<div class='layout'><p>what's called the Collision Domain.</p><p>载体和其中的设备总称 "冲突域"</p></div>	
<div class='layout'><p>Let go back to our earlier Ethernet example, where we had six computers on one shared cable,</p><p>让我们回到之前以太网的例子  一根电缆连6台计算机</p></div>	
<div class='layout'><p>a.k.a. one collision domain.</p><p>也叫一个冲突域</p></div>	
<div class='layout'><p>To reduce the likelihood of collisions, we can break this network</p><p>为了减少冲突</p></div>	
<div class='layout'><p>into two collision domains by using a Network Switch.</p><p>我们可以用交换机把它拆成两个冲突域</p></div>	
<div class='layout'><p>It sits between our two smaller networks, and only passes data between them if necessary.</p><p>交换机位于两个更小的网络之间，必要时才在两个网络间传数据</p></div>	
<div class='layout'><p>It does this by keeping a list of what MAC addresses are on what side of the network.</p><p>交换机会记录一个列表，写着哪个 MAC 地址在哪边网络</p></div>	
<div class='layout'><p>So if A wants to transmit to C, the switch doesn't forward the data to the other network</p><p>如果A想传数据给C，交换机不会把数据转发给另一边的网络</p></div>	
<div class='layout'><p>there's no need.</p><p>没必要</p></div>	
<div class='layout'><p>This means if E wants to transmit to F at the same time, the network is wide open, and</p><p>如果E想同一时间传数据给F，网络仍然是空的</p></div>	
<div class='layout'><p>two transmissions can happen at once.</p><p>两个传输可以同时发生</p></div>	
<div class='layout'><p>But, if F wants to send data to A, then the switch passes it through,</p><p>但如果F想发数据给A  数据会通过交换机</p></div>	
<div class='layout'><p>and the two networks are both briefly occupied.</p><p>两个网络都会被短暂占用</p></div>	
<div class='layout'><p>This is essentially how big computer networks are constructed,</p><p>大的计算机网络也是这样构建的</p></div>	
<div class='layout'><p>including the biggest one of all – The Internet –</p><p>包括最大的网络 互联网</p></div>	
<div class='layout'><p>which literally inter-connects a bunch of smaller networks,</p><p>也是多个连在一起的稍小一点网络</p></div>	
<div class='layout'><p>allowing inter-network communication.</p><p>使不同网络间可以传递信息</p></div>	
<div class='layout'><p>What's interesting about these big networks,</p><p>这些大型网络有趣之处是</p></div>	
<div class='layout'><p>is that there's often multiple paths to</p><p>从一个地点到另一个地点</p></div>	
<div class='layout'><p>get data from one location to another.</p><p>通常有多条路线</p></div>	
<div class='layout'><p>And this brings us to another fundamental networking topic, routing.</p><p>这就带出了另一个话题 路由</p></div>	
<div class='layout'><p>The simplest way to connect two distant computers, or networks,</p><p>连接两台相隔遥远的计算机或网路，</p></div>	
<div class='layout'><p>is by allocating a communication line for their exclusive use.</p><p>最简单的办法，是分配一条专用的通信线路</p></div>	
<div class='layout'><p>This is how early telephone systems worked.</p><p>早期电话系统就是这样运作的</p></div>	
<div class='layout'><p>For example, there might be 5 telephone lines running between Indianapolis and Missoula.</p><p>假设"印第安纳波利斯"和"米苏拉"之间，有五条电话线</p></div>	
<div class='layout'><p>If John picked up the phone wanting to call Hank, in the 1910s,</p><p>如果在1910年代，John 想打电话给 Hank</p></div>	
<div class='layout'><p>John would tell a human operator where he wanted to call,</p><p>John要告诉操作员他想打到什么地方</p></div>	
<div class='layout'><p>and they'd physically connect John's phone line into</p><p>然后工作人员手动将 John 的电话连到，</p></div>	
<div class='layout'><p>an unused line running to Missoula.</p><p>通往米苏拉的未使用线路</p></div>	
<div class='layout'><p>For the length of the call, that line was occupied, and if all 5 lines were already</p><p>通话期间 这条线就被占用了 如果五条线都被占用了，</p></div>	
<div class='layout'><p>in use, John would have to wait for one to become free.</p><p>John 要等待某条线空出来</p></div>	
<div class='layout'><p>This approach is called Circuit Switching,</p><p>这叫 "电路交换"，</p></div>	
<div class='layout'><p>because you're literally switching whole</p><p>因为是把电路</p></div>	
<div class='layout'><p>circuits to route traffic to the correct destination.</p><p>连接到正确目的地</p></div>	
<div class='layout'><p>It works fine, but it's relatively inflexible and expensive,</p><p>能用倒是能用，但不灵活而且价格昂贵 </p></div>	
<div class='layout'><p>because there's often unused capacity.</p><p>因为总有闲置的线路</p></div>	
<div class='layout'><p>On the upside, once you have a line to yourself – or if you have the money to buy one for</p><p>好处是 如果有一条专属于自己的线路，</p></div>	
<div class='layout'><p>your private use – you can use it to its full capacity, without having to share.</p><p>你可以最大限度地随意使用，无需共享</p></div>	
<div class='layout'><p>For this reason, the military, banks and other high importance operations</p><p>因此军队， 银行和其他一些机构</p></div>	
<div class='layout'><p>still buy dedicated circuits to connect their data centers.</p><p>依然会购买专用线路来连接数据中心</p></div>	
<div class='layout'><p>Another approach for getting data from one place to another is Message Switching,</p><p>传输数据的另一个方法是 "报文交换"</p></div>	
<div class='layout'><p>which is sort of like how the postal system works.</p><p>报文交换 就像邮政系统一样</p></div>	
<div class='layout'><p>Instead of dedicated route from A to B, messages are passed through several stops.</p><p>不像之前A和B有一条专有线路，消息会经过好几个站点</p></div>	
<div class='layout'><p>So if John writes a letter to Hank,</p><p>如果 John 写一封信给 Hank</p></div>	
<div class='layout'><p>it might go from Indianapolis to Chicago, and then</p><p>信件可能从"印第安纳波利斯"到"芝加哥"</p></div>	
<div class='layout'><p>hop to Minneapolis, then Billings, and then finally make it to Missoula.</p><p>然后"明尼阿波利斯" 然后"比林斯" 最后到"米苏拉"</p></div>	
<div class='layout'><p>Each stop knows where to send it next</p><p>每个站点都知道下一站发哪里，</p></div>	
<div class='layout'><p>because they keep a table of where to pass letters given a destination address.</p><p>因为站点有表格，记录到各个目的地，信件该怎么传</p></div>	
<div class='layout'><p>What's neat about Message Switching is that it can use different routes,</p><p>报文交换的好处是 可以用不同路由，</p></div>	
<div class='layout'><p>making communication more reliable and fault-tolerant.</p><p>使通信更可靠更能容错</p></div>	
<div class='layout'><p>Sticking with our mail example,</p><p>回到邮件的例子</p></div>	
<div class='layout'><p>if there's a blizzard in Minneapolis grinding things to a halt,</p><p>如果"明尼阿波利斯"有暴风雪中断了通信，</p></div>	
<div class='layout'><p>the Chicago mail hub can decide to route the letter through Omaha instead.</p><p>芝加哥可以传给"奥马哈"</p></div>	
<div class='layout'><p>In our example, cities are acting like network routers.</p><p>在这个例子里，城市就像路由器一样</p></div>	
<div class='layout'><p>The number of hops a message takes along a route is called the hop count.</p><p>消息沿着路由跳转的次数，叫"跳数"(hop count)</p></div>	
<div class='layout'><p>Keeping track of the hop count is useful because it can help identify routing problems.</p><p>记录跳数很有用，因为可以分辨出路由问题</p></div>	
<div class='layout'><p>For example, let's say Chicago thinks the fastest route to Missoula is through Omaha,</p><p>举例，假设芝加哥认为，去米苏拉的最快路线是 奥马哈</p></div>	
<div class='layout'><p>but Omaha thinks the fastest route is through Chicago.</p><p>但奥马哈认为，去米苏拉的最快路线是 芝加哥</p></div>	
<div class='layout'><p>That's bad, because both cities are going to look at the destination address, Missoula,</p><p>这就糟糕了，因为2个城市看到目的地是米苏拉</p></div>	
<div class='layout'><p>and end up passing the message back and forth between them, endlessly.</p><p>结果报文会在2个城市之间，不停传来传去</p></div>	
<div class='layout'><p>Not only is this wasting bandwidth, but it's a routing error that needs to get fixed!</p><p>不仅浪费带宽 而且这个路由错误需要修复！</p></div>	
<div class='layout'><p>This kind of error can be detected because the hop count is</p><p>这种错误会被检测到，因为跳数记录在消息中，</p></div>	
<div class='layout'><p>stored with the message and updated along its journey.</p><p>而且传输时会更新跳数</p></div>	
<div class='layout'><p>If you start seeing messages with high hop counts,</p><p>如果看到某条消息的跳数很高，</p></div>	
<div class='layout'><p>you can bet something has gone awry in the routing!</p><p>就知道路由肯定哪里错了</p></div>	
<div class='layout'><p>This threshold is the Hop Limit.</p><p>这叫"跳数限制"</p></div>	
<div class='layout'><p>A downside to Message Switching is that messages are sometimes big.</p><p>报文交换的缺点之一是有时候报文比较大</p></div>	
<div class='layout'><p>So, they can clog up the network, because the whole message has to be transmitted from</p><p>会堵塞网络 因为要把整个报文从一站传到下一站后，</p></div>	
<div class='layout'><p>one stop to the next before continuing on its way.</p><p>才能继续传递其他报文</p></div>	
<div class='layout'><p>While a big file is transferring, that whole link is tied up.</p><p>传输一个大文件时  整条路都阻塞了</p></div>	
<div class='layout'><p>Even if you have a tiny, one kilobyte email trying to get through,</p><p>即便你只有一个1KB的电子邮件要传输，也只能等大文件传完，</p></div>	
<div class='layout'><p>it either has to wait for the big file transfer to finish or take a less efficient route.</p><p>或是选另一条效率稍低的路线</p></div>	
<div class='layout'><p>That's bad.</p><p>这就糟了</p></div>	
<div class='layout'><p>The solution is to chop up big transmissions into many small pieces, called packets.</p><p>解决方法是 将大报文分成很多小块，叫"数据包"</p></div>	
<div class='layout'><p>Just like with Message Switching, each packet contains a destination address on the network,</p><p>就像报文交换 每个数据包都有目标地址，</p></div>	
<div class='layout'><p>so routers know where to forward them.</p><p>因此路由器知道发到哪里</p></div>	
<div class='layout'><p>This format is defined by the "Internet Protocol", or IP for short,</p><p>报文具体格式由"互联网协议"定义，简称 IP，</p></div>	
<div class='layout'><p>a standard created in the 1970s.</p><p>这个标准创建于 1970 年代</p></div>	
<div class='layout'><p>Every computer connected to a network gets an IP Address.</p><p>每台联网的计算机都需要一个IP地址</p></div>	
<div class='layout'><p>You've probably seen these as four, 8-bit numbers written with dots in between.</p><p>你可能见过，以点分隔的4组数字</p></div>	
<div class='layout'><p>For example,172.217.7.238 is an IP Address for one of Google's servers.</p><p>例如 172.217.7.238 是 Google 其中一个服务器的IP地址</p></div>	
<div class='layout'><p>With millions of computers online, all exchanging data,</p><p>数百万台计算机在网络上不断交换数据，</p></div>	
<div class='layout'><p>bottlenecks can appear and disappear in milliseconds.</p><p>瓶颈的出现和消失是毫秒级的</p></div>	
<div class='layout'><p>Network routers are constantly trying to balance the load across whatever routes they know</p><p>路由器会平衡与其他路由器之间的负载，</p></div>	
<div class='layout'><p>to ensure speedy and reliable delivery, which is called congestion control.</p><p>以确保传输可以快速可靠，这叫"阻塞控制"</p></div>	
<div class='layout'><p>Sometimes different packets from the same message take different routes through a network.</p><p>有时，同一个报文的多个数据包，会经过不同线路</p></div>	
<div class='layout'><p>This opens the possibility of packets arriving at their destination out of order,</p><p>到达顺序可能会不一样，</p></div>	
<div class='layout'><p>which is a problem for some applications.</p><p>这对一些软件是个问题</p></div>	
<div class='layout'><p>Fortunately, there are protocols that run on top of IP,</p><p>幸运的是，在 IP 之上还有其他协议</p></div>	
<div class='layout'><p>like TCP/IP, that handle this issue.</p><p>比如 TCP/IP， 可以解决乱序问题</p></div>	
<div class='layout'><p>We'll talk more about that next week.</p><p>我们下周会讲</p></div>	
<div class='layout'><p>Chopping up data into small packets,</p><p>将数据拆分成多个小数据包，</p></div>	
<div class='layout'><p>and passing these along flexible routes with spare capacity,</p><p>然后通过灵活的路由传递</p></div>	
<div class='layout'><p>is so efficient and fault-tolerant, it's what the whole internet runs on today.</p><p>非常高效且可容错，如今互联网就是这么运行的</p></div>	
<div class='layout'><p>This routing approach is called Packet Switching.</p><p>这叫"分组交换"</p></div>	
<div class='layout'><p>It also has the nice property of being decentralized,</p><p>有个好处是 它是去中心化的</p></div>	
<div class='layout'><p>with no central authority or single point of failure.</p><p>没有中心权威机构  没有单点失败问题</p></div>	
<div class='layout'><p>In fact, the threat of nuclear attack is why</p><p>事实上 因为冷战期间有核攻击的威胁，</p></div>	
<div class='layout'><p>packet switching was developed during the cold war!</p><p>所以创造了分组交换</p></div>	
<div class='layout'><p>Today, routers all over the globe work cooperatively to find efficient routings,</p><p>如今，全球的路由器协同工作，找出最高效的线路</p></div>	
<div class='layout'><p>exchanging information with each other using special protocols,</p><p>用各种标准协议运输数据</p></div>	
<div class='layout'><p>like the Internet Control Message Protocol (ICMP)</p><p>比如 "因特网控制消息协议"(ICMP)</p></div>	
<div class='layout'><p>and the Border Gateway Protocol (BGP).</p><p>和 "边界网关协议"(BGP)</p></div>	
<div class='layout'><p>The world's first packet-switched network,</p><p>世界上第一个分组交换网络</p></div>	
<div class='layout'><p>and the ancestor to the modern internet, was the ARPANET,</p><p>以及现代互联网的祖先是 ARPANET</p></div>	
<div class='layout'><p>named after the US agency that funded it,</p><p>名字来源于赞助这个项目的机构，</p></div>	
<div class='layout'><p>the Advanced Research Projects Agency.</p><p>美国高级研究计划局</p></div>	
<div class='layout'><p>Here's what the entire ARPANET looked like in 1974.</p><p>这是 1974 年整个 ARPANET 的样子</p></div>	
<div class='layout'><p>Each smaller circle is a location,</p><p>每个小圆表示一个地点，</p></div>	
<div class='layout'><p>like a university or research lab, that operated a router.</p><p>比如大学或实验室，那里运行着一个路由器</p></div>	
<div class='layout'><p>They also plugged in one or more computers</p><p>并且有一台或多台计算机</p></div>	
<div class='layout'><p>you can see PDP-1's, IBM System 360s,</p><p>能看到 "PDP-1" 和"IBM 360系统"</p></div>	
<div class='layout'><p>and even an ATLAS in London connected over a satellite link.</p><p>甚至还有一个伦敦的 ATLAS，是通过卫星连到网络里的</p></div>	
<div class='layout'><p>Obviously the internet has grown by leaps and bounds in the decades since.</p><p>显然 互联网在这几十年间发展迅速</p></div>	
<div class='layout'><p>Today, instead of a few dozen computers online, it's estimated to be nearing 10 billion.</p><p>如今不再只有几十台计算机联网，据估计 有接近100亿台联网设备</p></div>	
<div class='layout'><p>And it continues to grow rapidly,</p><p>而且互联网会继续快速发展</p></div>	
<div class='layout'><p>especially with the advent of wifi-connected refrigerators, thermostat</p><p>特别是如今各种智能设备层出不穷，比如联网冰箱，恒温器</p></div>	
<div class='layout'><p>and other smart appliances, forming an "internet of things".</p><p>以及其他智能家电，它们组成了"物联网"</p></div>	
<div class='layout'><p>So that's part one – an overview of computer networks.</p><p>第一部分到此结束 ，我们对计算机网络进行了概览</p></div>	
<div class='layout'><p>Is it a series of tubes?</p><p>网络是一堆管子组成的吗？</p></div>	
<div class='layout'><p>Well, sort of.</p><p>额 算是吧</p></div>	
<div class='layout'><p>Next week we'll tackle some higher-level transmission protocols,</p><p>下周我们会讨论一些高级传输协议</p></div>	
<div class='layout'><p>slowly working our way up to the World Wide Web.</p><p>然后讲万维网</p></div>	
<div class='layout'><p>I'll see you then!</p><p>到时见啦</p></div>	
﻿
</div> <!--container-->
<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>
<a id="fPagea" href="index.html" target="_self"><div id="fPage" style="color:#fff;">上<br>一<br>章</div></a>
<a href="index.html" target="_self"><div id="menuPage" style="color:#fff;">目<br>录</div></a>
<a id="LPagea" href="javascript:void(null)" target="_self"><div id="lPage" style="color:#fff;">下<br>一<br>章</div></a>
<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
	//上一页、下一页按钮，需要文件名是数字
	var strUrl=window.location.href;
	var arrUrl=strUrl.split("/");
	var thispage=arrUrl[arrUrl.length-1];
	var thispage2=thispage.split(".");
	var thispage3=thispage2[thispage2.length-2];
	if(thispage3 == 0){
		var obj5=document.getElementById("fPage");
		obj5.style.display="none";
	}else{
		var fpage = thispage3 - 1;
		fpage = fpage +".html";
		document.getElementById("fPagea").href=fpage;
	}
	if(thispage3 == 100){
		var obj6=document.getElementById("lPage");
		obj6.style.display="none";
	}else{
		var fpage = parseInt(thispage3) + 1;
		fpage = fpage +".html";
		document.getElementById("LPagea").href=fpage;
	}
</script>
</div>
</body>
</html>
