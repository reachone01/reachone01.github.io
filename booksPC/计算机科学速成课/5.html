<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//谷歌浏览器  
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox等浏览器
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//谷歌浏览器  
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox等浏览器  
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
</script>
<script>
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:link，#container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:85.29%;
	line-height:1.6em;
	overflow:hidden;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}
#goTopBtn, #goBottom, #shangy, #xiay, #menuPage, #lPage, #fPage, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #menuPage, #lPage, #fPage, #ftsize1, #ftsize3{
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #lPage, #fPage, #ftsize, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#fPage{
	bottom: 236px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
	//writing-mode:tb-rl;
}
#menuPage{
	bottom: 198px;
	height:27px;
	white-space:nowrap;
	overflow:hidden;
}
#lPage{
	bottom: 145px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
}
#ftsize1{
	bottom:360px;
}
#ftsize2{
	bottom:334px;
}
#ftsize3{
	bottom:308px;
}
#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #menuPage:hover, #lPage:hover, #fPage:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #menuPage a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link, #menuPage a:visited, #lPage a:link, #fPage a:link, #lPage a:visited, #fPage a:visited {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
.code0, .code2, .code4{
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
.layout, .layout2{
    clear:both;
	width:95%;
	border:1px dotted #eee;
	margin:auto;
	margin-bottom:5px;
	overflow:hidden;
}
.layout2 .right, .layout2 .left, .layout p{
margin-bottom:-55px;
padding-bottom:55px;
text-align: justify;
margin:0;
padding:0;
margin-left:1%;
margin-right:1%;
}
.layout2 .left, .layout p{
float:left;
width:60%;
font-size:1.0em;
}
.layout2 .right,  .layout p+p {
	float: left;
	width:34%;
	border-left:1px dotted #cccccc;
	font-size:0.9em;
	padding-left:1%;
	
}
.layout2 .right p, .layout2 .left p, .layout p{
padding-bottom:5px;
}
h3{
text-indent:3%;
font-size:1em;
height:2.0em;
padding:0;
margin:0;
}
</style>
</head>
<body>
<div id="container">
﻿<div class='layout'><p>5 How Computers Calculate - the ALU</p><p>算术逻辑单元</p></div>	
<div class='layout'><p>Hi, I'm Carrie Ann and this is Crash Course Computer Science.</p><p>嗨，我是CarrieAnne，欢迎收看计算机科学速成课</p></div>	
<div class='layout'><p>So last episode, we talked about how numbers can be represented in binary.</p><p>上集，我们谈了如何用二进制表示数字</p></div>	
<div class='layout'><p>Representing Like, 00101010 is 42 in decimal.</p><p>比如二进制00101010是十进制的42</p></div>	
<div class='layout'><p>Representing and storing numbers is an important function of a computer,</p><p>表示和存储数字是计算机的重要功能</p></div>	
<div class='layout'><p>but the real goal is computation, or manipulating numbers in a structured and purposeful way,</p><p>但真正的目标是计算，有意义的处理数字</p></div>	
<div class='layout'><p>like adding two numbers together.</p><p>比如把两个数字相加</p></div>	
<div class='layout'><p>These operations are handled by a computer's Arithmetic and Logic Unit,</p><p>这些操作由计算机的"算术逻辑单元"处理</p></div>	
<div class='layout'><p>but most people call it by its street name:</p><p>但大家会简称：</p></div>	
<div class='layout'><p>the ALU.</p><p>ALU</p></div>	
<div class='layout'><p>The ALU is the mathematical brain of a computer.</p><p>ALU是计算机的数学大脑</p></div>	
<div class='layout'><p>When you understand an ALU's design and function,</p><p>等你理解了ALU的设计和功能之后</p></div>	
<div class='layout'><p>you'll understand a fundamental part of modern computers.</p><p>你就理解了现代计算机的基石</p></div>	
<div class='layout'><p>It is THE thing that does all of the computation in a computer,</p><p>ALU*就是*计算机里负责运算的组件，</p></div>	
<div class='layout'><p>so basically everything uses it.</p><p>基本其他所有部件都用到了它</p></div>	
<div class='layout'><p>First though, look at this beauty.</p><p>先来看看这个美人</p></div>	
<div class='layout'><p>This is perhaps the most famous ALU ever, the Intel 74181.</p><p>这可能是最著名的ALU，英特尔74181</p></div>	
<div class='layout'><p>When it was released in 1970,</p><p>1970年发布时，</p></div>	
<div class='layout'><p>it was It was the first complete ALU that fit entirely inside of a single chip -</p><p>它是第一个封装在单个芯片内的完整ALU</p></div>	
<div class='layout'><p>Which was a huge engineering feat at the time.</p><p>这在当时是惊人的工程壮举</p></div>	
<div class='layout'><p>So today we're going to take those Boolean logic gates we learned about last week</p><p>今天我们用上周学的布尔逻辑门</p></div>	
<div class='layout'><p>to build a simple ALU circuit with much of the same functionality as the 74181.</p><p>做一个简单的ALU电路，功能和74181一样</p></div>	
<div class='layout'><p>And over the next few episodes we'll use this to construct a computer from scratch.</p><p>然后接下来几集，用它从头做出一台电脑</p></div>	
<div class='layout'><p>So it's going to get a little bit complicated,</p><p>所以会有点复杂</p></div>	
<div class='layout'><p>but I think you guys can handle it.</p><p>但我觉得你们搞的定</p></div>	
<div class='layout'><p>An ALU is really two units in one</p><p>ALU有2个单元，</p></div>	
<div class='layout'><p>there's an arithmetic unit and a logic unit.</p><p>1个算术单元和1个逻辑单元</p></div>	
<div class='layout'><p>Let's start with the arithmetic unit,</p><p>我们先讲"算术单元"，</p></div>	
<div class='layout'><p>which is responsible for handling all numerical operations in a computer,</p><p>它负责计算机里的所有数字操作</p></div>	
<div class='layout'><p>like addition and subtraction.</p><p>比如加减法</p></div>	
<div class='layout'><p>It also does a bunch of other simple things like add one to a number,</p><p>它还做很多其他事情，比如给某个数字+1</p></div>	
<div class='layout'><p>which is called an increment operation, but we'll talk about those later.</p><p>这叫增量运算，我们之后会说</p></div>	
<div class='layout'><p>Today, we're going to focus on the piece of rsistance, the crme de la crme of operations</p><p>今天的重点是一切的根本</p></div>	
<div class='layout'><p>that underlies almost everything else a computer does adding two numbers together.</p><p>"把两个数字相加"</p></div>	
<div class='layout'><p>We could build this circuit entirely out of individual transistors,</p><p>我们可以用单个晶体管一个个拼，把这个电路做出来，</p></div>	
<div class='layout'><p>but that would get confusing really fast.</p><p>但很快就会复杂的难以理解</p></div>	
<div class='layout'><p>So instead as we talked about in Episode 3</p><p>所以与其用晶体管，我们会像第3集</p></div>	
<div class='layout'><p>we can use a high-level of abstraction and build our components out of logic gates,</p><p>用更高层的抽象，用逻辑门来做</p></div>	
<div class='layout'><p>in this case: AND, OR, NOT and XOR gates.</p><p>我们会用到AND，OR，NOT和XOR逻辑门</p></div>	
<div class='layout'><p>The simplest adding circuit that we can build takes two binary digits, and adds them together.</p><p>最简单的加法电路，是拿2个bit加在一起（bit是0或1）</p></div>	
<div class='layout'><p>So we have two inputs, A and B, and one output, which is the sum of those two digits.</p><p>有2个输入：A和B，1个输出：就是两个数字的和</p></div>	
<div class='layout'><p>Just to clarify: A, B and the output are all single bits.</p><p>需要注意的是：A，B，输出，这3个都是单个Bit（0或1）</p></div>	
<div class='layout'><p>There are only four possible input combinations.</p><p>输入只有四种可能</p></div>	
<div class='layout'><p>The first three are: 0+0 = 0</p><p>前三个是，0+0=0</p></div>	
<div class='layout'><p>1+0 = 1 0+1 = 1</p><p>1+0=1，0+1=1</p></div>	
<div class='layout'><p>Remember that in binary, 1 is the same as true, and 0 is the same as false.</p><p>记住二进制里，1与true相同，0与false相同</p></div>	
<div class='layout'><p>So this set of inputs exactly matches the boolean logic of an XOR gate,</p><p>这组输入和输出，和XOR门的逻辑完全一样</p></div>	
<div class='layout'><p>and we can use it as our 1-bit adder.</p><p>所以我们可以把XOR用作1位加法器（adder）</p></div>	
<div class='layout'><p>But the fourth input combination, 1 + 1, is a special case. 1 + 1 is 2 (obviously)</p><p>但第四个输入组合，1+1，是个特例，1+1=2（显然）</p></div>	
<div class='layout'><p>but there's no 2 digit in binary,</p><p>但二进制里没有2</p></div>	
<div class='layout'><p>so as we talked about last episode, the result is 0 and the 1 is carried to the next column.</p><p>上集说过，二进制1+1的结果是0，1进到下一位</p></div>	
<div class='layout'><p>So the sum is really 10 in binary.</p><p>和是10<sup>(二进制)</sup></p></div>	
<div class='layout'><p>Now, the output of our XOR gate is partially correct 1 plus 1, outputs 0.</p><p>XOR门的输出，只对了一部分，1+1输出0</p></div>	
<div class='layout'><p>But, we need an extra output wire for that carry bit.</p><p>但我们需要一根额外的线代表"进位"</p></div>	
<div class='layout'><p>The carry bit is only "true" when the inputs are 1 AND 1,</p><p>只有输入是1和1时，进位才是"true"</p></div>	
<div class='layout'><p>because that's the only time when the result (two) is bigger than 1 bit can store</p><p>因为算出来的结果用1个bit存不下</p></div>	
<div class='layout'><p>and conveniently we have a gate for that!</p><p>方便的是，我们刚好有个逻辑门能做这个事！</p></div>	
<div class='layout'><p>It's not that complicated just two logic gates -</p><p>没那么复杂就两个逻辑门而已</p></div>	
<div class='layout'><p>but let's abstract away even this level of detail</p><p>让我们抽象化</p></div>	
<div class='layout'><p>and encapsulate our newly minted half adder as its own component,</p><p>把"半加器"封装成一个单独组件</p></div>	
<div class='layout'><p>with two inputs bits A and B and two outputs, the sum and the carry bits.</p><p>两个输入A和B都是1位，两个输出"总和"与"进位"</p></div>	
<div class='layout'><p>This takes us to another level of abstraction</p><p>这进入了另一层抽象</p></div>	
<div class='layout'><p>heh I feel like I say that a lot.</p><p>我好像说了很多次，</p></div>	
<div class='layout'><p>I wonder if this is going to become a thing.</p><p>说不定会变成一个梗</p></div>	
<div class='layout'><p>Anyway, If you want to add more than 1 + 1</p><p>如果想处理超过1+1的运算，</p></div>	
<div class='layout'><p>we're going to need a "Full Adder."</p><p>如我们需要"全加器"</p></div>	
<div class='layout'><p>That half-adder left us with a carry bit as output.</p><p>半加器输出了进位</p></div>	
<div class='layout'><p>That means that when we move on to the next column in a multi-column addition,</p><p>意味着，我们算下一列的时候</p></div>	
<div class='layout'><p>and every column after that, we are going to have to add three bits together, no two.</p><p>还有之后的每一列，我们得加3个位在一起，并不是2个</p></div>	
<div class='layout'><p>A full adder is a bit more complicated</p><p>全加器复杂了一点点</p></div>	
<div class='layout'><p>it takes three bits as inputs: A, B and C.</p><p>有3个输入：A，B，C（都是1个bit)</sup></p></div>	
<div class='layout'><p>So the maximum possible input is 1 + 1 + 1,</p><p>所以最大的可能是1+1+1</p></div>	
<div class='layout'><p>which equals 1 carry out 1, so we still only need two output wires: sum and carry.</p><p>总和1"进位"1，所以要两条输出线："总和"和"进位"</p></div>	
<div class='layout'><p>We can build a full adder using half adders.</p><p>我们可以用半加器做全加器</p></div>	
<div class='layout'><p>To do this, we use a half adder to add A plus B</p><p>我们先用半加器将A和B相加</p></div>	
<div class='layout'><p>just like before but then feed that result and input C into a second half adder.</p><p>然后把C输入到第二个半加器</p></div>	
<div class='layout'><p>Lastly, we need a OR gate to check if either one of the carry bits was true.</p><p>最后用一个OR门检查进位是不是true</p></div>	
<div class='layout'><p>That's it, we just made a full adder!</p><p>这样就做出了一个全加器！</p></div>	
<div class='layout'><p>Again,we can go up a level of abstraction and wrap up this full adder as its own component.</p><p>我们可以再提升一层抽象，把全加器作为独立组件</p></div>	
<div class='layout'><p>It takes three inputs, adds them, and outputs the sum and the carry, if there is one.</p><p>全加器会把A，B，C三个输入加起来，输出"总和"和"进位"</p></div>	
<div class='layout'><p>Armed with our new components, we can now build a circuit that takes two, 8-bit numbers</p><p>现在有了新组件，我们可以相加两个8位数字</p></div>	
<div class='layout'><p>Let's call them A and B  and adds them together.</p><p>叫两个数字叫A和B好了</p></div>	
<div class='layout'><p>Let's start with the very first bit of A and B,</p><p>我们从A和B的第一位开始</p></div>	
<div class='layout'><p>which we'll call A0 and B0.</p><p>叫A0和B0好了</p></div>	
<div class='layout'><p>At this point, there is no carry bit to deal with,</p><p>现在不用处理任何进位，</p></div>	
<div class='layout'><p>because this is our first addition.</p><p>因为是第一次加法</p></div>	
<div class='layout'><p>So we can use our half adder to add these two bits together.</p><p>所以我们可以用半加器，来加这2个数字</p></div>	
<div class='layout'><p>The output is sum0.</p><p>输出叫sum0</p></div>	
<div class='layout'><p>Now we want to add A1 and B1 together.</p><p>现在加A1和B1</p></div>	
<div class='layout'><p>It's possible there was a carry from the previous addition of A0 and B0,</p><p>因为A0和B0的结果有可能进位</p></div>	
<div class='layout'><p>so this time we need to use a full adder that also inputs the carry bit.</p><p>所以这次要用全加器，除了A1和B1，还要连上进位</p></div>	
<div class='layout'><p>We output this result as sum1.</p><p>输出叫sum1</p></div>	
<div class='layout'><p>Then, we take any carry from this full adder,</p><p>然后，把这个全加器的进位，连到下个全加器的输入，处理A2和B2</p></div>	
<div class='layout'><p>and run it into the next full adder that handles A2 and B2.</p><p>然后，把这个全加器的进位，连到下个全加器的输入，处理A2和B2</p></div>	
<div class='layout'><p>And we just keep doing this in a big chain until all 8 bits have been added.</p><p>以此类推，把8个bit都搞定</p></div>	
<div class='layout'><p>Notice how the carry bits ripple forward to each subsequent adder.</p><p>注意每个进位是怎么连到下一个全加器的</p></div>	
<div class='layout'><p>For this reason, this is called an 8-bit ripple carry adder.</p><p>所以叫"8位行波进位加法器"</p></div>	
<div class='layout'><p>Notice how our last full adder has a carry out.</p><p>注意最后一个全加器有"进位"的输出</p></div>	
<div class='layout'><p>If there is a carry into the 9th bit, it means the sum of the two numbers is too large to fit into 8-bits.</p><p>如果第9位有进位，代表着2个数字的和太大了，超过了8位</p></div>	
<div class='layout'><p>This is called an overflow.</p><p>这叫"溢出"<sup>(overflow)</sup></p></div>	
<div class='layout'><p>In general, an overflow occurs when the result of an addition is too large</p><p>一般来说"溢出"的意思是，两个数字的和太大了</p></div>	
<div class='layout'><p>to be represented by the number of bits you are using.</p><p>超过了用来表示的位数</p></div>	
<div class='layout'><p>This can usually cause errors and unexpected behavior.</p><p>这会导致错误和不可预期的结果</p></div>	
<div class='layout'><p>Famously, the original PacMan arcade game used 8 bits to keep track of what level you were on.</p><p>著名的例子是，吃豆人用8位存当前关卡数</p></div>	
<div class='layout'><p>This meant that if you made it past level 255 the largest number storablein 8 bits to level 256,</p><p>如果你玩到了第256关（8位bit最大表示255）</p></div>	
<div class='layout'><p>the ALU overflowed.</p><p>ALU会溢出</p></div>	
<div class='layout'><p>This caused a bunch of errors and glitches making the level unbeatable.</p><p>造成一连串错误和乱码，使得该关卡无法进行</p></div>	
<div class='layout'><p>The bug became a rite of passage for the greatest PacMan players.</p><p>这个bug成了厉害吃豆人玩家的代表</p></div>	
<div class='layout'><p>So if we want to avoid overflows,</p><p>如果想避免溢出</p></div>	
<div class='layout'><p>we can extend our circuit with more full adders, allowing us to add 16 or 32 bit numbers.</p><p>我们可以加更多全加器，可以操作16或32位数字</p></div>	
<div class='layout'><p>This makes overflows less likely to happen, but at the expense of more gates.</p><p>让溢出更难发生，但代价是更多逻辑门</p></div>	
<div class='layout'><p>An additional downside is that it takes a little bit of time for each of the carries to ripple forward.</p><p>另外一个缺点是，每次进位都要一点时间</p></div>	
<div class='layout'><p>Admittedly, not very much time, electrons move pretty fast,</p><p>当然时间不久，因为电子移动的很快</p></div>	
<div class='layout'><p>so we're talking about billionths of a second,</p><p>但如今的量级是每秒几十亿次运算，</p></div>	
<div class='layout'><p>but that's enough to make a difference in today's fast computers.</p><p>所以会造成影响</p></div>	
<div class='layout'><p>For this reason, modern computers use a slightly different adding circuit</p><p>所以，现代计算机用的加法电路有点不同</p></div>	
<div class='layout'><p>called a 'carry-look-ahead' adder</p><p>叫"超前进位加法器"</p></div>	
<div class='layout'><p>which is faster, but ultimately does exactly the same thing</p><p>它更快，做的事情是一样的</p></div>	
<div class='layout'><p>adds binary numbers.</p><p>把二进制数相加</p></div>	
<div class='layout'><p>The ALU's arithmetic unit also has circuits for other math operations</p><p>ALU的算术单元，也能做一些其他数学运算</p></div>	
<div class='layout'><p>and in general these 8 operations are always supported.</p><p>一般支持这8个操作</p></div>	
<div class='layout'><p>And like our adder, these other operations are built from individual logic gates.</p><p>就像加法器一样，这些操作也是由逻辑门构成的</p></div>	
<div class='layout'><p>Interestingly, you may have noticed that there are no multiply and divide operations.</p><p>有趣的是，你可能注意到没有乘法和除法</p></div>	
<div class='layout'><p>That's because simple ALUs don't have a circuit for this,</p><p>因为简单的ALU没有专门的电路来处理</p></div>	
<div class='layout'><p>and instead just perform a series of additions.</p><p>而是把乘法用多次加法来实现</p></div>	
<div class='layout'><p>Let's say you want to multiply 12 by 5.</p><p>假设想算12x5</p></div>	
<div class='layout'><p>That's the same thing as adding 12 to itself 5 times.</p><p>这和把"12"加5次是一样的</p></div>	
<div class='layout'><p>So it would take 5 passes through the ALU to do this one multiplication.</p><p>所以要5次ALU操作来实现这个乘法</p></div>	
<div class='layout'><p>And this is how many simple processors,</p><p>很多简单处理器都是这样做的</p></div>	
<div class='layout'><p>like those in your thermostat, TV remote, and microwave, do multiplication.</p><p>比如恒温器，电视遥控器和微波炉</p></div>	
<div class='layout'><p>It's slow, but it gets the job done.</p><p>慢是慢，但是搞的定</p></div>	
<div class='layout'><p>However, fancier processors, like those in your laptop or smartphone,</p><p>然而笔记本和手机有更好的处理器</p></div>	
<div class='layout'><p>have arithmetic units with dedicated circuits for multiplication.</p><p>有专门做乘法的算术单元</p></div>	
<div class='layout'><p>And as you might expect, the circuit is more complicated than addition</p><p>你可能猜到了，乘法电路比加法复杂</p></div>	
<div class='layout'><p>there's no magic, it just takes a lot more logic gates</p><p>没什么魔法，只是更多逻辑门</p></div>	
<div class='layout'><p>which is why less expensive processors don't have this feature.</p><p>所以便宜的处理器没有.</p></div>	
<div class='layout'><p>Ok, let's move on to the other half of the ALU:</p><p>好了，我们现在讲ALU的另一半：</p></div>	
<div class='layout'><p>the Logic Unit.</p><p>逻辑单元</p></div>	
<div class='layout'><p>Instead of arithmetic operations, the Logic Unit performs well...</p><p>逻辑单元执行逻辑操作</p></div>	
<div class='layout'><p>logical operations, like AND, OR and NOT, which we've talked about previously.</p><p>比如之前讨论过的AND，OR和NOT操作</p></div>	
<div class='layout'><p>It also performs simple numerical tests,</p><p>它也能做简单的数值测试</p></div>	
<div class='layout'><p>like checking if a number is negative.</p><p>比如一个数字是不是负数</p></div>	
<div class='layout'><p>For example, here's a circuit that tests if the output of the ALU is zero.</p><p>例如，这是检查ALU输出是否为0的电路</p></div>	
<div class='layout'><p>It does this using a bunch of OR gates to see if any of the bits are 1.</p><p>它用一堆OR门检查其中一位是否为1</p></div>	
<div class='layout'><p>Even if one single bit is 1,</p><p>哪怕只有一个Bit<sup>(位)</sup>是1，</p></div>	
<div class='layout'><p>we know the number can't be zero and then we use a final NOT gate to flip this input</p><p>我们就知道那个数字肯定不是0，然后用一个NOT门取反</p></div>	
<div class='layout'><p>so the output is 1 only if the input number is 0.</p><p>所以只有输入的数字是0，输出才为1</p></div>	
<div class='layout'><p>So that's a high level overview of what makes up an ALU.</p><p>以上就是ALU的一个高层次概括</p></div>	
<div class='layout'><p>We even built several of the main components from scratch, like our ripple adder.</p><p>我们甚至从零做了几个主要组件，比如行波进位加法器</p></div>	
<div class='layout'><p>As you saw, it's just a big bunch of logic gates connected in clever ways.</p><p>它们只是一大堆逻辑门巧妙的连在一起而已.</p></div>	
<div class='layout'><p>Which brings us back to that ALU you admired so much at the beginning of the episode.</p><p>让我们回到视频开始时的ALU，</p></div>	
<div class='layout'><p>The Intel 74181.</p><p>英特尔74181</p></div>	
<div class='layout'><p>Unlike the 8-bit ALU we made today, the 74181 could only handle 4-bit inputs,</p><p>和我们刚刚做的8位ALU不同，74181只能处理4位输入</p></div>	
<div class='layout'><p>which means</p><p>也就是说</p></div>	
<div class='layout'><p>YOU BUILT AN ALU THAT'S LIKE TWICE AS GOOD AS THAT SUPER FAMOUS ONE. WITH YOUR MIND!</p><p>你刚做了一个比英特尔74181还好的ALU！</p></div>	
<div class='layout'><p>Well.. sort of.</p><p>其实差不多啦..</p></div>	
<div class='layout'><p>We didn't build the whole thing</p><p>我们虽然没有全部造出来</p></div>	
<div class='layout'><p>but you get the idea.</p><p>但你理解了整体概念</p></div>	
<div class='layout'><p>The 74181 used about 70 logic gates, and it couldn't multiply or divide.</p><p>74181用了大概70个逻辑门，但不能执行乘除.</p></div>	
<div class='layout'><p>But it was a huge step forward in miniaturization,</p><p>但它向小型化迈出了一大步</p></div>	
<div class='layout'><p>opening the doors to more capable and less expensive computers.</p><p>让计算机可以更强大更便宜</p></div>	
<div class='layout'><p>This 4-bit ALU circuit is already a lot to take in,</p><p>4位ALU已经要很多逻辑门了</p></div>	
<div class='layout'><p>but our 8-bit ALU would require hundreds of logic gates to fully build</p><p>但我们的8位ALU会需要数百个逻辑门</p></div>	
<div class='layout'><p>and engineers don't want to see all that complexity when using an ALU,</p><p>工程师不想在用ALU时去想那些事情，</p></div>	
<div class='layout'><p>so they came up with a special symbol to wrap it all up, which looks like a big V'.</p><p>所以想了一个特殊符号来代表它，看起来像一个大"V"</p></div>	
<div class='layout'><p>Just another level of abstraction!</p><p>又一层抽象！</p></div>	
<div class='layout'><p>Our 8-bit ALU has two inputs, A and B, each with 8 bits.</p><p>我们的8位ALU有两个输入，A和B，都是8位<sup>(bits)</sup></p></div>	
<div class='layout'><p>We also need a way to specify what operation the ALU should perform,</p><p>我们还需要告诉ALU执行什么操作</p></div>	
<div class='layout'><p>for example, addition or subtraction.</p><p>例如加法或减法</p></div>	
<div class='layout'><p>For that, we use a 4-bit operation code.</p><p>所以我们用4位的操作代码</p></div>	
<div class='layout'><p>We'll talk about this more in a later episode,</p><p>我们之后的视频会再细说</p></div>	
<div class='layout'><p>but in brief, 1000 might be the command to add, while 1100 is the command for subtract.</p><p>简言之，"1000"可能代表加法命令，"1100"代表减法命令</p></div>	
<div class='layout'><p>Basically, the operation code tells the ALU what operation to perform.</p><p>操作代码告诉ALU执行什么操作</p></div>	
<div class='layout'><p>And the result of that operation on inputs A and B is an 8-bit output.</p><p>输出结果是8位的</p></div>	
<div class='layout'><p>ALUs also output a series of Flags,</p><p>ALU还会输出一堆标志（Flag）</p></div>	
<div class='layout'><p>which are 1-bit outputs for particular states and statuses.</p><p>标志是1位的，代表特定状态.</p></div>	
<div class='layout'><p>For example, if we subtract two numbers, and the result is 0,</p><p>比如相减两个数字，结果为0</p></div>	
<div class='layout'><p>our zero-testing circuit, the one we made earlier, sets the Zero Flag to True (1).</p><p>我们的零测试电路（前面做的），会将零标志设为True（1）</p></div>	
<div class='layout'><p>This is useful if we are trying to determine if two numbers are are equal.</p><p>如果想知道两个数字是否相等，这个非常有用</p></div>	
<div class='layout'><p>If we wanted to test if A was less than B,</p><p>如果想知道：A是否小于B</p></div>	
<div class='layout'><p>we can use the ALU to calculate A subtract B and look to see if the Negative Flag was set to true.</p><p>可以用ALU来算A减B，看负标志是否为true</p></div>	
<div class='layout'><p>If it was, we know that A was smaller than B.</p><p>如果是true，我们就知道A小于B</p></div>	
<div class='layout'><p>And finally, there's also a wire attached to the carry out on the adder we built,</p><p>最后，还有一条线连到加法器的进位</p></div>	
<div class='layout'><p>so if there is an overflow, we'll know about it.</p><p>如果有溢出，我们就知道</p></div>	
<div class='layout'><p>This is called the Overflow Flag.</p><p>这叫溢出标志</p></div>	
<div class='layout'><p>Fancier ALUs will have more flags,</p><p>高级ALU有更多标志</p></div>	
<div class='layout'><p>but these three flags are universal and frequently used.</p><p>但这3个标志是ALU普遍用的</p></div>	
<div class='layout'><p>In fact, we'll be using them soon in a future episode.</p><p>其实，我们之后的视频会用到它们</p></div>	
<div class='layout'><p>So now you know how your computer does all its basic mathematical operations digitally</p><p>现在你知道了，</p></div>	
<div class='layout'><p>with no gears or levers required.</p><p>计算机是怎样在没有齿轮或杠杆的情况下进行运算</p></div>	
<div class='layout'><p>We're going to use this ALU when we construct our CPU two episodes from now.</p><p>接下来两集我们会用ALU做CPU</p></div>	
<div class='layout'><p>But before that, our computer is going to need some memory!</p><p>但在此之前，计算机需要一些"记忆"！</p></div>	
<div class='layout'><p>We'll talk about that next week.</p><p>我们下周会讲</p></div>	
﻿
</div> <!--container-->
<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>
<a id="fPagea" href="index.html" target="_self"><div id="fPage" style="color:#fff;">上<br>一<br>章</div></a>
<a href="index.html" target="_self"><div id="menuPage" style="color:#fff;">目<br>录</div></a>
<a id="LPagea" href="javascript:void(null)" target="_self"><div id="lPage" style="color:#fff;">下<br>一<br>章</div></a>
<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
	//上一页、下一页按钮，需要文件名是数字
	var strUrl=window.location.href;
	var arrUrl=strUrl.split("/");
	var thispage=arrUrl[arrUrl.length-1];
	var thispage2=thispage.split(".");
	var thispage3=thispage2[thispage2.length-2];
	if(thispage3 == 0){
		var obj5=document.getElementById("fPage");
		obj5.style.display="none";
	}else{
		var fpage = thispage3 - 1;
		fpage = fpage +".html";
		document.getElementById("fPagea").href=fpage;
	}
	if(thispage3 == 100){
		var obj6=document.getElementById("lPage");
		obj6.style.display="none";
	}else{
		var fpage = parseInt(thispage3) + 1;
		fpage = fpage +".html";
		document.getElementById("LPagea").href=fpage;
	}
</script>
</div>
</body>
</html>
