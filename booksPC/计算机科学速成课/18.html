<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//谷歌浏览器  
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox等浏览器
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//谷歌浏览器  
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox等浏览器  
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
</script>
<script>
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:link，#container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:85.29%;
	line-height:1.6em;
	overflow:hidden;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}
#goTopBtn, #goBottom, #shangy, #xiay, #menuPage, #lPage, #fPage, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #menuPage, #lPage, #fPage, #ftsize1, #ftsize3{
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #lPage, #fPage, #ftsize, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#fPage{
	bottom: 236px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
	//writing-mode:tb-rl;
}
#menuPage{
	bottom: 198px;
	height:27px;
	white-space:nowrap;
	overflow:hidden;
}
#lPage{
	bottom: 145px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
}
#ftsize1{
	bottom:360px;
}
#ftsize2{
	bottom:334px;
}
#ftsize3{
	bottom:308px;
}
#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #menuPage:hover, #lPage:hover, #fPage:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #menuPage a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link, #menuPage a:visited, #lPage a:link, #fPage a:link, #lPage a:visited, #fPage a:visited {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
.code0, .code2, .code4{
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
.layout, .layout2{
    clear:both;
	width:95%;
	border:1px dotted #eee;
	margin:auto;
	margin-bottom:5px;
	overflow:hidden;
}
.layout2 .right, .layout2 .left, .layout p{
margin-bottom:-55px;
padding-bottom:55px;
text-align: justify;
margin:0;
padding:0;
margin-left:1%;
margin-right:1%;
}
.layout2 .left, .layout p{
float:left;
width:60%;
font-size:1.0em;
}
.layout2 .right,  .layout p+p {
	float: left;
	width:34%;
	border-left:1px dotted #cccccc;
	font-size:0.9em;
	padding-left:1%;
	
}
.layout2 .right p, .layout2 .left p, .layout p{
padding-bottom:5px;
}
h3{
text-indent:3%;
font-size:1em;
height:2.0em;
padding:0;
margin:0;
}
</style>
</head>
<body>
<div id="container">
﻿<div class='layout'><p>18 Operating Systems</p><p>18 操作系统</p></div>	
<div class='layout'><p>Hi, I'm Carrie Anne, and welcome to Crash Course Computer Science!</p><p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p></div>	
<div class='layout'><p>Computers in the 1940s and early 50s ran one program at a time.</p><p>1940，1950 年代的电脑，每次只能运行一个程序</p></div>	
<div class='layout'><p>A programmer would write one at their desk, for example, on punch cards.</p><p>程序员在打孔纸卡上写程序</p></div>	
<div class='layout'><p>Then, they'd carry it to a room containing a room-sized computer,</p><p>然后拿到一个计算机房间， </p></div>	
<div class='layout'><p>and hand it to a dedicated computer operator.</p><p>交给操作员</p></div>	
<div class='layout'><p>That person would then feed the program into the computer when it was next available.</p><p>等计算机空下来了，操作员会把程序放入</p></div>	
<div class='layout'><p>The computer would run it, spit out some output, and halt.</p><p>然后运行，输出结果，停机</p></div>	
<div class='layout'><p>This very manual process worked OK back when computers were slow,</p><p>以前计算机慢，这种手动做法可以接受</p></div>	
<div class='layout'><p>and running a program often took hours, days or even weeks.</p><p>运行一个程序通常要几小时，几天甚至几周</p></div>	
<div class='layout'><p>But, as we discussed last episode,</p><p>但上集说过，</p></div>	
<div class='layout'><p>computers became faster... and faster... and faster</p><p>计算机越来越快，越来越快</p></div>	
<div class='layout'><p>exponentially so!</p><p>指数级增长！</p></div>	
<div class='layout'><p>Pretty soon, having humans run around and inserting programs into readers</p><p>很快，放程序的时间 </p></div>	
<div class='layout'><p>was taking longer than running the actual programs themselves.</p><p>比程序运行时间还长</p></div>	
<div class='layout'><p>We needed a way for computers to operate themselves,</p><p>我们需要一种方式 让计算机自动运作</p></div>	
<div class='layout'><p>and so, operating systems were born.</p><p>于是"操作系统"诞生了</p></div>	
<div class='layout'><p>Operating systems , or OS for short, are just programs.</p><p>操作系统，简称 OS，其实也是程序</p></div>	
<div class='layout'><p>But, special privileges on the hardware let them run and manage other programs.</p><p>但它有操作硬件的特殊权限 ，可以运行和管理其它程序</p></div>	
<div class='layout'><p>They're typically the first one to start when a computer is turned on,</p><p>操作系统一般是开机第一个启动的程序</p></div>	
<div class='layout'><p>and all subsequent programs are launched by the OS.</p><p>其他所有程序 都由操作系统启动</p></div>	
<div class='layout'><p>They got their start in the 1950s,</p><p>操作系统开始于 1950 年代，</p></div>	
<div class='layout'><p>as computers became more widespread and more powerful.</p><p>那时计算机开始变得更强大更流行</p></div>	
<div class='layout'><p>The very first OS augmented the mundane, manual task of loading programs by hand.</p><p>第一个操作系统 加强了程序加载方式</p></div>	
<div class='layout'><p>Instead of being given one program at a time,</p><p>之前只能一次给一个程序，现在可以一次多个</p></div>	
<div class='layout'><p>computers could be given batches.</p><p>之前只能一次给一个程序，现在可以一次多个</p></div>	
<div class='layout'><p>When the computer was done with one,</p><p>当计算机运行完一个程序，</p></div>	
<div class='layout'><p>it would automatically and near-instantly start the next.</p><p>会自动运行下一个程序</p></div>	
<div class='layout'><p>There was no downtime while someone scurried around an office to find the next program to run.</p><p>这样就不会浪费时间，找下一个程序的纸卡</p></div>	
<div class='layout'><p>This was called batch processing .</p><p>这叫 批处理</p></div>	
<div class='layout'><p>While computers got faster, they also got cheaper.</p><p>电脑变得更快更便宜，</p></div>	
<div class='layout'><p>So, they were popping up all over the world,</p><p>开始在出现在世界各地</p></div>	
<div class='layout'><p>especially in universities and government offices.</p><p>特别是大学和政府办公室</p></div>	
<div class='layout'><p>Soon, people started sharing software.</p><p>很快，人们开始分享软件，</p></div>	
<div class='layout'><p>But there was a problem</p><p>但有一个问题</p></div>	
<div class='layout'><p>In the era of one-off computers, like the Harvard Mark 1 or ENIAC,</p><p>在哈佛1号和 ENIAC 那个时代，计算都是一次性的</p></div>	
<div class='layout'><p>programmers only had to write code for that one single machine.</p><p>程序员只需要给那"一台"机器写代码</p></div>	
<div class='layout'><p>The processor, punch card readers, and printers were known and unchanging.</p><p>处理器，读卡器，打印机都是已知的</p></div>	
<div class='layout'><p>But as computers became more widespread,</p><p>但随着电脑越来越普遍，</p></div>	
<div class='layout'><p>their configurations were not always identical,</p><p>计算机配置并不总是相同的</p></div>	
<div class='layout'><p>like computers might have the same CPU, but not the same printer.</p><p>比如计算机可能有相同 CPU，但不同的打印机</p></div>	
<div class='layout'><p>This was a huge pain for programmers.</p><p>这对程序员很痛苦</p></div>	
<div class='layout'><p>Not only did they have to worry about writing their program,</p><p>不仅要担心写程序，</p></div>	
<div class='layout'><p>but also how to interface with each and every model of printer,</p><p>还要担心程序怎么和不同型号打印机交互</p></div>	
<div class='layout'><p>and all devices connected to a computer, what are called peripherals.</p><p>以及计算机连着的其他设备，这些统称"外部设备"</p></div>	
<div class='layout'><p>Interfacing with early peripherals was very low level,</p><p>和早期的外部设备交互，是非常底层的</p></div>	
<div class='layout'><p>requiring programmers to know intimate hardware details about each device.</p><p>程序员要了解设备的硬件细节</p></div>	
<div class='layout'><p>On top of that, programmers rarely had access to every model of a peripheral to test their code on.</p><p>加重问题的是，程序员很少能拿到所有型号的设备来测代码</p></div>	
<div class='layout'><p>So, they had to write code as best they could, often just by reading manuals,</p><p>所以一般是阅读手册来写代码，</p></div>	
<div class='layout'><p>and hope it worked when shared.</p><p>祈祷能正常运行</p></div>	
<div class='layout'><p>Things weren't exactly plug-and-play</p><p>现在是"即插即用"，</p></div>	
<div class='layout'><p>back then more plug-and-pray.</p><p>以前是"祈祷能用"</p></div>	
<div class='layout'><p>This was clearly terrible,</p><p>这很糟糕，</p></div>	
<div class='layout'><p>so to make it easier for programmers,</p><p>所以为了程序员写软件更容易</p></div>	
<div class='layout'><p>Operating Systems stepped in as intermediaries between software programs and hardware peripherals.</p><p>操作系统充当软件和硬件之间的媒介</p></div>	
<div class='layout'><p>More specifically, they provided a software abstraction, through APIs,</p><p>更具体地说，操作系统提供 API 来抽象硬件，</p></div>	
<div class='layout'><p>called device drivers .</p><p>叫"设备驱动程序"</p></div>	
<div class='layout'><p>These allow programmers to talk to common input and output hardware,</p><p>程序员可以用标准化机制</p></div>	
<div class='layout'><p>or I/O for short, using standardized mechanisms.</p><p>和输入输出硬件（I/O）交互</p></div>	
<div class='layout'><p>For example, programmers could call a function like "print highscore",</p><p>比如，程序员只需调用 print(highscore)</p></div>	
<div class='layout'><p>and the OS would do the heavy lifting to get it onto paper.</p><p>操作系统会处理  输到纸上的具体细节</p></div>	
<div class='layout'><p>By the end of the 1950s, computers had gotten so fast,</p><p>到 1950 年代尾声，电脑已经非常快了</p></div>	
<div class='layout'><p>they were often idle waiting for slow mechanical things, like printers and punch card readers.</p><p>处理器经常闲着，等待慢的机械设备（比如打印机和读卡器）</p></div>	
<div class='layout'><p>While programs were blocked on I/O,</p><p>程序阻塞在 I/O 上</p></div>	
<div class='layout'><p>the expensive processor was just chillin'... not like a villain</p><p>而昂贵的处理器则在度假，就是放松啥也不做</p></div>	
<div class='layout'><p>you know, just relaxing.</p><p>而昂贵的处理器则在度假，就是放松啥也不做</p></div>	
<div class='layout'><p>In the late 50's, the University of Manchester, in the UK,</p><p>50年代后期，英国曼彻斯特大学，</p></div>	
<div class='layout'><p>started work on a supercomputer called Atlas, one of the first in the world.</p><p>开始研发世界上第一台超级计算机，Atlas</p></div>	
<div class='layout'><p>They knew it was going to be wicked fast,</p><p>他们知道机器会超级快，</p></div>	
<div class='layout'><p>so they needed a way to make maximal use of the expensive machine.</p><p>所以需要一种方式来最大限度的利用它</p></div>	
<div class='layout'><p>Their solution was a program called the Atlas Supervisor, finished in 1962.</p><p>他们的解决方案是一个程序叫 Atlas Supervisor ，于1962年完成</p></div>	
<div class='layout'><p>This operating system not only loaded programs automatically, like earlier batch systems,</p><p>这个操作系统 ，不仅像更早期的批处理系统那样，能自动加载程序</p></div>	
<div class='layout'><p>but could also run several at the same time on its single CPU.</p><p>还能在单个 CPU 上同时运行几个程序</p></div>	
<div class='layout'><p>It did this through clever scheduling.</p><p>它通过调度来做到这一点</p></div>	
<div class='layout'><p>Let's say we have a game program running on Atlas,</p><p>假设 Atlas 上有一个游戏在运行</p></div>	
<div class='layout'><p>and we call the function "print(highscore)"</p><p>并且我们调用一个函数 print(highscore)</p></div>	
<div class='layout'><p>which instructs Atlas to print the value of a variable named "highscore"</p><p>它让 Atlas 打印一个叫 highscore 的变量值</p></div>	
<div class='layout'><p>onto paper to show our friends that we're the ultimate champion of virtual tiddlywinks.</p><p>让朋友知道 我是最高分冠军</p></div>	
<div class='layout'><p>That function call is going to take a while, the equivalent of thousands of clock cycles,</p><p>print 函数运行需要一点时间，大概上千个时钟周期</p></div>	
<div class='layout'><p>because mechanical printers are slow in comparison to electronic CPUs.</p><p>但因为打印机比 CPU 慢，</p></div>	
<div class='layout'><p>So instead of waiting for the I/O to finish,</p><p>与其等着它完成操作</p></div>	
<div class='layout'><p>Atlas instead puts our program to sleep,</p><p>Atlas 会把程序休眠，运行另一个程序</p></div>	
<div class='layout'><p>then selects and runs another program that's waiting and ready to run.</p><p>Atlas 会把程序休眠，运行另一个程序</p></div>	
<div class='layout'><p>Eventually, the printer will report back to Atlas that it finished printing the value of "highscore".</p><p>最终， 打印机会告诉 Atlas， 打印已完成</p></div>	
<div class='layout'><p>Atlas then marks our program as ready to go,</p><p>Atlas 会把程序标记成可继续运行</p></div>	
<div class='layout'><p>and at some point, it will be scheduled to run again on the CPU,</p><p>之后在某时刻会安排给 CPU 运行</p></div>	
<div class='layout'><p>and continue onto the next line of code following the print statement.</p><p>并继续 print 语句之后的下一行代码</p></div>	
<div class='layout'><p>In this way, Atlas could have one program running calculations on the CPU,</p><p>这样， Atlas 可以在 CPU 上运行一个程序</p></div>	
<div class='layout'><p>while another was printing out data,</p><p>同时另一个程序在打印数据</p></div>	
<div class='layout'><p>and yet another reading in data from a punch tape.</p><p>另一个从穿孔磁带中读取数据。</p></div>	
<div class='layout'><p>Atlas' engineers doubled down on this idea,</p><p>Atlas 的工程师做的还要多，</p></div>	
<div class='layout'><p>and outfitted their computer with 4 paper tape readers, 4 paper tape punches,</p><p>配了4台纸带读取器，4台纸带打孔机</p></div>	
<div class='layout'><p>and up to 8 magnetic tape drives.</p><p>多达8个磁带驱动器</p></div>	
<div class='layout'><p>This allowed many programs to be in progress all at once,</p><p>使多个程序可以同时运行，</p></div>	
<div class='layout'><p>sharing time on a single CPU.</p><p>在单个 CPU 上共享时间</p></div>	
<div class='layout'><p>This ability, enabled by the Operating System, is called</p><p>操作系统的这种能力叫</p></div>	
<div class='layout'><p>multitasking.</p><p>多任务处理</p></div>	
<div class='layout'><p>There's one big catch to having many programs running simultaneously on a single computer, though.</p><p>同时运行多个程序有个问题</p></div>	
<div class='layout'><p>Each one is going to need some memory,</p><p>每个程序都会占一些内存，</p></div>	
<div class='layout'><p>and we can't lose that program's data when we switch to another program.</p><p>当切换到另一个程序时，我们不能丢失数据</p></div>	
<div class='layout'><p>The solution is to allocate each program its own block of memory.</p><p>解决办法是 给每个程序分配专属内存块</p></div>	
<div class='layout'><p>So, for example, let's say a computer has 10,000 memory locations in total.</p><p>举个例子，假设计算机一共有 10000 个内存位置</p></div>	
<div class='layout'><p>Program A might get allocated memory addresses 0 through 999,</p><p>程序 A 分配到内存地址 0 到 999</p></div>	
<div class='layout'><p>and Program B might get 1000 through 1999, and so on.</p><p>而程序 B 分配到内存地址 1000 到 1999，以此类推</p></div>	
<div class='layout'><p>If a program asks for more memory,</p><p>如果一个程序请求更多内存，</p></div>	
<div class='layout'><p>the operating system decides if it can grant that request,</p><p>操作系统会决定是否同意</p></div>	
<div class='layout'><p>and if so, what memory block to allocate next.</p><p>如果同意，分配哪些内存块</p></div>	
<div class='layout'><p>This flexibility is great, but introduces a quirk.</p><p>这种灵活性很好，但带来一个奇怪的后果</p></div>	
<div class='layout'><p>It means that Program A could end up being allocated non-sequential blocks of memory,</p><p>程序 A 可能会分配到非连续的内存块</p></div>	
<div class='layout'><p>in say addresses 0 through 999, and 2000 through 2999.</p><p>比如内存地址 0 到 999，以及 2000 到 2999</p></div>	
<div class='layout'><p>And this is just a simple example</p><p>这只是个简单例子</p></div>	
<div class='layout'><p>a real program might be allocated dozens of blocks scattered all over memory.</p><p>真正的程序可能会分配到内存中数十个地方</p></div>	
<div class='layout'><p>As you might imagine,</p><p>你可能想到了，</p></div>	
<div class='layout'><p>this would get really confusing for programmers to keep track of.</p><p>这对程序员来说很难跟踪</p></div>	
<div class='layout'><p>Maybe there's a long list of sales data in memory that</p><p>也许内存里有一长串销售额，</p></div>	
<div class='layout'><p>a program has to total up at the end of the day,</p><p>每天下班后要算销售总额</p></div>	
<div class='layout'><p>but this list is stored across a bunch of different blocks of memory.</p><p>但列表 存在一堆不连续的内存块里</p></div>	
<div class='layout'><p>To hide this complexity, Operating Systems virtualize memory locations.</p><p>为了隐藏这种复杂性，操作系统会把内存地址进行 "虚拟化"</p></div>	
<div class='layout'><p>With Virtual Memory, programs can assume their memory always starts at address 0,</p><p>这叫 "虚拟内存"，程序可以假定内存总是从地址0开始</p></div>	
<div class='layout'><p>keeping things simple and consistent.</p><p>简单又一致</p></div>	
<div class='layout'><p>However, the actual, physical location in computer memory</p><p>而实际物理位置</p></div>	
<div class='layout'><p>is hidden and abstracted by the operating system.</p><p>被操作系统隐藏和抽象了</p></div>	
<div class='layout'><p>Just a new level of abstraction.</p><p>一层新的抽象</p></div>	
<div class='layout'><p>Let's take our example Program B,</p><p>用程序 B 来举例，</p></div>	
<div class='layout'><p>which has been allocated a block of memory from address 1000 to 1999.</p><p>它被分配了内存地址 1000 到 1999</p></div>	
<div class='layout'><p>As far as Program B can tell, this appears to be a block from 0 to 999.</p><p>对程序 B 而言，它看到的地址是 0 到 999</p></div>	
<div class='layout'><p>The OS and CPU handle the virtual-to-physical memory remapping automatically.</p><p>操作系统会自动处理，虚拟内存和物理内存之间的映射</p></div>	
<div class='layout'><p>So, if Program B requests memory location 42,</p><p>如果程序 B 要地址 42，</p></div>	
<div class='layout'><p>it really ends up reading address 1042.</p><p>实际上是物理地址 1042</p></div>	
<div class='layout'><p>This virtualization of memory addresses is even more useful for Program A,</p><p>这种内存地址的虚拟化  对程序 A 甚至更有用</p></div>	
<div class='layout'><p>which in our example, has been allocated two blocks of memory</p><p>在例子中，A 被分配了两块隔开的内存</p></div>	
<div class='layout'><p>that are separated from one another.</p><p>在例子中，A 被分配了两块隔开的内存</p></div>	
<div class='layout'><p>This too is invisible to Program A.</p><p>程序 A 不知道这点.</p></div>	
<div class='layout'><p>As far as it can tell, it's been allocated a continuous block of 2000 addresses.</p><p>以 A 的视角，它有 2000 个连续地址</p></div>	
<div class='layout'><p>When Program A reads memory address 999,</p><p>当程序 A 读内存地址 999 时，</p></div>	
<div class='layout'><p>that does coincidentally map to physical memory address 999.</p><p>会刚好映射到物理内存地址 999</p></div>	
<div class='layout'><p>But if Program A reads the very next value in memory, at address 1000,</p><p>但如果程序 A 读下一个地址 1000</p></div>	
<div class='layout'><p>that gets mapped behind the scenes to physical memory address 2000.</p><p>会映射到物理地址 2000</p></div>	
<div class='layout'><p>This mechanism allows programs to have flexible memory sizes,</p><p>这种机制使程序的内存大小可以灵活增减，</p></div>	
<div class='layout'><p>called dynamic memory allocation,</p><p>叫"动态内存分配"</p></div>	
<div class='layout'><p>that appear to be continuous to them.</p><p>对程序来说，内存看起来是连续的.</p></div>	
<div class='layout'><p>It simplifies everything and offers tremendous flexibility to the Operating System</p><p>它简化了一切，为操作系统同时运行多个程序，</p></div>	
<div class='layout'><p>in running multiple programs simultaneously.</p><p>提供了极大的灵活性</p></div>	
<div class='layout'><p>Another upside of allocating each program its own memory,</p><p>给程序分配专用的内存范围，</p></div>	
<div class='layout'><p>is that they're better isolated from one another.</p><p>另一个好处是 这样隔离起来会更好</p></div>	
<div class='layout'><p>So, if a buggy program goes awry, and starts writing gobbledygook,</p><p>如果一个程序出错，开始写乱七八糟的数据</p></div>	
<div class='layout'><p>it can only trash its own memory, not that of other programs.</p><p>它只能捣乱自己的内存，不会影响到其它程序.</p></div>	
<div class='layout'><p>This feature is called Memory Protection.</p><p>这叫 "内存保护"</p></div>	
<div class='layout'><p>This is also really useful in protecting against malicious software, like viruses.</p><p>防止恶意软件（如病毒）也很有用</p></div>	
<div class='layout'><p>For example, we generally don't want other programs to have the ability</p><p>例如，我们不希望其他程序有能力，</p></div>	
<div class='layout'><p>to read or modify the memory of, let say, our email,</p><p>读或改邮件程序的内存</p></div>	
<div class='layout'><p>with that kind of access,</p><p>如果有这种权限，</p></div>	
<div class='layout'><p>malware could send emails on your behalf and maybe steal personal information.</p><p>恶意软件可能以你的名义发邮件，甚至窃取个人信息</p></div>	
<div class='layout'><p>Not good!</p><p>一点都不好！</p></div>	
<div class='layout'><p>Atlas had both virtual and protected memory.</p><p>Atlas 既有"虚拟内存"也有"内存保护"</p></div>	
<div class='layout'><p>It was the first computer and OS to support these features!</p><p>是第一台支持这些功能的计算机和操作系统！</p></div>	
<div class='layout'><p>By the 1970s, computers were sufficiently fast and cheap.</p><p>到 1970 年代，计算机足够快且便宜</p></div>	
<div class='layout'><p>Institutions like a university could buy a computer and let students use it.</p><p>大学会买电脑让学生用</p></div>	
<div class='layout'><p>It was not only fast enough to run several programs at once,</p><p>计算机不仅能同时运行多个程序，</p></div>	
<div class='layout'><p>but also give several users simultaneous, interactive access.</p><p>还能让多用户能同时访问</p></div>	
<div class='layout'><p>This was done through a terminal,</p><p>多个用户用"终端"来访问计算机</p></div>	
<div class='layout'><p>which is a keyboard and screen that connects to a big computer,</p><p>终端只是键盘+屏幕，连到主计算机，终端本身没有处理能力</p></div>	
<div class='layout'><p>but doesn't contain any processing power itself.</p><p>终端只是键盘+屏幕，连到主计算机，终端本身没有处理能力</p></div>	
<div class='layout'><p>A refrigerator-sized computer might have 50 terminals connected to it,</p><p>冰箱大小的计算机可能有50个终端，</p></div>	
<div class='layout'><p>allowing up to 50 users.</p><p>能让50个用户使用</p></div>	
<div class='layout'><p>Now operating systems had to handle not just multiple programs,</p><p>这时操作系统不但要处理多个程序，</p></div>	
<div class='layout'><p>but also multiple users.</p><p>还要处理多个用户</p></div>	
<div class='layout'><p>So that no one person could gobble up all of a computer's resources,</p><p>为了确保其中一个人  不会占满计算机资源</p></div>	
<div class='layout'><p>operating systems were developed that offered time-sharing.</p><p>开发了 分时操作系统</p></div>	
<div class='layout'><p>With time-sharing each individual user was only allowed to utilize</p><p>意思是 每个用户只能用</p></div>	
<div class='layout'><p>a small fraction of the computer's processor, memory, and so on.</p><p>一小部分处理器、内存等</p></div>	
<div class='layout'><p>Because computers are so fast,</p><p>因为电脑很快，</p></div>	
<div class='layout'><p>even getting just 1/50th of its resources was enough for individuals to complete many tasks.</p><p>即使拿到 1/50 的资源也足以完成许多任务</p></div>	
<div class='layout'><p>The most influential of early time-sharing Operating Systems was</p><p>早期分时操作系统中，最有影响力的是，</p></div>	
<div class='layout'><p>Multics,  or Multiplexed Information and Computing Service,</p><p>Multics（多任务信息与计算系统）</p></div>	
<div class='layout'><p>released in 1969.</p><p>于 1969 年发布</p></div>	
<div class='layout'><p>Multics was the first major operating system designed to be secure from the outset.</p><p>Multics 是第一个，从设计时就考虑到安全的操作系统</p></div>	
<div class='layout'><p>Developers didn't want mischievous users accessing data they shouldn't,</p><p>开发人员不希望恶意用户 访问不该访问的数据</p></div>	
<div class='layout'><p>like students attempting to access the final exam on their professor's account.</p><p>比如学生假装成教授，访问期末考试的文件</p></div>	
<div class='layout'><p>Features like this meant Multics was really complicated for its time,</p><p>这导致 Multics 的复杂度超过当时的平均水准</p></div>	
<div class='layout'><p>using around 1 Megabit of memory, which was a lot back then!</p><p>操作系统会占大约 1 Mb 内存，这在当时很多！</p></div>	
<div class='layout'><p>That might be half of a computer's memory, just to run the OS!</p><p>可能是内存的一半，只拿来运行操作系统！</p></div>	
<div class='layout'><p>Dennis Ritchie, one of the researchers working on Multics, once said:</p><p>Multics 的研究人员之一 Dennis Ritchie 曾说过</p></div>	
<div class='layout'><p>One of the obvious things that went wrong with Multics as a commercial success </p><p>阻碍 Multics 获得商业成功的一个明显问题是</p></div>	
<div class='layout'><p>was just that it was sort of over-engineered in a sense.</p><p>从某种方面来说，它被过度设计了，</p></div>	
<div class='layout'><p>There was just too much in it."</p><p>功能太多了"</p></div>	
<div class='layout'><p>This lead Dennis, and another Multics researcher,</p><p>所以 Dennis 和另一个 Multics 研究员，</p></div>	
<div class='layout'><p>Ken Thompson, to strike out on their own and build a new, lean operating system</p><p>Ken Thompson 联手打造新的操作系统</p></div>	
<div class='layout'><p>called Unix.</p><p>叫 Unix</p></div>	
<div class='layout'><p>They wanted to separate the OS into two parts:</p><p>他们想把操作系统分成两部分：</p></div>	
<div class='layout'><p>First was the core functionality of the OS,</p><p>首先是操作系统的核心功能</p></div>	
<div class='layout'><p>things like memory management, multitasking,and dealing with I/O,</p><p>如内存管理，多任务和输入/输出处理，这叫"内核"</p></div>	
<div class='layout'><p>which is called the kernel .</p><p>如内存管理，多任务和输入/输出处理，这叫"内核"</p></div>	
<div class='layout'><p>The second part was a wide array of useful tools that came bundled with,</p><p>第二部分是一堆有用的工具</p></div>	
<div class='layout'><p>but not part of the kernel, things like programs and libraries.</p><p>但它们不是内核的一部分（比如程序和运行库）</p></div>	
<div class='layout'><p>Building a compact, lean kernel meant intentionally leaving some functionality out.</p><p>紧凑的内核 意味着功能没有那么全面</p></div>	
<div class='layout'><p>Tom Van Vleck, another Multics developer, recalled:</p><p>Multics 的另一个开发者 Tom Van Vleck 回忆说：</p></div>	
<div class='layout'><p>I remarked to Dennis that easily half the code I was writing in Multics was error recovery code.</p><p>我对 Dennis 说，我在 Multics 写的一半代码都是错误恢复代码</p></div>	
<div class='layout'><p>He said, "We left all that stuff out of Unix.</p><p>他说:"Unix 不会有这些东西</p></div>	
<div class='layout'><p>If there's an error, we have this routine called panic,</p><p>如果有错误发生，我们就让内核"恐慌"（panic）</p></div>	
<div class='layout'><p>and when it is called, the machine crashes,</p><p>当调用它时，机器会崩溃</p></div>	
<div class='layout'><p>and you holler down the hall, 'Hey, reboot it.'""</p><p>你得在走廊里大喊，"嘿，重启电脑"</p></div>	
<div class='layout'><p>You might have heard of kernel panics.</p><p>你可能听过 "内核恐慌"（kernel panic）</p></div>	
<div class='layout'><p>This is where the term came from.</p><p>这就是这个词的来源</p></div>	
<div class='layout'><p>It's literally when the kernel crashes, has no recourse to recover,</p><p>内核如果崩溃，没有办法恢复</p></div>	
<div class='layout'><p>and so calls a function called "panic".</p><p>所以调用一个叫"恐慌"（panic）的函数</p></div>	
<div class='layout'><p>Originally, all it did was print the word "panic" and then enter an infinite loop.</p><p>起初只是打印"恐慌"一词，然后无限循环</p></div>	
<div class='layout'><p>This simplicity meant that Unix could be run on cheaper and more diverse hardware,</p><p>这种简单性意味着 ，Unix 可以在更便宜更多的硬件上运行</p></div>	
<div class='layout'><p>making it popular inside Bell Labs, where Dennis and Ken worked.</p><p>使 Unix 在 Dennis 和 Ken 工作的，贝尔实验室大受欢迎</p></div>	
<div class='layout'><p>As more developers started using Unix to build and run their own programs,</p><p>越来越多开发人员用 Unix 写程序和运行程序</p></div>	
<div class='layout'><p>the number of contributed tools grew.</p><p>工具数量日益增长</p></div>	
<div class='layout'><p>Soon after its release in 1971,</p><p>1971 年发布后不久</p></div>	
<div class='layout'><p>it gained compilers for different programming languages and even a word processor,</p><p>就有人写了不同编程语言的编译器，甚至文字处理器</p></div>	
<div class='layout'><p>quickly making it one of the most popular OSes of the 1970s and 80s.</p><p>使得 Unix 迅速成为，1970~80年代最流行的操作系统之一</p></div>	
<div class='layout'><p>At the same time, by the early 1980s,</p><p>到 1980 年代早期</p></div>	
<div class='layout'><p>the cost of a basic computer had fallen to the point where individual people could afford one,</p><p>计算机的价格 降到普通人买得起 ，</p></div>	
<div class='layout'><p>called a personal or home computer.</p><p>这些叫"个人电脑"或"家庭电脑"</p></div>	
<div class='layout'><p>These were much simpler than the big mainframes</p><p>这些电脑比大型主机简单得多，</p></div>	
<div class='layout'><p>found at universities, corporations, and governments.</p><p>主机一般在大学，公司和政府</p></div>	
<div class='layout'><p>So, their operating systems had to be equally simple.</p><p>因此操作系统也得简单</p></div>	
<div class='layout'><p>For example, Microsoft's Disk Operating System, or MS-DOS, was just 160 kilobytes,</p><p>举例，微软的磁盘操作系统（MS-DOS）只有 160 kB，</p></div>	
<div class='layout'><p>allowing it to fit, as the name suggests, onto a single disk.</p><p>一张磁盘就可以容纳</p></div>	
<div class='layout'><p>First released in 1981, it became the most popular OS for early home computers,</p><p>于 1981 年发布，成为早期家用电脑最受欢迎的操作系统</p></div>	
<div class='layout'><p>even though it lacked multitasking and protected memory.</p><p>虽然缺少"多任务"和"保护内存"这样功能</p></div>	
<div class='layout'><p>This meant that programs could,</p><p>意味着程序经常</p></div>	
<div class='layout'><p>and would, regularly crash the system.</p><p>使系统崩溃</p></div>	
<div class='layout'><p>While annoying, it was an acceptable tradeoff,</p><p>虽然很讨厌但还可以接受，</p></div>	
<div class='layout'><p>as users could just turn their own computers off and on again!</p><p>因为用户可以重启</p></div>	
<div class='layout'><p>Even early versions of Windows,</p><p>哪怕是微软 1985 年发布的早期 Windows，</p></div>	
<div class='layout'><p>first released by Microsoft in 1985  and which dominated the OS scene throughout the 1990s,</p><p>虽然在 90 年代很流行</p></div>	
<div class='layout'><p>lacked strong memory protection.</p><p>但却缺乏"内存保护"</p></div>	
<div class='layout'><p>When programs misbehaved,</p><p>当程序行为不当时，</p></div>	
<div class='layout'><p>you could get the blue screen of death,</p><p>就会"蓝屏"</p></div>	
<div class='layout'><p>a sign that a program had crashed so badly that it took down the whole operating system.</p><p>代表程序崩溃的非常严重，把系统也带崩溃了</p></div>	
<div class='layout'><p>Luckily, newer versions of Windows have better protections and usually don't crash that often.</p><p>幸运的是，新版Windows有更好的保护，不会经常崩溃</p></div>	
<div class='layout'><p>Today, computers run modern operating systems,</p><p>如今的计算机 有现代操作系统</p></div>	
<div class='layout'><p>like Mac OS X, Windows 10, Linux, iOS and Android.</p><p>比如 Mac OS X，Windows 10 ，Linux，iOS和Android</p></div>	
<div class='layout'><p>Even though the computers we own are most often used by just a single person,</p><p>虽然大部分设备只有一个人使用</p></div>	
<div class='layout'><p>you!</p><p>你！</p></div>	
<div class='layout'><p>their OS all have multitasking and virtual and protected memory.</p><p>操作系统依然有"多任务， "虚拟内存"， "内存保护"</p></div>	
<div class='layout'><p>So, they can run many programs at once:</p><p>因此可以同时运行多个程序：</p></div>	
<div class='layout'><p>you can watch YouTube in your web browser,</p><p>一边在浏览器看 YouTube，一</p></div>	
<div class='layout'><p>edit a photo in Photoshop,</p><p>一边在 Photoshop 修图</p></div>	
<div class='layout'><p>play music in Spotify and sync Dropbox all at the same time.</p><p>用 Spotify 放音乐，同步 Dropbox</p></div>	
<div class='layout'><p>This wouldn't be possible without those decades of research and development on Operating Systems,</p><p>如果没有操作系统这几十年的发展，这些都不可能，</p></div>	
<div class='layout'><p>and of course the proper memory to store those programs.</p><p>当然，我们也需要地方放程序</p></div>	
<div class='layout'><p>Which we'll get to next week.</p><p>下周会讨论</p></div>	
﻿
</div> <!--container-->
<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>
<a id="fPagea" href="index.html" target="_self"><div id="fPage" style="color:#fff;">上<br>一<br>章</div></a>
<a href="index.html" target="_self"><div id="menuPage" style="color:#fff;">目<br>录</div></a>
<a id="LPagea" href="javascript:void(null)" target="_self"><div id="lPage" style="color:#fff;">下<br>一<br>章</div></a>
<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
	//上一页、下一页按钮，需要文件名是数字
	var strUrl=window.location.href;
	var arrUrl=strUrl.split("/");
	var thispage=arrUrl[arrUrl.length-1];
	var thispage2=thispage.split(".");
	var thispage3=thispage2[thispage2.length-2];
	if(thispage3 == 0){
		var obj5=document.getElementById("fPage");
		obj5.style.display="none";
	}else{
		var fpage = thispage3 - 1;
		fpage = fpage +".html";
		document.getElementById("fPagea").href=fpage;
	}
	if(thispage3 == 100){
		var obj6=document.getElementById("lPage");
		obj6.style.display="none";
	}else{
		var fpage = parseInt(thispage3) + 1;
		fpage = fpage +".html";
		document.getElementById("LPagea").href=fpage;
	}
</script>
</div>
</body>
</html>
