<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//谷歌浏览器  
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox等浏览器
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//谷歌浏览器  
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox等浏览器  
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}
function changePage(){ 
	var page = document.getElementById("container");
	page.style.background="black";
	page.style.color="white";
	page.style.fontSize="22px";
	page.style.fontFamily="MV boli";
}
</script>
<script>
document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000" style="color:red;">红色</option><option value="#006600" style="color:green;">绿色</option><option value="#0000ff" style="color:blue;">蓝色</option><option value="#660000" style="color:#006600;">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fontsize id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select>><br>字体类型<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontFamily=this.options[this.selectedIndex].value;"> <option value="宋体" >宋体</option> <option value="MV boli" style="font-family:MV boli">MV boli</option> <option value="隶书" style="font-family:隶书">隶书</option> <option value="黑体" style="font-family:黑体">黑体</option><option value="楷体" style="font-family:楷体">楷体</option><option value="幼圆" style="font-family:幼圆">幼圆</option><option value="华文中宋" style="font-family:华文中宋">华文中宋</option><option value="华文行楷" style="font-family:华文行楷">华文行楷</option><option value="微软雅黑" style="font-family:微软雅黑">微软雅黑</option><option value="Arial" style="font-family:Arial">Arial</option><option value="Vrinda" style="font-family:Vrinda">Vrinda</option><option value="Tahoma" style="font-family:Tahoma">Tahoma</option><option value="Courier" style="font-family:Courier">Courier</option><option value="Times" style="font-family:Times">Times</option><option value="Georgia" style="font-family:Georgia">Georgia</option><option value="Lucida" style="font-family:Lucida">Lucida</option></select><br><a onClick="changePage()" target="_self" id="changepage">黑底白字</a></div>');   
</script>
<style type="text/css">
#tbrowser a:link，#container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:85.29%;
	line-height:1.6em;
	overflow:hidden;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}
#goTopBtn, #goBottom, #shangy, #xiay, #menuPage, #lPage, #fPage, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #menuPage, #lPage, #fPage, #ftsize1, #ftsize3{
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #lPage, #fPage, #ftsize, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#fPage{
	bottom: 236px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
	//writing-mode:tb-rl;
}
#menuPage{
	bottom: 198px;
	height:27px;
	white-space:nowrap;
	overflow:hidden;
}
#lPage{
	bottom: 145px;
	height:42px;
	white-space:nowrap;
	overflow:hidden;
}
#ftsize1{
	bottom:360px;
}
#ftsize2{
	bottom:334px;
}
#ftsize3{
	bottom:308px;
}
#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #menuPage:hover, #lPage:hover, #fPage:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #menuPage a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link, #menuPage a:visited, #lPage a:link, #fPage a:link, #lPage a:visited, #fPage a:visited {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
.code0, .code2, .code4{
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
.layout, .layout2{
    clear:both;
	width:95%;
	border:1px dotted #eee;
	margin:auto;
	margin-bottom:5px;
	overflow:hidden;
}
.layout2 .right, .layout2 .left, .layout p{
margin-bottom:-55px;
padding-bottom:55px;
text-align: justify;
margin:0;
padding:0;
margin-left:1%;
margin-right:1%;
}
.layout2 .left, .layout p{
float:left;
width:60%;
font-size:1.0em;
}
.layout2 .right,  .layout p+p {
	float: left;
	width:34%;
	border-left:1px dotted #cccccc;
	font-size:0.9em;
	padding-left:1%;
	
}
.layout2 .right p, .layout2 .left p, .layout p{
padding-bottom:5px;
}
h3{
text-indent:3%;
font-size:1em;
height:2.0em;
padding:0;
margin:0;
}
</style>
</head>
<body>
<div id="container">
﻿<div class='layout'><p>13 Intro to Algorithms</p><p>13 算法入门</p></div>	
<div class='layout'><p>Hi, I'm Carrie Anne, and welcome to CrashCourse Computer Science!</p><p>嗨，我是 Carrie Anne，欢迎收看计算机科学速成课！</p></div>	
<div class='layout'><p>Over the past two episodes, we got our first taste of programming in a high-level language,</p><p>前两集，我们"初尝"了高级编程语言，</p></div>	
<div class='layout'><p>like Python or Java.</p><p>比如 Python 和 Java</p></div>	
<div class='layout'><p>We talked about different types of programming language statements</p><p>我们讨论了几种语句</p></div>	
<div class='layout'><p>like assignments, ifs, and loops -</p><p>赋值语句，if 语句，循环语句</p></div>	
<div class='layout'><p>as well as putting statements into functions that perform a computation,</p><p>以及把代码打包成 "函数"</p></div>	
<div class='layout'><p>like calculating an exponent.</p><p>比如算指数</p></div>	
<div class='layout'><p>Importantly, the function we wrote to calculate exponents is only one possible solution.</p><p>重要的是，之前写的指数函数，只是无数解决方案的一种</p></div>	
<div class='layout'><p>There are other ways to write this function</p><p>还有其它方案</p></div>	
<div class='layout'><p>using different statements in different orders -</p><p>用不同顺序写不同语句</p></div>	
<div class='layout'><p>that achieve exactly the same numerical result.</p><p>也能得到一样结果</p></div>	
<div class='layout'><p>The difference between them is the algorithm,</p><p>不同的是 "算法"，意思是：</p></div>	
<div class='layout'><p>that is the specific steps used to complete the computation.</p><p>解决问题的具体步骤</p></div>	
<div class='layout'><p>Some algorithms are better than others even if they produce equal results.</p><p>即使结果一致，有些算法会更好</p></div>	
<div class='layout'><p>Generally, the fewer steps it takes to compute, the better it is,</p><p>一般来说，所需步骤越少越好</p></div>	
<div class='layout'><p>though sometimes we care about other factors, like how much memory it uses.</p><p>不过有时我们也会关心其他因素，比如占多少内存</p></div>	
<div class='layout'><p>The term algorithm comes from Persian polymath Muhammad ibn Musa al-Khwarizmi</p><p>算法 一词来自 波斯博识者 阿尔·花拉子密</p></div>	
<div class='layout'><p>who was one of the fathers of algebra more than a millennium ago.</p><p>1000 多年前的代数之父之一</p></div>	
<div class='layout'><p>The crafting of efficient algorithms</p><p>如何想出高效算法</p></div>	
<div class='layout'><p>a problem that existed long before modern computers -</p><p>是早在计算机出现前就有的问题</p></div>	
<div class='layout'><p>led to a whole science surrounding computation,</p><p>诞生了专门研究计算的领域，</p></div>	
<div class='layout'><p>which evolved into the modern discipline of...</p><p>然后发展成一门现代学科</p></div>	
<div class='layout'><p>you guessed it!</p><p>你猜对了！</p></div>	
<div class='layout'><p>Computer Science!</p><p>计算机科学！</p></div>	
<div class='layout'><p>One of the most storied algorithmic problems in all of computer science is sorting</p><p>记载最多的算法之一是"排序"</p></div>	
<div class='layout'><p>as in sorting names or sorting numbers.</p><p>比如给名字、数字排序</p></div>	
<div class='layout'><p>Computers sort all the time.</p><p>排序到处都是</p></div>	
<div class='layout'><p>Looking for the cheapest airfare,</p><p>找最便宜的机票</p></div>	
<div class='layout'><p>arranging your email by most recently sent,</p><p>按最新时间排邮件</p></div>	
<div class='layout'><p>or scrolling your contacts by last name</p><p>按姓氏排联系人</p></div>	
#NAME?	
<div class='layout'><p>You might think</p><p>你可能想</p></div>	
<div class='layout'><p>sorting isn't so tough how many algorithms can there possibly be?</p><p>排序看起来不怎么难… 能有几种算法呢？</p></div>	
<div class='layout'><p>The answer is: a lot.</p><p>答案是超多</p></div>	
<div class='layout'><p>Computer Scientists have spent decades inventing algorithms for sorting,</p><p>计算机科学家花了数十年发明各种排序算法</p></div>	
<div class='layout'><p>with cool names like Bubble Sort and Spaghetti Sort.</p><p>还起了酷酷的名字，"冒泡排序"、"意面排序"</p></div>	
<div class='layout'><p>Let's try sorting!</p><p>我们来试试排序！</p></div>	
<div class='layout'><p>Imagine we have a set of airfare prices to Indianapolis.</p><p>试想有一堆机票价格，都飞往  印第安纳波利斯 (美国地名)</p></div>	
<div class='layout'><p>We'll talk about how data like this is represented in memory next week,</p><p>数据具体怎么在内存中表示  下周再说</p></div>	
<div class='layout'><p>but for now, a series of items like this is called an array.</p><p>上图的这样一组数据  叫"数组"（Array）</p></div>	
<div class='layout'><p>Let's take a look at these numbers to help see how we might sort this programmatically.</p><p>来看看怎么排序</p></div>	
<div class='layout'><p>We'll start with a simple algorithm.</p><p>先从一种简单算法开始</p></div>	
<div class='layout'><p>First, let's scan down the array to find the smallest number.</p><p>先找到最小数，</p></div>	
<div class='layout'><p>Starting at the top with 307.</p><p>从最上面的 307 开始</p></div>	
<div class='layout'><p>It's the only number we've seen, so it's also the smallest.</p><p>因为现在只看了这一个，所以它是最小数</p></div>	
<div class='layout'><p>The next is 239, that's smaller than 307,</p><p>下一个是 239，比 307 小</p></div>	
<div class='layout'><p>so it becomes our new smallest number.</p><p>所以新的最小数变成 239</p></div>	
<div class='layout'><p>Next is 214, our new smallest number.</p><p>下一个是 214 ，新的最小数</p></div>	
<div class='layout'><p>250 is not, neither is 384, 299, 223 or 312.</p><p>250 不是，384， 299， 223， 312 都不是</p></div>	
<div class='layout'><p>So we've finished scanning all numbers,</p><p>现在扫完了所有数字</p></div>	
<div class='layout'><p>and 214 is the smallest.</p><p>214 是最小的</p></div>	
<div class='layout'><p>To put this into ascending order,</p><p>为了升序排列（从小到大排序）</p></div>	
<div class='layout'><p>we swap 214 with the number in the top location.</p><p>把 214 和最上面的数字，交换位置</p></div>	
<div class='layout'><p>Great! We sorted one number!</p><p>好棒！ 刚排序了一个数字！</p></div>	
<div class='layout'><p>Now we repeat the same procedure,</p><p>现在重复同样的过程</p></div>	
<div class='layout'><p>but instead of starting at the top, we can start one spot below.</p><p>这次不从最上面开始，从第 2 个数开始</p></div>	
<div class='layout'><p>First we see 239, which we save as our new smallest number.</p><p>先看到 239，我们当作是 "最小数"</p></div>	
<div class='layout'><p>Scanning the rest of the array, we find 223 is the next smallest,</p><p>扫描剩下的部分，发现 223 最小</p></div>	
<div class='layout'><p>so we swap this with the number in the second spot.</p><p>所以把它和第 2 位交换</p></div>	
<div class='layout'><p>Now we repeat again, starting from the third number down.</p><p>重复这个过程，从第 3 位数字开始</p></div>	
<div class='layout'><p>This time, we swap 239 with 307.</p><p>让 239 和 307 互换位置</p></div>	
<div class='layout'><p>This process continues until we get to the very last number,</p><p>重复直到最后一个数字</p></div>	
<div class='layout'><p>and voila, the array is sorted and you're ready to book that flight to Indianapolis!</p><p>瞧，数字排好了，可以买机票了！</p></div>	
<div class='layout'><p>The process we just walked through is one way</p><p>刚刚这种方法，</p></div>	
<div class='layout'><p>or one algorithm for sorting an array.</p><p>或者说算法，</p></div>	
<div class='layout'><p>It's called Selection sort and it's pretty basic.</p><p>叫 选择排序 非常基础的一种算法</p></div>	
<div class='layout'><p>Here's the pseudo-code.</p><p>以下是"伪代码"</p></div>	
<div class='layout'><p>This function can be used to sort 8, 80, or 80 million numbers</p><p>这个函数可以排序8个， 80个或8千万个数字</p></div>	
<div class='layout'><p>and once you've written the function, you can use it over and over again.</p><p>函数写好了就可以重复使用</p></div>	
<div class='layout'><p>With this sort algorithm, we loop through each position in the array, from top to bottom,</p><p>这里用循环 遍历数组</p></div>	
<div class='layout'><p>and then for each of those positions,</p><p>每个数组位置都跑一遍循环，</p></div>	
<div class='layout'><p>we have to loop through the array to find the smallest number to swap.</p><p>找最小数然后互换位置</p></div>	
<div class='layout'><p>You can see this in the code, where one FOR loop is nested inside of another FOR loop.</p><p>可以在代码中看到这一点，（一个 for 循环套另一个 for 循环）</p></div>	
<div class='layout'><p>This means, very roughly, that if we want to sort N items, we have to loop N times,</p><p>这意味着，大致来说，如果要排 N 个东西，要循环 N 次，</p></div>	
<div class='layout'><p>inside of which, we loop N times, for a grand total of roughly N times N loops, or N squared.</p><p>每次循环中再循环 N 次，共 N*N，  或 N</p></div>	
<div class='layout'><p>This relationship of input size to the number of steps the algorithm takes to run</p><p>算法的 输入大小 和 运行步骤 之间的关系</p></div>	
<div class='layout'><p>characterizes the complexity of the Selection Sort algorithm.</p><p>叫算法的 复杂度</p></div>	
<div class='layout'><p>It gives you an approximation of how fast, or slow, an algorithm is going to be.</p><p>表示运行速度的量级</p></div>	
<div class='layout'><p>Computer Scientists write this order of growth in something known as no joke -</p><p>计算机科学家们把算法复杂度叫 没开玩笑</p></div>	
<div class='layout'><p>big O notation.</p><p>大 O 表示法</p></div>	
<div class='layout'><p>N squared is not particularly efficient.</p><p>算法复杂度 O(N  ) 效率不高</p></div>	
<div class='layout'><p>Our example array had n = 8 items, and 8 squared is 64.</p><p>前面的例子有 8 个元素（n=8）， 8  = 64</p></div>	
<div class='layout'><p>If we increase the size of our array from 8 items to 80,</p><p>如果 8 个变 80 个</p></div>	
<div class='layout'><p>the running time is now 80 squared, which is 6,400.</p><p>运行时间变成 80  = 6400</p></div>	
<div class='layout'><p>So although our array only grew by 10 times from 8 to 80 -</p><p>虽然大小只增长了 10 倍（8 到 80）</p></div>	
<div class='layout'><p>the running time increased by 100 times from 64 to 6,400!</p><p>但运行时间增加了 100 倍！（64 到 6400 ）</p></div>	
<div class='layout'><p>This effect magnifies as the array gets larger.</p><p>随着数组增大，对效率的影响会越来越大</p></div>	
<div class='layout'><p>That's a big problem for a company like Google,</p><p>这对大公司来说是个问题，比如 谷歌</p></div>	
<div class='layout'><p>which has to sort arrays with millions or billions of entries.</p><p>要对几十亿条信息排序</p></div>	
<div class='layout'><p>So, you might ask,</p><p>作为未来的计算机科学家你可能会问：</p></div>	
<div class='layout'><p>as a burgeoning computer scientist, is there a more efficient sorting algorithm?</p><p>有没有更高效的排序算法？</p></div>	
<div class='layout'><p>Let's go back to our old, unsorted array</p><p>回到未排序的数组</p></div>	
<div class='layout'><p>and try a different algorithm, merge sort.</p><p>试另一个算法 "归并排序"</p></div>	
<div class='layout'><p>The first thing merge sort does is check if the size of the array is greater than 1.</p><p>第一件事是检查数组大小是否 > 1</p></div>	
<div class='layout'><p>If it is, it splits the array into two halves.</p><p>如果是，就把数组分成两半</p></div>	
<div class='layout'><p>Since our array is size 8, it gets split into two arrays of size 4.</p><p>因为数组大小是 8，所以分成两个数组，大小是 4</p></div>	
<div class='layout'><p>These are still bigger than size 1, so they get split again, into arrays of size 2,</p><p>但依然大于 1，所以再分成大小是 2 的数组</p></div>	
<div class='layout'><p>and finally they split into 8 arrays with 1 item in each.</p><p>最后变成 8 个数组，每个大小为 1</p></div>	
<div class='layout'><p>Now we are ready to merge, which is how "merge sort" gets its name.</p><p>现在可以"归并"了，"归并排序"因此得名</p></div>	
<div class='layout'><p>Starting with the first two arrays, we read the first and only value in them,</p><p>从前两个数组开始，读第一个（也是唯一一个）值</p></div>	
<div class='layout'><p>in this case, 307 and 239.</p><p>307 和 239</p></div>	
<div class='layout'><p>239 is smaller, so we take that value first.</p><p>239 更小，所以放前面</p></div>	
<div class='layout'><p>The only number left is 307, so we put that value second.</p><p>剩下的唯一数字是 307 ，所以放第二位</p></div>	
<div class='layout'><p>We've successfully merged two arrays.</p><p>成功合并了两个数组</p></div>	
<div class='layout'><p>We now repeat this process for the remaining pairs, putting them each in sorted order.</p><p>重复这个过程，按序排列</p></div>	
<div class='layout'><p>Then the merge process repeats.</p><p>然后再归并一次</p></div>	
<div class='layout'><p>Again, we take the first two arrays, and we compare the first numbers in them.</p><p>同样，取前两个数组，比较第一个数</p></div>	
<div class='layout'><p>This time its 239 and 214.</p><p>239 和 214</p></div>	
<div class='layout'><p>214 is lowest, so we take that number first.</p><p>214 更小，放前面</p></div>	
<div class='layout'><p>Now we look again at the first two numbers in both arrays: 239 and 250.</p><p>再看两个数组里的第一个数：239 和 250</p></div>	
<div class='layout'><p>239 is lower, so we take that number next.</p><p>239 更小，所以放下一位</p></div>	
<div class='layout'><p>Now we look at the next two numbers: 307 and 250.</p><p>看剩下两个数：307 和 250</p></div>	
<div class='layout'><p>250 is lower, so we take that.</p><p>250 更小，所以放下一位</p></div>	
<div class='layout'><p>Finally, we're left with just 307, so that gets added last.</p><p>最后剩下 307 ，所以放最后</p></div>	
<div class='layout'><p>In every case, we start with two arrays,</p><p>每次都以 2 个数组开始</p></div>	
<div class='layout'><p>each individually sorted, and merge them into a larger sorted array.</p><p>然后合并成更大的有序数组</p></div>	
<div class='layout'><p>We repeat the exact same merging process for the two remaining arrays of size two.</p><p>我们把刚隐藏起来的，下面的数组也这样做</p></div>	
<div class='layout'><p>Now we have two sorted arrays of size 4.</p><p>现在有两个大小是 4 的有序数组</p></div>	
<div class='layout'><p>Just as before, we merge,</p><p>就像之前，</p></div>	
<div class='layout'><p>comparing the first two numbers in each array, and taking the lowest.</p><p>比较两个数组的第一个数，取最小数</p></div>	
<div class='layout'><p>We repeat this until all the numbers are merged,</p><p>重复这个过程，直到完成</p></div>	
<div class='layout'><p>and then our array is fully sorted again!</p><p>就排好了！</p></div>	
<div class='layout'><p>The bad news is: no matter how many times we sort these,</p><p>但坏消息是：无论排多少次</p></div>	
<div class='layout'><p>you're still going to have to pay $214 to get to Indianapolis.</p><p>你还是得付 214 美元到 印第安纳波利斯</p></div>	
<div class='layout'><p>Anyway, the "Big O" computational complexity of merge sort is N times the Log of N.</p><p>总之，"归并排序"的算法复杂度是 O(n * log n)</p></div>	
<div class='layout'><p>The N comes from the number of times we need to compare and merge items,</p><p>n 是需要 比较+合并 的次数</p></div>	
<div class='layout'><p>which is directly proportional to the number of items in the array.</p><p>和数组大小成正比</p></div>	
<div class='layout'><p>The Log N comes from the number of merge steps.</p><p>log N 是合并步骤的次数</p></div>	
<div class='layout'><p>In our example, we broke our array of 8 items into 4,</p><p>例子中把大小是 8 的数组，分成四个数组</p></div>	
<div class='layout'><p>then 2, and finally 1.</p><p>然后分成 2 个，最后分成 1 个</p></div>	
<div class='layout'><p>That's 3 splits.</p><p>分了 3 次</p></div>	
<div class='layout'><p>Splitting in half repeatedly like this has a logarithmic relationship with the number of items</p><p>重复切成两半，和数量成对数关系</p></div>	
<div class='layout'><p>trust me!</p><p>相信我！</p></div>	
<div class='layout'><p>Log base 2 of 8 equals 3 splits.</p><p>Log8=3</p></div>	
<div class='layout'><p>If we double the size of our array to 16 that's twice as many items to sort -</p><p>如果数组大小变成 16 之前的两倍</p></div>	
<div class='layout'><p>it only increases the number of split steps by 1</p><p>也只要多分割 1 次</p></div>	
<div class='layout'><p>since log base 2 of 16 equals 4.</p><p>因为 Log16=4</p></div>	
<div class='layout'><p>Even if we increase the size of the array more than a thousand times,</p><p>即使扩大一千倍</p></div>	
<div class='layout'><p>from 8 items to 8000 items, the number of split steps stays pretty low.</p><p>从8到8000，分割次数也不会增大多少</p></div>	
<div class='layout'><p>Log base 2 of 8000 is roughly 13.</p><p>log8000≈13</p></div>	
<div class='layout'><p>That's more, but not much more than 3 -about four times larger --</p><p>13 比 3 只是4倍多一点</p></div>	
<div class='layout'><p>and yet we're sorting a lot more numbers.</p><p>然而排序的元素多得多</p></div>	
<div class='layout'><p>For this reason, merge sort is much more efficient than selection sort.</p><p>因此"归并排序"比"选择排序"更有效率</p></div>	
<div class='layout'><p>And now I can put my ceramic cat collection in name order MUCH faster!</p><p>这下我收藏的陶瓷猫  可以更快排序了！</p></div>	
<div class='layout'><p>There are literally dozens of sorting algorithms we could review,</p><p>有好几十种排序算法，但没时间讲</p></div>	
<div class='layout'><p>but instead, I want to move on to my other favorite category of classic algorithmic problems:</p><p>所以我们来谈一个经典算法问题：</p></div>	
<div class='layout'><p>graph search!</p><p>图搜索</p></div>	
<div class='layout'><p>A graph is a network of nodes connected by lines.</p><p>图 是用线连起来的一堆 "节点"</p></div>	
<div class='layout'><p>You can think of it like a map, with cities and roads connecting them.</p><p>可以想成地图，每个节点是一个城市，线是公路</p></div>	
<div class='layout'><p>Routes between these cities take different amounts of time.</p><p>一个城市到另一个城市，花的时间不同</p></div>	
<div class='layout'><p>We can label each line with what is called a cost or weight.</p><p>可以用 成本(cost) 或 权重(weight) 来代称</p></div>	
<div class='layout'><p>In this case, it's weeks of travel.</p><p>代表要几个星期</p></div>	
<div class='layout'><p>Now let's say we want to find the fastest route</p><p>假设想找</p></div>	
<div class='layout'><p>for an army at Highgarden to reach the castle at Winterfell.</p><p>高庭到"凛冬城"的最快路线</p></div>	
<div class='layout'><p>The simplest approach would just be to try every single path exhaustively</p><p>最简单的方法是尝试每一条路</p></div>	
<div class='layout'><p>and calculate the total cost of each.</p><p>计算总成本</p></div>	
<div class='layout'><p>That's a brute force approach.</p><p>这是蛮力方法</p></div>	
<div class='layout'><p>We could have used a brute force approach in sorting,</p><p>假设用蛮力方法 来排序数组</p></div>	
<div class='layout'><p>by systematically trying every permutation of the array to check if it's sorted.</p><p>尝试每一种组合，看是否排好序</p></div>	
<div class='layout'><p>This would have an N factorial complexity</p><p>这样的时间复杂度是 O(n！)</p></div>	
<div class='layout'><p>that is the number of nodes, times one less, times one less than that, and so on until 1.</p><p>n 是节点数，n！ 是 n 乘 n-1 乘 n-2.. 一直到 1</p></div>	
<div class='layout'><p>Which is way worse than even N squared.</p><p>比 O(n)还糟糕</p></div>	
<div class='layout'><p>But, we can be way more clever!</p><p>我们可以更聪明些！</p></div>	
<div class='layout'><p>The classic algorithmic solution to this graph problem was invented by</p><p>图搜索问题的经典算法  发明者是</p></div>	
<div class='layout'><p>one of the greatest minds in computer science practice and theory, Edsger Dijkstra</p><p>理论计算机科学的伟人 Edsger Dijkstra</p></div>	
<div class='layout'><p>so it's appropriately named Dijkstra's algorithm.</p><p>所以叫 "Dijkstra 算法"</p></div>	
<div class='layout'><p>We start in Highgarden with a cost of 0, which we mark inside the node.</p><p>从"高庭"开始，此时成本为0，把0标在节点里</p></div>	
<div class='layout'><p>For now, we mark all other cities with question marks</p><p>其他城市标成问号，</p></div>	
<div class='layout'><p>we don't know the cost of getting to them yet.</p><p>因为不知道成本多少</p></div>	
<div class='layout'><p>Dijkstra's algorithm always starts with the node with lowest cost.</p><p>Dijkstra 算法总是从成本最低的节点开始</p></div>	
<div class='layout'><p>In this case, it only knows about one node, Highgarden, so it starts there.</p><p>目前只知道一个节点 "高庭"， 所以从这里开始</p></div>	
<div class='layout'><p>It follows all paths from that node to all connecting nodes that are one step away,</p><p>跑到所有相邻节点，</p></div>	
<div class='layout'><p>and records the cost to get to each of them.</p><p>记录成本</p></div>	
<div class='layout'><p>That completes one round of the algorithm.</p><p>完成了一轮算法</p></div>	
<div class='layout'><p>We haven't encountered Winterfell yet,</p><p>但还没到"凛冬城"</p></div>	
<div class='layout'><p>so we loop and run Dijkstra's algorithm again.</p><p>所以再跑一次 Dijkstra 算法</p></div>	
<div class='layout'><p>With Highgarden already checked,</p><p>高庭 已经知道了</p></div>	
<div class='layout'><p>the next lowest cost node is King's Landing.</p><p>下一个成本最低的节点，是 "君临城"</p></div>	
<div class='layout'><p>Just as before, we follow every unvisited line to any connecting cities.</p><p>就像之前，记录所有相邻节点的成本</p></div>	
<div class='layout'><p>The line to The Trident has a cost of 5.</p><p>到"三叉戟河"的成本是 5</p></div>	
<div class='layout'><p>However, we want to keep a running cost from Highgarden,</p><p>然而我们想记录的是，从"高庭"到这里的成本</p></div>	
<div class='layout'><p>so the total cost of getting to The Trident is 8 plus 5, which is 13 weeks.</p><p>所以"三叉戟河"的总成本是 8+5=13周</p></div>	
<div class='layout'><p>Now we follow the offroad path to Riverrun,</p><p>现在走另一条路到"奔流城"</p></div>	
<div class='layout'><p>which has a high cost of 25, for a total of 33.</p><p>成本高达 25 ，总成本 33</p></div>	
<div class='layout'><p>But we can see inside of Riverrun that we've already found a path with a lower cost of just 10.</p><p>但 "奔流城" 中最低成本是 10</p></div>	
<div class='layout'><p>So we disregard our new path, and stick with the previous, better path.</p><p>所以无视新数字，保留之前的成本 10</p></div>	
<div class='layout'><p>We've now explored every line from King's Landing and didn't find Winterfell, so we move on.</p><p>现在看了"君临城"的每一条路，还没到"凛冬城" 所以继续.</p></div>	
<div class='layout'><p>The next lowest cost node is Riverrun, at 10 weeks.</p><p>下一个成本最低的节点，是"奔流城"，要 10 周</p></div>	
<div class='layout'><p>First we check the path to The Trident, which has a total cost of 10 plus 2, or 12.</p><p>先看 "三叉戟河" 成本： 10+2=12</p></div>	
<div class='layout'><p>That's slightly better than the previous path we found, which had a cost of 13,</p><p>比之前的 13 好一点</p></div>	
<div class='layout'><p>so we update the path and cost to The Trident.</p><p>所以更新 "三叉戟河" 为 12</p></div>	
<div class='layout'><p>There is also a line from Riverrun to Pyke with a cost of 3.</p><p>奔流城到"派克城"成本是 3</p></div>	
<div class='layout'><p>10 plus 3 is 13, which beats the previous cost of 14,</p><p>10+3=13，之前是14</p></div>	
<div class='layout'><p>and so we update Pyke's path and cost as well.</p><p>所以更新 "派克城" 为 13</p></div>	
<div class='layout'><p>That's all paths from Riverrun checked. so you guessed it, Dijkstra's algorithm loops again.</p><p>奔流城出发的所有路径都走遍了，你猜对了，再跑一次 Dijkstra 算法</p></div>	
<div class='layout'><p>The node with the next lowest cost is The Trident</p><p>下一个成本最低的节点，是"三叉戟河"</p></div>	
<div class='layout'><p>and the only line from The Trident that we haven't checked is a path to Winterfell!</p><p>从"三叉戟河"出发，唯一没看过的路，通往"凛冬城"！</p></div>	
<div class='layout'><p>It has a cost of 10,</p><p>成本是 10</p></div>	
<div class='layout'><p>plus we need to add in the cost of 12 it takes to get to The Trident,</p><p>加"三叉戟河"的成本 12</p></div>	
<div class='layout'><p>for a grand total cost of 22.</p><p>总成本 22</p></div>	
<div class='layout'><p>We check our last path, from Pyke to Winterfell, which sums to 31.</p><p>再看最后一条路，"派克城"到"凛冬城"，成本 31</p></div>	
<div class='layout'><p>Now we know the lowest total cost, and also the fastest route for the army to get there,</p><p>现在知道了最低成本路线，让军队最快到达，</p></div>	
<div class='layout'><p>which avoids King's Landing!</p><p>还绕过了"君临城"！</p></div>	
<div class='layout'><p>Dijkstra's original algorithm, conceived in 1956,</p><p>Dijkstra 算法的原始版本，构思于 1956 年</p></div>	
<div class='layout'><p>had a complexity of the number of nodes in the graph squared.</p><p>算法复杂度是 O(n)</p></div>	
<div class='layout'><p>And squared, as we already discussed, is never great,</p><p>前面说过这个效率不够好</p></div>	
<div class='layout'><p>because it means the algorithm can't scale to big problems</p><p>意味着输入不能很大</p></div>	
<div class='layout'><p>like the entire road map of the United States.</p><p>比如美国的完整路线图</p></div>	
<div class='layout'><p>Fortunately, Dijkstra's algorithm was improved a few years later</p><p>幸运的是，Dijkstra 算法几年后得到改进</p></div>	
<div class='layout'><p>to take the number of nodes in the graph,</p><p>变成 O(n log n + l)</p></div>	
<div class='layout'><p>times the log of the number of nodes, PLUS the number of lines.</p><p>n 是节点数，l 是多少条线</p></div>	
<div class='layout'><p>Although this looks more complicated,</p><p>虽然看起来更复杂</p></div>	
<div class='layout'><p>it's actually quite a bit faster.</p><p>但实际更快一些</p></div>	
<div class='layout'><p>Plugging in our example graph, with 6 cities and 9 lines, proves it.</p><p>用之前的例子，可以证明更快，（6 个节点 9 条线）</p></div>	
<div class='layout'><p>Our algorithm drops from 36 loops to around 14.</p><p>从 36 减少到 14 左右</p></div>	
<div class='layout'><p>As with sorting,</p><p>就像排序，图搜索算法也有很多，有不同优缺点</p></div>	
<div class='layout'><p>there are innumerable graph search algorithms, with different pros and cons.</p><p>就像排序，图搜索算法也有很多，有不同优缺点</p></div>	
<div class='layout'><p>Every time you use a service like Google Maps to find directions,</p><p>每次用谷歌地图时</p></div>	
<div class='layout'><p>an algorithm much like Dijkstra's is running on servers to figure out the best route for you.</p><p>类似 Dijkstra 的算法就在服务器上运行，找最佳路线</p></div>	
<div class='layout'><p>Algorithms are everywhere</p><p>算法无处不在</p></div>	
<div class='layout'><p>and the modern world would not be possible without them.</p><p>现代世界离不开它们</p></div>	
<div class='layout'><p>We touched only the very tip of the algorithmic iceberg in this episode,</p><p>这集只触及了算法的冰山一角</p></div>	
<div class='layout'><p>but a central part of being a computer scientist</p><p>但成为计算机科学家的核心</p></div>	
<div class='layout'><p>is leveraging existing algorithms and writing new ones when needed,</p><p>是根据情况合理决定 用现有算法 还是自己写新算法</p></div>	
<div class='layout'><p>and I hope this little taste has intrigued you to SEARCH further.</p><p>希望这集的小例子能让你体会到这点</p></div>	
<div class='layout'><p>I'll see you next week.</p><p>下周见</p></div>	
﻿
</div> <!--container-->
<div>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a>
<a id="fPagea" href="index.html" target="_self"><div id="fPage" style="color:#fff;">上<br>一<br>章</div></a>
<a href="index.html" target="_self"><div id="menuPage" style="color:#fff;">目<br>录</div></a>
<a id="LPagea" href="javascript:void(null)" target="_self"><div id="lPage" style="color:#fff;">下<br>一<br>章</div></a>
<a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器  
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	}
	//上一页、下一页按钮，需要文件名是数字
	var strUrl=window.location.href;
	var arrUrl=strUrl.split("/");
	var thispage=arrUrl[arrUrl.length-1];
	var thispage2=thispage.split(".");
	var thispage3=thispage2[thispage2.length-2];
	if(thispage3 == 0){
		var obj5=document.getElementById("fPage");
		obj5.style.display="none";
	}else{
		var fpage = thispage3 - 1;
		fpage = fpage +".html";
		document.getElementById("fPagea").href=fpage;
	}
	if(thispage3 == 100){
		var obj6=document.getElementById("lPage");
		obj6.style.display="none";
	}else{
		var fpage = parseInt(thispage3) + 1;
		fpage = fpage +".html";
		document.getElementById("LPagea").href=fpage;
	}
</script>
</div>
</body>
</html>
