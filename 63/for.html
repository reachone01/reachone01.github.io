<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base  target="_blank"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>bat for</title>
<script language="JavaScript" type="text/javascript">

//bg_even("表格ID属性名","奇数行背景色","偶数行背景色","鼠标经过背景色","点击后背景色");
function bg_even(o,a,b,c,d){
        var t=document.getElementById(o).getElementsByTagName("tr");
        for(var i=0;i<t.length;i++){
                t[i].style.backgroundColor=(t[i].sectionRowIndex%2==0)?a:b;
                t[i].onclick=function(){
                        if(this.x!="1"){
                                this.x="1";
                                this.style.backgroundColor=d;
                        }else{
                                this.x="0";
                                this.style.backgroundColor=(this.sectionRowIndex%2==0)?a:b;
                        }
                }
                t[i].onmouseover=function(){
                        if(this.x!="1")this.style.backgroundColor=c;
                }
                t[i].onmouseout=function(){
                        if(this.x!="1")this.style.backgroundColor=(this.sectionRowIndex%2==0)?a:b;
                }
        }
}

</script> <script type="text/javascript">
 
 function goTopEx(){
var obj=document.getElementById("goTopBtn");
function getScrollTop(){
return document.documentElement.scrollTop;
}
function setScrollTop(value){
document.documentElement.scrollTop=value;
}
window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
obj.onclick=function(){
var goTop=setInterval(scrollMove,10);
function scrollMove(){
setScrollTop(getScrollTop()/111);
if(getScrollTop()<1)clearInterval(goTop);
}
}
}


</script>
<script type="text/javascript">
 
 function goTopEx(){
var obj=document.getElementById("goTopBtn");
function getScrollTop(){
return document.documentElement.scrollTop;
}
function setScrollTop(value){
document.documentElement.scrollTop=value;
}
window.onscroll=function(){getScrollTop()>0?obj.style.display="":obj.style.display="none";}
obj.onclick=function(){
var goTop=setInterval(scrollMove,10);
function scrollMove(){
setScrollTop(getScrollTop()/111);
if(getScrollTop()<1)clearInterval(goTop);
}
}
}


</script>
<style type="text/css">
<!--

.container {
	width: 78.125%;
	list-style-position:inside;
	margin:auto;
	font-family: "宋体",arial;
	line-height:22px;

}
h2{
font-size:20px;
font-weight:bold;
margin-top:-15px;
margin-bottom:-15px;
text-indent:o;
}

.tablecss{
	width: 100%;
	margin:auto;
	border-collapse:collapse;
	font-family: "宋体" arial;
	text-align:left;
	line-height:22px;
	margin-bottom:22px;
}

.tablecss th,td{
border:1px solid #aaa;
font-size:16px;
color:#000000;
}

.tablecss thead th{
border-bottom:2px solid #3d580b;
background-color:#8fc629;
color:#fff;
padding:5px 0px;
}
.tablecss th{
background-color:#f2f4b9;
}
.tablecss th.title{
background-color:#e3e685;
}
.tablecss tfoot td{
border-width:0px;
text-align:right;
font-size:16px;
color:#777;
}
.tablecss caption{
font-weight:bold;
padding:1px 0px;
color:#3d580b;
font-size:18px;
text-align:left;
}


.tablecss .bl{
border-left:none;
}

.tablecss .br{
border-right:none;
}

.tablecss tr{
height:6px;
}

#bod1 th.title{
background-color:#ffd56c;
}
#bod1 th{
background-color:#ffe8ae;
}
.clx td{
background-color:#CCCCFF;
}
.lxf td{
background-color:#f2f4b9;
}
.qzwq td{
background-color:#CCCCCC;
}
a:hover{
background-color:#CCCCCC;
}

a:link {
	text-decoration: none;
}
a:visited {
	text-decoration: none;
}
body {
	margin-top: 0px;
	line-height:18px;
}
.uls{
color:#CC6666;
font-weight:bold;
}
.uls>ol{
list-style:none;
font-weight:normal;
list-style:lower-latin;
color:#000000;

}
.color1{
color:red;
}.container p{
text-indent:2em;
font-size:18px;
font-family:"宋体";
margin-top:0px;
}
#goTopBtn {
	width: 18px;
line-height: 1.2;
padding: 5px 0;
background-color:#eee;
color:#000;
font-size: 12px;
text-align: center;
position: fixed;
_position: absolute;
 
right: 10px;
bottom: 105px;
_bottom: "auto";
cursor: pointer;
opacity: .6;
filter: Alpha(opacity=30);
	opacity=.3;
}
 #goTopBtn:hover{
 background-color:white;
 border:#ccc 1px solid;
 color:red;
 }
 
 
#goBottom {
	width: 18px;
line-height: 1.2;
padding: 5px 0;
background-color: #eee;
color: #fff;
font-size: 12px;
text-align: center;
position: fixed;
_position: absolute;
 
right: 10px;
bottom: 30px;
_bottom: "auto";
cursor: pointer;
filter: Alpha(opacity=30);
	opacity=.3;
	writing-mode:tb-rl;
}
 #goBottom:hover{
 background-color:white;
 border:#ccc 1px solid;
 color:red;
 }
 #shangy {
	width: 18px;
line-height: 1.2;
padding: 5px 0;
background-color: #eee;
color: #fff;
font-size: 12px;
text-align: center;
position: fixed;
_position: absolute;
 
right: 10px;
bottom: 80px;
_bottom: "auto";
cursor: pointer;
filter: Alpha(opacity=30);
	opacity=.3;
}
#xiay {
	width: 18px;
line-height: 1.2;
padding: 5px 0;
background-color: #eee;
color: #fff;
font-size: 12px;
text-align: center;
position: fixed;
_position: absolute;
 
right: 10px;
bottom: 55px;
_bottom: "auto";
cursor: pointer;
filter: Alpha(opacity=30);
	opacity=.3;
}
.ph{
margin:0px;
font-size:80%;
color:blue;
}
table{
border-collapse:collapse;
width:100%;
margin:auto;
}
table td{
border:0px;
border:1px solid #aaa;
padding:4px;}
-->
</style>
</head>

<body>

<div class="container">
  <table cellspacing="0" cellpadding="0">
    <col width="384" />
    <col width="82" />
    <col width="208" />
    <tr height="19">
      <td height="19" width="384">for %%var in (fileset) do comm</td>
      <td width="82">文件集合</td>
      <td width="208" align="left" valign="top">&nbsp;</td>
    </tr>
    <tr height="19">
      <td height="19" width="384">for /d %%var in    (directorySet) do comm</td>
      <td width="82">目录集合</td>
      <td width="208">不包括子目录</td>
    </tr>
    <tr height="38">
      <td height="38" width="384">for /r [[driver:]path] %var in (fileset) do comm</td>
      <td width="82">子目录中的文件</td>
      <td width="208">对以[path]指定为起点的的整个目录树进行处理;</td>
    </tr>
    <tr height="19">
      <td height="19" width="384">for /l %%var in (start,step,end) do comm</td>
      <td width="82">遍历一系列的值</td>
      <td width="208">命令重复执行n次；</td>
    </tr>
    <tr height="26">
      <td height="26" width="384">for /f [&quot;optins&quot;] %%var in (file-set) do comm</td>
      <td width="82">分析文本文件中的每一行</td>
      <td rowspan="3" width="208">以行为基础进行分析</td>
    </tr>
    <tr height="19">
      <td height="19" width="384">for /f [&quot;optins&quot;] %%var in (&quot;string&quot;) do comm</td>
      <td width="82">分析字符串</td>
    </tr>
    <tr height="19">
      <td height="19" width="384">for /f [&quot;optins&quot;] %%var in (command) do comm</td>
      <td width="82">分析命令输出</td>
    </tr>
  </table>
  <p>helps you interate through groups of files  and directories,and to parse text files,strings and command output on a  line-by-line basis.（1 对有空格的文件名的文件的处理要加&quot;&quot;;2 符号前一定要有空格；3 In (`command`)(esc键下的一个符号；);4 在批处理程序中使用 FOR 命令时，指定变量请使用 %%variable,而不要用 %variable。变量名称是区分大小写的，所以 %i 不同于 %I.5 interator变量名必须石a-b,A-B内,大小写敏感,是一个初始变量;)<br />
循环处理文件 for %a in (path.*.*) do command;<br />
循环处理目录 for /d %a in (directoryset) do command;<br />
循环处理某一目录下的全部子目录的某类文件 for /r path %a in (fileset) do command<br />
循环处理某一目录下全部目录及子目录 for /r path/d %a in (fileset) do command<br />
循环解析文本 for /f %a &quot;eol= skip= delims= tokens= usebackq&quot; in (txt  file set or `command` or &quot;text&quot;) do command;<br />
循环处理某一命令或命令组；for /l %a in (start,step,end) do command;</p>
  <h2>options</h2>
  <table cellspacing="0" cellpadding="0">
    <col width="70" />
    <col width="314" />
    <col width="98" />
    <col width="293" />
    <col width="65" />
    <tr height="19">
      <td height="19" width="70">选项</td>
      <td width="314">选项描述</td>
      <td width="98">实例</td>
      <td width="293">实例描述</td>
      <td width="65"></td>
    </tr>
    <tr height="38">
      <td height="38" width="70">eol</td>
      <td width="314">设置行尾注释字符，行尾注释字符后的所有数据都被命令看成是注释；</td>
      <td width="98">eol=#</td>
      <td width="293">将#设置为行尾注释字符；忽略以#开始的行；</td>
      <td width="65">end of line</td>
    </tr>
    <tr height="19">
      <td height="19" width="70">skip</td>
      <td width="314">设置文件起始处跳过的行数</td>
      <td width="98">skip=5</td>
      <td width="293">通过命令跳过源文件中的1-5行；</td>
      <td width="65"></td>
    </tr>
    <tr height="58">
      <td height="58" width="70">delims</td>
      <td width="314">设置名字段之间的分隔符，默认情况下为制表符或空格；(一行可以定义不同的符号将行分隔为不同的部分)</td>
      <td width="98">delims=,.:</td>
      <td width="293">指定逗号、句点、分号为分隔符</td>
      <td width="65">delimit</td>
    </tr>
    <tr height="54">
      <td rowspan="3" height="92" width="70">tokens</td>
      <td rowspan="3" width="314">为每一源行设置令牌字段，如果以a或A作为起始的迭代变量，则至多可以指定26个令牌。默认情况下，只对第一个令牌进行检查.(指定处理的字段)</td>
      <td width="98">tokens=1,3</td>
      <td width="293">%%A:wu %%B:wh</td>
      <td width="65"></td>
    </tr>
    <tr height="19">
      <td height="19" width="98">tokens=2-4</td>
      <td width="293">%%A:wanqun %%B:wh %%C:wwuhn@hotmail.com</td>
      <td width="65"></td>
    </tr>
    <tr height="19">
      <td height="19" width="98">tokens=*</td>
      <td width="293">把每一行当做整体处理，而不分割为字段</td>
      <td width="65"></td>
    </tr>
    <tr height="58">
      <td height="58" width="70">usebackq</td>
      <td width="314">规定可在源指定符中使用引号：对文件名使用双引号，对命令使用反引号（与~一起），对字符串使用单引号；</td>
      <td width="98">usebackq</td>
      <td width="293">激活该选项</td>
      <td width="65">quotation marks</td>
    </tr>
  </table>
  <p><strong>for</strong>命令是一种对一系列对象依次循环执行同一个或多个命令的在命令行或批处理中运行的命令，结合一些Windows管理中的程序后，其处理功能强大、应用灵活方便程度令人</p>
  <p>基本格式：for [/参数] %变量 in (集) do 命令(这里写的是在命令行里用的格式，如果是在批处理中,需要把其中%再多加个%形成%%)：</p>
  <p>for是批处理中唯一的循环流程控制命令，它主要有以下几项功能:</p>
  <p class="ph">1 无参数时： 循环处理文件（某一路径下的文件集，或当前目录下的文件集，多个文件集可用空格分隔）；</p>
  <p class="ph">2 /d 循环处理目录；</p>
  <p class="ph">3 /r 循环处理目录内的文件及子目录；</p>
  <p class="ph">4 /l 循环指定的次数；</p>
  <p class="ph">5 /f 读取文本，以文本作为参数，批次执行循环体语句；</p>
  
  
  
  <p>
    <strong>变量：(</strong>记住如果是在批处理中使用for命令时，变量前的%需改为%%)这个变量名是由单个字母组成且区分大小写（原帮助是这么说的，实际运用中用单个数字作为变量名试过证明也可行），如%B和%b代表的是不同的变量。FOR命令会在每次循环中，把in (集)中读取到的值赋于这个变量，以便其后的命令中引用。</p><p>
    <strong>集：</strong>由系列文件、字符串或由命令产生的内容形成的集合（当然可用通配符   *   ？，还可引用环境变量），FOR命令是按一定顺序和规律分次读取集中内容，赋值给变量，并执行do后的命令，进行循环下一轮，直至集中内容读取完毕，而括号是格式必须的(括号前面需要要有空格)。</p><p>
    <strong>命令：</strong>可以是任何合格的DOS命令或外部可被DOS调用的程序，且可采用括号把多条命令括起来，在一次循环中执行。</p><p>
    <strong>附注：</strong>由于一些目录或文件名可能会有空格，所以很多时候集里和命令里往往需要用英文引号括起来(但有时引号里的内容可能会被认为是字符串)表示是一整体，下面开始的有些例中为简捷起见，忽略文件名或目录名带空格这种情况。</p><p>
	
    现在按参数分类举例解释其用法：</p>
	
    <strong class="color1">一、参数 /d,循环处理目录</strong></p><p>
      for /d %%变量 in (集) do 命令</p><p>
    </strong>/d   参数是指定仅对目录而不是文件执行的for命令。</p><p>
    <strong>例1:</p><p class="ph">
    </strong>在命令行输入（不是在批处理，之后不再解释）</p><p class="ph">
    for   /d %a in (c:\*.*) do echo   %a</p><p class="ph">
    运行会把C盘根目录下的全部目录分次显示出来,而不显示文件名</p><p class="ph">
    看起来有点乱，如果把命令提示回显关闭就清晰了:</p><p class="ph">
    <strong>for /d   %a in (c:\*.*) do @echo %a</strong></p>
	
	
<strong class="color1">二、参数 /R，循环处理目录内的文件及子目录</strong>

<p>
    </strong>/R参数之后还可带盘符及路径</p><p>
    <strong>for /r <U>此处可以带有路径</U>&nbsp;</strong><strong>%变量 in (集) do 命令</strong></p>
	<p>注意参数的两个限定：<br />
	<ol><li>目录限定操作的范围；</li><li>集限定操作的文件或文件类（使用通配符）；</li></ol></p>
	
	
	<p>
    在/r   之后的那个路径，指包含它之下的整个目录树（相当于DOS命令tree里的范围）中的所有目录，如果仅为一个英文句点 .   ，是指当前路径下的目录树，如果省略了路径则特指当前目录，而之后的in   (集)则相当于与前面每个目录相配的文件集</p><p>
    这里按in(集)中有无通配符分两种情况</p><p>
    <strong>1)</strong><strong>in(集)中没有通配符</p><p>
      </strong>指定的是单个文件或列举的具体文件(多个文件名之间用分隔符分隔，如空格、逗号等)</p><p>
    <strong>例2<br />
    </strong>@echo   of<br />
    for /r . %i in (abc.txt) do echo. &gt; %i<br />
    echo on<br />
    注：这里for /r   后的路径仅有一个<strong> .</strong> 而后面每个循环中echo<strong>. </strong>&gt;   %i相当于创建一个仅有一空行的文本文件，整体效果是在当前目录下包括子录，每个目录中建一个abc.txt。</p><p>
    <strong>例3</strong> （放入批处理中）<br />
    @echo off<br />
    rem 显示d:盘中所有文件名为file1和file2的列表 <br />
    for /r d:\ %%h in   (file1,file2) do if exist %%h echo %%h<br />
    pause</p><p>
    <strong>2)   in(集)中含有通配符*或？</p><p>
    </strong>这种里面的do命令将处理前面   /r指定的目录系列里每个含有in(集)中文件的项，而不去理会不含有相配文件的那些目录</p><p>
    <strong>例4：<br />
    </strong>@echo   off<br />
    rem 删除C盘中所有*.chk的文件<br />
    for /r c:\ %%h in (*.chk) do del /q   %%h<br />
    pause<br />
    注：del /q 表示用安静模式删除（不需确认）</p>
	

    <strong class="color1">三、参数 /L，循环指定的次数</strong>
	<p>
      for /L %%变量 in   (起始值，每次增值，结束时的比较值) do   命令</p><p>
    </strong>（上面L也可用小写，主要为了视觉上不与数字1混淆而没用小写）</p><p>
    (起始值，每次增值，结束时的比较值)相当于一个等差数字序列，从“起始值”的数字开始，每次增加多少（也可设定为负数）为“每次增值”，并与“结束时的比较值”比较，超出则退出for循环（也不执行本轮后面的do   命令）</p><p>
    例如 (1,1,3) 将产生序列 （1 2 3）；（1,2,9）将产生序列（1 3 5 7 9）；(5,-1,1) 将产生序列 (5 4 3 2   1)；（1,3,18）将产生序列（1 7 10 13 16）</p><p>
    <strong>例5 <br />
    </strong>@echo   off<br />
    ::在D盘建立aa1~ aa5五个文件夹<br />
    for /L %%i in (1,1,5) do md d:\aa   %%i<br />
    pause</p>
  <p>注：在行首，单个冒号<strong>:</strong>接一名称，是标号行，对应于批处理中go后指向的位置，而双冒号::一般是用来作注释用，注释在批处理中可以用rem加空格来表达，二者稍有不同，rem注释在未关闭命令回显时会在屏幕显示出来，而<strong>::</strong>则什么情况下都不会显示。</p>
  
  
  
  
  
  
<strong class="color1">四、参数   /f，解析文本并处理输出结果</strong>

<p>
    </strong>这个参数/f将会打开（集）里的文件，使for命令能处理文本文件的读取和添加删除替换等编辑性的操作，可谓功能强大，因此也相对复杂一些。</p>
	
<table style="border-collapse:collapse; border:0px;">
<tr>

<td></td><td>文件名-集 </td><td></td></tr><tr>
<td>for /f “选项” %变量 in (</td><td>“字符串”-集</td><td>) do 命令</td></tr><tr>
<td></td><td>‘命令’-集</td><td></td></tr>

</tr>
</table>

	  
	  
	  <p>/f   后可以带有几种选项，不带选项当然也是合格的格式，而带有参数则必须以引号整体括起来，后面的集里主要由三种形式形成的，最终在for循环中的每一轮中会形成读取一行字符串，来给指定的%变量、以及给由于选项中派生出附加变量赋值后，执行do后面的命令</p>
	
	
	<strong class="color1">
    下面以例子来具体说明和逐步理解各分项的用法</strong>
	<p>
    <strong>例6</p><p>
    </strong>假定d:\abc.txt内容如下：<br />
    姓名   性别 年龄 等-级 <br />
    张三 男 36   A-1 <br />
    李四 男 29   B-2 <br />
	赵六 女 31   A-2</p><p>
	
	执行如下命令：<br />
    for /f %c in (d:\abc.txt) do @echo   %c</p><p>
    则屏幕上显示：<br />
    姓名<br />
    张三<br />
    李四<br />
    赵六</p>
  <p>解释：这是for /r   在“%变量”前缺省参数选项时的情况，循环中每轮会默认以空格为分隔，在打开的文件中逐行给字符串分段，又因为没给增添附加变量（即仅一个变量%c）则仅把第一段的字符赋给%c，再执行   do后的命令，然后进行循环的下一轮，并且默认忽略空行</p><p>
    改一下：</p><p>
    for /f “skip=1 tokens=1,4 delims= ” %c in   (d:\abc.txt) do @echo %c %d</p><p>
    显示为：<br />
    张三 A-1<br />
    李四 B-2<br />
    赵六 A-2</p>
  <p>解：</p><p>
    skip：跳过前面指定的行数。</p>
<p>eol:忽略以指定字符开始的行。</p>
<p>delims:用于将行内容分割为几个部分，默认以空格、Tab为分割点，也可以在等号后指定其它分割点，如果想忽略掉默认的空格："delims="（＝后没有空格）；</p>
<p>tokens:指定取用的列序号，与变量进行对应，如果取了三列，则对应三个变量，每个变量的取值个数＝文本总行数－skip-eol;</p>
<p>usebackq:用一读取包含空格的文件名；


  <p>delims=   在一行中，用什么单个符号（可以有多字符组合，之间也不能加空格，被理解为多项单个字符，如要空格符须放最后）来分隔字符串作为读取赋值的单元(形成一段)，本例中等号后是空的表示仅用空格来分隔。——<strong>用什么刀来切分</strong></p>
	<p>tokens=1,4   这个等号后的数字表示依次取第几个被分隔的字符串段，来分别赋给%变量及顺序附加的变量，本例取第1个段赋给%c，第4个段赋给c后的一个变量也就是赋给%d，并且，可以写成tokens=1,2,5-7   或tokens=1,2,3<strong>* </strong>或tokens=1,2,5,7 分别表示取第1,2,5,6,7（依次赋给%c, %d, %e,   %,f,   %g共5个变量）、1,2,3及3后的所有段（要赋给3个变量）、1,2,5,7(要赋给4个变量)，tokens=后的数字号可以不按顺序，但书写的顺序与分配给变量的顺序是对应的，这是赋值，至于之后do命令中用不用是另一回事。换句话   ­­——<strong>最多只需取哪几段</strong></p>
	
	<p>in (变量)   中的那个变量，代表起始的一个变量名，按tokens中定义的总个数来扩充附加变量名，如总个数为3，则%c 就附加%d和%e ，要是%C就附加%D%E…   本例中tokens=1,4仅需两个，起始的是in () 括号中的%c 则每行中第一段赋给%c,第4段赋给变量%d </p><p>
    以第二行（第一行被skip=1跳过了）为例，在 “张三 男 36 A-1 ”   中（正好也是用的空格分隔）共被空格之刀切为五段，只要第1、4，即张三赋给%c, A-1赋给%d，执行@echo %c   %d然后下一轮…而空行照旧被省去了。</p>
  <p>再稍改一下：</p>
  <p>for /f “skip=1 tokens=4,1 delims=- “ %c in (d:\abc.txt) do @echo %c %d</p>
  <p>则显示为：<br>
    A 张三 <br>
    B 李四<br>
    A 赵六<br />

  <p><strong>例7</p><p>
  </strong>假定d:\aa.txt内容如下：<br />

Volume in drive D is MYDA<br>
    Volume Serial Number is C35D-8998<br />
Directory of D:tmp<br />
09/25/2001 10:40 AM 11,235 yg0925.txt<br>
    11/12/2001 04:29 pM 795   buple.txt<br>
    04/11/2002 04:18 AM 2,043 vitn.txt<br>
    3File(s) 12,673 bytes<br>
    0 Dir(s) 5,020,200,655 bytes free<br />

  <p>在命令行输入：<br>
    for /f &quot;skip=5 tokens=5&quot; %a in (d:\aa.txt) do @echo   %a</p><p>
    会显示：<br>
    yg0925.txt<br>
    buple.txt<br>
    vitn.txt<br>
    free<br>
          
    本意想把文件里列出的文件显示出来（当然也可以换成对文件进行其他命令操作）</p><p>
    通过skip=5   忽略掉前5行，默认以空格分隔后tokens=5取每行第五段字符就顺利地把文件名赋给变量%a,美中不足最后一行取了个不是文件名的（当然可用其他方法处理这个多余的只是for/f中没提供忽略最后几行的格式），而倒数第二行则无第五段。</p><p>
    显然例中aa.txt里的内容是某次执行dir命令后的内容。它可用类似命令：</p><p>
    dir   &gt; d:\aa.txt来建立</p><p>
         
    题外话<strong>，</strong>如果在dir中加入合适的参数/b，就可以回避多余的部分,还可加入/ad只显示目录，加入/a-d只显示文件等</p><p>
    那么，我们完全可以直接书写命令放入in后的（‘命令’-集）中</p><p>
    for   /f &quot;skip=5 tokens=5 &quot; %a in ('dir') do @echo %a</p>
  <p>效果一样。</p><p>
    注：命令集需用单引号括起来以表示不是文件集，如用双引号括起来则表示是字符串集，本例是为了说明for命令的用法，真正有这种用途也愿意用前面“题外话”的方法。如果你在执行本例后什么也没显示，你需要先用集里的命令先执行一次，看它显示的格式，也许需要把tokens=5   改成tokens=4 或许还应当给dir加上参数   /a-d以回避显示出目录。</p><p>
    如果集里是由多个文件组成，那么处理完一个文件后又处理完又去处理另一个文件，每个文件行数不同循环次数（do命令的次数）也将因此不同。</p><p>
    如果集里是由命令产生的系统，那么你必须首先熟悉该命令执行后会产生怎样效果的字符系统，才能正确安排后面的do命令</p>
  <p><strong>画龙点睛：</strong>无论in后的集是哪种形式，for/f   都最终<strong>分解</strong>为<strong>字符串</strong>，按需要是否“<strong>忽略几行</strong>”（skip=）、“<strong>用什么刀来切分</strong>”（delims=   ）、“<strong>最多只需取哪几段</strong>”（tokens=）将集里形成的字符串,<strong>逐行</strong>地<strong>分段赋给</strong>%或%%后的变量及可能顺延扩展出的<strong>变量</strong>，以<strong>执行</strong>do后的<strong>命令</strong>，每<strong>一行</strong>即为<strong>一</strong>轮<strong>循环</strong>。这里没完整说明全部参数，请在命令行用for/?查看。(下面的斜体字是复制的帮助里的内容)</p><p>
    例如：</p><p>
    <em>对于带有空格的文件名，您需要用双引号将文件名括起来。为了用这种方式来使用双引号，您还需要使用   usebackq   选项，否则，双引号会被理解成是用作定义某个要分析的字符串的。——</em><strong>换句话说,带有usebackq</strong>（放在for /f   之后的引号里）<strong>参数时 in ()里用双引号表示的仍是文件名。</p><p>
      还有一个选项eol=   ：</strong>前面所说skip=是表示忽略开始的几行，其实默认状况还忽略所有分号“ <strong>; </strong>”开始的行，如果你想不忽略分号开始的行，或者想忽略自己指定一字符开始的行就可以在for /f   之后那引号参数里使用eol=你自己定义的字符，但它不像delims=的那样可定义多个，只允许定义一个。</p>
  <p><strong></strong>另一花样：可以用 %~ 操作符将文件名分离成文件名、扩展名、盘符等独立部分   ，请看for/?中的解释（其中示例的变量为%I）：</p><p>
      <p>另外，FOR 变量参照的替换已被增强。您现在可以使用下列选项语法: </p>
%~I - 删除任何引号(&quot;)，扩充 %I <br>
    %~fI - 将 %I 扩充到一个完全合格的路径名 <br>
    %~dI - 仅将 %I   扩充到一个驱动器号 <br>
    %~pI - 仅将 %I 扩充到一个路径 <br>
    %~nI - 仅将 %I 扩充到一个文件名 <br>
    %~xI - 仅将 %I   扩充到一个文件扩展名 <br>
    %~sI - 扩充的路径只含有短名 <br>
    %~aI - 将 %I 扩充到文件的文件属性 <br>
    %~tI - 将 %I   扩充到文件的日期/时间 <br>
    %~zI - 将 %I 扩充到文件的大小 <br>
    %~$PATH:I - 查找列在路径环境变量的目录，并将 %I 扩充 <br>
    到找到的第一个完全合格的名称。如果环境变量名 </p><p>
    未被定义，或者没有找到文件，此组合键会扩充到空字符串 </em></p>
  <p>可以组合修饰符来得到多重结果: </p>
%~dpI - 仅将 %I 扩充到一个驱动器号和路径 <br>
    %~nxI - 仅将 %I 扩充到一个文件名和扩展名 <br>
    %~fsI - 仅将   %I 扩充到一个带有短名的完整路径名 <br>
    %~dp$PATH:I - 查找列在路径环境变量的目录，并将 %I 扩充 <br>
    到找到的第一个驱动器号和路径。 <br>
    %~ftzaI - 将 %I 扩充到类似输出线路的 DIR<br />

  <p>简记：凡是 %~ 打头的操作符，都是文件名或环境变量的分离操作。而每项要想运用自如，则需要付出辛勤的练习。</p>
  <p><strong>练习：</strong></p><p>
    遍历C、D盘，查找已知文件名(接收键盘输入)，把其存放位置、时间，记录到D:\mynote.txt   记录格式如：</p>
  <p>xx年xx月xx日 经查找在C盘、D盘的xx文件情况如下：<br>
       
    时间         位置<br>
    。。。。。   。。。。。。<br>
    。。。。。 。。。。。。<br>
    。。。。。 。。。。。。<br>
    。<br>
    。<br>
    。<br />

  <p>提示：可能用到的DOS命令、变量、参数： echo、set 、set/p 、%date%、%~    &gt;、&gt;&gt;  </p>
  <p>总结及提示： </p><p>
    for   命令的实际用法基本上已终结，但是仅此是不能写出强大功能的批处理的，它只是一条DOS命令，需要熟练一些其他的DOS命令和Windows系统提供的命令，组合运用，才能充分发挥其强大、实用的功能，使得一些复杂事情，处理起来意想不到的简洁方便。</p>
  <p>附：常见在批处理for命令中需要的一个的命令或者叫环境设置<strong>:</p><p>
    </strong>for命令实际上是会作循环，如果在每轮的命令中改变某环境变量值，在默认状态，一条for命令用%环境变量%只取一次值的,那么下轮循环中再用时还是改变前的值（包括do后面带有括号里的多条命令的执行期间），就没达到预期目的，为此，引入下面命令：</p><p>
    <strong>setlocal   enabledelayedexpansion</strong></p><p>
    开始批处理文件中环境改动的本地化操作,并启动延缓环境变量扩展。在执行SETLOCAL   达到批处理文件结尾时，对于该批处理文件的每个尚未执行的 setlocal 命令，都会有一个隐含的 endlocal   被执行。</p><p>
    在取变量值时，用!变量名!可以动态取值，延迟环境变量扩充允许您使用一个不同的字符(惊叹号)在执行时间扩充环境变量。这个用法实际是属于在批处理中所有复合型命令都需要注意的。如果批处理结束后不希望将改变的环境保留，建议总是加上<strong>setlocal </strong>。</p><p>
    要是结合一些其他复杂些的有关系统的、网络的命令（如wmic、net）进来，那才是方显FOR英雄本色，比如<strong>遍历本地磁盘</strong>可以用命令：<strong>wmic   logicaldisk where &quot;drivetype=3&quot; get name</strong> 显然要在所有磁盘里查找某文件并作相应操作就很容易了，用好for命令也是需要其他命令和计算机基础配合的。呵呵，本人水平有限，写的只是低级层次的...但愿能对有缘来这里看的初学DOS的FOR命令者有所帮助。</p>
    <p>&nbsp;</p>
    <p>&nbsp;</p>
    <p .="p0">在For命令语句的参数F中，最难理解的就是Delims和Tokens两个选项，本文简单的做一个比较和总结。</p>
    <p .="p0">“For /f”常用来解析文本，读取字符串。分工上，delims负责切分字符串，而tokens负责提取字符串。如果把字符串当作蛋糕，Delims像刀子，用来切蛋糕，tokens像叉子，用来取切好的蛋糕。下面我们用实例来进行理解。</p>
    <p .="p0">把以下内容保存为文本文件“歌曲列表.txt”，注意扩展名为“.txt”：</p>
    <p class="ph">序号、歌手名-歌曲名.后缀名</p>
    <p class="ph">1、饶天亮-玫瑰爱人.wma </p>
    <p class="ph">2、高一首-我不愿错过.mp3</p>
    <p class="ph">3、黃凱芹-傷感的戀人.MP3</p>
    <p class="ph">4、黄灿-黄玫瑰.lrc</p>
    <p class="ph">5、黎姿-如此这般的爱情故事.mp3</p>
    <p>代码1：显示全部内容</p>
    <p class="ph">@echo off</p>
    <p class="ph">for /f %%i in (歌曲列表.txt) do echo %%i</p>
    <p class="ph">pause&gt;nul</p>
    <p>运行结果：</p>
    <p class="ph">序号、歌手名-歌曲名.后缀名</p>
    <p class="ph">1、饶天亮-玫瑰爱人.wma</p>
    <p class="ph">2、高一首-我不愿错过.mp3</p>
    <p class="ph">3、黃凱芹-傷感的戀人.MP3</p>
    <p class="ph">4、黄灿-黄玫瑰.lrc</p>
    <p class="ph">5、黎姿-如此这般的爱情故事.mp3</p>
    <p .="p0">讲解：</p>
    <p .="p0"><span .="font-size: 10.5pt;">如果不使用参数“/f”，运行结果只显示括号里的文字字符“歌曲列表.txt”，而不能读取文本文件“歌曲列表.txt”中的内容。可见，“/f”是解析文本字符串的好工具。</p>
 
    <p .="p0"><span .="font-weight: bold; font-size: 14pt; mso-spacerun: yes">一、delims</p>
    <p .="p0">假如只要序号，不要歌手名、歌曲名和后缀名，如何办到？</p>
    <p .="p0">代码2：默认提取第一列</p>
    <p class="ph">@echo off</p>
    <p class="ph">for /f    &quot;delims=、&quot;   %%i in (歌曲列表.txt) do echo %%i</p>
    <p class="ph">pause&gt;nul</p>
    <p .="p0">运行结果：</p>
    <p class="ph">序号</p>
    <p class="ph">1</p>
    <p class="ph">2</p>
    <p class="ph">3</p>
    <p class="ph">4</p>
    <p class="ph">5</p>
    <p .="p0">讲解：</p>
    <p .="p0">&quot;delims=、&quot;表示定义顿号“、”为分隔符，并用该分隔符“、”切分文本字符串。字符串就是“歌曲列表.txt”里的内容，也就是文件里的文字和标点符号。</p>
    <p .="p0">该顿号是原文中就有的。除了顿号“、”，原文中还有减号“-”和点号“.”，因此你也可以用它们来做分隔符。</p>
    <p .="p0">代码3：用减号“-”做分隔符</p>
    <p class="ph">@echo off</p>
    <p class="ph">for /f  &quot;delims=-&quot;     %%i in (歌曲列表.txt) do echo %%i</p>
    <p class="ph">pause&gt;nul</p>
    <p .="p0">运行结果：</p>
    <p class="ph">序号、歌手名</p>
    <p class="ph">1、饶天亮</p>
    <p class="ph">2、高一首</p>
    <p class="ph">3、黃凱芹</p>
    <p class="ph">4、黄灿</p>
    <p class="ph">5、黎姿</p>
    <p .="p0">讲解：</p>
    <p .="p0">因为，当减号“-”被用做分隔符时，每行内容被减号“-”分隔成前后两半，默认只显示前半部分，而后半部分连同分隔符减号“-”都被忽略（省略）了。</p>
    <p .="p0">代码4：用点号“.”做分隔符</p>
    <p class="ph">@echo off</p>
    <p class="ph">for /f    &quot;delims=.&quot;     %%i in (歌曲列表.txt) do echo %%i</p>
    <p class="ph">pause&gt;nul</p>
    <p .="p0">运行结果：</p>
    <p class="ph">序号、歌手名-歌曲名</p>
    <p class="ph">1、饶天亮-玫瑰爱人</p>
    <p class="ph">2、高一首-我不愿错过</p>
    <p class="ph">3、黃凱芹-傷感的戀人</p>
    <p class="ph">4、黄灿-黄玫瑰</p>
    <p class="ph">5、黎姿-如此这般的爱情故事</p>
    <p .="p0">讲解：</p>
    <p .="p0">默认情况下，单纯使用delims而不用tokens时，只显示第一个分隔符前的内容，第一个分隔符和第一个分隔符后面的内容将被忽略。</p>
    <p .="p0">代码5：定义多个分隔符</p>
    <p class="ph">@echo off</p>
    <p class="ph">for /f    &quot;delims=、-.&quot;   %%i in (歌曲列表.txt) do echo %%i</p>
    <p class="ph">pause&gt;nul</p>
    <p .="p0">运行结果：</p>
    <p class="ph">序号</p>
    <p class="ph">1</p>
    <p class="ph">2</p>
    <p class="ph">3</p>
    <p class="ph">4</p>
    <p class="ph">5</p>
    <p .="p0">讲解：</p>
    <p .="p0">原因是，当定义顿号“、”、减号“-”和点号“.”三个标点符号为分隔符后，原文被分隔成四个部分。</p>
    <p .="p0">如第二行“1、饶天亮-玫瑰爱人.wma”将被分隔成“1”、“饶天亮”、“玫瑰爱人”和“wma” 四个部分。</p>
    <p .="p0">从第一行到最后一行，每行的每个部分对应下来相当于一个竖列。因此，原文就有“序号”、“歌手名”、“歌曲名”、“后缀名”四列。</p>
    <p .="p0"><span .="font-size: 10.5pt;">一般情况下，只读取第一列的内容。后面的内容需要用tokens选项提取。</p>
    <p .="p0"></p><p>
        <span .="font-size: 10.5pt;"></p>
    <p .="p0"><span .="font-weight: bold; font-size: 14pt; mso-spacerun: yes">二、tokens</p>
    <p .="p0">假如只要歌手名和歌曲名，不要序号和后缀名，如何办到？</p>
    <p .="p0">代码6：提取单列</p>
    <p class="ph">@echo off</p>
    <p class="ph">for /f    &quot;tokens=2   delims=、.&quot;   %%i in (歌曲列表.txt) do echo %%i</p>
    <p class="ph">pause&gt;nul</p>
    <p .="p0">运行结果将显示：</p>
    <p class="ph">歌手名-歌曲名</p>
    <p class="ph">饶天亮-玫瑰爱人</p>
    <p class="ph">高一首-我不愿错过</p>
    <p class="ph">黃凱芹-傷感的戀人</p>
    <p class="ph">黄灿-黄玫瑰</p>
    <p class="ph">黎姿-如此这般的爱情故事</p>
    <p .="p0">讲解：</p>
    <p .="p0">用delims定义顿号“、”和点号“.”作为分隔符，将原文分成三部分。</p>
    <p .="p0">如第六行“5、黎姿-如此这般的爱情故事.mp3”被分割成：</p>
    <p class="ph">第一部分（第一列）：5</p>
    <p class="ph">第二部分（第二列）：黎姿-如此这般的爱情故事</p>
    <p class="ph">第三部分（第三列）：mp3</p>
    <p .="p0">“tokens=2”表示用tokens提取第二列的字符串，即“黎姿-如此这般的爱情故事”。</p>
    <p .="p0">没有被tokens定义提取的第一列和第三列将被忽略。</p>
    <p .="p0">假如只要序号和歌曲名，而不要歌手名和后缀名，如何办到？</p>
    <p .="p0">代码7：提取多列</p>
    <p class="ph">@echo off</p>
    <p class="ph">for /f    &quot;tokens=1,3   delims=、-.&quot;   %%i in (歌曲列表.txt) do echo %%i     %%j</p>
    <p class="ph">pause&gt;nul</p>
    <p .="p0">运行结果将显示：</p>
    <p class="ph">序号     歌曲名</p>
    <p class="ph">1  玫瑰爱人</p>
    <p class="ph">2  我不愿错过</p>
    <p class="ph">3  傷感的戀人</p>
    <p class="ph">4  黄玫瑰</p>
    <p class="ph">5  如此这般的爱情故事</p>
    <p .="p0">讲解：</p>
    <p .="p0">“delims=、-.”表示定义顿号、减号和点号为分隔符。</p>
    <p .="p0">“tokens=1,3”表示只提取第一列和第三列。</p>
    <p .="p0">“%%i %%j”对应于“token”后面的列数。有多少列就要有多少个输出变量，并且各变量中的字母存在先后顺序。</p>
    <p .="p0">如何只提取文字，不要标点符号？</p>
    <p .="p0">代码8：忽略分隔符</p>
    <p class="ph">@echo off</p>
    <p class="ph">for /f    &quot;tokens=1,2-4   delims=、-.&quot;   %%i in (歌曲列表.txt) do echo %%i   %%j %%k   %%l</p>
    <p class="ph">pause&gt;nul</p>
    <p .="p0">运行结果：</p>
    <p class="ph">序号   歌手名   歌曲名 后缀名</p>
    <p class="ph">1  饶天亮   玫瑰爱人 wma</p>
    <p class="ph">2  高一首   我不愿错过 mp3</p>
    <p class="ph">3  黃凱芹   傷感的戀人 MP3</p>
    <p class="ph">4  黄灿 黄玫瑰   lrc</p>
    <p class="ph">5  黎姿   如此这般的爱情故事 mp3</p>
    <p .="p0">讲解：</p>
    <p .="p0">默认情况下，用做分隔符的标点符号将被忽略。</p>
    <p .="p0"><span .="font-size: 10.5pt;">“tokens=1,2-4”中的“2-4”表示第二至第四列。</p>
    <p .="p0"></p><p>
        <span .="font-size: 10.5pt;"></p>
    <p .="p0"></p><p>
    </p>
    <p .="p0"><span .="font-weight: bold; font-size: 14pt; mso-spacerun: yes">三、小结</p>
    <p .="p0">“For /f”</p>
    <p .="p0">一句话总结：解析文本，读取字符串。</p>
    <p .="p0"><span .="font-weight: bold; font-size: 10.5pt; mso-spacerun: yes">Delims的语法：</p>
    <p .="p0">FOR /F   &quot;Delims=符号集&quot;  %%I         IN (Command1)    DO Command2</p>
    <p .="p0">一句话总结：忽略分隔符，切分字符串。</p>
    <p .="p0">delims的意义包括两个方面：</p>
    <p .="p0"><span .="font-weight: bold; font-size: 10.5pt; mso-spacerun: yes">第一、指定原文中的标点符号作为分隔符。使得文本被划分为许多小部分，方便使用批处理命令读取和编辑。</p>
    <p .="p0"><span .="font-weight: bold; font-size: 10.5pt; mso-spacerun: yes">第二、读取第一个分隔符之前的内容。忽略第一个分隔符和分隔符后面的内容，如需读取和编辑，需要使用tokens等命令。</p>
    <p .="p0">注意分隔符和标点符号的联系和区别。</p>
    <p .="p0">分隔符就是原文中的标点符号，可以是一个标点符号也可以是多个。但原文中的标点符号不一定是分隔符。并且分隔符不一定是标点符号，字母和中文也是可以用作分隔符的。</p>
    <p .="p0">分隔符需要定义，即用”delims=”来指定，等于号后面跟被用来做分隔符的标点符号，该标点符号来自原文。</p>
    <p .="p0">当有多个标点符号被定义为分隔符时，标点符号之间没有空格。当用空格做分隔符时，空格应该放在其它用作分隔符的标点符号之后。</p>
    <p .="p0">即使不使用delims，默认情况下，批处理也将空格作为分隔符。如文件名“Program   Files”中含有空格时，批处理一般只读取空格前的“Program”，剩下的“Files”被忽略了。</p>
    <p .="p0">例：</p>
    <p .="p0">代码9：空格默认作为分隔符</p>
    <p class="ph">@echo off</p>
    <p class="ph">for /f &quot;delims=&quot; %%a in   (&quot;伟大的中国人民万岁 万岁 万万岁&quot;) do echo %%a</p>
    <p class="ph">pause&gt;nul</p>
    <p .="p0">运行结果：</p>
    <p .="p0">伟大的中国人民万岁   万岁 万万岁</p>
    <p .="p0">讲解：</p>
    <p .="p0">“delims=”等号后面没有空格，代表取消默认以空格作为分隔符，相当于“tokens=*”，提取全部字符；等号后面有空格时表示定义空格为分隔符，此时delims可以省略。</p>
    <p .="p0">批处理默认空格是分隔符，分隔符会隐藏第一个分隔符后面的所有内容。为了显示完整的信息，所以有必要取消该功能。</p>
    <p .="p0">因此，当文件名或路径中含有空格时，需要用双引号括住。如果不使用双引号，括号内的内容将被当做文件名，如果文件名不存在，将提示“系统找不到……”。</p>
    <p .="p0">如果不使用“delims=”，即使使用双引号，也只能显示第一个空格前面的字符串，后面的字符串将被默认忽略。</p>
    <p .="p0"><span .="font-weight: bold; font-size: 10.5pt; mso-spacerun: yes">T<span .="font-weight: bold; font-size: 10.5pt; mso-spacerun: yes">okens的语法：</p>
    <p .="p0">FOR /F   &quot;tokens=x,y,m-n&quot;  %%I         IN (Command1)    DO Command2</p>
    <p .="p0">一句话总结：提取列。</p>
    <p .="p0"><span .="font-weight: bold; font-size: 10.5pt; mso-spacerun: yes">T<span .="font-weight: bold; font-size: 10.5pt; mso-spacerun: yes">okens的意义就是，提取指定的列。</p>
    <p .="p0">注意列与句的联系与区别。</p>
    <p .="p0">文本内容由许多文字字符串组成，它们被标点符号分隔，两个标点符号之间的语句我们称为“句子”。</p>
    <p .="p0">当标点符号被“tokens=”指定为分隔符之后，文字将被分成多个部分。对应的每行的每个部分我们称之为“列”。</p>
    <p .="p0">一列可能是一个句子，也可能包含多个句子，视delims定义的标点符号而定。</p>
    <p>其它方面：关于“行”的提取，前面做过一个很简单的：
      </p>
      <br />
@echo off<br>
        
del _test.txt<br>
          
set /p p=请输入要文本路径：<br>
    
findstr /n .* %p%&gt;&gt;_test.txt<br>
        
set /p   m=请输入要定位的行：<br>
        
echo.<br>
    
for /f &quot;tokens=1,* delims=:&quot; %%a in ('findstr   /b   &quot;%m%&quot;   _test.txt') do if %%a==%m% echo %%b<br>
          
echo.<br>
pause</p>
    <p>列出C盘中所有的文本文件 <br />
for /r c:\ %%B in (*.txt) do echo %%B</p>
    <p>列出%systemroot%下的所有目录及子目录 <br />
      for /r %systemroot% /d %%B in(*) do echo  %%B</p>
    <p>列出C盘下的所有exe文件，仅列出文件名； <br />
      for /r c:\ %a in (*.exe) do @echo %~na</p>
    <p>列出C盘下的所有exe文件，仅列出文件名+扩展名； <br />
      for /r c:\ %a in (*.exe) do @echo %~nxa</p>
    <p>&nbsp;</p>
    <p>对一组文件中的每一个文件执行某个特定命令。 <br />
FOR %variable IN (set) DO command  [command-parameters]<br />
FOR %variable IN (fileSet) DO command  [command-parameters]<br />
   %variable  指定一个单一字母可替换的参数(只能是字线，%%variable用在批处理）。 <br />
   (set)      指定一个或一组文件,路径+文件名。可以使用通配符，可以作空格分隔。 <br />
   command    指定对每个文件执行的命令（在命令中引用%variable做参数）。 <br />
   command-parameters 为特定命令指定参数或命令行开关。 </p>
    <p>如果启用命令扩展，则会支持下列 FOR 命令的其他格式:<br />
      /D和/R是与目录或文件有关的命令;<br />
      /D是对指定集中的目录进行处理； <br />
      FOR /D %variable IN (directorySet) DO  command [command-parameters]<br />
      如果集中包含通配符，则指定与目录名匹配，而不与文件名匹配。 <br />
      /R有时用于通过遍历文件夹查找一个文件或文件夹,速度比tree d:慢,但更实用;<br />
      /R是以指定的目录为基准，对其下的所有子目录、指定的集的限制进行处理； <br />
      FOR /R [[drive:]path] %variable IN  (subdirectorySet) DO command [command-parameters]<br />
      检查以  [drive:]path 为根的目录树，指向每个目录中的 FOR 语句。 <br />
      如果在 /R 后没有指定目录规范，则使用当前目录。如果集仅为一个单点(.)字符,则枚举该目录树。 </p>
    <p>/L可以按指定的(end-start)/step+1次数进行循环，同时变量生成：start,start+1*step+start+2*step…end)这样一个数组； <br />
      FOR /L %variable IN (start,step,end) DO  command [command-parameters]<br />
      该集表示以增量形式从开始到结束的一个数字序列。因此，(1,1,5)将产生序列 1 2 3 4 5，(5,-1,1)将产生序列(5 4 3 2 1)</p>
    <p>/F parsing file content and command output  or text;<br />
      for /f &quot;tokens=*&quot; %%a in ('dir')  do ( command[command-parameters])<br />
      for循环语句用于分析&quot;dir&quot;命令所显示的字符串，&quot;/f&quot;参数表示for语句以解析方式工作。For语句首先执行括号中&quot;dir&quot;命令，然后进入for语句块执行相应的命令。&quot;tokens&quot;参数只有一个&quot;*&quot;,表示&quot;%%a&quot;将依次代表&quot;dir&quot;命令输出的每一行。For语句循环次数等于&quot;dir&quot;命令显示结果的行数。 <br />
      FOR /F [&quot;options&quot;] %variable IN  (file-set) DO command [command-parameters]<br />
      FOR /F [&quot;options&quot;] %variable IN  (&quot;string&quot;) DO command [command-parameters]<br />
      FOR /F [&quot;options&quot;] %variable IN  ('command') DO command [command-parameters](注意符号是`,esc 下的符号） <br />
      fileset 为一个或多个文件名(以空格分隔）。继续到 fileset 中的下一个文件之前，每份文件都被打开、读取并经过处理。处理包括读取文件，将其分成一行行的文字，忽略空行，然后将每行解析成零或更多的符号。然后用已找到的符号字符串变量值调用 For 循环.</p>
    <p>循环命令，只要条件符合，它将多次执行同一命令或命令组。 <br />
      for [%%f] in (集合）do (命令） <br />
      集合set，指定要用指定命令处理的一个或多个文件，目录，数值范围或文本字符串所执行的命令； </p>
    <p>for /l %%i in (1,2,10) do md %%i<br />
      上述语句在批处理文件中的作用是创建5个文件夹,文件夹名称依次为1,3,5,7,9.可以发现,%%i的结束值并晨end的10,而是不大于end的一个数;</p>
    <p>语法:<br />
      for %%var in (fileset) do  command[command-parameters]<br />
      %%var:指定一个单一字母可替换的参数.<br />
      (set):指定一个或一组文件.可以使用通配符;<br />
      command:指定对文件执行的命令;<br />
      command-parameters:为特定命令指定参数或命令行开关.</p>
    <p>如果命令扩展被启用,则下列额外的for命令格式会受到支持;<br />
      1 for /d %%var in (set) do command  [command-parameters]<br />
      如果集中包含符,则指定与目录名匹配,而不与文件名匹配;</p>
    <p>for /r [[driver:]path] %var in in (set) do  command [command-parameters]<br />
      检查以[drive:]path为根的目录树,指向每个目录中的for语句.如果在/r后没有指定目录,则使用当前目录.如果集为一个单点(.)字符,则枚举该目录树.</p>
    <p>for /l %%var in (start,step,end) do  command[command-parameters]<br />
      该集表示以增量形式从开始到结束的一个数字序列.</p>
    <p>命令行中的for语句主要用于石厅局级的文件或目录中进行迭代处理,并以行为基础分析文本文件\字符串以及命令的输出信息;</p>
    <p>do (statement),statement可以是单一命令,也可以是使用命令管道\命令链\命令分组等技术组合起来的多条命令;</p>
    <p>如果需要重复地执行一条命令或一系列命令，可以使用for语句； <br />
      主要用于在成组的文件与目录中进行迭代处理，并以行为基础分析文本文件、字符串、命令的输出信息； </p>
    <p>for interator do (statement)<br />
      interator:用于控制for循环的执行。对interator中每一个步骤或元素，都会执行特定的。它可以是单一的一条命令，也可以是使用命令管道、命令链、命令分组等技术组合起来的多条命令； <br />
      interator通常包含： <br />
      1 一个初始化变量（要使用的值的占位符）； <br />
      变量只存在于for循环的上下文中； <br />
      变量名必须在a-z或A-Z的范围内，比如%%A、%%B、%%C.<br />
      变量名大小写敏感，也就是说，%%A与%%a是不同的； <br />
      2 一组需要反复执行的元素（需要遍历的一组文件或某范围内的一组值）， </p>
    <p>1 遍历一系列的值 <br />
      for /l %%var in (start,step,end) do comm<br />
      step可以使用负值； <br />
      运行流程： <br />
      首先对内部变量start,step,end进行初始化，将其赋值为应用中实际指定的值。之后，对start值为end值进行比较，如果start值可以按step中指定的值进行递增或递减操作，则条件为真（或按照另一种约定，条件为假），根据差别条件的真假判断是否需要执行语句。在条件为真的情形下，使用start值执行语句，并根据指定的step值对初始值进行递增或递减操作，之后重复这一过程直至遍历所有的值，或者条件发生变化。在条件为假的情况下，退出for循环语句，并跳到脚本中的下一语句执行； <br />
      for /l %%b in (0,2,10) do @ echo %%b<br />
      该语句的输出为 <br />
      0<br />
      2<br />
      4<br />
      6<br />
      8<br />
      10<br />
      2 在成组的文件中进行迭代操作 <br />
      for %%var in (fileset) do comm<br />
      fileset可以为如下的形式： <br />
      1 通过文件名指定的单独文件，如myfile.txt.<br />
      2 通过文件名通配符指定的一组文件，如*.txt.<br />
      3 通过多个文件名（使用空格分隔）指定的多个或多组文件，如*.txt *.rtf *doc.<br />
      for %%B in (c:\users\wwu\*.txt) do @echo  %%B<br />
      for %%B in (%systemroot%\*.txt  %systemroot%\*.rtf %systemroot%\*.doc) do @echo %%B<br />
      for %%B in (%systemroot%\*.txt  %systemroot%\*.rtf %systemroot%\*.doc) do @echo %%B &amp; move c:\data</p>
    <p>3 在目录中迭代执行 <br />
      for /d %%var in (directorySet) do comm<br />
      对目录的迭代处理与对文件的迭代处理是一样的，所不同的是，此时指定的是目录路径而不是文件路径。 <br />
      for /d %%B in (%systemroot%\*) do @echo %%B<br />
      for /d循环对指定的目录集进行迭代处理，但不包括这些目录中的子目录。要访问子目录及整个目录结构，可以使用for /f循环； <br />
      也可以使用空格分隔目录名： <br />
      for /d %%B in (%systemroot% %systemroot%\*)  do @echo %%B<br />
      文件迭代也可以和目录迭代技术结合起来，以便对目录集中的所有文件进行处理： <br />
      for /d %%B in (%appdata% %appdatat%\*) do （@ for %%C in  (&quot;%%B\*.txt&quot;) do echo %%C） </p>
    <p>对以[path]指定为起点的的整个目录树（逐级子目录的文件）进行处理;<br />
      for /r [[driver:]path] %var in (fileset) do  comm<br />
      如果path缺省，则默认为当前目录； <br />
      如，列出c:\中的所有文本文件 <br />
      for /r c:\ %B in (*.txt) do @echo %B<br />
      for /r c:\ %B in (*.docx) do @echo %B<br />
      /d与/r结合起来使用，如下例，列出了 %systemroot% 下的所有目录和子目录 <br />
      for /r %systemroot% /d %B in (*) do @echo  %B</p>
    <p>4 分析文件的内容与输出 <br />
      for /f [&quot;optins&quot;] %%var in  (source) do comm<br />
      for /f [&quot;optins&quot;] %%var in  (file-set) do comm<br />
      for /f [&quot;optins&quot;] %%var in  (&quot;string&quot;) do comm<br />
      for /f [&quot;optins&quot;] %%var in  (command) do comm<br />
      optins用于设置文本匹配选项； <br />
      in (source)用于指定文本的来源； <br />
      comm指定了在文本匹配时要执行的命令； <br />
      source指定的文本是以行为基础进行分析，文本的每行被命令当作一个记录处理；记录（或行）中不同的字段由特定的字符分隔开（比如制表符、空格，默认情况为空格）。通过替换技术，命令执行时会使用变量的实际值来替代占位符变量； <br />
      参考data.txt中如下二行文本： <br />
      William Stanek Engineering  Williams@adatum.com 3408<br />
      wu wanqun wh wwuhn@hotmail.com 222<br />
      如果将该行文本看成一个记录，可以划分为5个字段。如果初始变量设置为 %%A,则第一次迭代： <br />
      %%A:William<br />
      %%B:Stanek;<br />
      %%C:Engineering<br />
      %%D:Williams@adatum.com <br />
      %%E:3408<br />
      第二次迭代： <br />
      %%A:wu<br />
      %%B:wanqun<br />
      %%C:wh<br />
      %%D:wwuhn@hotmail.com<br />
      %%E:222</p>
    <p>for /f &quot;tokens=1-5&quot; %A in  (data.txt) do @echo name:%A %B department:%C email:%D ext%E<br />
      for /f &quot;tokens=1-5&quot; %%A in  (data.txt) do (@echo name:%%A %%B <br />
      @echo department:%%C <br />
      @echo email:%%D <br />
      @echo ext:%%E)</p>
    <p>tokens指定要处理的字段，如果初始变量是%%A，则每一个字段是%%A,第二个字段是%%B，...<br />
      文本文件中所有的空行被忽略； <br />
      可以通过空格或通配符指定多个源文件； <br />
      如果文件名包含空格，可者想执行某条命令，可以使用usebackq选项与引号，如 <br />
      for /f &quot;tokens=3-5 usebackq&quot; %%C  in (`type &quot;user data.txt&quot;`) do (@echo depart:%%C email:%%D ext:%%E)</p>
    <p>for /r c:\ %a in (*.exe) do @echo %~nxa  &gt;&gt;exefile.txt<br />
      注意顺序，如果用下面的顺序就不行： <br />
      for /r %a c:\ in (*.exe) do @echo %~nxa  &gt;&gt;exefile.txt</p>
    <p><br />
      
            </p>
</div>
<a name="bottom" id="bottom"></a>
<DIV style="DISPLAY: none" id=goTopBtn>&and;</DIV>
<div id="shangy"><a href="javascript:void(null)" onclick="shangy()" target="_self">&uarr;</a></div>
<div id="xiay"><a href="javascript:void(null)" onclick="xiay()" target="_self">&darr;</a></div>
<div id="goBottom"><a href="#bottom" target="_self">&or;</a></div>
<SCRIPT type=text/javascript>goTopEx();</SCRIPT>
<script type="text/javascript">
function xiay(){
window.scrollBy(0,window.innerHeight);
}
function shangy(){
window.scrollBy(0,-window.innerHeight);
}
</script>
</body>
</html>
<script language="JavaScript" type="text/javascript">
bg_even("tablecss","#fff","#F5F5F5","#FFFFCC","#FFFF84");
</script>