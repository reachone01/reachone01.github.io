<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>摘录PCnotes</title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//谷歌浏览器
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop属
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//谷歌浏览器
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox等浏览器
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//谷歌浏览器
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox等浏览器  
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000">红色</option><option value="#006600">绿色</option><option value="#0000ff">蓝色</option><option value="#660000">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:40em;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:100%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
#tbrower{
border-collapse:collapse;
}
#tbrower td{


border:1px #ccc solid;
padding:2px;
}
</style></head><body onload="downn();">
<div>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	//if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	//}
</script>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a><a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onclick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onclick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onclick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a></div>
<div id="container">
<script>
	goTopEx();
</script>


<p>临时对象的开销比局部对象小些。</p>

<p>编译器从模板生成一个特定的类或函数的过程称为模板的实例化。</p>

<p>如果这个指针变量需要定义为只读，即不能再另有指向，同时由编译器实现自动解引用，也就像使用一个变量一样来引用地址指向的值，则这样的指针变量在C++里称为引用，引用可以理解为一个变量的别名。</p>

<p>对象的列表初始化方法，大大提升了C++中object初始化语法的简易化程序。</p>

<p>并非所有类型都需要销毁实例，它牵涉应用程序的资源管理，主要在有动态内存需要释放时。</p>

<p>动态多态：纵向多态；函数重载和模板：横向多态；</p>
<hr />


<p>C++大胆地运用了类型修正符(type modifier），对原型进行一些修改和限制。主要包括：const、volatile、mutable</p>

<p>const用于规定变量的不可修改性；</p>

<p>mutable用于成员变量，指当声明一个const对象时，如果某个成员是mutable属性的，则该成员变量可以被修改，但是整体的“常量性”不变。</p>

<p>volatile是指当一个变量被优化存储到寄存器中时，在不断从寄存器中调用时，可能在内存中有对其修改，但没有同步更新的寄存器，volatile是告诉编译器，不能优化存储到寄存器中，以免出现更新不同步的错误。</p>

<p>类是一等公民：类实例可以作为函数的参数和返回值，可以在内存的任何域中出现：堆、栈、全程变量区。</p>
<hr />


<p>Objects contain their own data and algorithms.</p>

<p>The concept object include class and instance.</p>

<p>Polymorphism is A single name can have multiple meanings depending on its context.</p>
<p>所谓多态，简单地讲，就是指一个名字（或符号）具有多种含义。</p>
<p>Escape sequences tell the compiler to treat characters in a special way.</p>
<h4>variable</h4>
<p>variables are names for memory locations, instead of a series a number of a address.</p>

<p>We can  write a value in them;</p>

<p>We can change the value stored there;</p>

<p>We cannot erase the memory location;</p>

<p>Some value is always there;</p>
<hr />



<p>Result of an operator depends on the types of operands:</p>

<p>If both operands are int, the result is int;</p>

<p>If one or both operands are double, the result is double;</p>

<p>Binary operators with equal precedence are performed left to right</p>

<p>Unary operators of equal precedence are performed right to left</p>
<hr />

<p>Pointers "point" to a variable by telling where the variable is located</p>

<p>Sequential Containers are containers where the ultimate position of the element depends on where it was inserted, not on its value. </p>

<p>Container Adapters use the sequential containers for storage, but modify the user interface to stack, queue or other structure. </p>
<h4>异常</h4>
<p>如何处理一个异常，取决于该异常的类型。这与重载函数的参数匹配有些相似，但又有所不同。</p>

<p>重载函数可能有多个参数，而捕捉异常时的参数只有一个；其次，处理异常之后不会像调用函数那样返回异常的发生处。异常处理严重影响语句的运行顺序。</p>

<p>当有多个catch语句时，所发生的异常会按顺序与之匹配，一旦匹配成功就进入异常处理，不再与剩余的catch语句继续配对。</p>

<p>在异常处理中，有一种方法可以与所有的异常匹配，那就是使用catch (…)。</p>

<p>除了系统能够抛出异常外，用户也可以抛出异常。用户抛出的异常也可以被捕捉并处理。</p>

<p>抛出异常使用throw语句，它可以出现在任何函数体内。其语法格式为：</p>

<p>	throw 表达式;</p>

<p>如果throw抛出的异常没有被捕捉处理，则也会导致程序退出。</p>

<p>容器使用了一种叫“空间配置器”的东西，能够自动进行存储空间的申请、扩容和释放。</p>





<p>try语句括起一个测试块，其中含有可能出错的语句。如果有异常发生，则会抛出特定类型的异常。</p>

<p>每一个catch语句是一个异常处理器，相当于一个带参数的函数，功能是对指定异常类型进行处理。</p>

<p>一旦一个异常信号被抛出，那么与这个信号有相同类型参数的catch子句会捕获这个异常并处理。处理完成后整个异常处理流程结束。</p>
<hr />

<p>true和false是字面常量标识符，并不是字符串</p>
<p>形参：变量声明，实参用来初始化形参，分配内存，存储一个普通值或地址值；</p>

<p>函数返回值：临时变量，存储一个普通值或地址值；</p>

<p><h4>常量对象</h4></p>

<p>const关键字可以约束普通变量，也可以约束一个对象，使之成为常量对象。例如：</p>

<p>const Rectangle rect(3, 4);</p>

<p>这样一来，对象rect的所有属性都是不可修改的，除非某个属性被说明成是mutable。</p>

<p>常量对象不是很常见。最容易出现的一个场合是函数返回对象的值这一情况。这个返回的对象被编译器自动约束成为常量对象。另一个经常使用常量对象（引用）的场合是对象作为函数的参数。</p>

<p>与无约束对象一样，可以调用常量对象的成员函数来完成某项操作。但这可能带来潜在的错误：这个成员函数可能会修改对象的属性。</p>
<hr />

<p>类中的枚举成员不属于对象，而是该类的所有对象共享的。因此，对枚举成员的访问必须采用名字限定的方式进行。例如：</p>

<p>    Quadrangle::ID id = Quadrangle::RECTANGLE; //OK</p>

<p>     id = SQUARE;  //error</p>

<p>同样地，如果枚举定义被放在非公有段中，以上访问如果发生在Quadrangle类之外就是非法的。</p>
<hr />

<p>声明和定义包括</p>

<p>1 变量的声明和定义</p>

<p>2 函数的声明和定义</p>

<p>3 类型的声明和定义</p>

<p>继承性是对象之间合作的另一种方式(另两种方式是友元类和对象作成员)，派生类继承了基类，一个派生类对象除了可以包含基类对象，这一点和对象作成员类似，派生类还可以继承基类中的成员， 派生类对象可以在类外直接使用继承的基类公有成员。</p>

<p>类既可看作模块又可看作类型，继承的引入使这两种观点更加明显，从模块和类型两个角度来仔细考察继承的意义。</p>

<p><h4>一个成员函数什么时候需要声明为虚函数呢？主要考虑以下几点：</h4></p>

<p>首先考虑成员函数所在的类是否会做为基类。然后看成员函数在类的继承后有无功能被修改？如果希望修改其功能，一般将它声明为虚函数。</p>

<p>如果成员函数在类被继承之后功能不需要修改，或派生类中用不到该函数，则不要把它声明为虚函数。</p>

<p>应当考虑对成员函数的调用是通过对象名还是基类指针或引用去访问。如果通过基类指针或引用去访问，则声明为虚函数。</p>

<p>如果希望通过基类指针或者引用访问派生类成员函数，但基类功能比较抽象或者不能确定功能，可以将基类定义为抽象类，即只定义函数名字，没有函数体，具体功能由派生类添加。</p>

<p>对象销毁时（离开对象的作用域后），需要调用析构函数。在多态调用时，是用基类的指针访问派生类的对象。如果析构函数是非虚函数，则基类指针只能访问基类的析构函数，而不能访问派生类的析构函数，导致派生类对象销毁时，没有调用派生类的析构函数，只是调用了基类的析构函数。如果把析构函数定义成虚函数，则可克服这个问题。其实就是通过virtual这个定义在析构函数前的关键字，告诉编译器，需要调用子类的析构函数做析构。</p>
<hr />

<p>C++从C语言继承过来，但是我们的Bjarne博士更具有先见之明，他为了避免受到C语言的局限性，参考了很多的语言，例如：从Simula继承了类的概念，从Algol68继承了运算符重载、引用以及在任何地方声明变量的能力，从BCPL获得了//注释，从Ada得到了模板、名字空间，从Ada、Clu和ML取来了异常。</p>
<h4>隐式类型转换、类的隐式类型转换</h4>
<p>C++的内部数据类型遵循隐式类型转换规则。假设某个表达市中使用了一个短整型变量，而编译器根据上下文认为这儿需要是的长整型，则编译器就会根据类型转换规则自动把它转换成长整型，这种隐式转换出现在赋值、参数传递、返回值、初始化和表达式中。我们也可以为类提供相应的转换规则。</p>
<p>对一个类建立隐式转换规则需要构造一个转换函数，该函数作为类的成员，可以把该类的对象和其他数据类型的对象进行相互转换。声明了转换函数，就告诉了编译器，当根据句法判定需要类型转换时，就调用函数。</p>
<p>有两种转换函数。一种是转换构造函数;另一种是成员转换函数。需要采用哪种转换函数取决于转换的方向。</p>
<hr />

<p>派生类应当向基类的构造函数传递参数</p>
<p>在c++语言程序中，对象之间的相互通信通过调用成员函数实现。</p>
<p>类的成员函数可以访问全部数据成员，类的对象却只能访问公共成员。</p>
<p>cin是C++预定义的标准输入流对象</p>
<p>多态类中的虚函数表是Compile-Time，还是Run-Time时建立的</p>
<p>虚拟函数表是在编译期就建立了，各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组。而对象的隐藏成员--虚拟函数表指针是在运行期--也就是构造函数被调用时进行初始化的，这是实现多态的关键。</p>
<p>malloc是库函数，不在编译器控制范围之内；new是运算符，在编译器控制范围之内。 ? </p>
<p>调用malloc时，从堆中申请内存；调用new时，从堆中申请内存并为内存调用构造函数。</p>
<p>C++中为什么用模板类。</p>
<p>(1) 可用来创建动态增长和减小的数据结构</p>
<p>(2) 它是类型无关的，因此具有很高的可复用性。</p>
<p>(3) 它在编译时而不是运行时检查数据类型，保证了类型安全。</p>
<p>(4) 它是平台无关的，有可移植性。</p>
<p>(5) 可用于基本数据类型。</p>

<h4>默认参数</h4>
<p>可以为参数指定默认值，在函数调用时没有指定与形参相对应的实参时就自动使用默认值。默认参数可以简化复杂函数的调用。</p>
<p>默认参数通常在函数名第一次出现在程序中的时候，如在函数原型中，指定默认参数值。指定默认参数的方式从语法上看与变量初始化相似。例如： void myfunc(int x=0,int y=1); 如果一个函数中有多个参数，则默认参数应从右至左逐个定义。</p>
<p>在对函数进行重载时，不允许为其指定缺省参数，同时，对于重载的函数原型间不允许有类型完全相同的参数列表，对于返回类型，在重载时没有特别的要求。</p>
<p>class B:virtual public A{}虚函数的使用方法是在基类用virtual声明成员函数为虚函数。</p>
<p>类模板是一系列相关类的模板，类成员组成相同，成员函数的源代码形式相同，所不同的是所针对的类型。类模板的成员函数都是模板函数，在用类模板定义对象时，由于没有像函数实参表这样的额外信息渠道，因此无法按函数模板的方式省略模板实参。但可以为类模板的参数设置默认值。</p>
<p>在c++语言中，数据封装要解决的问题是防止不同模块之间数据的非法访问</p>

<h4>构造函数</h4>
<p>派生类构造函数要负责调用基类的构造函数</p>
<p>C++本身就规定创建子类对象的时，先调用基类的构造函数，然后再调用自己类的构造函数。当我们的基类没有自己定义构造函数时候（就是系统默认的构造函数）时。创建子类对象会先默认调用基类的默认构造函数 。但是，当我们的基类自己定义了构造函数，（可能定义了很多个）此时不会再自动生产默认构造。但是它不知道应该调用基类中的哪个构造，所以需要手动指定。</p>
<p>在释放派生类对象时，析构函数函数的执行顺序是：先执行派生类的析构函数，然后执行成员对象的析构函数，最后执行基类的析构函数。</p>
<p>C++本身就规定创建子类对象的时，先调用基类的构造函数，然后再调用自己类的构造函数。当我们的基类没有自己定义构造函数时候（就是系统默认的构造函数）时。创建子类对象会先默认调用基类的默认构造函数 <https://www.baidu.com/s?wd=%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao>。但是，当我们的基类自己定义了构造函数，（可能定义了很多个）此时不会再自动生产默认构造。但是它不知道应该调用基类中的哪个构造，所以需要手动指定。(如果基类定义了无参的构造函数，派生类可以不在构造函数的参数列表中调用基类的构造函数)</p>
<p>当没有显式调用指定形式的构造函数。系统自动调用无参构造函数，如果没有为类指定此构造函数，则系统自动为其生成一个最简单的无参构造函数。</p>
<hr />

<p>当自加运算符做后缀表达式的时候，表达式的值不变，只有变量的值增1</p>
<p>C++语言中的类是可以组成层次结构的，类是用于描述事物的属性和对事物的操作，类与类之间有相对的独立性，但其可以通过一些方法进行信息的通信。</p>
<p>C++中类的成员对象比类的对象先初始化。</p>
<p>C++中产生虚基类的作用就是为了解决继承中的二义性问题，通过虚基类继承可以把父基类中相同的函数只编译一次。</p>
<p>友元函数是独立于当前类的外部函数，但它可以访问该类的所有对象的成员；拷贝构造函数是使用已存在的对象初始化正在生成的对象时调用的成员函数。</p>
<p>在C++语言中，所有的函数都是平行的，即在定义函数时是互相独立的，一个函数并不从属于另一个函数，即函数不能嵌套定义，但可以互相调用。但是不能调用main()函数。</p>
<p>关连容器：数据成员有序；</p>
<p>map成员是pair类对象。</p>
<p>set成员是基本类型或自定义类型；大小比较可自定义函数，也有缺省的默认函数less，也就是<；如果类型是自定义类型，需要这个类型重载<运算符。</p>
<p>派生类的构造函数的成员初始化列中，不能包含基类的子对象初始化;。</p>

<p>要使引用pr代表变量char * p；，则pr应初始化为 char*& pr = p; 。</p>
<p>friend Sample operator+( Sample &s1, Sample &s2);//二元运算符，两个参数则是非成员函数，一个参数则是成员函数</p>
<p>Sample operator+( Sample &s); //二元运算符，两个参数则是非成员函数，一个参数则是成员函数</p>
<p>当没有显式调用指定形式的构造函数。系统自动调用无参构造函数，如果没有为类指定此构造函数，则系统自动为其生成一个最简单的无参构造函数。</p>
<p>在C++语言程序中，对象之间的相互通信通过调用成员函数实现。</p>
<hr />

<p>派生类初始化三部分内容：</p>
<p></p>
<p>1 新增内嵌对象以外的数据成员</p>
<p>2 新增的内嵌对象；</p>
<p>3 基类数据成员（不包括基类内嵌对象）；</p>
<p>第二和第三在初始化列表中调用构造完成；</p>
<p>在参数表中包含上述三类参数的实参；</p>
<hr />

<p>要实现函数重载，需要使用不同形参列表为同一函数编写不同的定义。</p>
<p>在已有作用域中创建的作用域就是嵌套作用域；</p>
<p>默认拷贝构造函数按成员逐项进行复制可能导致对象的浅拷贝，这时副本对象的指针数据成员与原始对象的指针数据成员指向相同的内存块。深拷贝是指对象的副本与原始对象没有共享的内存块。默认赋值运算符成员函数只提供按成员逐项进行的复制。</p>

<h4>virtual析构函数</h4>
<p>如果类中有虚函数，那么也应当将析构函数声明为虚函数。然而，有些程序员认为，为了安全起见，总是应当将析构函数声明为虚函数。因为当有多继承时，基类的析构函数定义为virtual时，编译器才会产生自动调用子类析构函数的行为。</p>
<p>派生类中有资源需要回收，而在编程中采用多态，由基类的指针指向派生类，则在释放的时候，如果基类的析构函数不是virtual，则派生类的析构函数得不到释放</p>

<p>C++中基类采用virtual虚析构函数是为了防止内存泄漏。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。</p><p>文字量、常量和需要类型转换的参数都可以传递给const&参数，但不能传递给非const的引用参数。也就是说对非const引用参数不允许做类型转换。</p>
<p>检查字符串s中是否包含字符串t，若包含，则返回并输出t在s中的开始位置（下标值），否则返回-1。请将程序补充完整。</p>
<pre>
#include&lt;iostream>
using namespace std;
int main()
{
	int i,j,k;
	char s[20]="Today is sunday!",t[10]="sun";
	for(i=0;s[i]!='\0';i++)
	{
		for(j=i,k=0; t[k]!='\0'&&s[j] == t[k];j++,k++);
		if(t[k]=='\0')
		{
			cout&lt;&lt;"t在s中的开始位置下标为:"&lt;&lt;i&lt;&lt;endl;
			return i;
		}
	}
	return -1;
}
</pre>
<p>字符串字面量在C中具有数组类型char[N]，在C++中则为const char[N]，在表达式中当发生数组到指针的转换时，对应的等效指针类型分别是char*和const char*，因此，在C中，char *p = “ABCDEF”是合法的，但让人惊奇的是，上述语句在C++中也是合法的！看起来一个pointer to const char指针被赋予了pointer to char指针，似乎违反了C++中指针转换的more cv-qualified原则。其实字符串字面量在C++中存在两种转换，一种转换依据当前上下文环境，另一种遵循数组到指针的转换。</p>
<p>文件操作：建立流（C的流指针与C++的流对象），让一个文件与之相关联，如C的open函数，c++的open方法或直接初始化时附加一个路径。建立关联也称为打开文件，取消关联也称为关闭文件；</p>
<p>强类型的C++的泛型，除了使用模板，函数重载以外，还有类型方面的泛化，如void、variant、union。</p>
<p>At the language level, C++ represents  interfaces by declarations.</p>
<p>Exceptions report errors found at run time. If an error can be found at compile time, it is usually  preferable to do so. That’s what much of the type system and the facilities for specifying the interfaces  to user-defined types are for.</p>
<p>Concrete classes – especially classes with small representations – are much like built-in types: we  define them as local variables, access them using their names, copy them around, etc. Classes in  class hierarchies are different: we tend to allocate them on the free store using new, and we access  them through pointers or references.</p>
<p>Now each object is owned by a unique_ptr that will delete the object when it is no longer needed,  that is, when its unique_ptr goes out of scope.</p>
<p>If a constructor acquires a resource, its class needs a destructor to release the resource;</p>
<p>Use dynamic_cast where class hierarchy navigation is unavoidable;</p>
<p>Use dynamic_cast to a reference type when failure to find the required class is considered a failure; </p>
<p>Use dynamic_cast to a pointer type when failure to find the required class is considered a valid alternative; </p>
<p>Use unique_ptr or shared_ptr to avoid forgetting to delete objects created using new;</p>
<p>constructor taking a single argument defines a conversion from its argument type.</p>
<p>explicit Vector(int s); // no implicit conversion from int to Vector</p>


<hr />

<p>The && means "rvalue reference" and is a reference to which we can bind an rvalue. The word  "rvalue" is intended to complement "lvalue," which roughly means "something that can appear on  the left-hand side of an assignment." So an rvalue is – to a first approximation – a value that you  can’t assign to, such as an integer returned by a function call. Thus, an rvalue reference is a reference  to something that nobody else can assign to, so we can safely "steal" its value.</p>
<p>&&的意思是“右值引用”，是一个我们可以绑定右值的引用。“rvalue”这个词是对“lvalue”的补充，它大致意思是“可以出现在赋值左侧的某个值”。因此，rvalue是——对于第一个近似值——一个不能赋值的值，例如函数调用返回的整数。因此，右值引用是对其他人无法分配的对象的引用，因此我们可以安全地“窃取”它的值。</p>
<p>a move constructor allows an object to move simply and cheaply from one  scope to another.</p>
<p>That way, objects that we cannot or would not want to copy out of a scope can be  simply and cheaply moved out instead.</p>
<p>Do not copy data from an unbounded source to a  fixed-length array.</p>
<p>The code or text segment includes instructions and read-only data.</p>
<p>Guarantee that storage for strings has sufficient  space for character data and the null terminator.(bounds-checking)</p>
<p>mistakes using the basic_string class include</p>
<p>Using an invalidated or uninitialized iterator</p>
<p>Passing an out-of-bounds index</p>
<p>Using an iterator range that really is not a range</p>
<p>Passing an invalid iterator position</p>


<hr />

<p>Never use gets(). Because it is impossible to tell without knowing the data  in advance how many characters gets() will read, and because gets() will  continue to store characters past the end of the buffer, it is extremely dangerous  to use. It has been used to break computer security.</p>
<p>The C Standard fgets() function has similar behavior to gets(). The  fgets() function accepts two additional arguments: the number of characters  to read and an input stream. When stdin is specified as the stream, fgets()  can be used to simulate the behavior of gets().</p>
<p>array and string the problems of security: buffer overflow and bounds checking. operator =、[], string-handling function,and basc_string class's iterator, gets() replaced by fgets() or getchar(), strcpy() with strncpy().</p>
<p>The gets_s() function accepts an additional  argument, rsize_t, that specifies the maximum number of characters to  input. An error condition occurs if this argument is equal to zero or greater  than RSIZE_MAX or if the pointer to the destination character array is NULL. If  an error condition occurs, no input is performed and the character array is  not modified. Otherwise, the gets_s() function reads, at most, one less than  the number of characters specified, and a null character is written immediately  after the last character read into the array.</p>
<p>The behavior of the getline() function is similar to that of fgets() but offers  several extra features. </p>
<p></p>
<p>First, if the input line is too long, rather than truncating  input, the function resizes the buffer using realloc(). </p>
<p>Second, if successful, it  returns the number of characters read, which is useful in determining whether  the input has any null characters before the newline. The getline() function  works only with buffers allocated with malloc(). If passed a null pointer,  getline() allocates a buffer of sufficient size to hold the input. As such, the user  must explicitly free() the buffer later. </p>
<p>the strncpy() function is not guaranteed to null-terminate the  destination string, the programmer must be careful to ensure that the destination  string is properly null-terminated without overwriting the last character.</p>

<hr />



<p>一般情况下，重载输入（输出）运算符函数不能是类的成员函数。因为如果一个运算符函数是类的成员，则其左运算数就应当是调用运算符函数的类的对象，而此点是无法改变的。</p>
<p>重载输入（输出）运算符时，其左边的参数是流，而右边参数是类的对象。因此重载输入（输出）运算符函数必须是非成员函数－而用友元函数。</p>
<p>Templates offer compile-time "duck typing";</p>
<p>No significant program is written in just a bare programming language. First, a set of libraries is  developed. These then form the basis for further work.</p>
<p>In addition to the standard-library components, most implementations offer "graphical user  interface" systems (GUIs), Web interfaces, database interfaces, etc.</p>
<p>确保你的编译器支持Regex，如果你的编译器是GCC-4.9.0或者VS2013以下版本，请升级后，再使用。</p>


<hr />

<p>In <fstream>, the standard library provides streams to and from a file:</p>
<p></p>
<p>ifstreams for reading from a file</p>
<p></p>
<p>ofstreams for writing to a file</p>
<p></p>
<p>fstreams for reading from and writing to a file</p>
<p>ofstream ofs {"target"}; // "o" for "output"</p>
<p>if (!ofs)</p>
<p>error("couldn't open 'target' for writing");</p>
<p>Testing that a file stream has been properly opened is usually done by checking its state.</p>
<p>ifstream ifs {"source"}; // "i" for "input"</p>
<p>if (!ifs)</p>
<p>error("couldn't open 'source' for reading");</p>
<p>Assuming that the tests succeeded, ofs can be used as an ordinary ostream (just like cout) and ifs can be used as an ordinary istream (just like cin).</p>
<p>Use cout for normal output and cerr for errors;</p>

<hr />


<p>运算符函数重载：将指定的运算表达式转化为对运算符函数的调用，运算对象转化为运算符函数的实参。</p>
<p>the equivalent information represented as a  pointer plus offsets.</p>
<p>程序库：头文件（库函数原型，由编译器来做类型检查）+库文件（函数实现，由链接器链接，将代码复制到可执行文件中）。</p>
<p></p>
<p>VC++提供了一个名为comment的指令，它可以搭配lib选项给链接器发送一个特定信息，以链接特定的程序库。因此头文件中的代码：</p>
<p></p>
<p>#pragma comment(lib, "mylib")</p>
<p></p>
<p>将告知链接器链接程序库mylib。一般来说，最好使用项目管理工具，比如nmake或者MSBuild，用于确保将正确的程序库链接到项目中。</p>
<p></p>
<p>大部分C运行时库是以如下方式实现的，在一个静态库或者动态链接库中编译函数，然后在头文件中声明函数原型。开发人员在链接器命令行中提供了程序库，通常还将为该程序库引用头文件，以便编译器能够访问函数原型。只要链接器能够识别该程序库，就可以在项目代码中输入其函数原型（将它定义为外部链接，以便告知编译器函数是在其他地方定义的）。这样可以省去将某些大型文件引入到源代码中的麻烦，因为这些文件中很有可能包含大量不会用到的函数原型。</p>
<p>If you have a class hierarchy that relies on virtual functions to get polymorphic behavior, do not store objects directly in a container.  instead store a pointer (or a smart pointer).</p>
<p>For example:</p>
<p>vector<Shape> vs; // No, don’t - there is no room for a Circle or a Smiley</p>
<p>vector<Shape?>vps; //better, but see §4.5.3</p>
<p>vector<unique_ptr<Shape>> vups; // OK</p>
<p>Why doesn’t the standard guarantee range checking? Many performance-critical applications  use vectors and checking all subscripting implies a cost on the order of 10%. Obviously, that cost  can vary dramatically depending on hardware, optimizers, and an application’s use of subscripting.  However, experience shows that such overhead can lead people to prefer the far more unsafe builtin  arrays. Even the mere fear of such overhead can lead to disuse. At least vector is easily range  checked at debug time and we can build checked versions on top of the unchecked default.</p>
<p>a map is known as an associative array or a dictionary. It is implemented as a balanced  binary tree.</p>
<hr />

<p>变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p>
<p></p>
<p>当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 extern 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。</p>
<hr />

<p>类型限定符提供了变量的额外信息。包括有const、volatile、restrict。C++ 允许在 char、int 和 double 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。</p>
<p>const 类型的对象在程序执行期间不能被修改改变。</p>
<p>volatile	修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。</p>
<p>restrict	由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。告诉编译器，对象已经被指针所引用，不能通过除该指针外所有其他直接或间接的方式修改该对象的内容。</p>
<p>C++ 存储类说明符：定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。auto、register、static、extern、mutable、thread_local (C++11)、从 C++ 11 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。</p>
<p>C++ 允许在 char、int 和 double 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。下面列出了数据类型修饰符：signed、unsigned、long、short、</p>
<p>存储类说明符 类型限定符 类型修饰符 标识符</p>
<p>specifier delimiter modifier identifier</p>
<p>extern volatile unsigned long int i;</p>
<p>volatile unsigned long int i=0;</p>
<hr />

<p>函数参数传值、返回值，都会在栈上有一个值的内存空间的副本，而传址（包括引用），内存副本只是一个内存地址的副本；指向函数体栈帧外一段空间的首地址。</p>
<p>调用类型	描述</p>
<p>传值调用	该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</p>
<p>指针调用	该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</p>
<p>引用调用	该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</p>

<p>传值、传址（引用）、返回值、返回址（引用），值是函数栈帧上的值，址是本函数栈帧以外上的内在空间上的址。</p>
<p>当函数返回一个引用时，则返回一个指向返回值的隐式指针。这样，函数就可以放在赋值语句的左边。</p>
<p>当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的，但是，可以返回一个对静态变量的引用。</p>
<p>C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量。</p>

<hr />

<p>C++ 中有大量的函数用来操作以 null 结尾的字符串：supports a wide range of functions that manipulate null-terminated strings。</p>
<p>就 C++ 编程而言，C++ 类为数据抽象提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。</p>
<p></p>
<p>例如，您的程序可以调用 sort() 函数，而不需要知道函数中排序数据所用到的算法。实际上，函数排序的底层实现会因库的版本不同而有所差异，只要接口不变，函数调用就可以照常工作。</p>
<p>cin 对象的附加函数，比如 getline()函数从外部读取一行，ignore() 函数会忽略掉之前读语句留下的多余字符。</p>
<hr />

<p>为什么基类指针和引用可以指向派生类对象，但是反过来不行？</p>
<p>在内存中，一个基类类型的指针是覆盖N个单位长度的内存空间。</p>
<p>当其指向派生类的时候，由于派生类元素在内存中堆放是：前N个是基类的元素，N之后的是派生类的元素。</p>
<p>于是基类的指针就可以访问到基类也有的元素了，但是此时无法访问到派生类（就是N之后）的元素。</p>
<p>p是基类指针，p指向的是绿色的部分，但可以通过转换把让p指向派生类(实际上p的指向的地址没有变，只是类型变了，指向的空间的大小不一样而已)</p>
<p></p>
<p>派生类的指针却不能指向基类，那样那越界，就是说小的可以变大，大的却不能变小</p>
<p>而基类指针指向派生类对象实例，是通过多态实现的。只能调用其接口，及虚函数。</p>
<hr />



<p>静态类型：对象在声明时采用的类型，在编译期既已确定；</p>
<p>动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；</p>
<p>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</p>
<p>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；必须搞清楚的一点是：动态绑定只有当我们指针或引用调用虚函数的时候才会发生。</p>
<p>从上面的定义也可以看出，非虚函数一般都是静态绑定，而虚函数都是动态绑定（如此才可实现多态性）。</p>
<p>所以在C++中有两种类型转换static_cast和dynamic_cast的。</p>
<p>另外C++增加了const，所以又有了const_cast。</p>
<p>对于C的转换，有了reinterpret_cast的转换。</p>
<p>dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。</p>
<p>在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；</p>
<p>在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。</p>
<hr />


<p>ofstream(fileName, mode)</p>
<p>ios::app :  start writing at end of file</p>
<p>ios::ate: start reading or writing at end of file</p>
<p>Ios::in : open for reading</p>
<p>ios::trunc: truncate file to zero length if it exists</p>
<p>ios::nocreate : error when opening if file does not exist</p>
<p>ios::noreplace: error when opening for output if file exists.</p>
<p>ios::binary: open file in binary mode.</p>
<p>ios::out : open for writing</p>
<p></p>
<p>fstream file; file.open("Group.dat", ios::app | ios:: out | ios::in | ios::binary);</p>
<p>基类ios(继承istream的类)提供一个重载的强制类型转换运算符，将流变成void*类型的指针。如果读取数值时发生错误或遇到文件结束符，则指针值为0。编译器能够隐式使用void*类型的强制转换运算符。</p>
<p>stringstream类用于执行C++风格的串流的输入操作。 </p>
<p>　　ostringstream类用于执行C风格的串流的输出操作。 </p>
<p>　　strstream类同时可以支持C风格的串流的输入输出操作。</p>

<hr />


<p>两个整数相除是整除(integer division)，小数部分丢失(即截尾，truncated)。</p>
<p>c++编译器只能对操作数的数据类型一致的表达式求值。要保证操作数的数据类型一致，编译器对所选择的操作数进行提升(promotion)操作(也称为隐式类型转换，implicit conversion)。</p>
<p>程序中一个标识符有意义的部分称为其作用域。例如，块中声明局部变量时，其只能在这个块或这个块嵌套的块中引用。一个标识符的4个作用域是函数范围(function scope)、文件范围(file scope)、块范围(block scope)和函数原型范围(function-prototype scope)。后面还要介绍第五个--类范围(class scope)。</p>
<p>派生类总是负责直接基类的构造。</p>
<p>派生类利用初始化列表构造基类的属性。</p>
<p>有多个基类的情况下，派生类对基类的构造顺序取决于继承顺序，先继承的先构造，最后构造自身。析构顺序与此相反。</p>

<p>静态数据成员共享数据的一种机制，比全局变量安全，能将作用域限制在类内；</p>
<p>Thus, the standard containers plus back_inserter()s eliminate the need to use error-prone, explicit C-style memory management using realloc().</p>
<p>Dynamic memory management in C programs can be extremely complicated  and consequently prone to defects. Common programming defects related to  memory management include initialization errors, failing to check return values,  dereferencing null or invalid pointers, referencing freed memory, freeing the same  memory multiple times, memory leaks, and zero-length allocations.</p>
<p>Initializing large blocks of memory can degrade performance and is not  always necessary. The decision by the C standards committee to not require  malloc() to initialize this memory reserves this decision for the programmer.  If required, you can initialize memory using memset() or by calling calloc(),  which zeros the memory. When calling calloc(), ensure that the arguments,  when multiplied, do not wrap.</p>
<hr />

<p>Containers are neatly partitioned  into two categories: sequence containers and associative containers.  The sequence containers are conceptually similar to arrays; they provide  accesses to sequences of elements. Associative containers contain key/value pairs, so elements in the containers can be looked up by key.</p>
<p>Invariants are features of a class that don’t  change once they’ve been constructed.</p>
<p>By wrapping a dynamic object with  a smart pointer, you can rest assured that memory will be cleaned up appropriately  as soon as the object is no longer needed.</p>
<p>Examples of actions you might  want to take in a destructor include releasing file handles, flushing network  sockets, and freeing dynamic objects.</p>
<p>Pointers encode both pieces of information required to interact with another  object—that is, the object’s address and the object’s type.</p>
<p>Pointers share several characteristics with arrays. Pointers encode object location.  Arrays encode the location and length of contiguous objects.</p>
<p>References are safer, more convenient versions of pointers. You declare references  with the & declarator appended to the type name. References cannot  be assigned to null (easily), and they cannot be reseated (or reassigned).  These characteristics eliminate some bugs endemic to pointers.</p>
<p>If you’ve been programming in an application language, chances are you’ve  used an automatic memory manager, or a garbage collector. At runtime, programs  create objects. Periodically, the garbage collector determines which objects  are no longer required by the program and safely deallocates them. This  approach frees the programmer from worrying about managing an object’s  life cycle, but it incurs several costs, including runtime performance, and  requires some powerful programming techniques like deterministic  resource management.  C++ takes a more efficient approach. The trade-off is that C++ programmers  must have intimate knowledge of storage durations. It’s our job,  not the garbage collector’s, to craft object lifetimes.</p>
<p>Because the compiler doesn’t typically clean up memory after an object is deleted, a  subtle and potentially serious type of bug called a use after free can occur. If you  delete an object and accidentally reuse it, your program might appear to function correctly  because the deallocated memory might still contain reasonable values. In some  situations, the problems don’t manifest until the program has been in production for a  long time—or until a security researcher finds a way to exploit the bug and discloses it!</p>
<p>In practice, your program’s operating environment might clean up leaked resources  for you. For example, if you’ve written user-mode code, modern operating systems will  clean up the resources when the program exits. However, if you’ve written kernel code,  those operating systems won’t clean up the resources. You’ll only reclaim them when  the computer reboots.</p>
<p>You use try-catch blocks to establish exception handlers for a block of code.  Within the try block, you place code that might throw an exception. Within  the catch block, you specify a handler for each exception type you can handle.</p>
<p>左值存储在一个内存单元中，右值存储在寄存器中。使用右值引用可以将右值备份到内存单元中。</p>
<p>相当于快速引用一个寄存器的值。</p>
<p>The static_cast reverses a well-defined implicit conversion, such as an integer  type to another integer type. The object-to-cast is of some type that the  desired-type implicitly converts to. The reason you might need static_cast is  that, generally, implicit casts aren’t reversible.</p>
<p>C++语言把每一个文件都看成一个有序的字节流（把文件看成n个字节）</p>
<p>每一个文件以文件结束符(end-of-file marker)结束。</p>
<p>当打开一个文件时，该文件就和某个流关联起来。</p>
<p>与这些对象相关联的流提供程序与特定文件或设备之间的通信通道。</p>
<p>例如．cin对象(标准输入流对象)使程序能从键盘输入数据，cout对象(标准输出流对象)使程序能向屏幕输出数据。</p>
<p>C++文件的读写和控制台读写一样，可以用流提取运算符“>>”从文件读数据，也可以用流插入运算符”&lt;&lt;”将数据写入文件，也可以用文件流的其他成员函数读写文件，如get函数，put函数等。</p>
<p>判断文件结束</p>
<p>>>读：可以通过判断输入流对象值是否为0。</p>
<p>get读：判断读入字符是否是EOF。</p>
<p>其他方式读：通过成员函数eof。eof函数不需要参数，返回一个整型值。当读操作遇到文件结束时，该函数返回1，否则返回0。</p>

<hr />

<p>传统的异常处理：就地处理</p>
<p>C++的新异常处理特性：</p>
<p>异常处理将检测发现错误的代码与处理错误的代码分开来。程序员的工作也可做相应分工（例如，库函数程序员负责检测异常，而调用库函数的另一程序员则负责捕获与处理异常）。</p>
<p>使程序员可以删除程序执行“主线条”中的错误处理代码，从而提高程序的可读性和可维护性。</p>
<p>一个函数抛出异常，它必须假定该异常能被捕获和处理。异常捕获机制使得C++可以把问题集中在一处解决。</p>
<p>catch处理器定义自己的范围。catch在括号中指定要捕获的对象类型。catch处理器中的参数可以命名也可以无名。如果是命名参数，则可以在处理器中引用这个参数。如果是无名参数(只指定匹配抛出对象类型的类型)，则信息不从抛出点传递到处理器中，只是把控制从抛出点转到处理器中．许多异常都可以这样。</p>
<p>catch (…) 捕获任意类型的异常。</p>
<p>异常捕获原理</p>
<p>如果一个异常信号被抛出，异常处理器中第一个参数与异常抛出对象相匹配的函数将捕获该异常信号，然后进入相应的catch语句，执行异常处理程序。</p>
<hr />


<p>一个字符串从定义到处理再到输出，涉及到编辑器、编译器和输出环境三个因素，正确的处理和显示需要三个因素的共同保障，每一个环节都不能出错。</p>
<p>代码编辑器采用何种编码方式决定了字符串最初的编码，比如编辑器如果采用GBK，那么代码文件中的所有字符都是以GBK编码存储。当编译器处理字符串时，可以通过前缀来判断字符串的编码类型，如果目标编码与原编码不同，则编译器会进行转换，比如C++11中的前缀u8表示目标编码为UTF-8的字符，如果代码文件采用的是GBK，编译器按照UTF-8去解析字符串常量，则可能会出现错误。</p>
<p>UTF-8编码的Unicode数据，C++11还是使用了8bits宽度的char类型数组来表示。</p>
<hr />

<p>类的成员函数是对类中数据成员操作的实现，成员函数也是函数的一种，和一般的函数一样。成员函数也可以定义函数类型，具有参数表，有返回类型。</p>
<p>在C++中，当一个函数成员被调用时，系统自动地传递一个隐含的参数给函数成员，该隐含参数是一个指向接收该函数调用的对象的指针，于是，函数成员就知道该对哪个对象进行操作。在程序中，可以使用关键字this来引用该指针，因而称为this指针。this是一个隐含于每一个类的成员函数中的特殊指针，该指针是一个指向正在被某个成员函数操作的对象的指针。</p>
<p>当对一个对象调用成员函数时，编译程序先将对象的地址赋给this指针，然后调用成员函数，每次成员函数存取数据成员时，则隐含使用this指针。通常不显式地使用this指针来引用数据成员，可以使用*this来标识调用该成员函数的对象。</p>
<hr />

<p>派生类的构造函数：不继承，其参数列表要考虑对基类及其本类的数据成员进行初始化，对基类数据成员的初始化在初始化列表中调用基类的成员函数。数据成员是对象时也要在初始化列表中调用初始化列表进行初始化，另外，const成员和reference成员也要在初始化列表中初始化，其它部分可以在构造函数的函数体中初始化。</p>
<pre>
#include &lt;iostream>
using namespace std;
#ifndef _SIZE_T_DEFINED
#ifdef _WIN64
typedef unsigned __int64 size_t;
#else
typedef _W64 unsigned int size_t;
#endif
#define _SIZE_T_DEFINED
#endif
void main()
{
    cout&lt;&lt;sizeof(size_t);
}
</pre>
<p>浅拷贝</p>
<p>实现对象间数据元素的一一对应复制。</p>
<p>深拷贝</p>
<p>当被复制的对象数据成员是指针类型时，不是复制该指针成员本身，而是将指针所指的对象进行复制。</p>
<p>何时需要虚析构函数？</p>
<p>当你可能通过基类指针删除派生类对象时</p>
<p>如果你打算允许其他人通过基类指针调用对象的析构函数（通过delete这样做是正常的），并且被析构的对象是有重要的析构函数的派生类的对象，就需要让基类的析构函数成为虚拟的。</p>
<p>为什么有的函数返回引用</p>
<p>如果一个函数的返回值是一个对象的值，它就被认为是一个常量，不能成为左值。</p>
<p>如果返回值为引用。由于引用是对象的别名，所以通过引用当然可以改变对象的值。</p>
<p>一个行为类似函数的对象，它可以不需参数，也可以带有若干参数，其功能是获取一个值，或者改变操作的状态。</p>
<p>任何普通的函数和任何重载了调用运算符operator()的类的对象都满足函数对象的特征</p>
<p>STL中也定义了一些标准的函数对象，如果以功能划分，可以分为算术运算、关系运算、逻辑运算三大类。为了调用这些标准函数对象，需要包含头文件<functional>。</p>
<p>异常接口声明</p>
<p>可以在函数的声明中列出这个函数可能抛掷的所有异常类型。</p>
<p>例如：</p>
<p>void fun() throw(A，B，C，D);</p>
<p>若无异常接口声明，则此函数可以抛掷任何类型的异常。</p>
<p>不抛掷任何类型异常的函数声明如下：</p>
<p>void fun() throw();</p>
<p>程序主要功能是描述数据和处理数据。</p>
<p>数据表现为常量和变量。所有的常量、变量都属于某种数据类型。类型决定了数据的操作方式。</p>
<p>对数据的读写通过内存访问实现。C++提供名访问和地址访问方式。可以通过指针变量间址访问所指对象。</p>
<p>引用是对象的别名。用引用访问对象与名访问方式一样。</p>
<p>关键字const用于约束对象为只读。</p>
<p>运算符表示了系统提供对基本数据的操作。表达式是由常量、变量和运算符连结起来，表达一个计算值的式子。</p>
<p>C++用标准流对象实现数据的输入和输出。输入语句，输出语句和表达式语句可以构成顺序执行的简单程序。</p>
<p>C++构成选择结构的条件语句有if语句和switch语句。</p>
<p>    if 语句适用于条件判断比较复杂的分支结构。嵌套if语句采用就近匹配的原则。   </p>
<p>    用括号{ }改变复合语句结构，可以改变if与else的匹配关系。</p>
<p>    switch语句根据一个表达式的不同可能值决定选择执行，适用于条件判断比较简单的多路选择。</p>
<p> 循环结构有whlie语句、do_while 语句和 for 语句。</p>
<p>    while语句和do_while语句主要用于条件循环。</p>
<p>    for语句是C++中很灵活的循环语句，既可以用于控制次数循环，也可以用于条件循环。</p>
<p> 转向语句是程序的流程控制的补充机制。C++的转向语句主要有：break、continue和goto语句。</p>
<p>内联函数是C++为降低小程序调用开销的一种机制 </p>
<p> 函数重载是以同一个名字命名多个函数实现版本</p>
<p>常数据成员是指数据成员在实例化被初始化后约束为只读。</p>
<p>常成员函数是指成员函数的this指针被约束为指向常量的常指针，函数体内不能修改数据成员的值。</p>
<p>当一元运算符的操作数，或者二元运算符的左操作数是类的一个对象时，以成员函数重载；当一个运算符的操作需要修改类对象状态时，应该以成员函数重载。如果以成友元函数重载，则使用引用参数修改对象。</p>
<p>当运算符的操作数（尤其是第一个操作数）希望有隐式转换，则重载算符时必须用友元函数。</p>
<p>构造函数和类型转换函数可以实现基本类型与类类型，以及类类型之间的类型转换。</p>
<p>多态性特别适合于实现分层结构的软件系统，便于对问题抽象时定义共性，实现时定义区别</p>
<p>在c语言中，“数据”和“处理数据的操作（函数）”是分开来声明的，也就是说，语言本身并没有支持“数据和函数”之间的关联性。在c++中，通过抽象数据类型（abstract data type，ADT），在类中定义数据和函数，来实现数据和函数直接的绑定。</p>
<p>先构造父类，再构造成员变量、最后构造自己</p>
<p>先析构自己，在析构成员变量、最后析构父类</p>
<p>C++中没有接口的概念</p>
<p>C++中可以使用纯虚函数实现接口</p>
<p>接口类只是一个功能说明，而不是功能实现。</p>
<p>子类需要根据功能说明定义功能实现。</p>

<hr />

<p>编译器会对函数模板进行两次编译</p>
<p>在声明的地方对模板代码本身进行编译；在调用的地方对参数替换后的代码进行编译。</p>
<p>可以这样声明和使用类模板：</p>
<p>1) 先写出一个实际的类。由于其语义明确，含义清楚，一般不会出错。</p>
<p>2) 将此类中准备改变的类型名(如int要改变为float或char)改用一个自己指定的虚拟类型名(如上例中的numtype)。</p>
<p>3) 在类声明前面加入一行，格式为：</p>
<p>    template <class 虚拟类型参数></p>
<p>如：</p>
<p>    template <class numtype> //注意本行末尾无分号</p>
<p>    class Compare</p>
<p>    {…}; //类体</p>

<hr />

<p>C++编译器通过throw 来产生对象，C++编译器再执行对应的catch分支，相当于一个函数调用，把实参传递给形参。</p>
<p>也有点类似于switch语句，throw定义值类型，catch类似case分句</p>
<p>cout流通常是传送到显示器输出，但也可以被重定向输出到磁盘文件，而cerr流中的信息只能在显示器输出。</p>
<p>由于文件设备并不像显示器屏幕与键盘那样是标准默认设备，所以它在fstream.h头文件中是没有像cout那样预先定义的全局对象，所以我们必须自己定义一个该类的对象。</p>
<p>stack是简单地装饰deque容器而成为另外的一种容器。</p>
<p>queue是简单地装饰deque容器而成为另外的一种容器。</p>
<p>priority_queue<int> p1; //默认是最大值优先级队列</p>
<p>	//priority_queue<int, vector<int>, less<int>> p1; //相当于这样写</p>
<p>	priority_queue<int, vector<int>, greater<int>> p2; //最小值优先级队列</p>
<p>ostrstream::str()返回的是char*</p><p>ostringstream::str()返回的是std::string</p><p>By default, an enum class has only assignment, initialization, and comparisons (e.g., == and <; §1.4) defined.</p><p>If you don’t want to explicitly qualify enumerator names and want enumerator values to be ints  (without the need for an explicit conversion), you can remove the class from enum class to get a  ‘‘plain’’ enum. The enumerators from a ‘‘plain’’ enum are entered into the same scope as the name  of their enum and implicitly converts to their integer value.</p><p>机器字长：CPU 一次能处理数据的位数，与 CPU 中的 寄存器位数 有关</p><p>bitset<4> bitset1; //无参构造，长度为４，默认每一位为０</p><p> bitset<8> bitset2(12); //长度为８，二进制保存，前面用０补充</p><p> bitset<10> bitset3(string("100101"));//长度为10，前面用０补充</p><p> bitset<13> bitset4("10101"); //长度为13，前面用０补充</p><p> cout &lt;&lt; bitset1 &lt;&lt; endl; //0000</p><p> cout &lt;&lt; bitset2 &lt;&lt; endl; //00001100</p><p> cout &lt;&lt; bitset3 &lt;&lt; endl; //0000100101</p><p> cout &lt;&lt; bitset4 &lt;&lt; endl; //0000000010101</p><p>成员函数和友元函数可以访问一个类的私有部分；</p><p>成员函数位于类的作用域之内；</p><p>非静态成员函数必须经由一个对象去激活；</p><p>标准容器并不是从一个公共基类派生的，迭代器也是如此；</p><p>vector<int> ved;</p><p>vecor<int>::iterator v = vec.begin();</p><p>while(v!=vec.end()){</p><p>    cout&lt;&lt;*v&lt;&lt;endl;</p><p>v++;}</p><p>一个字符集就是在字符与整数值之间的一种映射；</p><p>basic_string是一个模板类，string是模板形参为char的basic_string模板类的类型定义；</p><p>'basic_string<char, char_traits<char>, allocator<char> > string;</p><p>C语言的类型转换问题在于操作比较含糊，而C++的类型转换更容易更醒目；</p><p>构造函数应完成简单有效的功能，不应完成复杂的运算和大量的内存管理。	</p><p>如果该类有相当多的初始化工作，应生成专门的Init（…）函数，不能完全在构造函数中进行，因为构造函数没有返回值，不能确定初始化是否成功。</p><p>void setToNull(int *&tempPtr)</p><p>{</p><p>    tempPtr = nullptr; // use 0 instead if not C++11</p><p>}</p><p>int* p;</p><p>&tempPtr = p; //tempPtr is a int*</p><p>pass by address is actually just passing an address by value!</p><p></p><p>Therefore, we can conclude that C++ really passes everything by value! The properties of pass by address (and reference) comes solely from the fact that we can dereference the passed address to change the argument, which we can not do with a normal value parameter!</p><p>Advantages of passing by address:</p><p></p><p>Pass by address allows a function to change the value of the argument, which is sometimes useful. Otherwise, const can be used to guarantee the function won’t change the argument. (However, if you want to do this with a non-pointer, you should use pass by reference instead).</p><p>Because a copy of the argument is not made, it is fast, even when used with large structs or classes.</p><p>We can return multiple values from a function via out parameters.</p><p>Disadvantages of passing by address:</p><p></p><p>Because literals and expressions do not have addresses, pointer arguments must be normal variables.</p><p>All values must be checked to see whether they are null. Trying to dereference a null value will result in a crash. It is easy to forget to do this.</p><p>Because dereferencing a pointer is slower than accessing a value directly, accessing arguments passed by address is slower than accessing arguments passed by value.</p><p>When to use pass by address:</p><p></p><p>When passing built-in arrays (if you’re okay with the fact that they’ll decay into a pointer).</p><p>When passing a pointer and nullptr is a valid argument logically.</p><p>When not to use pass by address:</p><p></p><p>When passing a pointer and nullptr is not a valid argument logically (use pass by reference and dereference the pointer argument).</p><p>When passing structs or classes (use pass by reference).</p><p>When passing fundamental types (use pass by value).</p><p>As you can see, pass by address and pass by reference have almost identical advantages and disadvantages. Because pass by reference is generally safer than pass by address, pass by reference should be preferred in most cases.</p><p>When to use return by address:</p><p></p><p>When returning dynamically allocated memory</p><p></p><p>When returning function arguments that were passed by address</p><p></p><p>When not to use return by address:</p><p></p><p>When returning variables that were declared inside the function or parameters that were passed by value (use return by value)</p><p></p><p>When returning a large struct or class that was passed by reference (use return by reference)</p><p>When to use return by reference:</p><p></p><p>When returning a reference parameter</p><p></p><p>When returning an element from an array that was passed into the function</p><p></p><p>When returning a large struct or class that will not be destroyed at the end of the function (e.g. one that was passed in)</p><p></p><p>When not to use return by reference:</p><p></p><p>When returning variables that were declared inside the function or parameters that were passed by value (use return by value)</p><p></p><p>When returning a built-in array or pointer value (use return by address)</p><p></p><pre>#include &lt;functional>#include &lt;iostream> int foo(){    return 5;} int goo(){    return 6;} int main(){    std::function&lt;int()> fcnPtr = foo; // declare function pointer that returns an int and takes no parameters    fcnPtr = goo; // fcnPtr now points to function goo    std::cout &lt;&lt; fcnPtr(); // call the function just like normal     return 0;}</pre><p>auto fcnPtr = foo;</p><p>typedef bool (*validateFcn)(int, int);</p><p></p><p>bool validate(int x, int y, bool (*fcnPtr)(int, int)); // ugly</p><p></p><p>bool validate(int x, int y, validateFcn pfcn) // clean</p><p>void setID(int id) { m_id = id; }</p><p>is converted by the compiler into:</p><p></p><p></p><p>    void setID(Simple* const this, int id) { this->m_id = id; }</p><p>such as teacher and department class (aggregation), unlike persiona and head class(composition).</p><p>associations such as patient and doctor class.</p><p>提取方法：将大方法的一部分转换为便于理解的新方法；</p><p>提取类：将现有类的部分代码转移到新类中；</p><p>在C中，描述库函数的头文件是接口，在面向对象编程中，类的接口是公有属性和方法的集合；</p><p>标记（mark）和清扫（sweep）是一种垃圾回收方法。使用这种方法的垃圾回收器定期检查程序中的每个指针，并将指针引用的内存标记为仍在使用。在每一轮周期结束时，未标记的内存视为没有在使用，因而被释放。</p><p>1 在垃圾回收器中注册所有指针，这样就可以进行遍历操作；</p><p>2 让所有对象都从一个混入类中派生，允许垃圾回收器将对象标记为正在使用；</p><p>3 确保垃圾回收器运行时不能修改指针；</p>
<pre>#include &lt;iostream>#include &lt;memory>using namespace std;class Simple{public:	void go(){}};void leaky(){	Simple* p = new Simple();	p->go();	delete p;//如果go()抛出异常，delete得不到执行从而产生内存泄露}void notleaky(){	unique_ptr&lt;Simple> p(new Simple()); //c+11	p->go();}</pre><p>每个普通的方法调用都会传递一个指向对象的指针，这就是称为“ 隐藏”参数的this指针。使用这个指针可访问数据成员或者调用方法，也可将其传递给其他方法或函数。有时还用它来消除名称的歧义。</p><p>委托构造函数delegating constructors允许构造函数在初始化列表中调用同一个类的其他构造函数。</p><p>对象的移动语义move semantics需要实现移动构造函数move constructor和移动赋值函数运算符move assignment operator。如果源对象是操作结束后被销毁的临时对象，编译器就会使用这两个方法。这两个方法将数据成员从源对象移动到新对象，然后使源对象处于有效但不确定的状态。通常会将源对象的数据成员重置为空值。这样做实际上将内存和其他资源的所有权从一个对象移动到另一个对象。这两个方法基本上只对成员变量进行表层复制（shallow copy），然后转换已分配内存和其他资源的所有权，从而阻止悬挂指针和内存泄漏。</p><p>大多数情况下，应该使用引用而不是指针。对象的引用甚至可像指向对象的指针那样支持多态性。但也有一些情况下要求使用指针，一个例子是更改指向的位置，因为无法改变引用所指的变量。例如，动态分配内存时，应该将结果存储在指针而不是引用中。需要使用指针的另一种情况是可选参数，即指针参数可以定义为带默认值nullptr的可选函数，而引用参数不能这样定义。还有一种情况是要在容器中存储多态类型。</p><p>有一种方法可以判断使用指针还是引用作为参数和返回值：考虑谁拥有内存。如果接收变量的代码负责释放相关对象的内存，那么必须使用指向对象的指针，最好是智能指针，这是传递拥有权的推荐方式。如果接收变量的代码不需要释放内存，那么应该使用引用。</p><p>编译器必须在编译期间对constexpr函数求值，函数也不允许有任何副作用。</p><p>static_cast允许在继承层次中执行向下转换（指针或引用），但也不能将某种类型的指针转换为不相关的其他类型的指针。如果没有可用的转换构造函数，static_cast()无法将某种类型的对象直接转换为另一种类型的对象。</p><p>reinterpret_cast()在执行转换时不会执行任何类型检测。</p><p>static_cast()不执行运行期间的类型检测。dynamic_cast()为继承层次结构内的类型转换提供运行时检测。可用它转换指针或引用。dynamic_cast()在运行时检测底层对象的类型信息。如果类型转换没有意义，将会返回一个空指针（用于指针）或招聘一个std::bad_cast异常（用于引用）。</p><p>static_cast()或reinterpret_cast()沿着继承层次结构向下执行同样的类型转换。dynamic_cast()的不同之处在于它会执行运行时（动态）类型检测，而static_cast()或reinterpret_cast()甚至会不执行不正确的类型转换。</p><p>运行时类型信息存储在对象的虚函数表中。因此，为使用dynamic_cast()，类至少要有一个虚方法。如果类不具有虚函数表，常用使用dynamic_cast()将导致编译错误。</p><p>缓冲的流：不是立即将数据发送到目的地，而是缓冲输入的数据，然后以块的方式发送。</p><p>流不仅包含普通数据，还包含称为当前位置（current position）的特殊数据。当前位置指的是流将要进入下一次读写操作的位置。</p><p>流的三个公共的来源的目的地：控制台、文件和字符串；</p><p>流内建了标记化的功能。</p><p>从技术角度看，std::string是对std::basic_string模板进行char实例化的类型别名。</p><p>string提供一些边界检查、赋值语义以及比较操作，还有串联、子字符串提取以及子字符串或字符的替换。</p><p>标准库还提供string_view类，这是各类字符串表示的只读视图，可用于简单替换const string&&，而且不会带来开销，它从不复制字符串。</p><p>在STL中，只有pari和tuple允许存储异构元素；</p><p>C和C++程序员经常将一组标志位保存在单个int或long中，每个位对应一个标志。程序员通过按位运算符设置和访问这些位。C++标准库提供了bitset类，这个类抽象了这些位操作，因此再也不需要使用这些位运算符。</p><p>bitset有固定大小，不支持固定迭代器。可将bitset想象为可以读写的布尔值序列，不局限于int或其他基本数据类型的大小。</p><p>函数不可以嵌套定义，但可以嵌套lambda表达式；</p><p>使用UTF-8时中，一个Unicode字符编码为1－4个char.</p><p>using string basic_string<char>;</p><p>using wstring basic_string<wchar_t>;</p><p>using u16string basic_string<char16_T>;</p><p>using u32string basic_string<char32_T>;</p><p>In C++14, we can assign binary literals by using the 0b prefix:</p>
<pre>void printInteger(const int myValue){    std::cout &lt;&lt; myValue;}const int usersAge { age }; // usersAge can not be changed</pre><p>Runtime constants are those whose initialization values can only be resolved at runtime (when your program is running). Variables such as usersAge and myValue in the snippets above are runtime constants, because the compiler can’t determine their initial values at compile time. usersAge relies on user input (which can only be given at runtime) and myValue depends on the value passed into the function (which is only known at runtime). However, once initialized, the value of these constants can’t be changed.</p>
<pre>#include &lt;iostream> int main(){ // start outer block     int x(5);     { // start nested block        int y(7);        // we can see both x and y from here        std::cout &lt;&lt; x &lt;&lt; " + " &lt;&lt; y &lt;&lt; " = " &lt;&lt; x + y;    } // y destroyed here     // y can not be used here because it was already destroyed!     return 0;} // x is destroyed here</pre><p>垃圾回收可能也会引发一些问题，如当垃圾回收器运行时，程序可能会停止响应。析构函数具有不确定性。</p><p>When you should use namespaces</p><p>When you write a library or code that you want to share otherwise, place the code inside a namespace. You can’t know what the environment your code will be used in looks like, which can quickly lead to conflicting names. Placing library code inside a namespace also allows the user to see the contents of your library by using their editor’s auto-complete and suggestion feature.</p><p>In applications, namespaces can be used to separate application code and code that could be split off into a library. For example helper functions for strings and localization or math. The application needs those, but they could be replaced by a library or used in another project.</p><p>cin</p><pre>#include &lt;string>#include &lt;iostream> int main(){    std::cout &lt;&lt; "Pick 1 or 2: ";    int choice=0;    std::cin &gt;&gt; choice;	// cin actually gets the string "1\n" or "2\n". 						// It then extracts the 2 to variable choice, 						// leaving the newline stuck in the input stream. 	//std::cin.ignore(32767, '\n'); // ignore up to 32767 characters until a \n is removed    std::cout &lt;&lt; "Now enter your name: ";    std::string name="";    std::getline(std::cin, name); // name only get '\n'     std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; ", you picked " &lt;&lt; choice &lt;&lt; '\n';	system("pause");    return 0;}</pre><p>enum class 可以避免枚举常量的命名冲突。</p>
<pre>int main(){    enum class Color // "enum class" defines this as a scoped enumeration instead of a standard enumeration    {        RED, // RED is inside the scope of Color        BLUE    };     enum class Fruit    {        BANANA, // BANANA is inside the scope of Fruit        APPLE    };     Color color = Color::RED; // note: RED is not directly accessible any more, we have to use Color::RED    Fruit fruit = Fruit::BANANA; // note: BANANA is not directly accessible any more, we have to use Fruit::BANANA	    if (color == fruit) // compile error here, as the compiler doesn't know how to compare different types Color and Fruit        std::cout &lt;&lt; "color and fruit are equal\n";    else        std::cout &lt;&lt; "color and fruit are not equal\n";     return 0;}</pre><p>exit(0); // terminate and return 0 to operating system</p><p>C++理论上用面相对象的思维构建程序更好。对于一个稍微大型一些的项目，最上层应该是App对象，用于整个程序的启动，视情况看是否需要持续运行而搞定事件循环。先设计好各种系统支撑类，如配置文件相关，日志相关，命令行参数解析相关，多线程管理，异步队列，插件模型等。接下来就是业务功能相关类的抽象，并考虑如何结合到App中初始化并运行。搭积木更适合大型程序的构建方式，即可以优先构造下级模块，也可以先定义接口组装模块再逐步实现下级功能。</p><p>It is sometimes the case that we know we want a loop to execute at least once, such as when displaying a menu. To help facilitate this, C++ offers the do-while loop:</p><pre>int selection;     do    {        std::cout &lt;&lt; "Please make a selection: \n";        std::cout &lt;&lt; "1) Addition\n";        std::cout &lt;&lt; "2) Subtraction\n";        std::cout &lt;&lt; "3) Multiplication\n";        std::cout &lt;&lt; "4) Division\n";        std::cin &gt;&gt; selection;    }    while (selection != 1 && selection != 2 &&        selection != 3 && selection != 4);     // do something with selection here    // such as a switch statement</pre><p>For loops in old code</p><p>In older versions of C++, variables defined as part of the init-statement did not get destroyed at the end of the loop. This meant that you could have something like this:</p><pre>for (int count=0; count &lt; 10; ++count) // count defined here    std::cout &lt;&lt; count &lt;&lt; " "; // count is not destroyed in older compilers std::cout &lt;&lt; "\n";std::cout &lt;&lt; "I counted to: " &lt;&lt; count &lt;&lt; "\n"; // so you can still use it here</pre><p>This use has been disallowed, but you may still see it in older code.</p><p>compelling reason to use C-style strings, use std::string (defined in the <string> header) instead. std::string is easier, safer, and more flexible.</p><p>Prefer std::string_view over std::string for read-only strings, unless you already have a std::string.</p><p>dereference ptr (get the value that ptr is pointing to)</p><p>This is why pointers must have a type. Without a type, a pointer wouldn’t know how to interpret the contents it was pointing to when it was dereferenced. It’s also why the type of the pointer and the variable address it’s being assigned to must match. If they did not, when the pointer was dereferenced, it would misinterpret the bits as a different type.</p><p>One of the most annoying issues with C-style arrays is that in most cases they decay to pointers when evaluated. However, if a C-style array is passed by reference, this decaying does not happen.</p><pre>#include &lt;iostream>// Note: You need to specify the array size in the function declarationvoid printElements(int (&arr)[4]){	int length = sizeof(arr)/sizeof(arr[0]); // we can now do this since the array won't decay		for (int i=0; i &lt; length; ++i)	{		std::cout &lt;&lt; arr[i] &lt;&lt; " ";	}}</pre><p>Normally r-values have expression scope, meaning the values are destroyed at the end of the expression in which they are created.</p><p>std::cout &lt;&lt; 2 + 3; // 2 + 3 evaluates to r-value 5, which is destroyed at the end of this statement</p><p>However, when a reference to a const value is initialized with an r-value, the lifetime of the r-value is extended to match the lifetime of the reference.</p><pre>int somefcn(){    const int &ref = 2 + 3; // normally the result of 2+3 has expression scope and is destroyed at the end of this statement    // but because the result is now bound to a reference to a const value...    std::cout &lt;&lt; ref; // we can use it here} // and the lifetime of the r-value is extended to here, when the const reference dies</pre><p>int (*array)[5] = new int[10][5];</p><p>二维动态数组与二维指针</p><pre>int (*array1)[5] = new int[10][5];int *array2 = new int[50]; // a 10x5 array flattened into a single arrayint **array = new int*[10]; // allocate an array of 10 int pointers — these are our rowsfor (int count = 0; count &lt; 10; ++count)    array[count] = new int[5]; // these are our columnsfor (int count = 0; count < 10; ++count)    delete[] array[count];delete[] array; // this needs to be done last</pre><p>std::array, accessing array elements can be done via the [] operator (which does no bounds checking) or the at() function (which does bounds checking):</p><p>array[6] = 2; // no bounds checking</p><p>array.at(7) = 3; // does bounds checking</p><p>array provides all of the functionality of C++ built-in arrays (and more) in a form that won’t decay into a pointer. These should generally be preferred over built-in fixed arrays.</p><p>Default parameters won’t work for functions called through function pointers. Default parameters are resolved at compile-time (that is, if you don’t supply an argument for a defaulted parameter, the compiler substitutes one in for you when the code is compiled). However, function pointers are resolved at run-time. Consequently, default parameters can not be resolved when making a function call with a function pointer. You’ll explicitly have to pass in values for any defaulted parameters in this case.</p><p>One nuance of C++ that is often missed or misunderstood is that access control works on a per-class basis, not a per-object basis.</p><p>经常忽略或误解的C++的一个细微差别是，访问控制在每个类的基础上工作，而不是基于每个对象。</p><p>Note that if you use the exit() function, your program will terminate and no destructors will be called. Be wary if you’re relying on your destructors to do necessary cleanup work (e.g. write something to a log file or database before exiting).</p><p>class</p><p>1 base address, a calss namespace;</p><p>2 class access, including static and friend member;</p><p>3 member function how to operato member data, cincluding initialization, clean up dynamic memory, copy, assign, move, etc.</p><p>It turns out that there are three different ways to overload operators: the member function way, the friend function way, and the normal function way.</p><p>##将参数连接到一起。</p><p>Note that there’s no confusion between the negative operator- and the minus operator- since they have a different number of parameters.</p><p>Don’t define overloaded operators that don’t make sense for your class.</p><p>Operator() is also commonly overloaded to implement functors (or function object), which are classes that operate like functions. The advantage of a functor over a normal function is that functors can store data in member variables (since they are classes).</p><p>public members can be accessed by anybody. Private members can only be accessed by member functions of the same class or friends. This means derived classes can not access private members of the base class directly!</p><p>Remember that derived has a Base part and a Derived part. When we assign a Derived object to a Base object, only the Base portion of the Derived object is copied. The Derived portion is not.</p><p>Remember that derived has a Base part and a Derived part. When we assign a Derived object to a Base object, only the Base portion of the Derived object is copied. The Derived portion is not. In the example above, base receives a copy of the Base portion of derived, but not the Derived portion. That Derived portion has effectively been “sliced off”. Consequently, the assigning of a Derived class object to a Base class object is called object slicing (or slicing for short).</p><p>Catch parameters work just like function parameters, with the parameter being available within the subsequent catch block. Exceptions of fundamental types can be caught by value, but exceptions of non-fundamental types should be caught by const reference to avoid making an unnecessary copy.</p><p>try blocks catch exceptions not only from statements within the try block, but also from functions that are called within the try block.</p><p>gives us a chance to print an error of our choosing and then save the user’s state before exiting.</p><p>However, later, the const keyword was added to the language, and l-values were split into two sub-categories: modifiable l-values, which can be changed, and non-modifiable l-values, which are const.</p><p>如果忘记delete，则nudePtr超出作用域时自动释放，</p><p>	释放的是自身，其指向的动态内存却再也没有机会释放，造成动态内存泄漏</p><p>	res2超出作用域时会自动在栈上释放，同时会调用析构函数，delete m_ptr，释放堆上内存</p><p>	封装的指针（智能指针）在释放自身（栈）的同时释放了其成员指针指向的动态内存（堆内存）</p><p>	裸指针释放自身（栈）的同时却让其指向的动态内存失去了释放的机会（如果没有delete）</p><p>	delete的不是nudePtr本身（本身超出作用域会自动在栈上释放），</p><p>	delete针对的是其指向的堆内存，其实本质上也没有delete，只是标识为可重新链接的堆内存。</p><p>内存泄漏，最怕的是异常流程引起的内存泄漏。</p><p>对于异常，最怕的是用户的数据还没有保存，程序导致关闭，这是非常不好的体验。</p><p>However, if we construct an object or do an assignment where the argument is an r-value, then we know that r-value is just a temporary object of some kind. Instead of copying it (which can be expensive), we can simply transfer its resources (which is cheap) to the object we’re constructing or assigning. This is safe to do because the temporary will be destroyed at the end of the expression anyway, so we know it will never be used again!</p><p>STL also provides a number of generic algorithms for working with the elements of the container classes. These allow you to do things like search, sort, insert, reorder, remove, and copy elements of the container class.</p><p>stl算法：</p><p>std作为名字空间；</p><p>一般都有迭代器做为参数：</p><p>std::sort(vect.begin(), vect.end());</p><p>All string functionality in the standard library lives in the <string> header file. To use it, simply include the string header:</p><p>    #include &lt;string></p><p>There are actually 3 different string classes in the string header. The first is a templated base class named basic_string<>:</p><p>namespace std</p><p>{</p><p>    template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> ></p><p>        class basic_string;</p><p>}</p><p>You won’t be working with this class directly, so don’t worry about what traits or an Allocator is for the time being. The default values will suffice in almost every imaginable case.</p><p>There are two flavors of basic_string<> provided by the standard library:</p><p>namespace std</p><p>{</p><p>    typedef basic_string<char> string;</p><p>    typedef basic_string<wchar_t> wstring;</p><p>}</p><p>string sString("MyString");</p><p>cout &lt;&lt; sString.max_size() &lt;&lt; endl;//4294967293</p><p>reallocation process</p><p>1 allocated memory;</p><p>2 copy string;</p><p>3 deallocated memory;</p><p>finally ,got a new address.</p><p>Some devices, such as files and networks, are capable of being both input and output sources.</p><p>cin.ignore(32767, '\n'); // clear out any additional input from the stream</p><p>One interesting note is that std::endl; also flushes the output stream. Consequently, overuse of std::endl (causing unnecessary buffer flushes) can have performance impacts when doing buffered I/O where flushes are expensive (such as writing to a file). For this reason, performance conscious programmers will often use ‘\n’ instead of std::endl to insert a newline into the output stream, to avoid unnecessary flushing of the buffer.</p>
<p>1	文件布局</p>
<p>1.1 遵循统一的布局顺序来书写头文件。</p>
<p>头文件布局:</p><p>          文件头（参见第三章“注释”）</p><p>#ifndef 文件名_H（全大写）</p><p>#define 文件名_H</p><p>其它条件编译选项</p><p>          #include（依次为标准库头文件、非标准库头文件）</p><p>常量定义</p><p>          全局宏</p><p>          全局数据类型</p><p>          类定义</p><p>模板（template）（包括C++中的类模板和函数模板）</p><p>全局函数原型</p><p>#endif</p>
<p>1.2 遵循统一的布局顺序来书写实现文件</p><p>实现文件布局：</p><p>          文件头（参见第三章“注释”）</p><p>          #include（依次为标准库头文件、非标准库头文件）</p><p>          常量定义</p><p>          文件内部使用的宏</p><p>          文件内部使用的数据类型</p><p>全局变量</p><p>本地变量（即静态全局变量）</p><p>          局部函数原型</p><p>类的实现</p><p>          全局函数</p><p>局部函数</p>

<p>遵循统一的顺序书写类的定义及实现</p>
<p>类的定义（在定义文件中）按如下顺序书写：</p>
<p>    公有属性</p>
<p>    公有函数</p>
<p>    保护属性</p>
<p>    保护函数</p>
<p>    私有属性</p>
<p>    私有函数</p>


<p>类的实现（在实现文件中）按如下顺序书写：</p>
<p>    构造函数</p>
<p>析构函数</p>
<p>公有函数</p>
<p>保护函数</p>
<p>私有函数</p>
<p>声明类的时候，public、protected、private关键字与分界符{} 对齐，这些部分的内容要进行缩进。</p><p>一个变量有且只有一个功能，不能把一个变量用作多种用途。</p><p>一条语句只完成一个功能。</p><p>对于有返回值的函数，每一个分支都必须有返回值。</p><p>函数的功能要单一，不要设计多用途的函数。</p><p>必须对所调用函数的错误返回值进行处理。</p><p>构造函数应完成简单有效的功能，不应完成复杂的运算和大量的内存管理。	</p><p>如果该类有相当多的初始化工作，应生成专门的Init（…）函数，不能完全在构造函数中进行，因为构造函数没有返回值，不能确定初始化是否成功。</p><p>断言是用来处理不应该发生的错误情况的，对于可能会发生的且必须处理的情况要写防错程序，而不是断言。如某模块收到其它模块或链路上的消息后，要对消息的合理性进行检查，此过程为正常的错误检查，不能用断言来实现。</p><p>指向指针的指针及更多级的指针必须逐级检查。</p><p>使用断言检查函数输入参数的有效性、合法性。</p><p>对所有具有返回值的接口函数的返回结果进行断言检查。</p><p>流（Streams）</p><p>只在记录日志时使用流。</p><p>定义：流是printf()和scanf()的替代。</p><p>优点：有了流，在输出时不需要关心对象的类型，不用担心格式化字符串与参数列表不匹配（虽然在gcc中使用printf也不存在这个问题），打开、关闭对应文件时，流可以自动构造、析构。</p><p>缺点：流使得pread()等功能函数很难执行，如果不使用printf之类的函数而是使用流很难对格式进行操作（尤其是常用的格式字符串%.*s），流不支持字符串操作符重新定序（%1s），而这一点对国际化很有用。</p><p>结论：</p><p>不要使用流，除非是日志接口需要，使用printf之类的代替。</p><p>使用流还有很多利弊，代码一致性胜过一切，不要在代码中使用流。</p><p>对象的状态：对象的数据成员，对象的成员函数可以分为：修改状态的成员函数和访问状态的成员函数。</p><p>封装有修改全局变量的函数要小心了，因为封装的目的是重用，重用会造成对全局变量的不可控，特别是当全局变量用做数组下标时。</p><p>赋值式初始化的限制：</p><p>1 如果一个对象需要两个入参呢？，不支持需要多个入参的构造。（其构造函数有两个参数）；</p><p>2 堆对象的双重初始化：int* p = new int(5);</p><p>int a=3;</p><p>int b=4;</p><p>int c=a+b;</p><p>CPU计算a+b，即不能借用a和b的内存，也不能借用赋值目标c的内存，总得有个临时存储位置吧？这位置可能是某块临时内存，也可能是某些个寄存器。</p><p>动作数据化的三种方法：</p><p>1 函数指针；</p><p>2 函数对象；</p><p>3 Lambda函数；</p><p>工厂函数：一种外部构造函数，称为“工厂式”构造的思路。将构造函数私有化，再通过友元函数以实现在特定场合创建出唯一的并且不允许复制的对象。</p><p>The make_shared() version mentions X only once, so it is usually shorter (as well as faster) than the version with the explicit new.</p><p>引用计数的出现，解决了对象独占的问题，但是也带来了循环引用的困扰，使用weak_ptr可以打破这种循环。</p><p>weak_ptr本身设计的很简单，就是为了辅助shared_ptr的，它本身不能直接定义指向原始指针的对象，只能指向shared_ptr对象，同时也不能将weak_ptr对象直接赋值给shared_ptr类型的变量，最重要的一点是赋值给它不会增加引用计数。</p><p>测试weak_ptr常用函数的用法</p><p>weak_ptr中只有函数lock和expired两个函数比较重要，因为它本身不会增加引用计数，所以它指向的对象可能在它用的时候已经被释放了，所以在用之前需要使用expired函数来检测是否过期，然后使用lock函数来获取其对应的shared_ptr对象，然后进行后续操作。</p><p>weak_ptr虽然是一个模板类，但是不能用来直接定义指向原始指针的对象。</p><p>weak_ptr接受shared_ptr类型的变量赋值，但是反过来是行不通的，需要使用lock函数。</p><p>weak_ptr设计之初就是为了服务于shared_ptr的，所以不增加引用计数就是它的核心功能。</p><p>由于不知道什么之后weak_ptr所指向的对象就会被析构掉，所以使用之前请先使用expired函数检测一下。</p><p>Any type (including primary template or specialization) that overloads unary * and -> is considered a smart pointer:</p><p>If it is copyable, it is recognized as a reference-counted shared_ptr.</p><p>If it is not copyable, it is recognized as a unique unique_ptr.</p><p>Functions can't capture local variables or be defined at local scope; if you need those things, prefer a lambda where possible, and a handwritten function object where not. On the other hand, lambdas and function objects don't overload; if you need to overload, prefer a function (the workarounds to make lambdas overload are ornate). If either will work, prefer writing a function; use the simplest tool necessary.</p><p>函数无法使用函数体外部的局部变量，也不能定义在局部作用域；如果你需要这方面功能，如果可能的话使用lambda表达式是较好的选择，否则需要自己实现函数对象。另一方面，lambda表达式和函数对象无法实现重载；如果你需要重载，函数更合适（通过折腾让lambda表达式重载的方法太高级）。如果两种方式都可用，用函数更好；使用满足需要的，最简单的工具。</p><p>std::cin.clear(); // reset any error flags</p><p>std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // ignore any characters in the input buffer until we find a newline</p><p>std::cin.get(); // get one more char from the user</p><p>Operators can be chained together such that the output of one operator can be used as the input for another operator.</p><p>local variables have the same definitions for scope and lifetime.</p><p>Whitespace is a term that refers to characters that are used for formatting purposes. In C++, this refers primarily to spaces, tabs, and newlines.</p><p>By default, non-const variables declared outside of a function are assumed to be external. However, const (and constexpr) variables declared outside of a function are assumed to be internal.</p><p>test</p><p>խ</p><p>test</p><p>窄</p><p>סҡ졢ɡ</p><p>string szU8 = WideChar2narrow(newstr,u8Len);</p><p>甲、乙、丙、丁、戊、己、庚、辛、壬、癸</p><p>All memory allocated on the stack is known at compile time. Consequently, this memory can be accessed directly through a variable.</p><p>指针可以指向一个编译时确定的对象（栈对象），也可以指定一个运行时确定的对象（堆对象）。</p><p>内置类做数据成员的类的类型。</p><p>在C++11中，<chrono>是标准模板库中与时间有关的头文件。该头文件中所有函数与类模板均定义在std::chrono命名空间中。</p><p>Typically, we won’t be able to use a member overload if the left operand is either not a class (e.g. int), or it is a class that we can’t modify (e.g. std::ostream).</p><p>The advantage of a functor over a normal function is that functors can store data in member variables (since they are classes).</p><p>Binding refers to the process that is used to convert identifiers (such as variable and function names) into addresses.</p><p>However, the advantage of late binding is that it is more flexible than early binding, because decisions about what function to call do not need to be made until run time.</p><p>A pure virtual function makes it so the base class can not be instantiated, and the derived classes are forced to define these functions before they can be instantiated. This helps ensure the derived classes do not forget to redefine functions that the base class was expecting them to.</p><p>An interface class is one with no member variables and all pure virtual functions.</p><p>An import library is a library that automates the process of loading and using a dynamic library.</p><p>std::unique_ptr is the C++11 replacement for std::auto_ptr. It should be used to manage any dynamically allocated object that is not shared by multiple objects. That is, std::unique_ptr should completely own the object it manages, not share that ownership with other classes.</p><p>Remember, when a std::shared pointer goes out of scope, it only considers whether other std::shared_ptr are co-owning the object. std::weak_ptr does not count!</p><p>C和C++的缺点就是需要写大量的内存管理代码，这是相对于Java的缺点。</p><p>STL的迭代器类总是内置在容器类中，所以定义迭代器时，总是需要前置容器类和一个域解析符。</p><p>STL中对于vector的iterator类定义，其实质是用裸指针实现category，另外还有定义的是value-type、iterator-range等。</p><p>函数对象，是一个对象在调用一个函数，这个函数叫operator()。</p><p>成员函数与友元函数，友元可以访问类的私有数据，但需增加类对象的入参，而成员函数隐含了一个this指针参数。this指针指向类对象，因为成员函数是在对象建立后才可以调用的。所以静态成员函数不隐含this指针，因为其不依赖于对象调用，可以是类对象调用。</p><p>封闭的概念，将函数定义到结构体内，同时成员具有访问控制，从而实现了信息隐藏。</p><p>Elements in associative containers are referenced by their key and not by their absolute position in the container.</p><p>深拷贝解决浅拷贝的问题，移动复制解决深拷贝的问题。</p><p>内部类：只给外部类的成员函数使用，可以定义为内部类为private，这也是一种封装和隐藏。如STL中窗口的迭代器类就是定义在容器类内的。</p><p>重载运算符的规则如下：</p><p>① c++不允许用户自己定义新的运算符，只能对已有的c++运算符进行重载；</p><p>② c++不能重载的运算符只有5个；</p><p>③ 重载不能改变运算符运算对象的个数；</p><p>④ 重载不能改变运算符的优先级和结合性；</p><p>⑤ 重载运算符的函数不能有默认的参数； </p><p>⑥ 重载的运算符必须和用户定义的自定义类型的对象一起使用，至少应有一个是类对象，即不允许参数全部是C++的标准类型。</p><p>运算符重载的一些规则： </p><p>① 一般情况下，单目运算符最好重载为类的成员函数，双目运算符则最好重载为类的友元函数；</p><p>② 双目运算符=、()、[]、-&gt;不能重载为类的友元函数； </p><p>③ 类型转换函数只能定义为一个类的成员函数，而不能定义为类的友元函数； </p><p>④ 若一个运算符的操作需要修改对象的状态，选择重载为成员函数较好；</p><p>⑤ 若运算符所需的操作数(尤其是第一个操作数)希望有隐式类型转换，则只能选用友元函数；</p><p>⑥ 当运算符函数是一个成员函数时，最左边的操作数(或者只有最左边的操作数)必须是运算符类的一个类对象(或者是对该类对象的引用)；如果左边的操作数必须是一个不同类的对象，或者是一个内部类型的对象，该运算符函数必须作为一个友元函数来实现。</p><p>掌握C++，怎样才算是入了一个门呢？</p><p>1 能够自己比较优雅地实现字符串操作函数；</p><p>2 实现字符串类；</p><p>3 实现智能指针，如shared_ptr；</p><p>4 实现迭代器</p><p>具有加载和运行功能的监控程序是操作系统的原型。</p>