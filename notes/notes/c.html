<!DOCTYPE html PUBLIC "-//W3C//DTD XTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<base target="_blank" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>摘录PCnotes</title>
<script type="text/javascript">
var userAgent = navigator.userAgent.toLowerCase();
var browser = 
	(browser = userAgent.match(/qqbrowser\/([\d.]+)/))?"qqbrowser/"+browser[1]:
	(browser = userAgent.match(/se\s+2.x/))?"sogou/2.x": //sougou
	(browser = userAgent.match(/msie\s+([\d.]+)/))?"msie/"+browser[1]: //ie
	(browser = userAgent.match(/chrome\/([\d.]+)/))?"chrome/"+browser[1]: //chrome
	(browser = userAgent.match(/firefox\/([\d.]+)/))?"firefox/"+browser[1]: //firefox
	(browser = userAgent.match(/version\/([\d.]+)\s+safari\/([\d.]+)/))?"safari/"+browser[1]: //safari
	(browser = userAgent.match(/opera\/([\d.]+)([\w\W]+)version\/([\d.]+)/))?"opera/"+browser[3]: //opera
	"other browser";
	var browser4 = browser.substr(0,2);
//实现回到页面顶部  
function goTopEx(){  
	var obj=document.getElementById("goTopBtn"); 
	var obj2=document.getElementById("shangy"); 
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");  
	
	function getScrollTop(){  
		if(browser4=="ch"){
			//谷歌浏览器
			//chrome63.0.3239.132对DTD XHTML 1.0不再支持body.scrollTop属性，只支持documentElement.scrollTop属
			return document.documentElement.scrollTop; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.scrollTop;  
		}  
	}
	function setScrollTop(value){ 
		if(browser4=="ch"){ 
			//谷歌浏览器
			document.documentElement.scrollTop=value; 
		}else{  
			//IE、firefox等浏览器
			document.documentElement.scrollTop=value;  
		} 
	}     
	window.onscroll=function(){getScrollTop()>50?obj.style.display="":obj.style.display="none";
	getScrollTop()>100?obj2.style.display="":obj2.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj3.style.display="":obj3.style.display="none";
	document.body.clientHeight-getScrollTop()>650?obj4.style.display="":obj4.style.display="none";
	}  
	obj.onclick=function(){  
		var goTop=setInterval(scrollMove,10);  
		function scrollMove(){  
				setScrollTop(getScrollTop()/1.1);  
				if(getScrollTop()<1)clearInterval(goTop);  
		}  
	}  
}  
function downn(){
	if(browser4=="ch"){
		//谷歌浏览器
		window.scrollBy(0,document.body.clientHeight);
	}else{
		//IE、firefox等浏览器  
		window.scrollBy(0,document.documentElement.clientHeight*1000); 
	}
}document.write('<div style="position:fixed; right: 10px; top:20px; color:#eee;">背景颜色<br><select name=bcolor id=bcolor onchange="javascript:document.body.style.background=this.options[this.selectedIndex].value;"><option style="background-color: #ffffff" value="#ffffff">白色</option><option style="background-color: #f6f6f6" value="#f6f6f6">银灰</option><option style="background-color: #e4ebf1" value="#e4ebf1">淡蓝</option><option style="background-color: #e6f3ff" value="#e6f3ff">蓝色</option> <option style="background-color: #eeeeee" value="#eeeeee">淡灰</option><option style="background-color: #eaeaea" value="#eaeaea">灰色</option>  <option style="background-color: #e4e1d8" value="#e4e1d8">深灰</option><option style="background-color: #e6e6e6" value="#e6e6e6">暗灰</option><option style="background-color: #eefaee" value="#eefaee">绿色</option><option style="background-color: #ffffed" value="#ffffed">明黄</option><option style="background-color: #333333" value="#333333">黑色</option></select><br>字体颜色<br><select name=txtcolor id=txtcolor onchange="javascript:document.getElementById(\'container\').style.color=this.options[this.selectedIndex].value;"> <option value="#000000">黑色</option><option value="#ff0000">红色</option><option value="#006600">绿色</option><option value="#0000ff">蓝色</option><option value="#660000">棕色</option><option value="#ffffff">白色</option></select><br>字体大小<br><select name=fonttype id=fonttype onchange="javascript:document.getElementById(\'container\').style.fontSize=this.options[this.selectedIndex].value;"> <option value="12px" >小号</option> <option value="14px" >较小</option> <option value="19px" >中号</option> <option value="19px" >默认</option><option value="22px" >较大</option><option value="25px" >大号</option><option value="35px" >35px</option><option value="45px" >45px</option><option value="55px" >55px</option><option value="65px" >65px</option><option value="75px" >75px</option><option value="85px" >85px</option><option value="95px" >95px</option></select></div>');   
</script>
<style type="text/css">
#tbrowser a:linked container a:visited{
	font-size:18px;
	text-decoration:none;
}
a:link{
	text-decoration:none;
	}
#container{
	font-size:1.2em;
	margin:auto;
	font-family:"宋体";
	width:40em;
	line-height:1.6em;
}
P{
	margin-top:16px;
	margin-bottom:16px;
	text-indent:2em;
}
.uls{
	color:#CC6666;
	font-weight:bold;
}
.uls>ol{
	list-style:none;
	font-weight:normal;
	list-style:lower-latin;
	color:#000000;
	line-height:1.3em;
}
h2{
	font-size:20px;
	font-weight:bold;
	margin-top:15px;
	margin-bottom:0px;
	text-indent:0em;
}#goTopBtn, #goBottom, #shangy, #xiay, #ftsize1, #ftsize2, #ftsize3{
	width: 18px;
    line-height: 1.2;
    padding: 5px 0;
    font-size: 12px;
    text-align: center;
    position: fixed;
	right: 10px;
    cursor: pointer;
    filter: Alpha(opacity=30);
	opacity=.3;
	font-weight:bold;
}
#goTopBtn, #goBottom, #ftsize1, #ftsize3  {
    background-color:#999;
    color:#000;
}
#shangy, #xiay, #ftsize2{
    background-color: #bbb;
    color: #000;
}
#ftsize1{
	bottom:240px;
}
#ftsize2{
	bottom:214px;
}
#ftsize3{
	bottom:188px;
}#goTopBtn{
    bottom: 105px;
}
#goBottom {
    bottom: 30px;
}
#shangy {
    bottom: 80px;
}
#xiay {
    bottom: 55px;
}
#goTopBtn:hover, #goBottom:hover, #shangy:hover, #xiay:hover, #ftsize1:hover, #ftsize2:hover, #ftsize3:hover{
	background-color:#ccc;
	border:#ccc 0px solid;
}
#goTopBtn a:link, #goBottom a:link, #xiay a:link, #shangy a:link, #ftsize1 a:link, #ftsize2 a:link, #ftsize3 a:link {
	text-decoration: none;
	color:white;
}
img{
	margin-right:2em;
	text-indent:2em;
	border:0;
}
.picsay{
	color:#930;
	font-size:90%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
}
.remark{
	color:#930;
	font-size:90%;
	line-height:140%;
	margin-top:-12px;
	text-indent:0em;
	padding:0;
}
.ref{
	color:#930;
	font-size:95%;
	line-height:150%;
	margin-top:-12px;
	text-indent:2em;
	padding:0;
}
pre{
	font-size:100%;
	line-height:130%;
	padding:0;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	//background-color:#ffe;
	background-color:#eee;
	}
.code0, .code2, .code4{
	font-size:95%;
	line-height:110%;
	margin-top:-12px;
	padding:0;
	//background-color:#D9D1CA;
	//background-color:#f6f6f6;
	//background-color:#fff5ee;
	background-color:#ffe;
}
.code0{
	color:red;
	text-indent:0em;
}
.code2{
	color:#930;
	text-indent:2em;
}
.code4{
	color:blue;
	text-indent:4em;
}
sub,sup{
	font-size:80%;
	color:red;
}
</style></head><body onLoad="downn();">
<div>
<script type=text/javascript>
	goTopEx();
	function xiay(){
		window.scrollBy(0,window.innerHeight-10);
	}
	function shangy(){
		window.scrollBy(0,-window.innerHeight+10);
	}
	var obj3=document.getElementById("xiay");
	var obj4=document.getElementById("goBottom");
	function getHeight(){  
		if(browser4=="ch"){
			//谷歌浏览器
			return document.body.clientHeight; 
		}else{
			//IE、firefox等浏览器 
			return document.documentElement.clientHeight;  
		}  
	}
	getHeight()<window.innerHeight+50?obj3.style.display="none":obj3.style.display="";
	getHeight()<window.innerHeight+50?obj4.style.display="none":obj4.style.display="";
	//if(browser4!="ch"){	//firefox需要尝一下才显示向下图标
		xiay();
		shangy();
	//}
</script>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.4em";' target="_self" style="color:#fff;" title="大：1.4em"><div id="ftsize1" style="color:#fff;">大</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.2em";' target="_self" style="color:#fff;" title="中：1.2em"><div id="ftsize2" style="color:#fff;">中</div></a>
<a id="ftsizea" onclick='document.getElementById("container").style.fontSize = "1.0em";' target="_self" style="color:#fff;" title="小：1em"><div id="ftsize3" style="color:#fff;">小</div></a><a target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="goTopBtn">&and;</div></a>
<a onClick="shangy()" target="_self" style="color:#fff;"><div style="display:none; color:#fff;" id="shangy">&uarr;</div></a>
<a onClick="xiay()" target="_self" style="color:#fff;"><div id="xiay" style="color:#fff;">&darr;</div></a>
<a onClick="downn()" target="_self" style="color:#fff;"><div id="goBottom" style="color:#fff;">&or;</div></a></div>
<div id="container">
<script>
	goTopEx();
</script>
<p>浮点数，小数点可以浮点，实际没有使用小数点，123.4可以表示为1.234e2，也可以表示为12.34e1，看起来好像浮点了，其实浮点数在内存中的表示将全部位分为3部分，1位的符号位，剩下的位分配给尾数与指数。</p>

<p>选择结构可以用向前跳转来实现；循环结构可以用向后跳转来实现。</p>

<p>111=2^3-1</p>

<p>2^32-1是int的最大值（unsigned);</p>

<p>通过指针来引用一个内存单元。</p>

<p>指针变量需要解引用。解引用自动解引用。</p>
<hr />

<p>类型规则</p>

<p>1 整数的内存表达</p>

<p>&nbsp;&nbsp;1.1 内存的布局与格式；</p>

<p>&nbsp;&nbsp;1.2 整数范围；</p>

<p>2 整数的操作规则</p>

<p>&nbsp;&nbsp;2.1 算子；</p>

<p>&nbsp;&nbsp;2.2 溢出规则；</p>

<p>&nbsp;&nbsp;2.3 异常处理规则；</p>

<p>3 整数和其他数据类型（如浮点数）的替换规则</p>

<p>&nbsp;&nbsp;3.1 小数点舍去规则；</p>

<p>&nbsp;&nbsp;3.2 整数转换成其他类（如浮点数）的规则；</p>

<p>值是类存内容的类型解释；</p>
<hr />

<p>指针是一个复合类型，它由以下两个元素组成：</p>

<p>(A,T)，A是内存物理地址，T是该地址包含的类型。</p>

<pre>
#ifndef FILE_H  //#if !define FILE_H
#define FILE_H
    ……
#endif
</pre>

<p>sizeof(f00());对函数地址操作返回的是函数返回值类型的内存字节数，所以不能对返回void类型的函数进行sizeof操作。</p>

<p>自增自减运算符的前置或后置单独使用时是没有区别的，但用做右值时由有区别了。</p>

<p>长行代码分两行书写：在一行的末尾加一反斜线符号可将此行和下一行当作同一行处理。注意反斜线符号必须是该行的尾字符——不允许有注释或空格符。同样，后继行行首的任何空格和制表符都是字符串字面值的一部分。正因如此，长字符串字面值的后继行才不会有正常的缩进。在define中，也可以通过使用反斜线符号使用多行。</p>

<p>至于编译器自动对齐的原因，是为了提高程序的性能，数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；然而，对齐的内存访问仅需要一次访问。（最终的目的还是为了实现指针在内存中的有规律跳动，以实现更高的效率。）</p>

<p>强制类型转换就是程序员明确提出的、需要通过特定格式的代码来指明的一种类型转换。</p>

<p>移位运算符是将数据看成二进制数，对其进行向左或向右移动若干位的运算。移位运算符分为左移和右移两种，均为二元运算符。</p>

<p>函数中可以有多个return语句，但每次调用只能有一个return语句被执行，所以只有一个返回值。</p>

<p>一旦遇到return语句，不管后面有没有代码，函数立即运行结束，将值返回。</p>

<p>在进行C语言某些算法编程的时候，需要使几种不同类型的变量存放到同一段内存单元中。也就是使用覆盖技术，几个变量互相覆盖。这种几个不同的变量共同占用一段内存的结构，在C语言中，被称作“共用体”类型结构，简称共用体。</p>
<hr />

<p>⑴ 宏名一般用大写字母表示，以便于与变量区别。</p>

<p>⑵ 宏定义末尾不必加分号，否则连分号一并替换。</p>

<p>⑶ 使用宏可提高程序通用性和易读性，减少不一致性，减少输入错误和便于修改。如数组大小常用宏定义。</p>

<p>⑷ 预处理是在编译之前的处理，而编译工作的任务之一就是语法检查，预处理不做语法检查。</p>

<p>⑸ 宏定义写在函数的花括号外边，作用域为其后的程序，通常在文件的最开头。</p>

<p>⑹ “字符串”中永远不包含宏，否则该宏名当字符串处理。</p>

<p>⑺ 宏定义不分配内存，变量定义分配内存。</p>
<p>define与const不同之处的一点，define可以定义常量数组的数组长度；</p>
<p>随机函数rand()用于产生从0开始到32767之间的随机数，它的使用语法如下：</p>
<hr />

<p>int r;</p>

<p>r=rand();</p>

<p>表示生成一个随机数并赋予变量r。</p>
<p>#include<time.h></p>

<p>srand((unsigned)time(NULL));</p>

<hr />

<p>变量名实际上是一个以一个名字对应代表一个地址，在对程序编译连接时由编译系统给每一个变量名分配对应的内存地址。从变量中取值，实际上是通过变量名找到相应的内存地址，从该存储单元中读取数据。</p>

<p>并不是任何地方出现的逗号都是作为逗号运算符。例如函数参数也是用逗号来间隔的。</p>
<hr />

<p>格式输出函数</p>

<p>函数作用：向终端（或系统隐含指定的输出设备）输出若干个任意类型的数据。</p>

<p>一般格式：printf（格式控制，输出表列）</p>

<p>s格式符输出字符串.</p>

<p>① %s例如：</p>

<p>printf("%s","china")</p>

<p>输出字符串“china”（不包括双引号）。</p>

<p>② %ms，输出的字符串占m列，若串长大于m，则全部输出，若串长小于m，则左补空格。</p>

<p>③ %-ms，若串长小于m，字符串向左靠，右补空格。</p>

<p>④ %m. ns,输出占m列，只取字符串中左端n个字符，输出在m列的右侧，左补空格。</p>

<p>⑤ %-m.ns，n个字符输出在m列的左侧，右补空格，若n〉m，m自动取n值。</p>

<p>printf(“%3s,%7.2s,%.4s,%-5.3s\n”, “china”, “china”, “china”, “china”);</p>
<hr />
<h4>循环</h4>
<p>可以省略表达式1和表达式3，只有表达式2，即只</p>

<p>给循环条件。如：</p>

<p>for(;i<=100;){sum=sum+i; i++;}  相当于   </p>

<p>while(i<=100)  {sum=sum+i; i++;}</p>


<p>在逗号表达式内按自左至右顺序求解，整个逗号表达式的值为其中最右边的表达式的值。如:</p>

<p>     for(i=1;i<=100;i++，i++) sum=sum+i;</p>

<p>相当于</p>

<p>     for(i=1;i<=100;i=i+2) sum=sum+i;</p>

<p>for循环内的表达式2一般是关系表达式(如i&lt;=100)或逻辑表达式\(如a&lt;b && x&lt;y)，但也可以是数值表达式或字符表达 式，只要其值为非零，就执行循环体。</p>

<p>for(i=0;(c=getchar())!=′＼n′;i+=c);   </p>

<p>在表达式2中先从终端接收一个字符赋给c，然后判断此赋值表达式的值是否不等于′＼n′(换行符)，如果不等于′＼n′，就执行循环体。</p>

<p>注意：此for语句的循环体为空语句，把本来要在循环体内处理的内容放在表达式3中，作用是一样的。可见for语句功能强，可以在表达式中完成本来应在循环体内完成的操作。</p>

<p>在while循环和do-while循环中，只在while后面的括号内指定循环条件，因此为了使循环能正常结束，应在循环体中包含使循环趋于结束的语句(如i++，或i=i+1等)。</p>

<p>for循环可以在表达式3中包含使循环趋于结束的操作，甚至可以将循环体中的操作全部放到表达式3中。因此for语句的功能更强，凡用while循环能完成的，用for循环都能实现。 </p>

<p>用while和do-while循环时，循环变量初始化的操作应在while和do-while语句之前完成。而for语句可以在表达式1中实现循环变量的初始化。</p>
<hr />

<p>二维数组中的元素在内存中的排列顺序是：按行存放，即先顺序存放第一行的元素，再存放第二行的元素……</p>

<p>主调函数和被调用函数之间有数据传递的关系。在不同的函数之间传递数据，可以使用的方法有：</p>

<p>参数：通过形式参数和实际参数</p>

<p>返回值：用return语句返回计算结果</p>



<p>对静态局部变量是在编译时赋初值的，即只赋初值一次，在程序运行时它已有初值。以后每次调用函数时不再重新赋初值而只是保留上次函数调用结束时的值。</p>

<p>在预编译时将宏名替换成字符串的过程称为“宏展开”。</p>
<hr />

<p>设有若干个人员的数据，其中有学生和教师。学生的数据中包括：姓名、号码、性别、职业、班级。教师的数据包括：姓名、号码、性别、职业、职务。可以看出，学生和教师所包含的数据是不同的。现要求把它们放在同一表格中，即可以使用共同体。</p>
<pre>
struct{	
	int num;	
	char name[10];	
	char sex;	
	char job;	
	union	
	{		
		int banji;		
		char position[10];	
	}category;	
}person[2];/*先设人数为2*/
</pre>
<hr />

<p>高位左移后溢出，舍弃。</p>

<p>右移运算符是a>>2表示将a的各二进制位右移2位，移到右端的低位被舍弃,对无符号数,高位补0。</p>

<p>a=1001011111101101  （用二进制形式表示，即使是十进制，内存中存储的本质都是二进制，所以也要时刻当做二进制看待）</p>

<p>a>>1: 0100101111110110  (逻辑右移时)</p>

<p>a>>1: 1100101111110110  (算术右移时)</p>

<p>信息的存取一般以字节为单位。实际上，有时存储一个信息不必用一个或多个字节，例如，“真”或“假”用０或１表示，只需１位即可。在计算机用于过程控制、参数检测或数据通信领域时，控制信息往往只占一个字节中的一个或几个二进制位，常常在一个字节中放几个信息。</p>

<p>malloc是库函数，不在编译器控制范围之内；new是运算符，在编译器控制范围之内。</p>

<p>调用malloc时，从堆中申请内存；调用new时，从堆中申请内存并为内存调用构造函数。</p>
<hr />

<p>基类的析构函数不是虚函数，会带来什么问题？</p>

<p>在实现多态时，如果是由基类指针指向在堆上动态创建派生对象时，如果delete此虚类指针，则基类的析构函数被调用，并不会调用派生类的析构函数，如果派生类中有在堆上动态创建的数据时，则会出现内存泄露。C++编译器的做法时，如果基类的析构函数前面有用virtual修饰，编译器会自动去调用派生类的析构函数（实现动态绑定，如果其它成员函数的动态绑定一样），做内存释放的工作。</p>
<hr />

<p>数组名作函数的参数，主调函数和被调函数共用一段存储单元。</p>
<p>编译器会根据函数的返回值类型和参数表来区分函数的不同重载形式。</p>
<p>声明一个volatile变量会要求编译器在每次使用该变量时都会获取它的一个新的副本。而不用通过该变量的值保存在一个寄存器中并复用它来优化程序。</p>
<p>一次非对齐的内存访问的时间相当于这些字节在同一个字中时的两倍，因为需要读取两个字。</p>
<p>计算机并不一定会一次读取一个字节，会通过获得更大块的数据来补偿缓慢的内存速度，如1字节，64字节，一个字等；</p>
<p>如今所有处理器都可以在一个内部时钟周期中执行一次位移或是加法操作。</p>
<p>x*4,x&lt;&lt;2更高效；</p>
<p>x*9=(x&lt;&lt;3)+x</p>
<p>内存管理器是C++运行时系统中监视动态变量的内存分配情况的一组函数和数据结构。</p>
<p>switch直通：</p>
<pre>
#include &lt;iostream>
using namespace std;
voi main()
{
	int n; cin&gt;n;
	switch(n) 
	{ 
	case 1: 
	case 2:cout&lt;'2'; break;//if(n==1 || n==2)
	case 3: 
	case 4:cout&lt;'3';break; 
	case 5:cout&lt;'5';break; //if(n==5)
	default:cout&lt;'6'; 
	}//若键盘输入1，则屏幕显示12
}
</pre>

<p>函数的指针还可以是表达式、函数调用；</p>

<p>共用体：同一段内存空间可以有多个类型形式；</p>
<hr />

<p>switch语句测试一个变量，根据它的值选择一个分支来执行。</p>
<p>switch关键字后面是圆括号中的表达式。该表达式必须求值为整数、字符或枚举值。switch主体由一系列条件分支构成，每个都包含case（条件）关键字、一个值和一个冒号。 </p>
<p>对条件进行标识的值必须是整数类型的常量。符合条件的包括整数、枚举值和字符。例如，5和a是有效值，但"abc"无效，因为它是字符串字面值。 </p>
<p>每个条件分支都可包含任意数量的语句。在每个分支末尾都用break语句退出switch语句。 </p>
<p>注意：一般不需要用大括号封闭条件分支中的代码。用break语句即可结束一个条件分层。但是，如果需要在分支代码中声明变量，就必须使用大括号。</p>
<p>switch语句可定义default分支。所有case标签都不匹配switch表达式，就执行default分支中的语句。 </p>
<p>提示：即使不执行任何特殊处理，也最好定义default分支。包含default分支表示你没有忘记它。另外，default分支有助于捕捉非预期的值，并向用户显示恰当的警告消息。</p>
<p>如果一个case分支末尾没有break语句，控制流程就会从下一个语句继续。这称为直通（fall-through）。可利用这个功能来避免重复的代码，只是注意不要无意间造成直通。</p>
<p>switch如果没有break，变量的各值之间就是or的关系，满足条件的分支直至break之间的语句都会被执行。</p>
<hr />

<p>continue放弃当前循环，继续下一次循环</p>
<p>指针的步长，不是字节，而是类型的长度；</p>
<hr />

<p>按位异或和按位取反有什么区别？对一个数字进行取反运算结果是多少，还与该类型是有符号还是无符号，占用的字节大小等有关.</p>
<p>int a = 10;</p>
<p> printf("按位异或的定位取反功能%d\n按位取反%d\n", a ^ 0xFF, ~a);</p>

<p>按位异或的定位取反功能245</p>
<p>按位取反-11</p>

<p>0xFF 这个是只有低8位为1，高位全是0。</p>
<p></p>
<p>整型10 是低4位为 1010，高位全为0，且一般来说是占用32位。</p>
<p></p>
<p>你应该明白了吧，区别就在于高位的行为不一样。</p>
<p></p>
<p>取反是将a高位的0都变成1，这样最高位的符号位也变成1了，所以最终值是负的。</p>
<p></p>
<p>而异或后，a的后8位都取反了，但前24位保持不变。这样值就是245.</p>
<hr />

<p>if语句的else子句指定的代码只有在if语句中表达式验证为false时才执行。</p>
<p>switch语句验证能当作int型的值，并执行标记有相应值的代码段。</p>
<p>switch语句中的default关键字指定的代码在被验证值与switch语句所列值无一匹配时执行。</p>
<p>从函数返回对象时，程序对该变量进行复制，然后将副本返回；</p>
<hr />
<h4>编译器对语言版本的支持：</h4>
<p>/*C89:*/ int i; for(i = 0;i < 10;++i) /*...*/ ... </p>
<p>/*C99*/ for(int i = 0;i < 10;++i) /*...*/ </p>
<p>这只是其中的一种差别，但是C99需要人为手动的开启，但是很多人有疑问，为什么有时候没有配置什么也能使用后面的语法？吴老师告诉你，这是因为你用了C++的文件进行C语言的开发，就像挂羊皮卖狗肉的道理。</p>
<hr />

<p>首先是整数，使用了这么多的C语言之后，每当在使用整数之时都会将其想象成二进制的存在，而不是十进制。原因在于，这是程序的本质所在，稍有研究编译器工作原理的都会发现，在编译器处理乘法乃至除法的时候，优秀的编译器总会想方设法的加快程序的速度，毫无疑问在所有运算中移位运算是最快速的"乘法"以及"除法": 1&lt;&lt;2 == 4 ,8>>2 == 2</p>
<p>*point_to_me = me; point_to_me++; 的语法糖，对于++，在非必要的情况下，请使用前缀递增，而非后缀递增，原因是消耗问题，仔细想想这两种递增的区别在何处？ 前缀递增总是在原数上进行递增操作，然而后缀递增呢？它首先拷贝一份原数放于别处，并且递增这份拷贝，在原数进行的操作完毕后，将这份拷贝再拷贝进原数取代它，此中的操作涉及的更多，所以在非必要的情况下，请使用前缀递增而不是后缀递增(递减也是同样的道理)</p>
<p>volatile 这个关键字常常被C语言教材所忽略，它很神秘。实际上确实如此，他的作用的确很神秘：一旦使用了，就是告诉编译器，即使这个变量没有被使用或修改其他内存单元，它的值也可能发生变化。通俗的说就是，告诉编译器，不要把你的那一套优化策略用在我身上。</p>
<p>一定要放一个 default 在最后，即使它永远不会用到。</p>
<p></p>
<p>每个 case 如果需要使用新变量，可以用 {} 包裹起来，并在里面完成所有操作。</p>
<p></p>
<pre>
&lt;pre>
  switch(...)
  {
  	case 1:
  		/**TODO**/
  		break;
  
  	case 2:
  	{
  		int new_vari;
  		/**创建新变量则用 {} 包裹起来**/
  	}
  	break;
  	
  	default:
  		call_error();
  }
&lt;/pre>
</pre>
<p>我们知道场面上，C语言拥有两种传递方式:按值传递和按址传递，但是你是否有认真研究过？这里给出一个实质，其实C语言只有按值传递，所谓按址传递只不过是按值传递的一种假象。至于原因稍微一想便能明白。</p>
<p></p>
<p>对于形参和实参而言两个关系紧密，可以这么理解总是实参将自己的一份拷贝传递给形参，这样形参便能安全的使用实参的值，但也带给我们一些麻烦，最经典的交换两数</p>
<pre>
void swap_v1(int* val_1, int* val_2)
{
    int temp = *val_1;
    *val_1 = *val_2;
    *val_2 = *val_1;
}
</pre>
<p>这就是所谓的按址传递，实际上只是将外部指针(实参)的值做一个拷贝，传递给形参val_1与val_2.</p>
<p>C语言并没有多维数组，因为内存是一种线性存在，即便是多维数组也是实现成一维数组的形式。</p>
<p>就多维数组在这里解释一下。所谓多维数组就是将若干个降一维的数组组合在一起，降一维的数组又由若干个更降一维的数组组合在一起，直到最低的一维数组。</p>
<p>[]便是指针运算的语法糖。</p>
<p>通俗地说，fgets将输入流中由调用起，stdin输入的东西存入起始地址为tran_to_int的地方，并且最多读取sizeof(tran_to_int)个，并在后方sscanf函数中将刚才读入的数据按照%d的格式存入stay_here，这就是C语言一直在强调的流概念的意义所在，这两个语句组合看起来也就是读取一个数据这么简单，但是我们要知道一个问题，一个关于scanf的问题</p>
<p></p>
<p>  scanf("%d", &stay_here);</p>
<p>这个语句将会读取键盘输入，直到回车之前的所有数据，什么意思？就是回车会留在输入流中，被下一个输入读取或者丢弃。这就有可能会影响我们的程序，产生意料之外的结果。而使用上当两句组合则不会。</p>
<p>C语言的三个函数malloc, calloc, realloc都是拥有很大风险的函数，在使用的时候务必记得对他们的结果进行校验，最好的办法还是对他们进行再包装，可以选择宏包装，也可以选择函数包装。</p>
<p>realloc函数是最为人诟病的一个函数，因为它的职能过于宽广，既能分配空间，也能释放空间，虽然看起来是一个好函数，但是有可能在不经意间会帮我们做一些意料之外的事情，例如多次释放空间。正确的做法就是，应该使用再包装阉割它的功能，使他只能进行扩展或者缩小堆内存块大小。</p>
<p>在内存分配的过程中，我们使用 malloc 进行分配，用 free 进行释放，但这是我们理解中的分配与释放吗？ 在调用 malloc 时，该函数或使用 brk() 或使用 mmap() 向操作系统申请一片内存，在使用时分配给需要的地方，与之对应的是 free，与我们硬盘删除东西一样，实际上:</p>
<p></p>
<p>int* value = malloc(sizeof(int)*5);</p>
<p>...</p>
<p>free(value);</p>
<p>printf("%d\n", value[0]);</p>
<p>代码中，为什么在 free 之后，我又继续使用这个内存呢？因为 free 只是将该内存标记上释放的标记，示意分配内存的函数，我可以使用，但并没有破坏当前内存中的内容，直到有操作对它进行写入。 这便引申出几个问题:</p>
<p></p>
<p>Bug更加难以发现，让我们假设，如果我们有两个指针p1,p2指向同一个内存，如果我们对其中某一个指针使用了 free(p1); 操作，却忘记了还有另一个指针指向它，那这就会导致很严重的安全隐患，而且这个隐患十分难以发现，原因在于这个Bug并不会在当时显露出来，而是有可能在未来的某个时刻，不经意的让你的程序崩溃。</p>
<p>有可能会让某些问题更加简化，例如释放一个条条相连的链表域。</p>
<p>某些大哥提到说，free并不是什么都不做，而是将该段地址空间的前面一小部分置零 但是如果地址空间很长的话，依旧有误用的风险，希望大家还是警惕</p>
<p></p>
<p>实际上之所以库作者不让free操作将地址空间清空，有一部分原因是为了性能考虑，<strong>因为置零操作是一个消耗性能的行为</strong>，具体可以自行尝试，所谓双刃剑就在于此。</p>
<p></p>
<p>总的来说，还是那句话C语言是一把双刃剑。</p>
<h4>宏和#、##</h4>
<p>预处理器一般只对同一行定义有效，但如果加上反斜杠，也能一直读取下去</p>
<p></p>
<p> #define err(flag) \</p>
<p>     if(flag) \</p>
<p>       printf("Correctly")</p>
<p>在宏的使用中有两个有用的操作符，姑且叫它操作符#, ##</p>

<p>对于# 我们可以认为#操作符的作用是将宏参数转化为字符串。</p>
<p></p>
<p>   #define HCMP(x, y) printf(#x" is equal to" #y" ? %d\n", (x) == (y))</p>
<p>   ...</p>
<p>   int x = 100, y = 200;</p>
<p>   HCMP(x, y);</p>
<p>展开以后</p>
<p></p>
<p>		printf("x is equal to y ? %d\n", (100) == (200));</p>
<p>对于##</p>
<p>它实现的是将本操作符两边的参数合并成为一个完整的标记，但需要注意的是，由于预处理器只负责展开，所以程序员必须自己保证这种标记的合法性，这里涉及到一些写法问题，都列出来</p>
<p></p>
<p>  	#define MERGE(x, y) have_define_ ## x + y</p>
<p>  	#define MERGE(x, y) have_define_##x + y</p>
<p>  	...</p>
<p>  	result = MERGE(1, 3);</p>
<p>这里首先说明，上述写法由于习惯原因，我使用第二种，但是无论哪种都无伤大雅，效果一样。上述代码展开以后是什么呢？</p>
<p></p>
<p>  	result = have_define_1 + 3;</p>
<p>在我看来，这就有点C++中模版的思想了，虽然十分原始，但是总是有了一个方向，凭借这种方法我们能够使用宏来进行相似却不同函数的调用，虽然我们可以使用函数指针数组来存储，但需要提前知晓有几个函数，并且如果要实现动态增长还需要消耗内存分配，但宏则不同。</p>
<p></p>
<p>  	inline int func_0(int arg_1, int arg_2) { return arg_1 + arg_2; }</p>
<p>  	inline int func_1(int arg_1, int arg_2) { return arg_1 - arg_2; }</p>
<p>  	inline int func_2(int arg_1, int arg_2) { return arg_1 * arg_2; }</p>
<p>  	inline int func_3(int arg_1, int arg_2) { return arg_1 / arg_2; }</p>
<p>  	#define CALL(x, arg1, arg2) func_##x(arg1, arg2)</p>
<p>  	...</p>
<p>  		printf("func_%d return %d\n",0 ,CALL(0, 2, 10));</p>
<p>  		printf("func_%d return %d\n",1 ,CALL(1, 2, 10));</p>
<p>  		printf("func_%d return %d\n",2 ,CALL(2, 2, 10));</p>
<p>  		printf("func_%d return %d\n",3 ,CALL(3, 2, 10));</p>
<h4>存储层次体系和局部原则</h4>

<p>打个不太贴切的比喻，假设计算机是一个家，CPU是一个人，想象一下这个家中的所有物品都是井然有序的，这个人想要工作必然会需要工作物品，所以他需要从某些地方拿来，用完以后再放回去，这些地方就是存储器，但是过了一段时间发现这么做太浪费时间，有时候某些东西太远了，所以，人想把它把它放在离自己更进的地方，这样自己的效率就高很多，如果这个东西一段时间内不再用，则把它放回原处，留出位置给更需要的工作物品，于是形成了越常使用的物品离人越近的现象。这便是计算机存储器的分层结构的意义。</p>
<p>而对于一个有良好局部性的程序而言，我们总能在离自己最近的地方找到我们所需要的数据，回到计算机：我们知道计算机的存储器是分层结构的，即每一层对应着不同的读写速度等级(CPU寄存器 > 高速缓存 > 主存 > 硬盘)，而我们的程序总是按照从左至右的顺序依次查找，每次找到一个所需要数据，不出意外，总是将其移动到上一层次的存储器中存储，以便下次更高速的访问，我们称这种行为叫做命中 。越好的程序，越能将当时所需的数据放在越靠近左边的地方。这便是局部性的意义所在。</p>
<p>当然，存储器如此分层也是出于无奈，在处理器的速度和存储器的速度实在差距的情况下只有如此做才能让处理器更加充分的利用，而不至于等待存储器读写而空闲，也许某一天，当内存的位价和普通硬盘不相上下或者差距不多的时候，也许内存就是硬盘了。而当今也有人使用某些特殊的软件在实现这个功能，凭着自己计算机上大容量的内存，分割出来当作硬盘使用，存取速度让硬盘望尘莫及。</p>

<hr />

<p>观察到多维数组的遍历中我们和平时的做法有些不同，是先对i进行遍历，再对j进行遍历，这就导致了程序必须在内存块中无规律的跳动，这里的无规律是计算机认为的无规律，虽然在我们看来的确是有迹可寻，优秀的编译器能够对它进行优化处理。就事论事，即这段程序的空间局部性比较差，对于一个在内存中大幅度跳跃，无规律跳跃的程序都将影响程序的性能。这个判定对于一个连续的内存块来说是很重要的，比如C语言中的结构体（内存对齐也是希望实现一种有规律的跳动）。</p>
<p>volatile int i = 0;</p>
<p>首先它的现象本质就是，确保每次读取 i 的时候，是从它的内存位置读取，每次对它操作完毕后，将结果写回它的内存位置，而不是将其优化保存在寄存器内。</p>
<p>{}除了用做语句块，还可以用做初始化；</p>
<p><h4>配置glib-2.28.8</h4></p>
<p>下载编译好的二进制包，预处理好(某些操作，不多说，网上有教程，记得用谷歌，或者到博客园里找类似的，但是版本比较老可能和我用的有一些出路，但可以依着葫芦画瓢)以后，将路径配置到工程里：</p>
<p>创建一个Win32程序，并且在属性管理器(左侧栏下部寻找)中创建属性表(Debug和Release各创建一个，设置都相同即可)</p>
<p>打开新建的属性表</p>
<p>通用属性->VC++目录->包含目录->编辑 添加下载下来的文件中的glib\glib2.28\include目录，不放心的还可以再添加一个glib\glib2.28\lib\glib-2.0\include目录</p>
<p>通用属性->VC++目录->库目录->编辑 添加glib\glib2.28\lib目录</p>
<p>通用属性->链接器->输入->附加依赖项 添加glib\glib2.28\lib目录下的所有.lib文件，即将这些文件的名字都手动输入进去，如果使用我的这个版本的话那就是</p>
<p>gio-2.0.lib glib-2.0.lib gthread-2.0.lib gmodule-2.0.lib gobject-2.0.lib</p>
<p>通用属性->C/C++->代码生成->运行库开启多线程/MT</p>
<p>Okay！成了</p>

<hr />



<p>A union is a struct in which all members are allocated at the same address so that the union occupies  only as much space as its largest member. Naturally, a union can hold a value for only one  member at a time.</p>
<p>预定义指针到设备文件（键盘或显示器）的FILE常量：</p>
<p>指向FILE常量的指针：设备文件</p>
<p>stdin：键盘</p>
<p>stdout：显示器</p>
<p>stderr：显示器</p>
<p>m=fgetc(stdin);</p>
<p>从指向FILE常量stdin(即键盘）的指针指定的文件中读取一个字符，并返回其ASCII值，该值赋值给m。</p>
<p>fputc(m,stdout);将字符（其ASCII值存储在m中）写入由FILE常量stdout指针指定的文件（显示器</p>
<p>m=fgetc(stdin);从指向FILE常量stdin(键盘)的指针指定的文件中读取一个字符，并返回其ASCII值，该值赋给m</p>
<p>函数是子程序，它允许你将大型计算任务分解为较小的计算任务；</p>
<p>函数是由大括号分隔的一段代码，它执行一些明确定义的任务并返回一个值；</p>
<p>函数是程序的构建块，它有助于使现有代码可重用。</p>
<p>函数也可以视为C中的派生类型。</p>
<p>函数是扩展C语言库的一种方法。</p>
<p>The C Standard strncpy() function is frequently recommended as an  alternative to the strcpy() function. Unfortunately, strncpy() is prone to  null-termination errors and other problems and consequently is not considered  to be a secure alternative to strcpy().</p>
<p>系统在主存中开辟一个专用的内存区域用来临时存放输入/输出信息，这种内存区域称为缓冲区。输入/输出流可以是缓冲的，也可以是非缓冲的。引入缓冲的目的是为了提高系统的效率。通常情况使用缓冲流.</p>
<p>程序库：头文件（库函数原型，由编译器来做类型检查）+库文件（函数实现，由链接器链接，将代码复制到可执行文件中）。</p>
<p>VC++提供了一个名为comment的指令，它可以搭配lib选项给链接器发送一个特定信息，以链接特定的程序库。因此头文件中的代码：</p>
<p></p>
<p>#pragma comment(lib, "mylib")</p>
<p></p>
<p>将告知链接器链接程序库mylib。一般来说，最好使用项目管理工具，比如nmake或者MSBuild，用于确保将正确的程序库链接到项目中。</p>
<p></p>
<p>大部分C运行时库是以如下方式实现的，在一个静态库或者动态链接库中编译函数，然后在头文件中声明函数原型。开发人员在链接器命令行中提供了程序库，通常还将为该程序库引用头文件，以便编译器能够访问函数原型。只要链接器能够识别该程序库，就可以在项目代码中输入其函数原型（将它定义为外部链接，以便告知编译器函数是在其他地方定义的）。这样可以省去将某些大型文件引入到源代码中的麻烦，因为这些文件中很有可能包含大量不会用到的函数原型。</p>
<p>cout &lt;&lt; "long最大值：" &lt;&lt; (numeric_limits<long>::max)(); //#include &lt;limits></p>
<p>变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p>
<p></p>
<p>当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 extern 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。</p>
<p>在函数或一个代码块（非控制结构的{}块，控制结构只是一条语句）内部声明的变量，称为局部变量。</p>
<p>一般情况下，系统为全局变量分配的存储空间在程序运行的过程中一般是不改变的，而为局部变量分配的存储单元是动态改变的。</p>
<p>变量是什么？是一个存储数据的内存单元，用变量名显式表示其内容值，变量包括右值和右值。其地址也可以称为指针，可以用一个指针变量来显式地引用地址值。</p>
<p>通过指针访问字符串常量：</p>
<p>char* str="hellow";</p>


<hr />

<p>参数传递：在调用函数与被调函数之间的数据复制、读、写；</p>
<p>函数调用时，形参会在栈帧上开辟内存单元，放置实参的值或地址。如果是地址，才是对调用函数内部的变量形成间接访问。</p>
<p>函数执行过程</p>
<p>在主程序中计算每个实际参数值</p>
<p>用实际参数值初始化形式参数</p>
<p>依次执行函数体的每个语句，直到遇见return语句或函数体结束</p>
<p>计算return后面的表达式的值，用表达式的值构造一个临时变量</p>
<p>回到调用函数，用临时变量置换函数调用，继续主程序的执行</p>
<p>函数可以将一段完成独立功能的程序封装起来。通过函数名就可执行这一段功能。使用函数可以将程序模块化</p>


<hr />

<p>What are pointers for </p>
<p></p>
<p>Accessing array elements.</p>
<p></p>
<p>Passing arguments to a function when the function needs to modify the original argument.</p>
<p></p>
<p>Passing arrays and strings to functions.</p>
<p></p>
<p>Obtaining memory from the system.</p>
<p></p>
<p>Creating data structures such as linked lists.</p>
<p>Generally, system programmers aren’t willing to pay overhead for programming  convenience, so C adheres to the zero-overhead principle: what  you don’t use, you don’t pay for. The strong type system is a prime example of  a zero-overhead abstraction. It’s used only at compile time to check for program  correctness. After compile time, the types will have disappeared, and  the emitted assembly code will show no trace of the type system.</p>
<p>The first argument to printf is always a format string. The format string  provides a template for the string to be printed, and it contains any number  of special format specifiers. Format specifiers tell printf how to interpret  and format the arguments following the format string. All format specifiers  begin with %.</p>
<p>For example, the format specifier for an int is %d. Whenever printf sees  a %d in the format string, it knows to expect an int argument following the  format specifier. Then printf replaces the format specifier with the argument’s  actual value.</p>
<p>Operators are functions that perform computations on operands. Operands  are simply objects.</p>
<p>const wchar_t* ws = L"中文abc";</p>
<p></p>
<p></p>
<p>大写的L是告诉编译器：这是宽字符串。所以，这时候是需要编译器根据locale来进行翻译的。</p>
<p>左值一般在内存，右值一般在寄存器。</p>
<p>左值：可寻址的非只读表达式；</p>

<p>函数执行过程</p>
<p>在主程序中计算每个实际参数值；</p>
<p>用实际参数值初始化形式参数；</p>
<p>依次执行函数体的每个语句，直到遇见return语句或函数体结束；</p>
<p>计算return后面的表达式的值，用表达式的值构造一个临时变量；</p>
<p>回到调用函数，用临时变量置换函数调用，继续主程序的执行；</p>
<p>C语言中关系运算和逻辑运算结果以1表示真，0表示假，同时规定表达式的值非零即为真。</p>
<p>	在条件语句if(a==0) 语句; 中，当a等于0时条件为真，则执行其后的语句。而在条件语句if(!a) 语句; 中，当a等于0时，!a即为真，则执行其后执行的语句。因此这两个条件语句是等价的。</p>
<p>	注意：类似地，条件语句if(a)等价于if(a!=0)。</p>
<p>for(int i=0,sum=0;i<=100;sum+=i++);</p>
<p>break用于跳出循环或switch:</p>
<p>    for(;;)</p>
<p>    {</p>
<p>        s=s+x;</p>
<p>        x++;</p>
<p>        if(x>100) break;</p>
<p>    }</p>
<p>数列求和一般会有两个迭代表达式</p>
<p>有1、2、3、4三个数字，能组成多少个互不相同且无重复数字的三位数？分别是多少？</p>
<p>可以采用三重循环组成所有的排列，而后再用if语句选择满足条件的排列即可。</p>
<p>斐波拉契数列</p>
<p>f1 f2 f1 f2</p>
<p>f1 = f1+f2</p>
<p>f2 = f1+f2</p>
<p>用continue可以在循环中排除条件：</p>
<p>for( i = 1 ; i<= 10 ; i++)</p>
<p>    { </p>
<p>        printf("n = ");</p>
<p>        scanf("%d",&n);</p>
<p>        if (n<0)   </p>
<p>            continue;</p>
<p>        sum = sum + n ;</p>
<p>    }</p>
<p>return退出循环体；</p>
<p>变量名是用来命名一个内存地址，这个地址可以是一块基本数据类型大小的首地址，也可以是一组相同类型的基本数据类型的首地址，也可以是一个事先自定义的结构体的首地址。</p>
<p>求字符串长度：</p>
<p>while (a[la++]);</p>
<p>在C程序中使用宏，实际上是经过了宏定义、宏调用、宏展开三个步骤。宏定义就是使用#define命令定义一个宏标识符所代表的字符串，而宏调用则是在程序中使用宏标识符代替相应的字符串，宏展开是指在开始编译源程序之前，将程序所有的宏调用使用相应的字符串来代替。</p>
<p>宏定义、宏调用与宏展开。	</p>
<p>	以下程序运行的结果为什么是29？</p>
<p></p>
<p>#define P  3</p>
<p>#define F(x)  P*x*x</p>
<p>int main()</p>
<p>{</p>
<p>  printf("%d\n",F(3+5));</p>
<p>  getch();</p>
<p>  return 0;</p>
<p>}</p>
<p>1 x=3+5</p>
<p>2 F(x)用P*x*x替换</p>
<p>3 p用3替换，x用3+5替换</p>
<p>带参宏和函数能等价吗？	</p>

<p>（1）函数调用时，要先求出实参表达式的值，然后再代入形参；而宏只做简单的字符替换，不进行运算。</p>
<p>（2）函数调用是在程序运行时处理的，为形参分配临时的存储单元；而宏的展开是在编译前进行，且展开时也不分配内存，不进行值的传递，更没有返回值的概念。</p>
<p>（3）函数中的形参和实参都必须定义数据类型，并且要求两者类型一致，如果不一致，要进行相应的类型转换；而宏不存在任何类型问题，宏名称和参数都不需要类型，仅仅是一个符号。</p>
<p>++p,++i,用于移动指针和下标，其实质是得到一个新的地址，只需++操作是因为这些内存单元是相信存储的；</p>
<p>两个指针相减，可以求出两个指针之间的存储单元大小；</p>
<p>复合语句由一对花括号将一组语句序列括起来形成一个程序段，经常出现在选择或循环语句中。当选择语句的分支和循环语句的循环体由多条语句组成时，就必须用花括号括起来形成完整的复合语句，起到层次划分的作用。甚至可以将若干条基本语句用花括号括起来，组成一个局部范围内的程序段，对变量的作用范围产生影响。</p>
<p>对于递归调用，可以理解为函数体副本机制为n份，其实只有一份，只是局部变量和参数及返回位置在栈中有函数桢的副本。</p>
<p>当调用发生时，程序的执行流程暂时离开主调函数，进入被调函数程序的执行；找到被调函数的程序入口地址，先把实际参数的值传递给对应的形式参数，再开始被调函数体的执行，最后通过return语句把其后表达式的结果返回到主调函数的调用点；程序的执行离开被调函数后，重新回到主调函数中，在调用点对被调函数的返回值进行处理，再继续执行调用点下面的语句。图4-1反映了两个函数之间调用和返回的关系。</p>
<p>在调用语句执行时，先把实参的值按对应关系传递给形参变量，作为形参的初始值参与在被调用函数中的运算。</p>
<p>形参：左值，实参：右值；</p>
<p>如果返回void或没有返回值，并不表示只有print，如传引用或地址，即使没有return，则也有可能影响被调函数的数据，也有可能修改全局变量。</p>
<p>求值算术函数使用传值参数，用return返回计算值。</p>
<p>功能性函数用return返回错误信息。</p>
<p>基本数据类型及其复合类型以字节为单位进行处理，位运算以位为单位进行处理。</p>
<p>若两个操作数都是整数，则为整除操作（求商，舍余），操作结果为整数。</p>
<p>%：只用于整数的求余操作（求余，舍商）。如：10%3=1</p>
<p>函数要处理的不是指针本身，而是指针所指向的数据。</p>
<p>算术右移：空出来的高位用符号位来填充；</p><p>逻辑右移：空出来的高位用0来填充；</p><p>int n = a+rand()%(b-a+1);</p><p>int m = rand()%11;</p><p>wchar_t是一个typedef而不是一个内部类型，_t就是用来区分标准类型与typedef；</p><p>不使用realloc( )。	</p><p>调用realloc对一个内存块进行扩展，导致原来的内容发生了存储位置的变化， realloc函数既要调用free，又要调用malloc。执行时究竟调用哪个函数，取决于是要缩小还是扩大相应内存块的大小。</p><p>Like a composition, an aggregation is still a part-whole relationship, where the parts are contained within the whole, and it is a unidirectional relationship. However, unlike a composition, parts can belong to more than one object at a time, and the whole object is not responsible for the existence and lifespan of the parts. When an aggregation is created, the aggregation is not responsible for creating the parts. When an aggregation is destroyed, the aggregation is not responsible for destroying the parts.</p><p>A literal constant is a fixed value inserted directly into the source code. Examples are 5 and “Hello world!”.</p><p>we defined a function as a collection of statements that execute sequentially. While that is certainly true, that definition doesn’t provide much insight into why functions are useful. Let’s update our definition: A function is a reusable sequence of statements designed to do a particular job.</p><p></p><p>You already know that every program must have a function named main (which is where the program starts execution when it is run). However, as programs start to get longer and longer, putting all the code inside the main function becomes increasingly hard to manage. Functions provide a way for us to split our programs into small, modular chunks that are easier to organize, test, and use. Most programs use many functions. The C++ standard library comes with plenty of already-written functions for you to use -- however, it’s just as common to write your own. Functions that you write yourself are called user-defined functions.</p><p>A function parameter is a variable used in a function. Function parameters work almost identically to variables defined inside the function, but with one difference: they are always initialized with a value provided by the caller of the function.</p><p>When a function is called, all of the parameters of the function are created as variables, and the value of each of the arguments is copied into the matching parameter. This process is called pass by value.</p><p>A definition actually implements (for functions or types) or instantiates (for variables) the identifier. Here are some examples of definitions:</p><pre>int add(int x, int y) // implements function add(){    int z{ x + y }; // instantiates variable z     return z;}</pre><p>A definition is needed to satisfy the linker. If you use an identifier without providing a definition, the linker will error.</p><p>A declaration is a statement that tells the compiler about the existence of an identifier and its type information. Here are some examples of declarations:</p><pre>int add(int x, int y); // tells the compiler about a function named "add" that takes two int parameters and returns an int.  No body!int x; // tells the compiler about an integer variable named x</pre><p>A declaration is all that is needed to satisfy the compiler. This is why we can use a forward declaration to tell the compiler about an identifier that isn’t actually defined until later.</p><p>When you #include a file, the preprocessor replaces the #include directive with the contents of the included file. The included contents are then preprocessed (along with the rest of the file), and then compiled.</p><p>The #define directive can be used to create a macro. In C++, a macro is a rule that defines how input text is converted into replacement output text.</p><p></p><p>There are two basic types of macros: object-like macros, and function-like macros.</p><p></p><p>Function-like macros act like functions, and serve a similar purpose. We will not discuss them here, because their use is generally considered dangerous, and almost anything they can do can be done by a normal function.(efficient, and generization.)</p><p></p><p>Object-like macros can be defined in one of two ways:</p><p></p><p>#define identifier</p><p></p><p>#define identifier substitution_text</p><p></p><p>The top definition has no substitution text, whereas the bottom one does. Because these are preprocessor directives (not statements), note that neither form ends with a semicolon.</p><p>Object-like macros with substitution text</p><p>When the preprocessor encounters this directive, any further occurrence of the identifier is replaced by substitution_text. The identifier is traditionally typed in all capital letters, using underscores to represent spaces.</p><p>Object-like macros without substitution text</p><p>Object-like macros can also be defined without substitution text.</p><p>For example:</p><p>#define USE_YEN</p><p>Macros of this form work like you might expect: any further occurrence of the identifier is removed and replaced by nothing!</p><p>This might seem pretty useless, and it is useless for doing text substitution. However, that’s not what this form of the directive is generally used for. We’ll discuss the uses of this form in just a moment.</p><p>Unlike object-like macros with substitution text, macros of this form are generally considered acceptable to use.</p><p>The conditional compilation preprocessor directives allow you to specify under what conditions something will or won’t compile.</p><p>解引用：解除引用得到值；</p><p>printf()使用转义字符和变量点位符。</p><p>When doing division with two integers (called integer division), C++ always produces an integer result. Since integers can’t hold fractional values, any fractional portion is simply dropped (not rounded!).</p><p>Much like an integer can vary in size depending on the system, size_t also varies in size. size_t is guaranteed to be unsigned and at least 16 bits, but on most systems will be equivalent to the address-width of the application. That is, for 32-bit applications, size_t will typically be a 32-bit unsigned integer, and for a 64-bit application, size_t will typically be a 64-bit unsigned integer. size_t is defined to be big enough to hold the size of the largest object creatable on your system (in bytes). For example, if size_t is 4 bytes, the largest object creatable on your system can’t be larger than the largest number representable by a 4-byte unsigned integer (per the table above, 4,294,967,295 bytes).</p><p>In programming, a constant is a fixed value that may not be changed. C++ has two kinds of constants: literal constants, and symbolic constants.</p>
<pre>int add(int x, int y){    return x + y;} int main(){    int x{ 5 };    int value = add(x, ++x); // is this 5 + 6, or 6 + 6?    // It depends on what order your compiler evaluates the function arguments in     std::cout &lt;&lt; value; // value could be 11 or 12, depending on how the above line evaluates! 12    return 0;}</pre><p>!(x && y) is equivalent to !x || !y</p><p>!(x || y) is equivalent to !x && !y</p><p>When individual bits of an object are used as Boolean values, the bits are called bit flags.</p><p>Given a sequence of bits, we typically number the bits from right to left, starting with 0 (not 1). Each number denotes a bit position.</p><p>76543210  Bit position</p><p>00000101  Bit sequence</p><p>Given the bit sequence 0000 0101, the bits that in position 0 and 2 have value 1, and the other bits have value 0.</p><p>0011 &lt;&lt; 3 is 1000</p><p>Note that in the third case, we shifted a bit off the end of the number! Bits that are shifted off the end of the binary number are lost forever.</p><p>constexpr unsigned char mask0{ 1 &lt;&lt; 0 }; // 0000 0001 </p><p>constexpr unsigned char mask1{ 1 &lt;&lt; 1 }; // 0000 0010</p><p>constexpr unsigned char mask2{ 1 &lt;&lt; 2 }; // 0000 0100</p><p>constexpr unsigned char mask3{ 1 &lt;&lt; 3 }; // 0000 1000</p><p>constexpr unsigned char mask4{ 1 &lt;&lt; 4 }; // 0001 0000</p><p>constexpr unsigned char mask5{ 1 &lt;&lt; 5 }; // 0010 0000</p><p>constexpr unsigned char mask6{ 1 &lt;&lt; 6 }; // 0100 0000</p><p>constexpr unsigned char mask7{ 1 &lt;&lt; 7 }; // 1000 0000</p><p>if you defined the function using bit flags like this:</p><p>void someFunction(std::bitset<32> options);</p><p>Then you could use bit flags to pass in only the options you wanted:</p><p>someFunction(option10 | option32);</p><p>To query bit states, we use bitwise AND:</p><p>if (flags & option4) ... // if option4 is set, do something</p><p>To set bits (turn on), we use bitwise OR:</p><p>flags |= option4; // turn option 4 on.</p><p>flags |= (option4 | option5); // turn options 4 and 5 on.</p><p>To clear bits (turn off), we use bitwise AND with bitwise NOT:</p><p>flags &= ~option4; // turn option 4 off</p><p>flags &= ~(option4 | option5); // turn options 4 and 5 off</p><p>To flip bit states, we use bitwise XOR:</p><p>flags ^= option4; // flip option4 from on to off, or vice versa</p><p>flags ^= (option4 | option5); // flip options 4 and 5</p><p>A block of statements, also called a compound statement, is a group of statements that is treated by the compiler as if it were a single statement. Blocks begin with a { symbol, end with a } symbol, and the statements to be executed are placed in between. Blocks can be used any place where a single statement is allowed. No semicolon is needed at the end of a block.</p><p>Local variables have block scope (also called local scope), which means they enter scope at the point of declaration and go out of scope at the end of the block that they are defined in.</p><p>int x=7;</p><p>x = x + 1;</p><p>In this statement, the variable x is being used in two different contexts. On the left side of the assignment operator, “x” is being used as an l-value (variable with an address). On the right side of the assignment operator, x is being used as an r-value, and will be evaluated to produce a value (in this case, 7). When C++ evaluates the above statement, it evaluates as:</p><p>x = 7 + 1;</p><p>Note: const variables are considered non-modifiable l-values.</p><p>Arrays allow us to store and access many variables of the same type through a single identifier. Array elements can be accessed using the subscript operator ([]). Be careful not to index an array out of the array’s range. Arrays can be initialized using an initializer list or uniform initialization (in C++11).</p><p>Fixed arrays must have a length that is set at compile time. Fixed arrays will usually decay into a pointer when evaluated or passed to a function.</p><p>Pointers are variables that store the memory address of (point at) another variable. The address-of operator (&) can be used to get the address of a variable. The dereference operator (*) can be used to get the value that a pointer points at.</p><p>return the address of a variable local to the function, agreed by VC6,but not others:</p><pre>int* doubleValue(int x){    int value = x * 2;    return &value; // return value by address here}</pre><p>The call stack in action</p><p>Let’s examine in more detail how the call stack works. Here is the sequence of steps that takes place when a function is called:</p><p>The program encounters a function call.</p><p>A stack frame is constructed and pushed on the stack. The stack frame consists of:</p><p>The address of the instruction beyond the function call (called the return address). This is how the CPU remembers where to return to after the called function exits.</p><p>All function arguments.</p><p>Memory for any local variables.</p><p>Saved copies of any registers modified by the function that need to be restored when the function returns</p><p>The CPU jumps to the function’s start point.</p><p>The instructions inside of the function begin executing.</p><p>When the function terminates, the following steps happen:</p><p>Registers are restored from the call stack</p><p>The stack frame is popped off the stack. This frees the memory for all local variables and arguments.</p><p>The return value is handled.</p><p>The CPU resumes execution at the return address.</p><p>Return values can be handled in a number of different ways, depending on the computer’s architecture. Some architectures include the return value as part of the stack frame. Others use CPU registers.</p><p>Typically, it is not important to know all the details about how the call stack works. However, understanding that functions are effectively pushed on the stack when they are called and popped off when they return gives you the fundamentals needed to understand recursion, as well as some other concepts that are useful when debugging.</p><p>In the context of a std::vector, length is how many elements are being used in the array, whereas capacity is how many elements were allocated in memory.</p><p>结构或联合的成员也可以是位字段。位字段是一个由具有特定数量的位组成的整数变量。如果连续声明多个小的位字段，编译器会将它们合成一个机器字（word）。这使得小单元信息具有带回紧凑的存储方式。当然，也可以使用位运算符来独立处理特定位，但是位字段允许我们利用名称来处理位，类似于结构或联合的成员。</p><p>位字段的声明多了一个宽度的定义，如：</p><p>unsigned int month:4;</p><p>struct Date{//用一个字的空间存储一个日期</p><p>unsigned int month:4;</p><p>unsigned int day:4;</p><p>signed int year:22;</p><p>_bool isDst:1; //如果是夏令时</p><p>};</p><p>位字段不能使用&来取址，也不能对位字段进行位运算。</p><p>文件打开时，系统给文件分配一个位置指针，用于指向文件当前的读写位置。每次读取字符，文件的位置指针便会自动向下移动读取数量的字节，不需要人为进行控制。这种功能在许多读写函数中都会有体现。</p><p>memcpy与memmove的目的都是将N个字节的源内存地址的内容拷贝到目标内存地址中。</p><p>但当源内存和目标内存存在重叠时，memcpy会出现错误，而memmove能正确地实施拷贝，但这也增加了一点点开销。</p><p>while ((c = fgetc(fp)) != EOF) {</p><p>　while (!feof(fp)) {</p><p>全局数据出场顺序不分先后。</p>
<pre>	union{		unsigned int i;		char ch[4];	}endian;	endian.i = 0x12345678;	for(int j=0; j&lt;4; j++)	{		cout&lt;&lt;hex&lt;&lt;(int)endian.ch[j];	}</pre><p>Prefix (unary)：Right-to-left</p><p>可以运算的地址叫指针，不可以运算的地址叫普通变量。</p><p>// 5 个函数指针的数组，函数返回指向 3 个 int 的数组的指针</p><p>int (*(*callbacks[5])(void))[3]</p><p> </p><p>// 与 typedef 相同</p><p>typedef int arr_t[3]; // arr_t 是 3 个 int 的数组</p><p>typedef arr_t* (*fp)(void); // 指针指向的函数返回 arr_t*</p><p>fp callbacks[5];</p>
<pre>#include &lt;stdio.h>int foo(int *a, int *b){    *a = 5;    *b = 6;    return *a + *b;}int rfoo(int *restrict a, int *restrict b) //C//int rfoo(int *__restrict__ a, int *__restrict__ b) //C++{    *a = 5;    *b = 6;    return *a + *b;}int main(){    int i =0;    int *a = &i;    int *b = &i;        printf("%d ",foo(a,b));    printf("%d ", rfoo(a,b));}</pre><p># 和 ## 运算符</p><p># 字符串化的意思，出现在宏定义中的#是把跟在后面的参数转换成一个字符串。</p><p>当用作字符串化操作时，# 的主要作用是将宏参数不经扩展地转换成字符串常量。</p><p> 宏定义参数的左右两边的空格会被忽略，参数的各个 Token 之间的多个空格会被转换成一个空格。</p><p> 宏定义参数中含有需要特殊含义字符如"或\时，它们前面会自动被加上转义字符 \。</p><p>## 连接符号，把参数连在一起。</p><p>将多个 Token 连接成一个 Token。要点：</p><p> 它不能是宏定义中的第一个或最后一个 Token。</p><p> 前后的空格可有可无。</p>